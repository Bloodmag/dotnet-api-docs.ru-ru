<Type Name="HttpResponse" FullName="System.Web.HttpResponse">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="68657bcf291225564a735695474ef67da01c6dca" />
    <Meta Name="ms.sourcegitcommit" Value="df6cf590aa3087f6c7c202712eee781c6a3c8f96" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="05/07/2018" />
    <Meta Name="ms.locfileid" Value="33683998" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HttpResponse" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HttpResponse extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.HttpResponse" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HttpResponse" />
  <TypeSignature Language="C++ CLI" Value="public ref class HttpResponse sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Инкапсулирует данные ответа HTTP, полученные при выполнении операции ASP.NET.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Методы и свойства <xref:System.Web.HttpResponse> предоставляются через <xref:System.Web.HttpApplication.Response%2A> свойство <xref:System.Web.HttpApplication>, <xref:System.Web.HttpContext>, <xref:System.Web.UI.Page>, и <xref:System.Web.UI.UserControl> классы.  
  
 Следующие методы <xref:System.Web.HttpResponse> класс поддерживаются только в сценариях обратной передачи и не в асинхронном повторном резервное сценариев:  
  
-   <xref:System.Web.HttpResponse.BinaryWrite%2A>  
  
-   <xref:System.Web.HttpResponse.Clear%2A>  
  
-   <xref:System.Web.HttpResponse.ClearContent%2A>  
  
-   <xref:System.Web.HttpResponse.ClearHeaders%2A>  
  
-   <xref:System.Web.HttpResponse.Close%2A>  
  
-   <xref:System.Web.HttpResponse.End%2A>  
  
-   <xref:System.Web.HttpResponse.Flush%2A>  
  
-   <xref:System.Web.HttpResponse.TransmitFile%2A>  
  
-   <xref:System.Web.HttpResponse.Write%2A>  
  
-   <xref:System.Web.HttpResponse.WriteFile%2A>  
  
-   <xref:System.Web.HttpResponse.WriteSubstitution%2A>  
  
 Частичные обновления включены, при использовании <xref:System.Web.UI.UpdatePanel> элементы управления для обновления выбранных областей страницы вместо обновления всей страницы с помощью обратной передачи. Дополнительные сведения см. в разделе [Обзор элемента управления UpdatePanel](http://msdn.microsoft.com/library/29a2265d-9674-4c19-b70e-e5560ee9689a) и [частичной отрисовке](http://msdn.microsoft.com/library/5c12736d-d9e9-464a-9388-3fe0f9f49e49).  
  
   
  
## Examples  
 В следующем примере создаются три перекрывающихся прямоугольника при запросе страницы. Код начинается, задав <xref:System.Web.HttpResponse.ContentType%2A> свойства изображение/jpeg, чтобы все страницы будут отображены в виде JPEG-изображения. Затем код вызывает <xref:System.Web.HttpResponse.Clear%2A> метод, чтобы гарантировать, что Лишнее содержимое не отправляется вместе с ответом. Затем код устанавливает <xref:System.Web.HttpResponse.BufferOutput%2A> свойство значение true, чтобы страница полностью обрабатывается перед отправкой запрашивающему клиенту. Затем создаются два объекта, используемый для рисования прямоугольников: <xref:System.Drawing.Bitmap> и <xref:System.Drawing.Graphics> объекта. Переменные, созданные на странице используются как координаты Рисование прямоугольников и строки, которая отображается в самом большом прямоугольнике.  
  
 При рисовании три прямоугольника и строка, которая появляется внутри них <xref:System.Drawing.Bitmap> сохраняется в <xref:System.IO.Stream> объекта, с которым связан <xref:System.Web.HttpResponse.OutputStream%2A> значение свойства и формат JPEG. Этот код вызывает <xref:System.Drawing.Image.Dispose%2A> и <xref:System.Drawing.Graphics.Dispose%2A> методов, чтобы освободить ресурсы, используемые два графических объектов. Наконец, код вызывает <xref:System.Web.HttpResponse.Flush%2A> способа передачи буфер от ответа для клиента, отправившего запрос.  
  
> [!NOTE]
>  В коде <xref:System.Web.HttpResponse> ссылка на объект осуществляется с помощью ключевого слова `Response`. Например `Response.Clear()` ссылается на <xref:System.Web.HttpResponse.Clear%2A?displayProperty=nameWithType> метод. <xref:System.Web.UI.Page> Класс имеет свойство с именем <xref:System.Web.UI.Page.Response%2A> , предоставляющий текущим экземпляром <xref:System.Web.HttpResponse>.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HttpResponse (System.IO.TextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.#ctor(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (writer As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HttpResponse(System::IO::TextWriter ^ writer);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="writer" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">Объект <see cref="T:System.IO.TextWriter" />, который разрешает пользовательские выходные данные HTTP.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Web.HttpResponse" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный член предназначен для поддержки платформы .NET Framework и не должен вызываться напрямую из кода приложения.  
  
 Методы и свойства <xref:System.Web.HttpResponse> предоставляются через встроенную функцию <xref:System.Web.HttpContext.Response%2A> объекта в ASP.NET.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddCacheDependency">
      <MemberSignature Language="C#" Value="public void AddCacheDependency (params System.Web.Caching.CacheDependency[] dependencies);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheDependency(class System.Web.Caching.CacheDependency[] dependencies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheDependency(System.Web.Caching.CacheDependency[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheDependency (ParamArray dependencies As CacheDependency())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheDependency(... cli::array &lt;System::Web::Caching::CacheDependency ^&gt; ^ dependencies);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencies" Type="System.Web.Caching.CacheDependency[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="dependencies">Файл, ключ кэша или объект <see cref="T:System.Web.Caching.CacheDependency" /> для добавления в список зависимостей приложения.</param>
        <summary>Связывает набор зависимостей кэша с ответом, чтобы упростить переход ответа в недействительное состояние, если он хранится в выходном кэше и указанные зависимости изменяются.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.AddCacheDependency%2A> Метод позволяет зависимости между кэшированные ответы и <xref:System.Web.Caching.CacheDependency> объекта.  
  
   
  
## Examples  
 Следующий пример демонстрирует создание зависимости кэша с помощью <xref:System.Web.HttpResponse.AddCacheDependency%2A> метод и <xref:System.Web.Caching.CacheDependency> объекта.  
  
 [!code-aspx-csharp[HttpResponse.AddCacheDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/CS/httpresponse.addcachedependency_cs.aspx#1)]
 [!code-aspx-vb[HttpResponse.AddCacheDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/HttpResponse.AddCacheDependency/VB/httpresponse.addcachedependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="dependencies" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Этот метод был вызван слишком поздно в конвейере обработки кэша, после того, как кэшированный ответ уже был создан.</exception>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddCacheItemDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ставит допустимость кэшированного ответа в зависимость от других элементов кэша.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (System.Collections.ArrayList cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(class System.Collections.ArrayList cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(System::Collections::ArrayList ^ cacheKeys);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">Объект <see cref="T:System.Collections.ArrayList" />, содержащий ключи элементов, от которых зависит текущий кэшированный ответ.</param>
        <summary>Ставит допустимость кэшированного ответа в зависимость от других элементов кэша.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если элементы, указанные в `cacheKeys` параметр удаляются из кэша, кэшированный ответ текущего элемента является недопустимым.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование страницы ASP.NET, которая кэшируется. Создает код для страницы <xref:System.Collections.ArrayList> объекта ключей, которые связаны с элементами, которые хранятся в <xref:System.Web.Caching.Cache> объекта. Затем код передает <xref:System.Collections.ArrayList> как параметр в вызове <xref:System.Web.HttpResponse.AddCacheItemDependencies%2A> метода. Это делает выходной кэшированный ответ не является допустимым, если какие-либо файлы, указанные в <xref:System.Collections.ArrayList> изменения.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/cacheitemsdepscs.aspx#5)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/cacheitemsdepsvb.aspx#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependencies">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependencies (string[] cacheKeys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependencies(string[] cacheKeys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependencies (cacheKeys As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependencies(cli::array &lt;System::String ^&gt; ^ cacheKeys);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKeys" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="cacheKeys">Массив ключей элементов, от которых зависит данный кэшированный ответ.</param>
        <summary>Ставит допустимость кэшированного элемента в зависимость от других элементов кэша.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если какие-либо `cacheKey`s удаляются из кэша, кэшированный ответ текущего элемента является недопустимым.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <Member MemberName="AddCacheItemDependency">
      <MemberSignature Language="C#" Value="public void AddCacheItemDependency (string cacheKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddCacheItemDependency(string cacheKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddCacheItemDependency (cacheKey As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddCacheItemDependency(System::String ^ cacheKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cacheKey" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="cacheKey">Ключ элемента, от которого зависит кэшированный ответ.</param>
        <summary>Ставит допустимость кэшированного ответа в зависимость от другого элемента кэша.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если элемент, соответствующий параметру `cacheKey` параметр удаляется из кэша, кэшированный ответ текущего элемента является недопустимым.  
  
   
  
## Examples  
 Ниже приведен пользовательский элемент управления ASP.NET, кэшируется. Код для вызова элемента управления <xref:System.Web.HttpResponse.AddCacheItemDependency%2A> метод с помощью ключа элемента, хранящегося в <xref:System.Web.Caching.Cache> объект, переданный в качестве параметра. Если элемент не существует в кэше, ответ элемента управления, которое было сохранено в кэше вывода становится недействительным. Это означает, что при последующем запросе новой версии элемента управления ответ будет добавлен в кэш вывода.  
  
 Затем код проверяет ли элемент, связанный с `bookData` ключ хранится в `Cache` объекта и отображает одно из двух строк текста, зависящие от результата. Затем в коде задается <xref:System.Web.UI.WebControls.BaseDataList.DataSource%2A> свойство <xref:System.Web.UI.WebControls.DataGrid> управления, который называется `dgBooks`, с помощью вызова пользовательской `DataHelper` общего класса `GetBookData` метод и заполняет <xref:System.Web.UI.WebControls.DataGrid> с <xref:System.Web.UI.Control.DataBind%2A> метод.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/bookscs.ascx#3)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/booksvb.ascx#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.AddCacheItemDependency(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddFileDependencies">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет группу имен файлов в коллекцию имен файлов, от которой зависит текущий ответ.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (System.Collections.ArrayList filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(class System.Collections.ArrayList filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.Collections.ArrayList)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As ArrayList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(System::Collections::ArrayList ^ filenames);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.Collections.ArrayList" />
      </Parameters>
      <Docs>
        <param name="filenames">Добавляемая коллекция файлов.</param>
        <summary>Добавляет группу имен файлов в коллекцию имен файлов, от которой зависит текущий ответ.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Следующий пример является страницей ASP.NET, который кэшируется. Создает код для страницы <xref:System.Collections.ArrayList> пути к файлам, а затем передает <xref:System.Collections.ArrayList> как параметр в вызове <xref:System.Web.HttpResponse.AddFileDependencies%2A> метода. В результате вывода кэшированный ответ, недопустимый Если любой из файлов, указанных в <xref:System.Collections.ArrayList> изменения.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples2#6](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/CS/responsefiledepscs.aspx#6)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples2#6](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples2/VB/responsefiledepsvb.aspx#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.Caching.CacheDependency" />
      </Docs>
    </Member>
    <Member MemberName="AddFileDependencies">
      <MemberSignature Language="C#" Value="public void AddFileDependencies (string[] filenames);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependencies(string[] filenames) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependencies(System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependencies (filenames As String())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependencies(cli::array &lt;System::String ^&gt; ^ filenames);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filenames" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="filenames">Добавляемый массив файлов.</param>
        <summary>Добавляет массив имен файлов в коллекцию имен файлов, от которой зависит текущий ответ.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Следующий пример добавляет массив имен файлов, подлежащих <xref:System.Web.HttpResponse.AddFileDependencies%2A> список зависимостей файлов. Если файлы изменяются, кэшированный ответ становится недействительным.  
  
 [!code-aspx-csharp[Response.AddFileDependency#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Response.AddFileDependency/CS/addfiledependency_cs.aspx#1)]
 [!code-aspx-vb[Response.AddFileDependency#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Response.AddFileDependency/VB/addfiledependency_vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddFileDependency">
      <MemberSignature Language="C#" Value="public void AddFileDependency (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFileDependency(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddFileDependency(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFileDependency (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFileDependency(System::String ^ filename);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Имя добавляемого файла.</param>
        <summary>Добавляет имя файла в коллекцию имен файлов, от которой зависит текущий ответ.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании <xref:System.Web.HttpResponse.AddFileDependency%2A> метод, чтобы добавить зависимость, необходимо также указать кэширование вывода программно или декларативно. Например чтобы указать декларативно кэширование выходных данных, используйте директиву. Дополнительные сведения см. в разделе [как: вывода страниц кэша с зависимостями файл](http://msdn.microsoft.com/library/95ad1c54-329e-45af-9343-a03a1d2ce9db).  
  
   
  
## Examples  
 Следующий пример демонстрирует добавление одно имя файла для <xref:System.Web.HttpResponse.AddFileDependency%2A> список зависимостей файлов. Если файл изменяется, кэшированный ответ становится недействительным.  
  
 [!code-csharp[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AddFileDependency Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AddFileDependency Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHeader">
      <MemberSignature Language="C#" Value="public void AddHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHeader(System::String ^ name, System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя заголовка HTTP, в который следует добавить <c>value</c>.</param>
        <param name="value">Строка, которую требуется добавить в заголовок.</param>
        <summary>Добавляет заголовок НТТР в поток вывода. Свойство <see cref="M:System.Web.HttpResponse.AddHeader(System.String,System.String)" /> обеспечивает совместимость с предыдущими версиями ASP.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.AddHeader%2A> совпадает со значением <xref:System.Web.HttpResponse.AppendHeader%2A> и предоставляется только для совместимости с предыдущими версиями ASP. С помощью ASP.NET, используйте <xref:System.Web.HttpResponse.AppendHeader%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOnSendingHeaders">
      <MemberSignature Language="C#" Value="public System.Web.ISubscriptionToken AddOnSendingHeaders (Action&lt;System.Web.HttpContext&gt; callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Web.ISubscriptionToken AddOnSendingHeaders(class System.Action`1&lt;class System.Web.HttpContext&gt; callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AddOnSendingHeaders(System.Action{System.Web.HttpContext})" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOnSendingHeaders (callback As Action(Of HttpContext)) As ISubscriptionToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Web::ISubscriptionToken ^ AddOnSendingHeaders(Action&lt;System::Web::HttpContext ^&gt; ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.ISubscriptionToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Action&lt;System.Web.HttpContext&gt;" />
      </Parameters>
      <Docs>
        <param name="callback">Метод обратного вызова.</param>
        <summary>[Поддерживается в .NET Framework 4.5.2 и более поздних версиях.]  
  
 Регистрирует обратный вызов, который среда выполнения ASP.NET будет вызывать непосредственно перед отправкой заголовков ответа для этого запроса.</summary>
        <returns>Объект <see cref="T:System.Web.ISubscriptionToken" />, который представляет подписку на псевдособытие OnSendingHeaders.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Метод AddOnSendingHeaders не вызывается, если модуль в машинном коде сначала записывает ответ.  
  
 Псевдособытие псевдо событие отличается от событий конвейера IHttpModule уровня, что подписки по запросу, а не подписку на уровне приложений. Цель, что обратный вызов может изменить код состояния ответа или могут устанавливать куки-файл ответа или заголовок. Другие примечания об использовании и предупреждения:  
  
-   Этот метод действует только в том случае, если службы IIS работают в режиме конвейера интегрированного конвейера и только в том случае, если заголовки ответа еще не были отправлены для текущего запроса.  
  
-   Среда выполнения ASP.NET не гарантирует ничего о, обратный вызов выполняется в потоке. Например обратный вызов могут вызываться синхронно в фоновом потоке, если выполняется фоновая запись. <xref:System.Web.HttpContext.Current%2A> доступна в такой поток не гарантируется.  
  
-   Функция обратного вызова не должна вызывать любой метод, управляющий текст сущности ответа или, приводит к записи. Например, обратный вызов не должны вызывать <xref:System.Web.HttpResponse.Redirect%2A>, как управлять текст сущности ответа, этот метод.  
  
-   Обратный вызов должен содержать только короткие синхронный код. Попытка вызова асинхронной операции или ожидания этой операции может привести к взаимоблокировке.  
  
-   Обратный вызов не должен вызывать исключение; в противном случае поведение не определено.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AppendCookie">
      <MemberSignature Language="C#" Value="public void AppendCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">
          <see cref="T:System.Web.HttpCookie" /> для добавления в поток вывода.</param>
        <summary>Добавляет файл cookie HTTP во встроенную коллекцию файлов cookie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается новый файл cookie с именем `LastVisit`, устанавливает значение файла cookie в текущую дату и время и добавляет файл cookie в текущую коллекцию файлов cookie. Все файлы cookie из коллекции отправляются клиенту в `Set-Cookie` заголовок НТТР потока вывода.  
  
 [!code-csharp[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Файл Cookie добавляется после отправки заголовков HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendHeader">
      <MemberSignature Language="C#" Value="public void AppendHeader (string name, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendHeader(string name, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendHeader(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendHeader (name As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendHeader(System::String ^ name, System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя заголовка НТТР, который добавляется в поток вывода.</param>
        <param name="value">Строка, которую требуется добавить в заголовок.</param>
        <summary>Добавляет заголовок НТТР в поток вывода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы используете <xref:System.Web.HttpResponse.AppendHeader%2A> метод для отправки заголовков кэша и в то же время использовать объектную модель кэша (<xref:System.Web.HttpResponse.Cache%2A>) для задания политики кэширования, заголовки ответа HTTP, относящиеся к кэшированию (`Cache-Control`, `Expires`, `Last-Modified`, `Pragma`, и `Vary`) могут быть удалены при использовании объектной модели кэша. Такое поведение позволяет ASP.NET сохранять наиболее строгие параметры. Например рассмотрим содержит пользовательские элементы управления. Если эти элементы имеют конфликтующие политики кэширования, будет использоваться наиболее строгие политики кэша. Если один пользовательский элемент управления задает заголовок "`Cache-Control: Public`«и другой пользовательский элемент управления задает более строгий заголовок»`Cache-Control: Private`» путем вызова метода <xref:System.Web.HttpCachePolicy.SetCacheability%2A>, то"`Cache-Control: Private`"заголовок будет отправлен с ответом.  
  
 Список стандартных заголовков HTTP/1.1, см. в разделе 14, «Определения полей заголовков», в [протокол HTTP/1.1](http://go.microsoft.com/fwlink/?LinkID=73147) спецификация на веб-сайте консорциума World Wide Web (W3C).  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Web.HttpResponse.AppendHeader%2A> метод, чтобы добавить пользовательский заголовок <xref:System.Web.HttpResponse> объекта, переданного в запрашивающему клиенту.  
  
 [!code-csharp[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/CS/responseappendheader.cs.aspx#1)]
 [!code-vb[System.Web.HttpResponse.AppendHeader_Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.AppendHeader_Example/VB/responseappendheader.vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Заголовок добавляется после отправки заголовков HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="AppendToLog">
      <MemberSignature Language="C#" Value="public void AppendToLog (string param);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AppendToLog(string param) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.AppendToLog(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendToLog (param As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AppendToLog(System::String ^ param);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="param" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="param">Текст, добавляемый в файл журнала.</param>
        <summary>Добавляет данные пользовательского журнала в файл журнала IIS.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы разрешить указанную строку для записи в файл журнала, сначала необходимо включить **запрос URI** параметр **расширенные свойства ведения журнала** диалоговое окно для сайта, который вы хотите войти активность в службах IIS .  
  
 Чтобы настроить расширенное ведение журнала в IIS 6.0, выполните следующие действия.  
  
1.  В диспетчере IIS разверните узел локального компьютера, разверните папку веб- или FTP-узлов, щелкните правой кнопкой мыши веб- или FTP-сайта и нажмите кнопку **свойства**.  
  
2.  Нажмите кнопку **веб- или FTP-сайта** , а затем выберите **включить ведение журнала** флажок (если он еще не выбрана).  
  
3.  В **формат журнала** щелкните **расширенный формат файла журнала W3C**.  
  
4.  Нажмите кнопку **свойства**.  
  
5.  Нажмите кнопку **Дополнительно** выберите свойства, которые вы хотите войти и нажмите кнопку **ОК**.  
  
   
  
## Examples  
 В следующем примере показано, как добавлять строку в журнал.  
  
 [!code-csharp[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.AppendToLog Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.AppendToLog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAppPathModifier">
      <MemberSignature Language="C#" Value="public string ApplyAppPathModifier (string virtualPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyAppPathModifier(string virtualPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyAppPathModifier (virtualPath As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyAppPathModifier(System::String ^ virtualPath);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="virtualPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="virtualPath">Виртуальный путь к ресурсу.</param>
        <summary>Добавляет идентификатор сеанса в виртуальный путь, если сеанс использует состояние <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" />, и возвращает объединенный путь. Если задаваемое свойством <see cref="P:System.Web.Configuration.SessionStateSection.Cookieless" /> состояние сеанса не используется, то метод <see cref="M:System.Web.HttpResponse.ApplyAppPathModifier(System.String)" /> возвращает исходный виртуальный путь.</summary>
        <returns>Параметр <paramref name="virtualPath" /> с добавленным идентификатором сеанса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> используется только с сеансами без поддержки файлов cookie для создания абсолютных элементов href.  
  
   
  
## Examples  
 В следующем примере объявляется строковую переменную с именем `urlConverted`и присваивает результат <xref:System.Web.HttpResponse.ApplyAppPathModifier%2A> вызова метода. Код передает значение переменной для <xref:System.Web.UI.WebControls.HyperLink> элемента управления <xref:System.Web.UI.WebControls.HyperLink.NavigateUrl%2A> свойство.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#5](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/responseapppathmodifiercs.aspx#5)]
 [!code-vb[System.Web.HttpResponse_Sample5#5](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/responseapppathmodifiervb.aspx#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginFlush">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginFlush (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginFlush(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BeginFlush(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginFlush (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginFlush(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Объект обратного вызова.</param>
        <param name="state">Состояние ответа.</param>
        <summary>Отправляет клиенту ответ, находящийся в данный момент в буфере.</summary>
        <returns>Объект асинхронного результата.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если базовый <xref:System.Web.HttpWorkerRequest> объект поддерживает асинхронные операции очистки и этот метод вызывается из события асинхронной модуль или асинхронный обработчик, операцию очистки выполняется асинхронно. В противном случае операция записи на диск выполняется синхронно. Асинхронной очистки поддерживается для IIS 6.0 и более поздних версий.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Отклик уже завершен.</exception>
      </Docs>
    </Member>
    <Member MemberName="BinaryWrite">
      <MemberSignature Language="C#" Value="public void BinaryWrite (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BinaryWrite(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.BinaryWrite(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub BinaryWrite (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BinaryWrite(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Байты, записываемые в поток вывода.</param>
        <summary>Записывает строку двоичных символов в поток вывода НТТР.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Следующий пример считывает текстовый файл в буфер и содержимое буфера записывается в поток вывода НТТР.  
  
 [!code-csharp[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.BinaryWrite Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.BinaryWrite Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public bool Buffer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public Property Buffer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Buffer { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, следует ли помещать выходные данные в буфер для отправки с последующей отправкой после завершения обработки ответа.</summary>
        <value>
          Значение <see langword="true" />, если выходные данные, отправляемые клиенту, помещаются в буфер; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Buffer%2A> Свойство является устаревшим для <xref:System.Web.HttpResponse.BufferOutput%2A> свойства и предоставляется только для совместимости с предыдущими версиями ASP. С помощью ASP.NET, используйте <xref:System.Web.HttpResponse.BufferOutput%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BufferOutput">
      <MemberSignature Language="C#" Value="public bool BufferOutput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BufferOutput" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.BufferOutput" />
      <MemberSignature Language="VB.NET" Value="Public Property BufferOutput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BufferOutput { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, следует ли помещать выходные данные в буфер для отправки с последующей отправкой после завершения обработки страницы.</summary>
        <value>
          Значение <see langword="true" />, если выходные данные, отправляемые клиенту, помещаются в буфер; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере задается <xref:System.Web.HttpResponse.ContentType%2A> свойство для ответа изображение/jpeg, вызывает <xref:System.Web.HttpResponse.Clear%2A> метод для удаления другое содержимое, которое может быть прикреплен к отклику, а затем устанавливает <xref:System.Web.HttpResponse.BufferOutput%2A> свойство значение true, чтобы вся страница будет обработать, прежде чем все содержимое отправляется запрашивающему клиенту.  
  
 Полный пример см. в разделе <xref:System.Web.HttpResponse> класса.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cache">
      <MemberSignature Language="C#" Value="public System.Web.HttpCachePolicy Cache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCachePolicy Cache" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cache" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cache As HttpCachePolicy" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCachePolicy ^ Cache { System::Web::HttpCachePolicy ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCachePolicy</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает политику кэширования веб-страницы (например, срок действия, параметры конфиденциальности и изменяемые предложения).</summary>
        <value>Объект <see cref="T:System.Web.HttpCachePolicy" />, содержащий сведения о политике кэширования для текущего ответа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Следующий пример записывает свойства текущей политики кэширования в поток вывода НТТР.  
  
 [!code-csharp[Classic HttpResponse.Cache Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cache Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cache Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CacheControl">
      <MemberSignature Language="C#" Value="public string CacheControl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CacheControl" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.CacheControl" />
      <MemberSignature Language="VB.NET" Value="Public Property CacheControl As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ CacheControl { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает заголовок HTTP <see langword="Cache-Control" />, который совпадает с одним из значений перечисления <see cref="T:System.Web.HttpCacheability" />.</summary>
        <value>Строковое представление значения перечисления <see cref="T:System.Web.HttpCacheability" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значения для `Private`, `Public`, и `No-Cache` представляют собой строки и должно быть заключено в кавычки (» «). Если <xref:System.Web.HttpResponse.CacheControl%2A> свойству присвоено значение, которое не соответствует ни одному из <xref:System.Web.HttpCacheability> значений перечисления, а затем <xref:System.ArgumentException> возникает исключение. Если <xref:System.Web.HttpResponse.CacheControl%2A> свойство не задано, задается возможность кэширования ответа <xref:System.Web.HttpCacheability.NoCache>.  
  
 `CacheControl`, <xref:System.Web.HttpResponse.Expires%2A>, И <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> свойства являются устаревшими. Вместо этого методы <xref:System.Web.HttpCachePolicy> класса доступны через <xref:System.Web.HttpResponse.Cache%2A> внутренний объект для управления Internet Information Services (IIS) выводить кэша и кэши клиентов.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Строковое значение не совпадает с одним из значений перечисления <see cref="T:System.Web.HttpCacheability" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Charset">
      <MemberSignature Language="C#" Value="public string Charset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Charset" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Charset" />
      <MemberSignature Language="VB.NET" Value="Public Property Charset As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Charset { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает кодировку НТТР для потока вывода.</summary>
        <value>Кодировка НТТР для потока вывода.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Charset` Свойству можно присвоить значение `null` отключение HTTP `Content-Type` заголовок.  
  
   
  
## Examples  
 Следующий пример проверяет, является ли кодировка потока вывода центральноевропейская кодировка (ISO).  
  
 [!code-csharp[System.Web.HttpResponse.Charset#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.Charset#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Charset/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Свойство <see langword="Charset" /> было задано после отправки заголовков.</exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет все содержимое вывода из потока буфера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Clear%2A> Метод не очищает данные заголовка.  
  
   
  
## Examples  
 В следующем примере задается <xref:System.Web.HttpResponse.ContentType%2A> свойство для ответа изображение/jpeg, вызывает <xref:System.Web.HttpResponse.Clear%2A> метод для удаления другое содержимое, которое может быть прикреплен к отклику, а затем устанавливает <xref:System.Web.HttpResponse.BufferOutput%2A> для свойства значение true, таким образом, будет страница «Готово» обработать, прежде чем все содержимое отправляется запрашивающему клиенту.  
  
 Полный пример см. в разделе <xref:System.Web.HttpResponse> класса.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearContent">
      <MemberSignature Language="C#" Value="public void ClearContent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearContent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearContent" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearContent ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearContent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет все содержимое вывода из потока буфера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.ClearContent%2A> Метод не очищает данные заголовка.  
  
   
  
## Examples  
 Следующий пример удаляет все содержимое из потока буфера.  
  
 [!code-csharp[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ClearContent Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ClearContent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.HttpResponse.ClearHeaders" />
      </Docs>
    </Member>
    <Member MemberName="ClearHeaders">
      <MemberSignature Language="C#" Value="public void ClearHeaders ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearHeaders() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.ClearHeaders" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearHeaders ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearHeaders();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет все заголовки из потока буфера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере вызывается <xref:System.Web.HttpResponse.ClearHeaders%2A> метод, чтобы гарантировать, что заголовки не отправляются с текущего ответа. Этот метод может оказаться особенно важно, если в ответе ASP.NET формируется изображения, например файла в формате JPEG. В этом примере <xref:System.Web.HttpResponse.ContentType%2A> свойству изображение/jpeg.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponseclearheaderscs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Sample5#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponseclearheadersvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Заголовки удаляются после отправки заголовков HTTP.</exception>
        <altmember cref="M:System.Web.HttpResponse.ClearContent" />
      </Docs>
    </Member>
    <Member MemberName="ClientDisconnectedToken">
      <MemberSignature Language="C#" Value="public System.Threading.CancellationToken ClientDisconnectedToken { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.CancellationToken ClientDisconnectedToken" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ClientDisconnectedToken" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientDisconnectedToken As CancellationToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::CancellationToken ClientDisconnectedToken { System::Threading::CancellationToken get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.CancellationToken</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Threading.CancellationToken" />, задействуемый при отключении клиента.</summary>
        <value>Токен отмены.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот API является потокобезопасным. Однако существуют некоторые ограничения на использование токена отмены. Неправильное использование может привести к гонки, взаимоблокировки или другие непредвиденные ситуации. Необходимо учитывать следующие рекомендации:  
  
-   Гарантирует, что не вызывать этот интерфейс API за пределами одного запроса, поскольку ASP.NET будет удалить токен отмены в конце запроса. Нет никакой гарантии, что маркер никогда не перейдет в отмененном состоянии до его удаления. Например если запрос завершается без отключения клиента, маркер будет удален без сначала было отменено.  
  
-   Не ожидаете <xref:System.Threading.CancellationToken.WaitHandle%2A?displayProperty=nameWithType>, как это согласуется со асинхронное уведомление и может приводить к взаимоблокировкам.  
  
-   Не вызывайте <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> перегрузки, которые обратный вызов на исходный <xref:System.Threading.SynchronizationContext> объекта.  
  
-   Не используйте <xref:System.Web.HttpContext> объекта или другие не многопоточное внутренним объектам ASP.NET из в обратный вызов, предоставленный <xref:System.Threading.CancellationToken.Register%2A?displayProperty=nameWithType> метод. Обратный вызов может выполняться параллельно с другими ASP.NET и кода приложения.  
  
-   Следите за методы обратного вызова краткосрочных и без блокировки.  
  
-   Приложите усилия, чтобы избежать возникновения исключения в методы обратного вызова.  
  
 Это свойство применимо только для Internet Information Service (IIS) 7.5 в интегрированном режиме. Если вызвать без правильного IIS версии или конвейера режима, <xref:System.PlatformNotSupportedException> возникает исключение. Чтобы определить версию служб IIS, используйте <xref:System.Web.HttpRuntime.IISVersion%2A>. Чтобы определить режим конвейера, используйте <xref:System.Web.HttpRuntime.UsingIntegratedPipeline%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Закрывает соединение с клиентом по данному сокету.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод завершает подключение к клиенту внезапные способом и не предназначен для обычной обработки HTTP-запроса. Метод отправляет пакет Сброс клиента, которая может привести к данные ответа, которые заносятся на сервере, клиенте или где-то между ними, который нужно удалить.  
  
 Тем не менее, обычно следует вызывать <xref:System.Web.HttpApplication.CompleteRequest%2A> вместо этого, если вы хотите перейти вперед к <xref:System.Web.HttpApplication.EndRequest> событий и отправки ответа клиенту.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContentEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding ContentEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding ContentEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ ContentEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает кодировку НТТР для потока вывода.</summary>
        <value>Объект <see cref="T:System.Text.Encoding" />, содержащий сведения о кодировке текущего ответа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию `ContentEncoding` можно указать в файле конфигурации ASP.NET в [глобализации элемент (схема параметров ASP.NET)](http://msdn.microsoft.com/library/e2dffc8e-ebd2-439b-a2fd-e3ac5e620da7) раздела. Если <xref:System.Web.HttpResponse.ContentEncoding%2A> указанный клиентом, переопределяются параметры конфигурации по умолчанию.  
  
   
  
## Examples  
 Следующий пример записывает понятное описание кодировку в выходной поток.  
  
 [!code-csharp[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.ContentEncoding Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.ContentEncoding Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Попытка установить <see cref="P:System.Web.HttpResponse.ContentEncoding" /> в значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ContentType">
      <MemberSignature Language="C#" Value="public string ContentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ContentType" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ContentType" />
      <MemberSignature Language="VB.NET" Value="Public Property ContentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ ContentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает MIME-тип НТТР потока вывода.</summary>
        <value>MIME-тип НТТР потока вывода. Значение по умолчанию — <see langword="text/html" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере задается <xref:System.Web.HttpResponse.ContentType%2A> свойство для ответа изображение/jpeg, вызывает <xref:System.Web.HttpResponse.Clear%2A> метод для удаления другое содержимое, которое может быть прикреплен к отклику, а затем устанавливает <xref:System.Web.HttpResponse.BufferOutput%2A> для свойства значение true, таким образом, будет страница «Готово» обработать, прежде чем все содержимое отправляется запрашивающему клиенту.  
  
 Полный пример см. в разделе <xref:System.Web.HttpResponse> класса.  
  
 [!code-csharp[System.Web.HttpResponse_Samples1#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#2)]
 [!code-vb[System.Web.HttpResponse_Samples1#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Свойству <see cref="P:System.Web.HttpResponse.ContentType" /> задано значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Cookies">
      <MemberSignature Language="C#" Value="public System.Web.HttpCookieCollection Cookies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpCookieCollection Cookies" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Cookies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Cookies As HttpCookieCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Web::HttpCookieCollection ^ Cookies { System::Web::HttpCookieCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpCookieCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию файлов сookie ответов.</summary>
        <value>Коллекция файлов cookie ответов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 ASP.NET содержит две коллекции встроенный файл cookie. Коллекции, доступной через <xref:System.Web.HttpRequest.Cookies%2A> коллекцию <xref:System.Web.HttpRequest> содержит файлы cookie, отправленных клиентом на сервер в `Cookie` заголовок. Коллекции, доступной через <xref:System.Web.HttpResponse.Cookies%2A> коллекцию <xref:System.Web.HttpResponse> содержатся новые объекты cookie, созданные на сервере и передаются клиенту в `Set-Cookie` заголовок.  
  
 После добавления файла cookie с помощью <xref:System.Web.HttpResponse.Cookies%2A?displayProperty=nameWithType> коллекции, доступна сразу в файл cookie <xref:System.Web.HttpRequest.Cookies%2A?displayProperty=nameWithType> коллекции, даже если не было отправлено ответ клиенту.  
  
   
  
## Examples  
 В следующем примере создается новый файл cookie с именем `LastVisit`, устанавливает значение файла cookie в текущую дату и время и добавляет файл cookie в текущую коллекцию файлов cookie. Все файлы cookie из коллекции отправляются клиенту в `Set-Cookie` заголовок НТТР потока вывода.  
  
 [!code-csharp[Classic HttpResponse.Cookies Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Cookies Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Cookies Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableKernelCache">
      <MemberSignature Language="C#" Value="public void DisableKernelCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableKernelCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableKernelCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableKernelCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableKernelCache();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Запрещает кэширование ядра для текущего ответа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если кэширование ядра не поддерживается, этот метод не оказывает влияния.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DisableUserCache">
      <MemberSignature Language="C#" Value="public void DisableUserCache ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableUserCache() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.DisableUserCache" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableUserCache ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableUserCache();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отключает кэширование IIS в пользовательском режиме для этого ответа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если кэширование IIS в пользовательском режиме не поддерживается, этот метод возвращает не выполняя никаких действий.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="End">
      <MemberSignature Language="C#" Value="public void End ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void End() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.End" />
      <MemberSignature Language="VB.NET" Value="Public Sub End ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void End();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отправляет клиенту все выходные данные, находящиеся в данный момент в буфере, прекращает выполнение страницы и создает событие <see cref="E:System.Web.HttpApplication.EndRequest" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предоставляется только для совместимости с ASP — то есть, для совместимости с технологией веб программирование на основе COM, предшествующей ASP.NET. Если вы хотите перейти вперед к <xref:System.Web.HttpApplication.EndRequest> событий и отправки ответа клиенту, обычно предпочтительнее вызовите <xref:System.Web.HttpApplication.CompleteRequest%2A> вместо него.  
  
 Для имитации поведения `End` метод в ASP, этот метод пытается вызвать <xref:System.Threading.ThreadAbortException> исключение. Если эта попытка окажется успешной, вызывающий поток будет прервана, что к падению производительности веб-узла. В этом случае код после вызова не <xref:System.Web.HttpResponse.End%2A> выполнения метода.  
  
 Если <xref:System.Web.HttpResponse.End%2A> метод не может инициировать <xref:System.Threading.ThreadAbortException>, вместо записывает байты ответа клиенту. Это выполняется синхронно, который также может быть к падению производительности веб-узла.  
  
 В любом случае (ли <xref:System.Threading.ThreadAbortException> возникает исключение), ответ конвейера происходит переключение <xref:System.Web.HttpApplication.EndRequest> событий.  
  
 <xref:System.Web.HttpApplication.CompleteRequest%2A> Метод не вызывают исключение и код после вызова метода <xref:System.Web.HttpApplication.CompleteRequest%2A> метод может быть выполнен. Если нужно избежать выполнения последующих кода и снижения производительности <xref:System.Web.HttpResponse.End%2A> является допустимым, можно вызвать <xref:System.Web.HttpResponse.End%2A> вместо <xref:System.Web.HttpApplication.CompleteRequest%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadAbortException">Вызов <see cref="M:System.Web.HttpResponse.End" /> завершил текущий запрос.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndFlush">
      <MemberSignature Language="C#" Value="public void EndFlush (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndFlush(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.EndFlush(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndFlush (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndFlush(IAsyncResult ^ asyncResult);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Объект асинхронного результата.</param>
        <summary>Завершает асинхронную операцию очистки.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Асинхронная операция очистки не поддерживается, и параметр <paramref name="asyncResult" /> — <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Асинхронная операция записи на диск не поддерживается, и параметр <paramref name="asyncResult" /> невозможно привести к объекту <c>FlushAsyncResult</c>.</exception>
      </Docs>
    </Member>
    <Member MemberName="Expires">
      <MemberSignature Language="C#" Value="public int Expires { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Expires" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Expires" />
      <MemberSignature Language="VB.NET" Value="Public Property Expires As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Expires { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает число минут перед тем, как истечет срок действия страницы, сохраненной в кэше браузера. Если пользователь возвращается к той же странице до момента истечения срока действия, будет отображена кэшированная версия. Свойство <see cref="P:System.Web.HttpResponse.Expires" /> обеспечивает совместимость с предыдущими версиями ASP.</summary>
        <value>Число минут перед тем, как срок действия страницы закончится.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Expires`, <xref:System.Web.HttpResponse.ExpiresAbsolute%2A> И <xref:System.Web.HttpResponse.CacheControl%2A> свойства стали нерекомендуемыми в пользу методы <xref:System.Web.HttpCachePolicy> доступного через <xref:System.Web.HttpResponse.Cache%2A> кэша вывода внутренний объект для управления Internet Information Services (IIS) и клиент кэширует.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpiresAbsolute">
      <MemberSignature Language="C#" Value="public DateTime ExpiresAbsolute { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.DateTime ExpiresAbsolute" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.ExpiresAbsolute" />
      <MemberSignature Language="VB.NET" Value="Public Property ExpiresAbsolute As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property DateTime ExpiresAbsolute { DateTime get(); void set(DateTime value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает абсолютную дату и время удаления кэшированных сведений из кэша. Свойство <see cref="P:System.Web.HttpResponse.ExpiresAbsolute" /> обеспечивает совместимость с предыдущими версиями ASP.</summary>
        <value>Дата и время истечения срока действия страницы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `ExpiresAbsolute`, <xref:System.Web.HttpResponse.Expires%2A>, И <xref:System.Web.HttpResponse.CacheControl%2A> свойства стали нерекомендуемыми в пользу методы <xref:System.Web.HttpCachePolicy> доступного через <xref:System.Web.HttpResponse.Cache%2A> кэша вывода внутренний объект для управления Internet Information Services (IIS) и клиент кэширует.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public System.IO.Stream Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream Filter" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Property Filter As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ Filter { System::IO::Stream ^ get(); void set(System::IO::Stream ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает объект фильтра оболочки, используемый для изменения тела сущности НТТР перед началом передачи.</summary>
        <value>Объект <see cref="T:System.IO.Stream" />, используемый в качестве фильтра вывода.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При создании `Stream` и задайте <xref:System.Web.HttpResponse.Filter%2A> свойства `Stream` объекта HTTP все выходные данные, отправляемые <xref:System.Web.HttpResponse.Write%2A> проходит через фильтр.  
  
   
  
## Examples  
 Следующий пример является страницей ASP.NET, который задает <xref:System.Web.HttpResponse.Filter%2A> свойства новый экземпляр `UpperCaseFilter` класса пользовательского <xref:System.IO.Stream> класс, который преобразует весь текст, который передает его в верхний регистр. Сведения о запросе сохраняются в текстовый файл, а затем <xref:System.Web.HttpResponse.Filter%2A> свойству. После размещения фильтра ответов, код вызывает <xref:System.Web.HttpRequest.MapPath%2A> метод для получения абсолютного пути в текстовый файл с именем `TestFile.txt` , выступает в качестве источника содержимого ответа. Затем он создает новый <xref:System.IO.StreamReader> объекта для чтения к текстовому файлу от начала до конца, а затем вызывает <xref:System.Web.HttpResponse.Write%2A> метод для отображения содержимого файла на странице.  
  
 [!code-aspx-csharp[System.Web.HttpRequest_Samples2#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/CS/requestsamples2cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpRequest_Samples2#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpRequest_Samples2/VB/requestsamples2vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Фильтрация данного элемента недопустима.</exception>
      </Docs>
    </Member>
    <Member MemberName="Flush">
      <MemberSignature Language="C#" Value="public void Flush ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Flush() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Flush" />
      <MemberSignature Language="VB.NET" Value="Public Sub Flush ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Flush();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отправляет клиенту все выходные данные, находящиеся в данный момент в буфере.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Заставляет все текущие буфер выходных данных, отправляемых клиенту. <xref:System.Web.HttpResponse.Flush%2A> Метод может вызываться несколько раз во время обработки запроса.  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Drawing.Graphics.Save%2A> метод, чтобы сохранить <xref:System.Drawing.Bitmap> объект <xref:System.Web.HttpResponse.OutputStream%2A> свойство и преобразует формат изображения JPEG. Затем код вызывает `Dispose` метод <xref:System.Drawing.Bitmap> объекта и <xref:System.Drawing.Graphics> объекта, освобождая ресурсы, которые они используют. Затем он вызывает <xref:System.Web.HttpResponse.Flush%2A> метод для отправки содержимого ответа для клиента, отправившего запрос.  
  
 Полный пример см. в разделе <xref:System.Web.HttpResponse> класса.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">После отправки ответа кэш очищается.</exception>
      </Docs>
    </Member>
    <Member MemberName="FlushAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task FlushAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task FlushAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.FlushAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function FlushAsync () As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task ^ FlushAsync();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Асинхронно отправляет клиенту все выходные данные, находящиеся в данный момент в буфере.</summary>
        <returns>Объект <see cref="T:System.Threading.Tasks.Task" />, который представляет асинхронную операцию.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HeaderEncoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding HeaderEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding HeaderEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeaderEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Property HeaderEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ HeaderEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает объект <see cref="T:System.Text.Encoding" />, который представляет кодирование для потока вывода текущего заголовка.</summary>
        <value>Объект <see cref="T:System.Text.Encoding" />, содержащий сведения о кодировке текущего заголовка.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.HeaderEncoding%2A> Свойство дает возможность отключения или изменения <xref:System.Text.Encoding> объекта в заголовке ответа с помощью <xref:System.Text.ASCIIEncoding>, <xref:System.Text.UnicodeEncoding>, <xref:System.Text.UTF7Encoding>, или <xref:System.Text.UTF8Encoding> объекта. Значение по умолчанию, значение кодировки — <xref:System.Text.UTF8Encoding> класса.  
  
 Изменяя тип <xref:System.Web.HttpResponse.HeaderEncoding%2A> свойства, может потенциально повысить риск определенных атак злоумышленников или причина конфиденциальных данных, отправляемых в заголовке ответа. Заголовок атак путем внедрения кода можно избежать, в частности, оставив <xref:System.Web.HttpResponse.HeaderEncoding%2A> свойство ответа по умолчанию. Атаки для уязвимых приложений могут отправляться обратно небезопасные данные как часть заголовка ответа. Если <xref:System.Web.HttpResponse.HeaderEncoding%2A> отключено из-за требования продолжения строки в заголовке или если любой заголовок создан на основе результатов непроверенных данных, данные заголовка должны проверяться перед отправкой в поток ответа.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение кодировки — <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">Значение кодировки — <see cref="P:System.Text.Encoding.Unicode" />.  
  
 \- или -  
  
 Заголовки уже были отправлены.</exception>
      </Docs>
    </Member>
    <Member MemberName="Headers">
      <MemberSignature Language="C#" Value="public System.Collections.Specialized.NameValueCollection Headers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Specialized.NameValueCollection Headers" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Headers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Headers As NameValueCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Specialized::NameValueCollection ^ Headers { System::Collections::Specialized::NameValueCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NameValueCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию заголовков ответа.</summary>
        <value>Коллекция <see cref="T:System.Collections.Specialized.NameValueCollection" /> заголовков ответа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Headers%2A> Свойство поддерживается только с [!INCLUDE[iisver](~/includes/iisver-md.md)] режим интегрированного конвейера и по крайней мере .NET Framework 3.0. При попытке получить доступ к <xref:System.Web.HttpResponse.Headers%2A> свойство и одно из этих двух условий не соблюдается, <xref:System.PlatformNotSupportedException> возникает исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Для этой операции требуется режим интегрированного конвейера в [!INCLUDE[iisver](~/includes/iisver-md.md)] и по крайней мере .NET Framework версии 3.0.</exception>
      </Docs>
    </Member>
    <Member MemberName="HeadersWritten">
      <MemberSignature Language="C#" Value="public bool HeadersWritten { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HeadersWritten" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.HeadersWritten" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HeadersWritten As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HeadersWritten { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[Поддерживается в .NET Framework 4.5.2 и более поздних версиях.]  
  
 Получает значение, указывающее, были ли записаны заголовки ответа.</summary>
        <value>
          Значение <see langword="true" />, если заголовки ответа были записаны; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClientConnected">
      <MemberSignature Language="C#" Value="public bool IsClientConnected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClientConnected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsClientConnected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClientConnected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClientConnected { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, определяющее наличие подключения клиента к серверу.</summary>
        <value>
          Значение <see langword="true" />, если клиент подключен в данный момент; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.IsClientConnected%2A> Возвращает `false` если выполняются следующие условия:  
  
-   Подключение к клиенту было прервано. Это может произойти, если <xref:System.Web.HttpResponse.Close%2A> был вызван метод, или если клиент остановил выполнение веб-страницы или перешел к другой странице.  
  
-   <xref:System.Web.HttpWorkerRequest> Объект, обрабатывающий запрос является `null` или <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> возвращает `false`. Если в настраиваемом <xref:System.Web.HttpWorkerRequest> объект обрабатывает запрос, то <xref:System.Web.HttpWorkerRequest.IsClientConnected%2A?displayProperty=nameWithType> метод может задаваться на основании пользовательских критериев. Например пользовательский рабочий запрос может инициировать тайм-аут после определенного периода времени.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Web.HttpResponse.IsClientConnected%2A> свойство, чтобы проверить, остается ли клиента, который запрашивает страницу подключен к серверу. Если <xref:System.Web.HttpResponse.IsClientConnected%2A> имеет значение true, этот код вызывает <xref:System.Web.HttpResponse.Redirect%2A> метод и клиент будет просмотреть другую страницу. Если <xref:System.Web.HttpResponse.IsClientConnected%2A> имеет значение false, а затем код вызывает <xref:System.Web.HttpResponse.End%2A> завершается метод и обработки всех страниц.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRequestBeingRedirected">
      <MemberSignature Language="C#" Value="public bool IsRequestBeingRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRequestBeingRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.IsRequestBeingRedirected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRequestBeingRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRequestBeingRedirected { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает логическое значение, указывающее изменение расположения клиента.</summary>
        <value>
          Значение <see langword="true" />, если значение заголовка ответа расположения отличается от текущего расположения, в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Web.HttpResponse.IsRequestBeingRedirected%2A> свойство с <xref:System.Web.HttpResponse.RedirectLocation%2A> свойства для тестирования и определить ли абсолютный URI, переданный клиенту в HTTP `Location` заголовок отличается от текущего URI и что нового предполагаемого URI, для которого создается будут переданы.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Output">
      <MemberSignature Language="C#" Value="public System.IO.TextWriter Output { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.TextWriter Output" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Output" />
      <MemberSignature Language="VB.NET" Value="Public Property Output As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::TextWriter ^ Output { System::IO::TextWriter ^ get(); void set(System::IO::TextWriter ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Разрешает выводить текст в исходящем потоке ответа НТТР.</summary>
        <value>Объект <see cref="T:System.IO.TextWriter" />, разрешающий пользовательский вывод на сторону клиента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Следующий пример является страницей ASP.NET, который содержит <xref:System.Web.UI.WebControls.TextBox> элемент управления с его <xref:System.Web.UI.WebControls.TextBox.TextMode%2A> свойство <xref:System.Web.UI.WebControls.TextBoxMode.MultiLine>. Код страницы имеет текст, который пользователь вводит в <xref:System.Web.UI.WebControls.TextBox.TextMode%2A>, использует <xref:System.Web.HttpServerUtility.HtmlEncode%2A> метода HTML кодирования и <xref:System.Web.HttpResponse.Output%2A> свойство для отображения на страницу закодированную строку.  
  
 [!code-aspx-csharp[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/CS/responseoutputcs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse.Output_Sample#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Output_Sample/VB/responseoutputvb.aspx#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OutputStream">
      <MemberSignature Language="C#" Value="public System.IO.Stream OutputStream { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IO.Stream OutputStream" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.OutputStream" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutputStream As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::IO::Stream ^ OutputStream { System::IO::Stream ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Разрешает вывод двоичных данных в теле исходящего содержимого НТТР.</summary>
        <value>Объект <see cref="T:System.IO.Stream" /> ввода-вывода, представляющий начальное содержимое тела исходящего содержимого НТТР.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Начиная с .NET Framework версии 2.0, при использовании <xref:System.IO.Stream.Write%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29?displayProperty=nameWithType> метод потока ввода-ВЫВОДА, возвращаемого по <xref:System.Web.HttpResponse.OutputStream%2A> свойства, может быть порожден следующие исключения:  
  
-   <xref:System.ArgumentOutOfRangeException>, если `offset` или `count` параметр имеет отрицательное значение или если `buffer` длина параметров минус `offset` меньше или равно нулю.  
  
-   <xref:System.ArgumentNullException>, если `buffer` параметр `null`.  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Drawing.Image.Save%2A> метод, чтобы сохранить <xref:System.Drawing.Bitmap> объект <xref:System.Web.HttpResponse.OutputStream%2A> свойство и преобразует изображение в формате JPEG. Затем код вызывает метод Dispose на <xref:System.Drawing.Bitmap> объекта и <xref:System.Drawing.Graphics> объекта, освобождая ресурсы, которые они используют. Наконец, код вызывает <xref:System.Web.HttpResponse.Flush%2A> метод для отправки содержимого ответа для клиента, отправившего запрос.  
  
 Полный пример см. в разделе <xref:System.Web.HttpResponse> класса.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Samples1#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/CS/responsesamplescs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Samples1#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Samples1/VB/responsesamplesvb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          Параметр <paramref name="OutputStream" /> недоступен.</exception>
      </Docs>
    </Member>
    <Member MemberName="Pics">
      <MemberSignature Language="C#" Value="public void Pics (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pics(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Pics(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pics (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pics(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Строка, которую требуется добавить в заголовок <see langword="PICS-Label" />.</param>
        <summary>Добавляет заголовок <see langword="PICS-Label" /> HTTP в поток вывода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Платформа для выбора содержимого Интернета (РИСУНКИ) — это стандарт консорциума World Wide Web (W3C) для содержимого пометки. РИСУНКИ — по существу это язык для создания систем оценок.  
  
 Любое значение может быть метка РИСУНКИ; ASP.NET не проверяет метку. Максимальная длина строки составляет 255 символов. Дополнительные сведения о стандартах РИСУНКИ и синтаксисе см. в разделе [World Wide Web Consortium](http://go.microsoft.com/fwlink/?LinkID=37125) веб-сайта.  
  
   
  
## Examples  
 Следующий пример является страницей ASP.NET, отображающий изображение. Этот код вызывает страницы <xref:System.Web.HttpResponse.Pics%2A> метод, чтобы задать HTTP `PICS-Label` заголовок для ответа. Строка, передаваемый в качестве параметра <xref:System.Web.HttpResponse.Pics%2A> метод представляет Метка оценки, созданные из веб-сайта Internet содержимого рейтинг ассоциации (ICRA).  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#2](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page2cs.aspx#2)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#2](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page2vb.aspx#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="PushPromise">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Повышает уровень обещанного объекта.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">URL-адрес push-запроса. Это должен быть виртуальный путь относительного ресурса, который сервер должен принудительно отправить клиенту.</param>
        <summary>Этот интерфейс API предназначен для поддержки приложений, принудительно отправляющих обещания клиентам HTTP 2.0. Дополнительные сведения о принудительной отправке с сервера Http2 можно найти в [разделе 8.2 спецификации HTTP/2: отправка с сервера](https://http2.github.io/http2-spec/#PushResources).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise не является детерминированным и приложения не должен содержать логику, которая зависит от него. Он предназначен только преимущество в производительности в некоторых случаях. Существует много условий (протокол и реализация), которые могут вызвать полностью игнорировать запросы принудительной. Ожидаемый результат основан на выстрелил и забыл.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PushPromise">
      <MemberSignature Language="C#" Value="public void PushPromise (string path, string method, System.Collections.Specialized.NameValueCollection headers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PushPromise(string path, string method, class System.Collections.Specialized.NameValueCollection headers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.PushPromise(System.String,System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub PushPromise (path As String, method As String, headers As NameValueCollection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PushPromise(System::String ^ path, System::String ^ method, System::Collections::Specialized::NameValueCollection ^ headers);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="headers" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="path">URL-адрес push-запроса. Это должен быть виртуальный путь относительного ресурса, который сервер должен принудительно отправить клиенту.</param>
        <param name="method">Метод запроса HTTP, который будет использоваться в push-запросе.</param>
        <param name="headers">Заголовок запроса HTTP, который будет использоваться в push-запросе.</param>
        <summary>Этот интерфейс API предназначен для поддержки приложений, принудительно отправляющих обещания клиентам HTTP 2.0. Дополнительные сведения о принудительной отправке с сервера Http2 можно найти в [разделе 8.2 спецификации HTTP/2: отправка с сервера](https://http2.github.io/http2-spec/#PushResources).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 PushPromise не является детерминированным и приложения не должен содержать логику, которая зависит от него. Он предназначен только преимущество в производительности в некоторых случаях. Существует много условий (протокол и реализация), которые могут вызвать полностью игнорировать запросы принудительной. Ожидаемый результат основан на выстрелил и забыл.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Redirect">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Перенаправляет клиента на новый URL-адрес.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Конечное расположение. Это может быть виртуальный путь относительно приложения.</param>
        <summary>Перенаправляет запрос по новому адресу и задает новый URL-адрес.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Web.HttpResponse.Redirect%2A> эквивалентно вызову <xref:System.Web.HttpResponse.Redirect%2A> со вторым параметром равным `true`.  
  
 <xref:System.Web.HttpResponse.Redirect%2A> вызовы <xref:System.Web.HttpResponse.End%2A> какие вызывает <xref:System.Threading.ThreadAbortException> исключение после завершения. Это исключение оказывает отрицательное влияние на производительность веб-приложения. Таким образом, рекомендуется вместо этой перегрузки использовать <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> перегружать и передать `false` для `endResponse` параметра, а затем вызовите <xref:System.Web.HttpApplication.CompleteRequest%2A> метод. Дополнительные сведения см. в описании метода <xref:System.Web.HttpResponse.End%2A>.  
  
> [!NOTE]
>  Только для мобильных страниц Если приложение зависит от сеансов без поддержки файлов cookie, или может получать запросы от мобильных устройств, которые требуют без поддержки файлов cookie, использование тильды (~) в пути может привести к созданию нового сеанса и потере данных сеанса. Для задания свойства на мобильный элемент управления с использованием пути, такие как «~ / путь», разрешить пути с помощью <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> «~ / пути» перед их занесением в свойство.  
  
 ASP.NET выполняет перенаправление, возвращая код состояния HTTP 302. Другой способ передачи управления на другую страницу — <xref:System.Web.HttpServerUtility.Transfer%2A> метод. <xref:System.Web.HttpServerUtility.Transfer%2A> Метод обычно более эффективны, так как это не вызывает кругового пути к клиенту. Дополнительные сведения см. в разделе [как: перенаправление пользователей на другую страницу](http://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e).  
  
   
  
## Examples  
 Следующий пример принудительно выполняется безусловное перенаправление на другой веб-сайт.  
  
 [!code-csharp[Classic HttpResponse.Redirect Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.Redirect Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.Redirect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Выполнена попытка перенаправления после отправки HTTP-заголовков.</exception>
      </Docs>
    </Member>
    <Member MemberName="Redirect">
      <MemberSignature Language="C#" Value="public void Redirect (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redirect(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Redirect(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redirect (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redirect(System::String ^ url, bool endResponse);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">Расположение целевого объекта.</param>
        <param name="endResponse">Указывает, должно ли прекратиться выполнение текущей страницы.</param>
        <summary>Перенаправляет клиента на новый URL-адрес. Задает новый URL-адрес и условия прекращения выполнения текущей страницы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Абсолютный URL-адрес (например, http://www.contoso.com/default.aspx) или относительный URL-адрес (например, Default.aspx) могут быть указаны для целевое расположение, но некоторые браузеры могут отклонить относительный URL-адрес.  
  
 При использовании этого метода в обработчике страницы для завершения запроса для одной страницы и начала новый запрос для другой страницы задайте `endResponse` для `false` и затем вызвать <xref:System.Web.HttpApplication.CompleteRequest%2A> метод. При указании `true` для `endResponse` параметра, этот метод вызывает метод <xref:System.Web.HttpResponse.End%2A> первоначальный запрос, который вызывает метод <xref:System.Threading.ThreadAbortException> исключение после ее завершения. Это исключение оказывает отрицательное влияние на производительность веб-приложения, поэтому передача `false` для `endResponse` рекомендуется использовать параметр. Дополнительные сведения см. в описании метода <xref:System.Web.HttpResponse.End%2A>.  
  
> [!NOTE]
>  Для мобильных страниц Если приложение зависит от сеансов без поддержки файлов cookie, или может получать запросы от мобильных устройств, которые требуют без поддержки файлов cookie, использование тильды (~) в пути можно создать новый сеанс и потере данных сеанса. Для задания свойства на мобильный элемент управления с использованием пути, такие как «~ / путь», разрешить пути с помощью <xref:System.Web.UI.MobileControls.MobileControl.ResolveUrl%2A> «~ / пути» перед их занесением в свойство.  
  
 ASP.NET выполняет перенаправление, возвращая код состояния HTTP 302. Другой способ передачи управления на другую страницу — <xref:System.Web.HttpServerUtility.Transfer%2A> метод. <xref:System.Web.HttpServerUtility.Transfer%2A> Метод обычно более эффективны, так как это не вызывает кругового пути к клиенту. Дополнительные сведения см. в разделе [как: перенаправление пользователей на другую страницу](http://msdn.microsoft.com/library/daef3f43-e018-43aa-b43c-46b27bac599e).  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Web.HttpResponse.IsClientConnected%2A> свойство, чтобы проверить, остается ли клиента, который запрашивает страницу подключен к серверу. Если <xref:System.Web.HttpResponse.IsClientConnected%2A> имеет значение true, этот код вызывает <xref:System.Web.HttpResponse.Redirect%2A> метод и клиент будет просмотреть другую страницу. Если <xref:System.Web.HttpResponse.IsClientConnected%2A> имеет значение false, а затем код вызывает <xref:System.Web.HttpResponse.End%2A> завершается метод и обработки всех страниц.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample4#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/CS/page1cs.aspx#1)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample4#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample4/VB/page1vb.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="url" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> содержит символ новой строки.</exception>
        <exception cref="T:System.Web.HttpException">Выполнена попытка перенаправления после отправки HTTP-заголовков.</exception>
        <exception cref="T:System.ApplicationException">Запрос страницы — это результат обратного вызова.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectLocation">
      <MemberSignature Language="C#" Value="public string RedirectLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedirectLocation" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.RedirectLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property RedirectLocation As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RedirectLocation { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение заголовка <see langword="Location" /> HTTP.</summary>
        <value>Абсолютный URI, переданный клиенту в заголовке <see langword="Location" /> HTTP.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Приведенный ниже показано, как использовать это свойство, чтобы указать URL-адрес перенаправления при кода постоянное перенаправление с помощью код ответа HTTP 301.  
  
```csharp  
Response.StatusCode = 301;  
Response.Status = "301 Moved Permanently";  
Response.RedirectLocation = "http://www.newurl.com ";  
Response.End();  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Заголовки HTTP уже записаны.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectPermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет безвозвратное перенаправление с запрошенного URL-адреса на заданный URL-адрес.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">Расположение, в которое следует перенаправить запрос.</param>
        <summary>Выполняет безвозвратное перенаправление с запрошенного URL-адреса на заданный URL-адрес.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> Перегруженный метод содержит код состояния HTTP 301 в ответе и URL-адрес, чтобы перенаправить запрос. Код состояния HTTP 301 — это стандартный код HTTP-ответа. Указывает, что существует постоянное перенаправление, и он обеспечивает место перенаправления.  
  
 Вызов <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%29> перегрузка метода завершает ответ.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="url" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> включает символ новой строки (<c>\n</c>).</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectPermanent">
      <MemberSignature Language="C#" Value="public void RedirectPermanent (string url, bool endResponse);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectPermanent(string url, bool endResponse) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectPermanent(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectPermanent (url As String, endResponse As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectPermanent(System::String ^ url, bool endResponse);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="endResponse" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="url">Расположение, в которое следует перенаправить запрос.</param>
        <param name="endResponse">
          Значение <see langword="true" /> для прерывания ответа, в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</param>
        <summary>Выполняет безвозвратное перенаправление с запрошенного URL-адреса на заданный URL-адрес и предоставляет возможность завершить ответ.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> Перегруженный метод содержит код состояния HTTP 301 в ответе и URL-адрес, чтобы перенаправить запрос. Эта перегрузка метода также предоставляет возможность указать, следует ли прервать или завершить ответ после выполнения перенаправления. Код состояния HTTP 301 — это стандартный код HTTP-ответа. Указывает, что существует постоянное перенаправление, и он обеспечивает место перенаправления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="url" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="url" /> включает символ новой строки (<c>\n</c>).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoute">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Перенаправляет запрос на новый URL-адрес, используя значения параметров маршрута, имя маршрута или и то и другое.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Object ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">Значения параметров маршрута.</param>
        <summary>Перенаправляет запрос на новый URL-адрес, используя значения параметров маршрута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предоставляется для удобства написания кода. Это эквивалентно вызову метода <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> метод со вторым параметром равным `false`.  
  
 Этот метод преобразует объект, который передается в `routeValues` для <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> с использованием <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> конструктор. <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Затем вызывается метод для определения URL-адрес.  
  
 ASP.NET выполняет перенаправление, возвращая код состояния HTTP 302.  
  
   
  
## Examples  
 Следующий пример показывает, как вызвать этот метод, чтобы перенаправить маршрут с параметрами, которые именуются `productid` и `category`.  
  
```vb  
Response.RedirectToRoute(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ни один маршрут не соответствует указанным параметрам маршрута.</exception>
        <exception cref="T:System.Web.HttpException">Была предпринята попытка перенаправления после отправки заголовков HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">Имя маршрута.</param>
        <summary>Перенаправляет запрос на новый URL-адрес, используя имя маршрута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предоставляется для удобства написания кода. Это эквивалентно вызову метода <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> метод со вторым параметром равным `false`.  
  
 Этот метод преобразует имя маршрута, который передается в `routeName` на URL-адрес с помощью <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> метод.  
  
 ASP.NET выполняет перенаправление, возвращая код состояния HTTP 302.  
  
   
  
## Examples  
 Следующий пример показывает, как вызвать этот метод, чтобы перенаправить маршрут с именем `Products`.  
  
```vb  
Response.RedirectToRoute("Products")  
```  
  
```csharp  
Response.RedirectToRoute("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ни один маршрут не соответствует указанным параметрам маршрута.</exception>
        <exception cref="T:System.Web.HttpException">Была предпринята попытка перенаправления после отправки заголовков HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">Значения параметров маршрута.</param>
        <summary>Перенаправляет запрос на новый URL-адрес, используя значения параметров маршрута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предоставляется для удобства написания кода. Это эквивалентно вызову метода <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> метод со вторым параметром равным `false`.  
  
 Этот метод вызывает метод <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> метод, чтобы определить URL-адрес.  
  
 ASP.NET выполняет перенаправление, возвращая код состояния HTTP 302.  
  
   
  
## Examples  
 Следующий пример показывает, как вызвать этот метод, чтобы перенаправить маршрут с параметрами, которые именуются `productid` и `category`.  
  
```vb  
Response.RedirectToRoute(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute(  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ни один маршрут не соответствует указанным параметрам маршрута.</exception>
        <exception cref="T:System.Web.HttpException">Была предпринята попытка перенаправления после отправки заголовков HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">Имя маршрута.</param>
        <param name="routeValues">Значения параметров маршрута.</param>
        <summary>Перенаправляет запрос на новый URL-адрес, используя значения параметров маршрута и имя маршрута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предоставляется для удобства написания кода. Это эквивалентно вызову метода <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> метод со вторым параметром равным `false`.  
  
 Этот метод преобразует объект, который передается в `routeValues` для <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> с использованием <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> конструктор. <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Затем вызывается метод для определения URL-адрес.  
  
 ASP.NET выполняет перенаправление, возвращая код состояния HTTP 302.  
  
   
  
## Examples  
 Следующий пример показывает, как вызвать этот метод, чтобы перенаправить маршрут с именем `Product` и с параметрами, которые именуются `productid` и `category`.  
  
```vb  
Response.RedirectToRoute("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ни один маршрут не соответствует указанным параметрам маршрута.</exception>
        <exception cref="T:System.Web.HttpException">Была предпринята попытка перенаправления после отправки заголовков HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoute">
      <MemberSignature Language="C#" Value="public void RedirectToRoute (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoute(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoute(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoute (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoute(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Имя маршрута.</param>
        <param name="routeValues">Значения параметров маршрута.</param>
        <summary>Перенаправляет запрос на новый URL-адрес, используя значения параметров маршрута и имя маршрута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предоставляется для удобства написания кода. Это эквивалентно вызову метода <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> метод со вторым параметром равным `false`.  
  
 <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Метод вызывается для определения URL-адрес.  
  
 ASP.NET выполняет перенаправление, возвращая код состояния HTTP 302.  
  
   
  
## Examples  
 Следующий пример показывает, как вызвать этот метод, чтобы перенаправить маршрут с именем `Product` и с параметрами, которые именуются `productid` и `category`.  
  
```vb  
Response.RedirectToRoute("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoute("Product",  
  (new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ни один маршрут не соответствует указанным параметрам маршрута.</exception>
        <exception cref="T:System.Web.HttpException">Была предпринята попытка перенаправления после отправки заголовков HTTP.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RedirectToRoutePermanent">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет постоянное перенаправление запроса с запрошенного URL-адреса на новый URL-адрес, используя значения параметров маршрута, имя маршрута или и то и другое.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Object ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeValues">Значения параметров маршрута.</param>
        <summary>Выполняет постоянное перенаправление запроса с запрошенного URL-адреса на новый URL-адрес, используя значения параметров маршрута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предоставляется для удобства написания кода. Это эквивалентно вызову метода <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> метод со вторым параметром равным `false`.  
  
 Этот метод преобразует объект, который передается в `routeValues` для <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> с использованием <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> конструктор. <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Затем вызывается метод для определения URL-адрес.  
  
 ASP.NET выполняет перенаправление, возвращая код состояния HTTP 301.  
  
   
  
## Examples  
 Следующий пример показывает, как вызвать этот метод, чтобы перенаправить маршрут с параметрами, которые именуются `productid` и `category`.  
  
```vb  
Response.RedirectToRoutePermanent(  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ни один маршрут не соответствует указанным параметрам маршрута.</exception>
        <exception cref="T:System.Web.HttpException">Была предпринята попытка перенаправления после отправки заголовков HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="routeName">Имя маршрута.</param>
        <summary>Выполняет постоянное перенаправление с запрошенного URL-адреса на новый URL-адрес, используя имя маршрута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предоставляется для удобства написания кода. Это эквивалентно вызову метода <xref:System.Web.HttpResponse.RedirectPermanent%28System.String%2CSystem.Boolean%29> метод со вторым параметром равным `false`.  
  
 Этот метод преобразует имя маршрута, который передается в `routeName` на URL-адрес с помощью <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> метод.  
  
 ASP.NET выполняет перенаправление, возвращая код состояния HTTP 301.  
  
   
  
## Examples  
 Следующий пример показывает, как вызвать этот метод, чтобы перенаправить маршрут с именем `Products`.  
  
```vb  
Response.RedirectToRoutePermanent("Products")  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Products");  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ни один маршрут не соответствует указанным параметрам маршрута.</exception>
        <exception cref="T:System.Web.HttpException">Была предпринята попытка перенаправления после отправки заголовков HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeValues">Значения параметров маршрута.</param>
        <summary>Выполняет постоянное перенаправление запроса с запрошенного URL-адреса на новый URL-адрес, используя значения параметров маршрута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предоставляется для удобства написания кода. Это эквивалентно вызову метода <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> метод со вторым параметром равным `false`.  
  
 Этот метод вызывает метод <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> метод, чтобы определить URL-адрес.  
  
 ASP.NET выполняет перенаправление, возвращая код состояния HTTP 301.  
  
   
  
## Examples  
 Следующий пример показывает, как вызвать этот метод, чтобы перенаправить маршрут с параметрами, которые именуются `productid` и `category`.  
  
```vb  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent(  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ни один маршрут не соответствует указанным параметрам маршрута.</exception>
        <exception cref="T:System.Web.HttpException">Была предпринята попытка перенаправления после отправки заголовков HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, object routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, object routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Object ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routeName">Имя маршрута.</param>
        <param name="routeValues">Значения параметров маршрута.</param>
        <summary>Выполняет постоянное перенаправление запроса с запрошенного URL-адреса на новый URL-адрес, используя значения параметров маршрута и имя маршрута, соответствующее новому URL-адресу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предоставляется для удобства написания кода. Это эквивалентно вызову метода <xref:System.Web.HttpResponse.RedirectPermanent%2A> метод со вторым параметром равным `false`.  
  
 Этот метод преобразует объект, который передается в `routeValues` для <xref:System.Web.Routing.RouteValueDictionary?displayProperty=nameWithType> с использованием <xref:System.Web.Routing.RouteValueDictionary.%23ctor%28System.Object%29?displayProperty=nameWithType> конструктор. <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> Затем вызывается метод для определения URL-адрес.  
  
 ASP.NET выполняет перенаправление, возвращая код состояния HTTP 301.  
  
   
  
## Examples  
 Следующий пример показывает, как вызвать этот метод, чтобы перенаправить маршрут с именем `Product` и с параметрами, которые именуются `productid` и `category`.  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  New With {.productid = "1", .category = "widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new { productid = "1", category = "widgets" });  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ни один маршрут не соответствует указанным параметрам маршрута.</exception>
        <exception cref="T:System.Web.HttpException">Была предпринята попытка перенаправления после отправки заголовков HTTP.</exception>
      </Docs>
    </Member>
    <Member MemberName="RedirectToRoutePermanent">
      <MemberSignature Language="C#" Value="public void RedirectToRoutePermanent (string routeName, System.Web.Routing.RouteValueDictionary routeValues);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RedirectToRoutePermanent(string routeName, class System.Web.Routing.RouteValueDictionary routeValues) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RedirectToRoutePermanent(System.String,System.Web.Routing.RouteValueDictionary)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RedirectToRoutePermanent (routeName As String, routeValues As RouteValueDictionary)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RedirectToRoutePermanent(System::String ^ routeName, System::Web::Routing::RouteValueDictionary ^ routeValues);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routeName" Type="System.String" />
        <Parameter Name="routeValues" Type="System.Web.Routing.RouteValueDictionary" />
      </Parameters>
      <Docs>
        <param name="routeName">Имя маршрута.</param>
        <param name="routeValues">Значения параметров маршрута.</param>
        <summary>Выполняет постоянное перенаправление запроса с запрошенного URL-адреса на новый URL-адрес, используя значения параметров маршрута и имя маршрута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предоставляется для удобства написания кода. Это эквивалентно вызову метода <xref:System.Web.HttpResponse.Redirect%28System.String%2CSystem.Boolean%29> метод со вторым параметром равным `false`.  
  
 Этот метод вызывает метод <xref:System.Web.Routing.RouteCollection.GetVirtualPath%2A?displayProperty=nameWithType> метод, чтобы определить URL-адрес.  
  
 ASP.NET выполняет перенаправление, возвращая код состояния HTTP 301.  
  
   
  
## Examples  
 Следующий пример показывает, как вызвать этот метод, чтобы перенаправить маршрут с именем `Product` и с параметрами, которые именуются `productid` и `category`.  
  
```vb  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"})  
```  
  
```csharp  
Response.RedirectToRoutePermanent("Product",  
  new RouteValueDictionary {productId="1", category="widgets"});  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Ни один маршрут не соответствует указанным параметрам маршрута.</exception>
        <exception cref="T:System.Web.HttpException">Была предпринята попытка перенаправления после отправки заголовков HTTP.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveOutputCacheItem">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Удаляет элементы из кэша вывода с помощью поставщика кэша вывода по умолчанию.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Виртуальный абсолютный путь к элементам, удаляемым из кэша.</param>
        <summary>Удаляет из кэша все элементы, связанные с поставщиком кэша вывода по умолчанию. Это статический метод.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для удаления элементов кэша вывода, связанные с поставщиком кэша вывода по умолчанию. Вызовите <xref:System.Web.HttpResponse.RemoveOutputCacheItem%2A> метод для удаления элементов кэша вывода, которые связаны с пользовательскими поставщиками кэша вывода, которые указаны в файле конфигурации веб-сайта.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="path" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          Параметр <paramref name="path" /> не является абсолютным виртуальным путем.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveOutputCacheItem">
      <MemberSignature Language="C#" Value="public static void RemoveOutputCacheItem (string path, string providerName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveOutputCacheItem(string path, string providerName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.RemoveOutputCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveOutputCacheItem (path As String, providerName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveOutputCacheItem(System::String ^ path, System::String ^ providerName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="providerName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Виртуальный абсолютный путь к элементам, удаляемым из кэша.</param>
        <param name="providerName">Поставщик, используемый для удаления артефактов из кэша вывода, связанных с указанным путем.</param>
        <summary>С помощью указанного поставщика кэша вывода удаляет из кэша вывода все элементы, связанные с указанным путем.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для удаления элементов кэша вывода, связанные с пользовательскими поставщиками кэша вывода, которые указаны в файле конфигурации веб-сайта. Чтобы удалить элементы кэша вывода, связанные с поставщиком кэша вывода по умолчанию, вызовите <xref:System.Web.HttpResponse.RemoveOutputCacheItem%28System.String%29> перегрузки метода.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="path" /> имеет значение null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="path" /> является недопустимым путем.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetCookie">
      <MemberSignature Language="C#" Value="public void SetCookie (System.Web.HttpCookie cookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCookie(class System.Web.HttpCookie cookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.SetCookie(System.Web.HttpCookie)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCookie (cookie As HttpCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCookie(System::Web::HttpCookie ^ cookie);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="cookie" Type="System.Web.HttpCookie" />
      </Parameters>
      <Docs>
        <param name="cookie">Файл cookie, который необходимо обновить в коллекции.</param>
        <summary>Так как метод <b>HttpResponse.SetCookie</b> предназначен только для внутреннего использования, его не следует вызывать в коде. Вместо этого можно вызвать метод <b>HttpResponse.Cookies.Set</b>, как показано в приведенном ниже примере.<br /> Обновляет существующий файл cookie из коллекции данных файлов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере обновляется значение существующего файла cookie.  
  
 [!code-csharp[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.SetCookie Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.SetCookie Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Сделана попытка задать файл Cookie после отправки заголовков HTTP.</exception>
        <altmember cref="F:System.Net.HttpRequestHeader.Cookie" />
        <altmember cref="T:System.Web.HttpCookie" />
        <altmember cref="T:System.Web.HttpCookieMode" />
      </Docs>
    </Member>
    <Member MemberName="Status">
      <MemberSignature Language="C#" Value="public string Status { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Status" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.Status" />
      <MemberSignature Language="VB.NET" Value="Public Property Status As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Status { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Задает строку <see langword="Status" />, возвращаемую клиенту.</summary>
        <value>При задании кода состояния клиенту возвращается строка, описывающая состояние вывода НТТР. По умолчанию используется значение "200 (ОК)".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.Status%2A> рекомендуется к использованию для <xref:System.Web.HttpResponse.StatusDescription%2A> и предоставляется только для совместимости с предыдущими версиями ASP. С помощью ASP.NET, используйте <xref:System.Web.HttpResponse.StatusDescription%2A> вместо него.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">Задан недопустимый код состояния.</exception>
      </Docs>
    </Member>
    <Member MemberName="StatusCode">
      <MemberSignature Language="C#" Value="public int StatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 StatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int StatusCode { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает код состояния НТТР вывода, возвращаемого клиенту.</summary>
        <value>Целое число, представляющее состояние НТТР вывода, возвращаемого клиенту. По умолчанию используется значение "200 (ОК)". Список допустимых кодах состояния см. в разделе [коды состояния Http](http://go.microsoft.com/fwlink/?LinkId=73157).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере проверяется код состояния выходного потока. Если код состояния не равен 200, выполняется дополнительный код.  
  
 [!code-csharp[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusCode/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          Свойство <see cref="P:System.Web.HttpResponse.StatusCode" /> задается после отправки заголовков HTTP.</exception>
        <altmember cref="P:System.Web.HttpResponse.SubStatusCode" />
      </Docs>
    </Member>
    <Member MemberName="StatusDescription">
      <MemberSignature Language="C#" Value="public string StatusDescription { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StatusDescription" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.StatusDescription" />
      <MemberSignature Language="VB.NET" Value="Public Property StatusDescription As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StatusDescription { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает строку состояния НТТР вывода, возвращаемого клиенту.</summary>
        <value>Строка, описывающая состояние НТТР вывода, возвращаемого клиенту. По умолчанию используется значение "ОК". Список допустимых кодах состояния см. в разделе [коды состояния Http](http://go.microsoft.com/fwlink/?LinkId=73157).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере проверяется строка состояния выходного потока. Если состояние не равно «ОК», выполняется дополнительный код.  
  
 [!code-csharp[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/cs/default.aspx#1)]
 [!code-vb[System.Web.HttpResponse.StatusDescription#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.StatusDescription/vb/default.aspx#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          Свойство <paramref name="StatusDescription" /> задается после отправки заголовков HTTP.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Выбранное значение имеет длину больше 512.</exception>
      </Docs>
    </Member>
    <Member MemberName="SubStatusCode">
      <MemberSignature Language="C#" Value="public int SubStatusCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SubStatusCode" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SubStatusCode" />
      <MemberSignature Language="VB.NET" Value="Public Property SubStatusCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SubStatusCode { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, определяющее код состояния ответа.</summary>
        <value>Целочисленное значение, которое представляет код подсостояния [!INCLUDE[iisver](~/includes/iisver-md.md)].</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.SubStatusCode%2A> Свойство поддерживается только в режиме интегрированного конвейера в [!INCLUDE[iisver](~/includes/iisver-md.md)] и по крайней мере .NET Framework версии 3.0. При задании <xref:System.Web.HttpResponse.SubStatusCode%2A> свойства, состояние входа [!INCLUDE[iisver](~/includes/iisver-md.md)] Если настроена трассировка неудачных запросов. Независимо от настройки трассировки, код никогда не отправляется в составе окончательного ответа на запрос. Дополнительные сведения см. в разделе [Устранение неполадок сбой запросов с помощью сбойных запросов в IIS 7.0](http://www.iis.net/default.aspx?tabid=2&subtabid=25&i=969&p=1).  
  
   
  
## Examples  
 В следующем примере задается <xref:System.Web.HttpResponse.SubStatusCode%2A> свойство в обработчике событий для <xref:System.Web.HttpApplication> экземпляр <xref:System.Web.HttpApplication.PostAuthenticateRequest> событий. Поместите файл кода в папке App_Code веб-приложения и настроить файл Web.config, чтобы зарегистрировать модуль. Дополнительные сведения см. в разделе [Пошаговое руководство: Создание и регистрация пользовательского HTTP-модуля](http://msdn.microsoft.com/library/7787d5be-40a4-4072-9075-c2b767428453).  
  
 [!code-csharp[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/CS/App_Code/TestModule.cs#1)]
 [!code-vb[System.Web.HttpResponse.SubStatusCode#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.SubStatusCode/VB/App_Code/TestModule.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Для этой операции требуется режим интегрированного конвейера в [!INCLUDE[iisver](~/includes/iisver-md.md)] и по крайней мере .NET Framework версии 3.0.</exception>
        <exception cref="T:System.Web.HttpException">Код состояния задается после отправки всех заголовков HTTP.</exception>
        <altmember cref="P:System.Web.HttpResponse.StatusCode" />
      </Docs>
    </Member>
    <Member MemberName="SupportsAsyncFlush">
      <MemberSignature Language="C#" Value="public bool SupportsAsyncFlush { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SupportsAsyncFlush" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SupportsAsyncFlush" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SupportsAsyncFlush As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SupportsAsyncFlush { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, поддерживает ли подключение асинхронные операции очистки.</summary>
        <value>
          Значение <see langword="true" />, если подключение поддерживает асинхронные операции очистки; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает значение <xref:System.Web.HttpWorkerRequest.SupportsAsyncFlush%2A?displayProperty=nameWithType> свойства.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressContent">
      <MemberSignature Language="C#" Value="public bool SuppressContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressContent" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressContent { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, следует ли отправить содержимое НТТР клиенту.</summary>
        <value>
          Значение <see langword="true" /> для подавления вывода; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере проверяется ли <xref:System.Web.HttpRequest.IsSecureConnection%2A> свойство имеет значение false. Если это так, <xref:System.Web.HttpResponse.SuppressContent%2A> задано значение true, чтобы остановить отправку ответа.  
  
 [!code-csharp[System.Web.HttpResponse_Sample5#3](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsesuppresscontentcs.aspx#3)]
 [!code-vb[System.Web.HttpResponse_Sample5#3](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsesuppresscontentvb.aspx#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressDefaultCacheControlHeader">
      <MemberSignature Language="C#" Value="public bool SuppressDefaultCacheControlHeader { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressDefaultCacheControlHeader" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressDefaultCacheControlHeader As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressDefaultCacheControlHeader { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>[Поддерживается в .NET Framework 4.5.2 и более поздних версиях.]  
  
 Возвращает или задает значение, указывающее, следует ли подавлять заголовок <c>Cache Control: private</c> по умолчанию для текущего HTTP-ответа.</summary>
        <value>
          <see langword="true" /> для подавления по умолчанию <c>управления кэшем: закрытый</c> заголовок для текущего HTTP-ответа; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию, ASP.NET отправляет `Cache-Control: private` заголовок ответа, если не был указан кэш явных политики для этого ответа. Это свойство позволяет подавление этот заголовок ответа по умолчанию для каждого запроса. Заголовок можно по-прежнему подавить для всего приложения, задав <xref:System.Web.Configuration.HttpRuntimeSection.SendCacheControlHeader%2A> в [httpRuntime (схема параметров ASP.NET) элемент](http://msdn.microsoft.com/library/e9b81350-8aaf-47cc-9843-5f7d0c59f369) или [outputCache элемент для кэширования (схема параметров ASP.NET)](http://msdn.microsoft.com/library/47cd2b47-316f-4dfd-bbf8-539be3066fee).  
  
 Соблюдайте осторожность при подавлении значение по умолчанию `Cache-Control: private` заголовок, как прокси-серверы и другие посредники могут считать ответы без этого заголовка может быть кэширован по умолчанию. Это обработки может привести к ненамеренное кэширование конфиденциальные сведения. В разделе [RFC 2616, 13.4 секунду](http://tools.ietf.org/html/rfc2616) для получения дополнительной информации.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SuppressFormsAuthenticationRedirect">
      <MemberSignature Language="C#" Value="public bool SuppressFormsAuthenticationRedirect { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.SuppressFormsAuthenticationRedirect" />
      <MemberSignature Language="VB.NET" Value="Public Property SuppressFormsAuthenticationRedirect As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SuppressFormsAuthenticationRedirect { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, следует ли отключить перенаправление аутентификации с помощью форм на страницу входа.</summary>
        <value>
          Значение <see langword="true" />, если перенаправление аутентификации на основе форм должно быть отменено; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию проверка подлинности форм преобразует коды состояния HTTP 401 на 302 для перенаправления на страницу входа. Это нецелесообразно, для некоторых типов ошибок, например при успешном завершении проверки подлинности, но авторизации завершается ошибкой, или в случае текущий запрос запрос AJAX или веб-службы. Это свойство позволяет отключить поведение перенаправления и отправки исходного кода состояния клиенту.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TransmitFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Записывает указанный файл непосредственно в поток вывода ответа HTTP, не используя буфер в памяти.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Имя файла, который записывается в выходные данные НТТР.</param>
        <summary>Записывает указанный файл непосредственно в поток вывода ответа HTTP, не используя буфер в памяти.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="filename" /> равно <see langword="null" /></exception>
      </Docs>
    </Member>
    <Member MemberName="TransmitFile">
      <MemberSignature Language="C#" Value="public void TransmitFile (string filename, long offset, long length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TransmitFile(string filename, int64 offset, int64 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.TransmitFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub TransmitFile (filename As String, offset As Long, length As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TransmitFile(System::String ^ filename, long offset, long length);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="length" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">Имя файла, который записывается в выходные данные НТТР.</param>
        <param name="offset">Позиция в файле, с которой начинается запись в выходные данные НТТР.</param>
        <param name="length">Количество передаваемых байтов.</param>
        <summary>Записывает указанную часть файла непосредственно в поток вывода ответа HTTP, не используя буфер в памяти.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При указании 0 как `offset` параметр и -1, поскольку `length` отправляется параметр, весь файл.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение параметра <paramref name="offset" /> меньше нуля.  
  
 \- или -  
  
 Значение параметра <paramref name="length" /> меньше –1.  
  
 \- или -  
  
 Параметр <paramref name="length" /> указывает количество байтов, превышающее количество байтов в файле, уменьшенное на значение смещения.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Внепроцессный рабочий запрос не поддерживается.  
  
 \- или -  
  
 Ответ не использует объект <see cref="T:System.Web.HttpWriter" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="offset" /> меньше нуля или больше размера файла.  
  
 \- или -  
  
 Значение параметра <paramref name="length" /> меньше -1 или больше значения параметра <paramref name="offset" /> плюс размер файла.</exception>
      </Docs>
    </Member>
    <Member MemberName="TrySkipIisCustomErrors">
      <MemberSignature Language="C#" Value="public bool TrySkipIisCustomErrors { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TrySkipIisCustomErrors" />
      <MemberSignature Language="DocId" Value="P:System.Web.HttpResponse.TrySkipIisCustomErrors" />
      <MemberSignature Language="VB.NET" Value="Public Property TrySkipIisCustomErrors As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TrySkipIisCustomErrors { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, которое указывает, отключены ли пользовательские ошибки [!INCLUDE[iisver](~/includes/iisver-md.md)].</summary>
        <value>
          Значение <see langword="true" />, чтобы запретить пользовательские ошибки IIS, в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> Свойство используется только в том случае, если приложение размещено в службах IIS 7.0. При выполнении в классическом режиме в IIS 7.0 <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> значение свойства по умолчанию — `true`. При работе в режиме интеграции с <xref:System.Web.HttpResponse.TrySkipIisCustomErrors%2A> значение свойства по умолчанию — `false`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Записывает сведения в поток вывода ответа НТТР.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char ch);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char ch) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (ch As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(char ch);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ch" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="ch">Символ, записываемый в поток вывода НТТР.</param>
        <summary>Записывает символ в поток вывода ответа НТТР.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается последовательность констант, которые записываются в страницу ASP.NET с помощью метода записи. Код вызывает эта версия метода Write, чтобы записать отдельные символьные константы на странице.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект <see cref="T:System.Object" />, записываемый в поток вывода НТТР.</param>
        <summary>Записывает объект <see cref="T:System.Object" /> в поток ответа HTTP.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (s As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ s);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Строка, записываемая в поток вывода НТТР.</param>
        <summary>Записывает строку в поток вывода ответа НТТР.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Динамически создаваемые страницы HTML могут создавать угрозу безопасности, если входные данные, полученные от веб-клиентов, не проверяется при получении от клиента или при передаче обратно клиенту. Вредоносный скрипт, внедренный в входных данных, передаваемых веб-узел, а затем обратно к клиенту может появиться исходить из надежного источника. Риск безопасности называется атакой по сценариев. Всегда проверяйте данные, полученные от клиента, при передаче с веб-узла в клиентских браузерах.  
  
 Кроме того, каждый раз, когда записи как HTML любых данных, полученных в качестве входных данных, необходимо кодировать их с помощью техники, например <xref:System.Web.HttpServerUtility.HtmlEncode%2A> или <xref:System.Web.HttpServerUtility.UrlEncode%2A> чтобы предотвратить выполнение вредоносных скриптов. Этот метод полезен для данных, который не был проверен, если он был получен.  
  
 При кодировании или фильтрации данных, необходимо указать набор знаков для веб-страниц, чтобы фильтр можно определить и удалить любую последовательность байтов, не принадлежащих значение (например, последовательности не алфавитно-цифровым) и может содержать вредоносный скрипт их.  
  
 Дополнительные сведения о межсайтовых атак с использованием сценариев см. в статье Q252985, «Как избежать межсайтовых сценариев проблем с безопасностью» на [базы знаний Майкрософт](http://go.microsoft.com/fwlink/?LinkID=37115) веб-сайта.  
  
   
  
## Examples  
 Следующий пример возвращает имя клиента обратно в браузер клиента. <xref:System.Web.HttpServerUtility.HtmlEncode%2A> Методы, позволяющие любой вредоносный скрипт и недопустимые символы, переданных в `UserName` поля ввода.  
  
 [!code-csharp[System.Web.HttpResponse.Write#1](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse.Write/CS/systemwebhttpresponsewrite.cs#1)]
 [!code-vb[System.Web.HttpResponse.Write#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse.Write/vb/systemwebhttpresponsewrite.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Записываемый массив символов.</param>
        <param name="index">Позиция в массиве символов, с которой начинается запись.</param>
        <param name="count">Число записываемых символов начиная с позиции <c>index</c>.</param>
        <summary>Записывает массив символов в поток вывода ответа НТТР.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается последовательность констант, которые записываются в страницу ASP.NET с помощью метода записи. Код вызывает эта версия метода Write, чтобы записать отдельные символьные константы на странице.  
  
 [!code-aspx-csharp[System.Web.HttpResponse_Sample5#4](~/samples/snippets/csharp/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/CS/httpresponsewritecharscs.aspx#4)]
 [!code-aspx-vb[System.Web.HttpResponse_Sample5#4](~/samples/snippets/visualbasic/VS_Snippets_WebNet/System.Web.HttpResponse_Sample5/VB/httpresponsewritecharsvb.aspx#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteFile">
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Записывает указанный файл непосредственно в поток вывода ответа НТТР.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filename">Имя файла, который записывается в выходные данные НТТР.</param>
        <summary>Записывает содержимое указанного файла непосредственно в выходной поток ответа HTTP в виде блока файла.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании этого метода с большими файлами вызова метода может вызывать исключение. Размер файла, который может использоваться с помощью этого метода зависит от конфигурации оборудования веб-сервера. Дополнительные сведения см. в статье 812406, «PRB: Response.WriteFile невозможно загрузить больших файлов» на [базы знаний Майкрософт](http://go.microsoft.com/fwlink/?linkid=149903) веб-сайта.  
  
   
  
## Examples  
 Следующий пример записывает все содержимое текстового файла с именем `Login.txt` (который может содержать литеральное HTML текст и элементы управления входными) непосредственно в выходной поток.  
  
 [!code-csharp[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="filename" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, bool readIntoMemory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, bool readIntoMemory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, readIntoMemory As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, bool readIntoMemory);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="readIntoMemory" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filename">Имя файла, записываемого в блок памяти.</param>
        <param name="readIntoMemory">Указывает на то, что файл будет записан в блок памяти.</param>
        <summary>Записывает содержимое указанного файла непосредственно в выходной поток ответа HTTP в виде блока памяти.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании этого метода с большими файлами вызова метода может вызывать исключение. Размер файла, который может использоваться с помощью этого метода зависит от конфигурации оборудования веб-сервера. Дополнительные сведения см. в статье 812406, «PRB: Response.WriteFile невозможно загрузить больших файлов» на [базы знаний Майкрософт](http://go.microsoft.com/fwlink/?linkid=149903) веб-сайта.  
  
   
  
## Examples  
 Следующий пример записывает файл в память.  
  
 [!code-csharp[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="filename" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (IntPtr fileHandle, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(native int fileHandle, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.IntPtr,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (fileHandle As IntPtr, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(IntPtr fileHandle, long offset, long size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileHandle" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="fileHandle">Дескриптор файла, который записывается в поток вывода НТТР.</param>
        <param name="offset">Позиция байта в файле, с которой начинается запись.</param>
        <param name="size">Число байтов, записываемое в поток вывода.</param>
        <summary>Записывает указанный файл непосредственно в поток вывода ответа НТТР.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании этого метода с большими файлами вызова метода может вызывать исключение. Размер файла, который может использоваться с помощью этого метода зависит от конфигурации оборудования веб-сервера. Дополнительные сведения см. в статье 812406, «PRB: Response.WriteFile невозможно загрузить больших файлов» на [базы знаний Майкрософт](http://go.microsoft.com/fwlink/?linkid=149903) веб-сайта.  
  
   
  
## Examples  
 Следующий пример записывает все содержимое текстового файла с именем `Login.txt` (который может содержать литеральное HTML текст и элементы управления входными) непосредственно в выходной поток.  
  
 [!code-csharp[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="fileHandler" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Web.HttpException">
          Значение параметра <paramref name="offset" /> меньше 0.  
  
 \- или -  
  
 Значение параметра <paramref name="size" /> больше, чем размер файла, уменьшенный на значение <paramref name="offset" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteFile">
      <MemberSignature Language="C#" Value="public void WriteFile (string filename, long offset, long size);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteFile(string filename, int64 offset, int64 size) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteFile(System.String,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteFile (filename As String, offset As Long, size As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteFile(System::String ^ filename, long offset, long size);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filename" Type="System.String" />
        <Parameter Name="offset" Type="System.Int64" />
        <Parameter Name="size" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="filename">Имя файла, который записывается в поток вывода НТТР.</param>
        <param name="offset">Позиция байта в файле, с которой начинается запись.</param>
        <param name="size">Число байтов, записываемое в поток вывода.</param>
        <summary>Записывает указанный файл непосредственно в поток вывода ответа НТТР.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании этого метода с большими файлами вызова метода может вызывать исключение. Размер файла, который может использоваться с помощью этого метода зависит от конфигурации оборудования веб-сервера. Дополнительные сведения см. в статье 812406, «PRB: Response.WriteFile невозможно загрузить больших файлов» на [базы знаний Майкрософт](http://go.microsoft.com/fwlink/?linkid=149903) веб-сайта.  
  
   
  
## Examples  
 Следующий пример записывает все содержимое текстового файла с именем `Login.txt` (который может содержать литеральный текст и HTML с элементами управления вводом) непосредственно в выходной поток.  
  
 [!code-csharp[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/csharp/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/CS/source.cs#1)]
 [!code-vb[Classic HttpResponse.WriteFile2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/Classic HttpResponse.WriteFile2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Web.HttpException">
          Значение параметра <paramref name="offset" /> меньше 0.  
  
 \- или -  
  
 Значение параметра <paramref name="size" /> больше, чем размер файла, уменьшенный на значение <paramref name="offset" />.</exception>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="filename" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="WriteSubstitution">
      <MemberSignature Language="C#" Value="public void WriteSubstitution (System.Web.HttpResponseSubstitutionCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteSubstitution(class System.Web.HttpResponseSubstitutionCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.HttpResponse.WriteSubstitution(System.Web.HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteSubstitution (callback As HttpResponseSubstitutionCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteSubstitution(System::Web::HttpResponseSubstitutionCallback ^ callback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.Web.HttpResponseSubstitutionCallback" />
      </Parameters>
      <Docs>
        <param name="callback">Метод, пользовательский элемент управления или объект для замены.</param>
        <summary>Позволяет выполнять вставку блоков замены ответа в ответ, что предоставляет возможность для динамического формирования указанных областей ответа для выходных кэшируемых ответов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать <xref:System.Web.HttpResponse.WriteSubstitution%2A> метода для подстановки после кэширования на страницах с кэшируемым выводом. Путем передачи <xref:System.Web.HttpContext> в метод обратного вызова с предписанных <xref:System.Web.HttpResponseSubstitutionCallback> подпись, можно заменить кэширования вывода содержимого в любом месте, заданного в кэше страницы. Чтобы инициировать замены, вызовите <xref:System.Web.HttpResponse.WriteSubstitution%2A> метод, передав ему метод обратного вызова, который должен быть потокобезопасным и может принимать одно из следующих:  
  
-   Статический метод для контейнера или элементов управления.  
  
-   Статический метод или метод для других произвольных объектов экземпляра.  
  
 При первом запросе к странице <xref:System.Web.HttpResponse.WriteSubstitution%2A> вызовы <xref:System.Web.HttpResponseSubstitutionCallback> делегат, выходные данные. Затем он добавляет буфер замены в ответ, в котором хранится делегат для вызова при последующих запросах. Наконец значительно снижает клиентские возможности кэширования с общедоступной только для сервера, для обеспечения будущие запросы для повторного вызова страницы делегат не кэширование на стороне клиента.  
  
> [!NOTE]
>  После кэширования подстановки не поддерживается для кэшированного пользовательского элемента управления, где кэширование вывода применяется на уровне пользовательского элемента управления. Это также называется фрагментарное кэширование. Дополнительные сведения см. в разделе [кэширование частей страницы ASP.NET](http://msdn.microsoft.com/library/cdd8e523-7305-4685-a456-c5be1de1367e).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Целевой объект параметра <paramref name="callback" /> имеет тип <see cref="T:System.Web.UI.Control" />.</exception>
        <altmember cref="T:System.Web.HttpResponseSubstitutionCallback" />
        <altmember cref="T:System.Web.UI.WebControls.Substitution" />
      </Docs>
    </Member>
  </Members>
</Type>