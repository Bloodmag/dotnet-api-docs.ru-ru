<Type Name="BindingBase" FullName="System.Windows.Data.BindingBase">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6871bcc8808192513fe5930b08bd4db0522bbb17" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30629568" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class BindingBase : System.Windows.Markup.MarkupExtension" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract BindingBase extends System.Windows.Markup.MarkupExtension" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Data.BindingBase" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class BindingBase&#xA;Inherits MarkupExtension" />
  <TypeSignature Language="C++ CLI" Value="public ref class BindingBase abstract : System::Windows::Markup::MarkupExtension" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Markup.MarkupExtension</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Modifiability=System.Windows.Modifiability.Unmodifiable, Readability=System.Windows.Readability.Unreadable)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.MarkupExtensionReturnType(typeof(System.Object))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Определяет общие характеристики классов <see cref="T:System.Windows.Data.Binding" />, <see cref="T:System.Windows.Data.PriorityBinding" />и <see cref="T:System.Windows.Data.MultiBinding" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поскольку <xref:System.Windows.Data.BindingBase.ProvideValue%2A?displayProperty=nameWithType> метод запечатан, класс пользовательской привязки, производный от <xref:System.Windows.Data.BindingBase> не будет правильно функционировать как [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] расширения разметки.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="BindingGroupName">
      <MemberSignature Language="C#" Value="public string BindingGroupName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BindingGroupName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingBase.BindingGroupName" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroupName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BindingGroupName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя группы <see cref="T:System.Windows.Data.BindingGroup" />, к которой принадлежит данная привязка.</summary>
        <value>Имя группы <see cref="T:System.Windows.Data.BindingGroup" />, к которой принадлежит данная привязка.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> не задано, принадлежит данная привязка <xref:System.Windows.Data.BindingGroup> только если источник привязки и <xref:System.Windows.FrameworkElement.DataContext%2A> родительского элемента, который имеет <xref:System.Windows.Data.BindingGroup> — это тот же объект.  
  
 Если <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> установлено в значение, принадлежит данная привязка <xref:System.Windows.Data.BindingGroup> если выполняются следующие условия:  
  
-   <xref:System.Windows.Data.BindingGroup.Name%2A> Из <xref:System.Windows.Data.BindingGroup> и <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> равны.  
  
-   <xref:System.Windows.Data.BindingGroup> Относится к целевому элементу привязки родительским элементом.  
  
 Если <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> равно `null`, привязка никогда не является частью <xref:System.Windows.Data.BindingGroup>.  
  
 Можно включить привязки, в которых источник, отличный от <xref:System.Windows.FrameworkElement.DataContext%2A> родительского элемента, который имеет <xref:System.Windows.Data.BindingGroup> , установив <xref:System.Windows.Data.BindingGroup.Name%2A> из <xref:System.Windows.Data.BindingGroup> и <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> свойство привязки, то же значение.  Вы можете исключить привязки, в которых один и тот же источник как <xref:System.Windows.FrameworkElement.DataContext%2A> родительского элемента, который имеет <xref:System.Windows.Data.BindingGroup> , установив <xref:System.Windows.Data.BindingGroup.Name%2A> из <xref:System.Windows.Data.BindingGroup> и <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> свойство привязки в разные значения.  
  
   
  
## Examples  
 Следующие примеры являются частью приложения, которое проверяет, ли пользователь задать свойства одинаковые значения для двух объектов. В первом примере создается два <xref:System.Windows.Controls.TextBox> элементов управления, каждый из которых является привязан к другому источнику данных: привязка первого <xref:System.Windows.Controls.TextBox> является частью <xref:System.Windows.Data.BindingGroup> из-за <xref:System.Windows.Controls.TextBox> наследует <xref:System.Windows.FrameworkElement.DataContext%2A> и <xref:System.Windows.Data.BindingGroup> из его родительский <xref:System.Windows.Controls.StackPanel>  
  
 Привязка на второй <xref:System.Windows.Controls.TextBox> является частью <xref:System.Windows.Data.BindingGroup> из-за <xref:System.Windows.Data.BindingGroup.Name%2A> из <xref:System.Windows.Data.BindingGroup> и <xref:System.Windows.Data.BindingBase.BindingGroupName%2A> из <xref:System.Windows.Data.Binding> устанавливаются равными `bindingGroup`.  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupName](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupname)]  
[!code-xaml[BindingGroupSnippets#ValidationAdornerSite](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#validationadornersite)]  
  
 В следующем примере показан <xref:System.Windows.Controls.ValidationRule> , в предыдущем примере.  В <xref:System.Windows.Controls.ValidationRule.Validate%2A> метода, в примере показано получение каждого исходного объекта, из <xref:System.Windows.Data.BindingGroup> и проверяет, равны ли свойства объектов.  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Delay">
      <MemberSignature Language="C#" Value="public int Delay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Delay" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingBase.Delay" />
      <MemberSignature Language="VB.NET" Value="Public Property Delay As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Delay { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает время (в миллисекундах) ожидания перед обновлением источника привязки после изменения значения в целевом объекте.</summary>
        <value>Количество времени в миллисекундах для ожидания перед обновлением источника привязки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании привязки для обновления источника привязки, каждый раз, когда изменяется значение свойства на целевом сервере задается <xref:System.Windows.Data.Binding.Mode%2A> свойства <xref:System.Windows.Data.BindingMode.TwoWay> и <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A> для <xref:System.Windows.Data.UpdateSourceTrigger.PropertyChanged>.  В этом случае можно использовать <xref:System.Windows.Data.BindingBase.Delay%2A> свойство, чтобы указать, следует ли задержки между при изменении целевой объект и при обновлении источника.  Это полезно в том случае, если требуется дать пользователям возможность менять свойства в объекте источника, но не каждое изменение немедленно фиксируются в источнике.  Например предположим, что имеется текстовое поле, является двусторонней данными, привязанными к свойству объекта данных.  Когда пользователь изменяет значение в текстовом поле, обновляется источник.  Чтобы реализовать этот сценарий, необходимо задать <xref:System.Windows.Data.Binding.Mode%2A> свойство <xref:System.Windows.Data.Binding> для <xref:System.Windows.Data.BindingMode.TwoWay> и <xref:System.Windows.Data.Binding.UpdateSourceTrigger%2A> для <xref:System.Windows.Data.UpdateSourceTrigger.PropertyChanged>.  Во избежание обновление исходного объекта с каждого нажатия клавиши задайте <xref:System.Windows.Data.BindingBase.Delay%2A> свойство разумное значение привязки для обновления только по истечении этого времени, поскольку пользователь остановил ввода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FallbackValue">
      <MemberSignature Language="C#" Value="public object FallbackValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object FallbackValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingBase.FallbackValue" />
      <MemberSignature Language="VB.NET" Value="Public Property FallbackValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ FallbackValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, которое следует использовать, когда привязка не может вернуть значение.</summary>
        <value>Значение по умолчанию — <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Привязка успешно возвращает значение, если:  
  
1.  Путь к источнику привязки разрешен.  
  
2.  Преобразователь значений, если таковые имеются, способен преобразовать полученное значение.  
  
3.  Полученное значение является допустимым для свойства привязки (цели).  
  
 Если 1 и 2 Возвращает <xref:System.Windows.DependencyProperty.UnsetValue?displayProperty=nameWithType>, целевое свойство присвоено значение <xref:System.Windows.Data.BindingBase.FallbackValue%2A>, если он доступен. При наличии не <xref:System.Windows.Data.BindingBase.FallbackValue%2A>, используется значение по умолчанию для целевого свойства.  
  
 Значение <xref:System.Windows.DependencyProperty.UnsetValue?displayProperty=nameWithType> не считается успешной возвращаемое значение.  
  
<a name="xamlTextUsage_FallbackValue"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
  
```  
<object FallbackValue="fallbackValue" />  
```  
  
 **- или -**  
  
```  
<object>  
  <object.FallbackValue>  
    fallbackValue  
    </object.FallbackValue>  
</object>  
```  
  
<a name="xamlValues_FallbackValue"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *fallbackValue*  
 Значение атрибута или объект элемента того же типа, что целевое свойство. В разделе документации по этим типам сведения об использовании XAML. Этот тип может или могут не поддерживать синтаксис атрибутов для его значения, или может или могут не поддерживать синтаксис элемента объекта (для которого требуется конструктор по умолчанию для данного типа). Тип целевого свойства таким образом влияют на синтаксисе значение <xref:System.Windows.Data.BindingBase.FallbackValue%2A> свойства.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Data.IValueConverter.Convert(System.Object,System.Type,System.Object,System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="ProvideValue">
      <MemberSignature Language="C#" Value="public override sealed object ProvideValue (IServiceProvider serviceProvider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object ProvideValue(class System.IServiceProvider serviceProvider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingBase.ProvideValue(System.IServiceProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function ProvideValue (serviceProvider As IServiceProvider) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ ProvideValue(IServiceProvider ^ serviceProvider);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serviceProvider" Type="System.IServiceProvider" />
      </Parameters>
      <Docs>
        <param name="serviceProvider">Объект, способный предоставлять службы для расширения разметки. Может иметь значение <see langword="null" />.</param>
        <summary>Возвращает объект, который следует задать для свойства, в котором применяются эта привязка и это расширение.</summary>
        <returns>Значение, задаваемое для целевого свойства привязки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта реализация поддерживает следующий базовый синтаксис для привязки через [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] для всех предоставленных практические производные классы (<xref:System.Windows.Data.Binding>, <xref:System.Windows.Data.PriorityBinding>, и <xref:System.Windows.Data.MultiBinding>).  
  
 <xref:System.Windows.Data.BindingBase> Реализации класса этот метод должен вернуть объект выражение, результат привязки. Привязка свойства работает, обращаясь к данной <xref:System.Windows.DependencyProperty> на данной <xref:System.Windows.DependencyObject>. Эти два блока данных передаются с помощью запроса для <xref:System.Windows.Markup.IProvideValueTarget> реализацию на `serviceProvider`, который [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] чтения делает доступными во время синтаксического разбора привязки. Эта реализация базового класса отвечает за проверку допустимого <xref:System.Windows.DependencyProperty> и <xref:System.Windows.DependencyObject>. Если они найдены, как осуществляется вызов внутреннего абстрактного метода базового класса, задав различные производные классы продолжится фактическую реализацию возврата выражения привязки. В противном случае модуль возвращает сам объект привязки. Возврат самой привязки приводит ошибки несоответствия типов, но это не должно происходить в обычных условиях.  
  
> [!IMPORTANT]
>  Так как синтаксис для привязки через [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] реализованное в этот метод зависит от реализации внутреннего переопределения, а потому, что <xref:System.Windows.Data.BindingBase.ProvideValue%2A?displayProperty=nameWithType> сам является запечатанным, класс пользовательской привязки, производный от <xref:System.Windows.Data.BindingBase> не будет правильно функционировать как [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] расширения разметки.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeFallbackValue">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeFallbackValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeFallbackValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingBase.ShouldSerializeFallbackValue" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeFallbackValue () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeFallbackValue();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, определяющее, должны ли процессы сериализации выполнять сериализацию действующего значения свойства <see cref="P:System.Windows.Data.BindingBase.FallbackValue" /> по экземплярам данного класса.</summary>
        <returns>
          Значение <see langword="true" />, если значение свойства <see cref="P:System.Windows.Data.BindingBase.FallbackValue" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTargetNullValue">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTargetNullValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTargetNullValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.BindingBase.ShouldSerializeTargetNullValue" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTargetNullValue () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTargetNullValue();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, которое указывает, должно ли свойство <see cref="P:System.Windows.Data.BindingBase.TargetNullValue" /> быть сериализовано.</summary>
        <returns>
          Значение <see langword="true" />, если свойство<see cref="P:System.Windows.Data.BindingBase.TargetNullValue" /> должно сериализоваться; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StringFormat">
      <MemberSignature Language="C#" Value="public string StringFormat { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StringFormat" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingBase.StringFormat" />
      <MemberSignature Language="VB.NET" Value="Public Property StringFormat As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StringFormat { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает строку, указывающую способ форматирования привязки при отображении связанного значения в виде строки.</summary>
        <value>Строка, указывающая способ форматирования привязки при отображении связанного значения в виде строки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Data.BindingBase.StringFormat%2A> может быть составной, стандартные или настраиваемые строковом формате. Дополнительные сведения о форматах строки см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 Если задать <xref:System.Windows.Data.Binding.Converter%2A> и <xref:System.Windows.Data.BindingBase.StringFormat%2A> преобразователь свойств для значения данных, сначала применяется и затем <xref:System.Windows.Data.BindingBase.StringFormat%2A> применяется.  
  
 При задании <xref:System.Windows.Data.BindingBase.StringFormat%2A> на <xref:System.Windows.Data.Binding> составной строковый формат, можно указать только один параметр.  
  
 При использовании <xref:System.Windows.Data.MultiBinding>, <xref:System.Windows.Data.BindingBase.StringFormat%2A> свойство применяется, только если это свойство установлено на <xref:System.Windows.Data.MultiBinding>.  Значение <xref:System.Windows.Data.BindingBase.StringFormat%2A> , установленное для всех дочерних <xref:System.Windows.Data.Binding> объектов учитывается.  Число параметров в формате составные строки не может превышать количество дочерних <xref:System.Windows.Data.Binding> объекты в <xref:System.Windows.Data.MultiBinding>.  
  
 При использовании <xref:System.Windows.Data.PriorityBinding>, можно задать <xref:System.Windows.Data.BindingBase.StringFormat%2A> на <xref:System.Windows.Data.PriorityBinding>, на дочерние объекты привязки, или оба.  Если <xref:System.Windows.Data.BindingBase.StringFormat%2A> набор для дочернего элемента, то есть привязка применяется, что используется значение.  Если <xref:System.Windows.Data.BindingBase.StringFormat%2A> не задано для дочернего элемента привязки, который применяется, <xref:System.Windows.Data.BindingBase.StringFormat%2A> из <xref:System.Windows.Data.PriorityBinding> применяется, если оно задано.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Windows.Data.BindingBase.StringFormat%2A> свойство для преобразования `Price`, который является <xref:System.Double>, строку, которая представляет валюту.  
  
 [!code-xaml[ContentStringSnippets#Binding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentStringSnippets/CSharp/Window1.xaml#binding)]  
  
 В следующем примере используется <xref:System.Windows.Data.BindingBase.StringFormat%2A> свойство <xref:System.Windows.Data.MultiBinding> Чтобы построить строку, содержащую `Description` и `Price` каждого элемента в <xref:System.Windows.Controls.ListBox>.  
  
 [!code-xaml[ContentStringSnippets#MultiBinding](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentStringSnippets/CSharp/Window1.xaml#multibinding)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetNullValue">
      <MemberSignature Language="C#" Value="public object TargetNullValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object TargetNullValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.BindingBase.TargetNullValue" />
      <MemberSignature Language="VB.NET" Value="Public Property TargetNullValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ TargetNullValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, используемое в целевом элементе, если значение источника равно <see langword="null" />.</summary>
        <value>Значение, используемое в целевом элементе, если значение источника равно <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="xamlTextUsage_TargetNullValue"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
  
```  
<object TargetNullValue="nullValue" />  
```  
  
 **- или -**  
  
```  
<object>  
  <object.TargetNullValue>  
    nullValue  
    </object.TargetNullValue>  
</object>  
```  
  
<a name="xamlValues_TargetNullValue"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *nullValue*  
 Значение атрибута или объект элемента того же типа, что целевое свойство. В разделе документации по этим типам сведения об использовании XAML. Этот тип может или могут не поддерживать синтаксис атрибутов для его значения, или может или могут не поддерживать синтаксис элемента объекта (для которого требуется конструктор по умолчанию для данного типа).  
  
   
  
## Examples  
 Следующий пример привязывает <xref:System.Windows.Controls.TextBox> свойству объекта.  Если свойство `null`, <xref:System.Windows.Controls.TextBox> отображает» введите строку.»  
  
 [!code-xaml[BindingGroupSnippets#TargetNullValue](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#targetnullvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>