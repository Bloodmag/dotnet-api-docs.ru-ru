<Type Name="CollectionView" FullName="System.Windows.Data.CollectionView">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8d3b9900ff3ea9a80c58df84188864118f024334" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30630938" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class CollectionView : System.Windows.Threading.DispatcherObject, System.Collections.IEnumerable, System.Collections.Specialized.INotifyCollectionChanged, System.ComponentModel.ICollectionView, System.ComponentModel.INotifyPropertyChanged" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit CollectionView extends System.Windows.Threading.DispatcherObject implements class System.Collections.IEnumerable, class System.Collections.Specialized.INotifyCollectionChanged, class System.ComponentModel.ICollectionView, class System.ComponentModel.INotifyPropertyChanged" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Data.CollectionView" />
  <TypeSignature Language="VB.NET" Value="Public Class CollectionView&#xA;Inherits DispatcherObject&#xA;Implements ICollectionView, IEnumerable, INotifyCollectionChanged, INotifyPropertyChanged" />
  <TypeSignature Language="C++ CLI" Value="public ref class CollectionView : System::Windows::Threading::DispatcherObject, System::Collections::IEnumerable, System::Collections::Specialized::INotifyCollectionChanged, System::ComponentModel::ICollectionView, System::ComponentModel::INotifyPropertyChanged" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Specialized.INotifyCollectionChanged</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.ICollectionView</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.INotifyPropertyChanged</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Представляет представление для группирования, сортировки, фильтрации коллекции данных и перемещения по ней.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не следует создавать объекты этого класса в коде. Чтобы создать представление коллекции для коллекции, которая реализует только <xref:System.Collections.IEnumerable>, создать <xref:System.Windows.Data.CollectionViewSource> , добавьте к коллекции <xref:System.Windows.Data.CollectionViewSource.Source%2A> свойства и просмотреть коллекции из get <xref:System.Windows.Data.CollectionViewSource.View%2A> свойство.  
  
 Представление коллекции можно представить как слой поверх коллекции источника привязки, позволяющий навигации и отображения коллекции на основании сортировки, фильтрации и запросов к группе, без необходимости управлять самой исходной коллекцией. Если в исходной коллекции реализован <xref:System.Collections.Specialized.INotifyCollectionChanged> интерфейса, которые вызывают изменения <xref:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged> распространения событий для просмотра.  
  
 Поскольку представление не приводит к изменению исходной коллекцией, исходной коллекции могут иметь несколько представлений, связанные с ним. С помощью представлений, можно отобразить и тех же данных разными способами. Например, можно использовать два представления с коллекцией `Task` объектов для отображения задач, отсортированных по приоритету с одной стороны страницы, сгруппированные по области с другой стороны страницы.  
  
 В [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] приложений, все коллекции имеет Просмотр коллекции по умолчанию. Вместо того чтобы напрямую работать с коллекцией, механизм привязки всегда получает доступ к коллекции посредством связанного представления. Чтобы получить представление по умолчанию, используйте <xref:System.Windows.Data.CollectionViewSource.GetDefaultView%2A?displayProperty=nameWithType> метод. Внутренний класс на основе <xref:System.Windows.Data.CollectionView> является представлением по умолчанию для коллекций, реализующих только <xref:System.Collections.IEnumerable>. <xref:System.Windows.Data.ListCollectionView> представление по умолчанию для коллекций, реализующих <xref:System.Collections.IList>. <xref:System.Windows.Data.BindingListCollectionView> представление по умолчанию для коллекций, реализующих <xref:System.ComponentModel.IBindingListView> или <xref:System.ComponentModel.IBindingList>.  
  
 Кроме того, можно создать представление коллекции в [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] с помощью <xref:System.Windows.Data.CollectionViewSource> класса, а затем привязать элемент управления к этому представлению. <xref:System.Windows.Data.CollectionViewSource> Класс [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] представление <xref:System.Windows.Data.CollectionView> класса. Пример см. в разделе [как: сортировка и группу данных с помощью представления в XAML](~/docs/framework/wpf/data/how-to-sort-and-group-data-using-a-view-in-xaml.md).  
  
 Дополнительные сведения см. в разделе «Привязка к коллекции» в [Общие сведения о привязке данных](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 Чтобы задать представление в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], используйте <xref:System.Windows.Data.CollectionViewSource> класса. <xref:System.Windows.Data.CollectionViewSource> — [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] представление <xref:System.Windows.Data.CollectionView> класс и предоставляет наиболее часто используемых членов <xref:System.Windows.Data.CollectionView> класса.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public CollectionView (System.Collections.IEnumerable collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.IEnumerable collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.#ctor(System.Collections.IEnumerable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; CollectionView(System::Collections::IEnumerable ^ collection);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.IEnumerable" />
      </Parameters>
      <Docs>
        <param name="collection">Базовая коллекция.</param>
        <summary>Инициализация нового экземпляра класса <see cref="T:System.Windows.Data.CollectionView" />, являющегося представлением заданной коллекции.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Экземпляр <xref:System.Windows.Data.CollectionView> привязан к [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] потока диспетчера код, вызывающий этот конструктор.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowsCrossThreadChanges">
      <MemberSignature Language="C#" Value="protected bool AllowsCrossThreadChanges { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsCrossThreadChanges" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.AllowsCrossThreadChanges" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property AllowsCrossThreadChanges As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool AllowsCrossThreadChanges { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, может ли какой-либо поток, кроме создавшего <see cref="T:System.Windows.Data.CollectionView" />, изменить <see cref="P:System.Windows.Data.CollectionView.SourceCollection" />.</summary>
        <value>
          Значение <see langword="true" />, если свойство <see cref="T:System.Windows.Data.CollectionView" /> может изменяться потоком, отличным от потока, создавшего объект <see cref="P:System.Windows.Data.CollectionView.SourceCollection" />; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFilter">
      <MemberSignature Language="C#" Value="public virtual bool CanFilter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFilter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.CanFilter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanFilter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanFilter { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, которое определяет, поддерживает ли представление фильтрацию.</summary>
        <value>
          <see langword="true" />, если элемент поддерживает фильтрацию; в противном случае — <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если это свойство возвращает `false`, параметр <xref:System.Windows.Data.CollectionView.Filter%2A> вызывает исключение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanGroup">
      <MemberSignature Language="C#" Value="public virtual bool CanGroup { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.CanGroup" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanGroup As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanGroup { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение значения, которое определяет, поддерживает ли представление группировку.</summary>
        <value>
          Значение <see langword="false" /> во всех случаях.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство можно использовать для проверки, является ли представление поддерживает сортировку перед добавлением <xref:System.Windows.Data.CollectionView.GroupDescriptions%2A>. Производные классы переопределять это свойство для указания, поддерживают ли они группировку.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanSort">
      <MemberSignature Language="C#" Value="public virtual bool CanSort { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanSort" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.CanSort" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CanSort As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanSort { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, которое определяет, поддерживает ли представление сортировку.</summary>
        <value>
          Значение <see langword="false" /> во всех случаях.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство можно использовать для проверки, является ли представление поддерживает сортировку перед добавлением <xref:System.Windows.Data.CollectionView.SortDescriptions%2A>. Производные классы переопределять это свойство для указания, поддерживают ли они сортировку.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClearChangeLog">
      <MemberSignature Language="C#" Value="protected void ClearChangeLog ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearChangeLog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.ClearChangeLog" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearChangeLog ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearChangeLog();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Replaced by ClearPendingChanges")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Очищение ожидающих изменений из журнала изменений</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Data.CollectionView.OnBeginChangeLogging(System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ClearPendingChanges">
      <MemberSignature Language="C#" Value="protected void ClearPendingChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ClearPendingChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.ClearPendingChanges" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ClearPendingChanges ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ClearPendingChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Очищает необработанные изменения в коллекцию.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionChanged">
      <MemberSignature Language="C#" Value="protected virtual event System.Collections.Specialized.NotifyCollectionChangedEventHandler CollectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Collections.Specialized.NotifyCollectionChangedEventHandler CollectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.CollectionView.CollectionChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Event CollectionChanged As NotifyCollectionChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual event System::Collections::Specialized::NotifyCollectionChangedEventHandler ^ CollectionChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Specialized.NotifyCollectionChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении представления.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged" />
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IComparer Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IComparer Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Comparer As IComparer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IComparer ^ Comparer { System::Collections::IComparer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IComparer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возврат объекта, который можно использовать для сравнения элементов представления.</summary>
        <value>Объект <see cref="T:System.Collections.IComparer" />, который можно использовать для сравнения элементов представления.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public virtual bool Contains (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.Contains(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Contains (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(System::Object ^ item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Объект для проверки.</param>
        <summary>Возврат значения, определяющего, принадлежит ли заданный элемент данному представлению.</summary>
        <returns>
          <see langword="true" />, если элемент принадлежит представлению; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не выполняет никаких предположений о принадлежности элемента базовой коллекции. Если вызывающий объект знает, что элемент принадлежит к базовой коллекции, он эффективнее вызывать <xref:System.Windows.Data.CollectionView.PassesFilter%2A> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public virtual int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.Count" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Count { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получения числа записей в представлении.</summary>
        <value>Число записей в представлении или -1, если число записей неизвестно.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если задан фильтр, значение этого свойства включает только элементы, которые проходят фильтр. Базовая коллекция имеет тип <xref:System.Collections.IEnumerable>, это является операцией o(1). Это значение кэшируется до изменения коллекции.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При наследовании от <see cref="T:System.Windows.Data.CollectionView" />, переопределите это свойство для реализации более эффективно.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Culture">
      <MemberSignature Language="C#" Value="public virtual System.Globalization.CultureInfo Culture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo Culture" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.Culture" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Culture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Globalization::CultureInfo ^ Culture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.CultureInfoIetfLanguageTagConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает сведений о языке и региональных параметрах, используемых в ходе сортировки.</summary>
        <value>Сведения о языке и региональных параметрах, используемых в ходе сортировки.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentChanged">
      <MemberSignature Language="C#" Value="public virtual event EventHandler CurrentChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler CurrentChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.CollectionView.CurrentChanged" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Event CurrentChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ CurrentChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после изменения <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Событие после изменения <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</para>
        </block>
        <altmember cref="E:System.ComponentModel.ICollectionView.CurrentChanged" />
      </Docs>
    </Member>
    <Member MemberName="CurrentChanging">
      <MemberSignature Language="C#" Value="public virtual event System.ComponentModel.CurrentChangingEventHandler CurrentChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CurrentChangingEventHandler CurrentChanging" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.CollectionView.CurrentChanging" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Event CurrentChanging As CurrentChangingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::ComponentModel::CurrentChangingEventHandler ^ CurrentChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CurrentChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> меняется.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Событие перед изменением <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</para>
        </block>
        <altmember cref="E:System.ComponentModel.ICollectionView.CurrentChanging" />
      </Docs>
    </Member>
    <Member MemberName="CurrentItem">
      <MemberSignature Language="C#" Value="public virtual object CurrentItem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object CurrentItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.CurrentItem" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CurrentItem As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ CurrentItem { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает текущий элемент в представлении.</summary>
        <value>Текущий элемент в представлении. По умолчанию первый элемент коллекции изначально является текущим элементом.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Представления коллекции поддерживают понятие указателя текущей записи. При переходе по объектам в представлении коллекции перемещается указатель записи, которая позволяет получить объект, который существует в определенном месте в коллекции.  
  
 Обратите внимание, что перемещение указателя текущей записи имеет некоторое отношение к сортировке или фильтрации, которая применяется к коллекции. При сортировке указатель текущей записи на последней выбранной записи, но представление коллекции реструктуризации вокруг нее. (Возможно выбранной записи находится в начале списка, но теперь выбранная запись может быть где-нибудь в середине). Фильтрация сохраняет выбранную запись, если данный выбор остается в представлении после фильтрации. В противном случае указатель текущей записи устанавливается на первую запись отфильтрованного представления коллекции.  
  
 Текущий элемент коллекции назначен автоматически, если целью привязки является единственное значение. Если целевой объект <xref:System.Windows.Controls.ItemsControl>, текущий элемент синхронизируется с выбранным элементом. Например, если поле со списком, привязанного к коллекции <xref:System.Windows.Data.CollectionView.CurrentItem%2A> синхронизируется с текущего выделенного элемента.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Только классы, которые передать валюты, обрабатывающих вызовы в другой внутренней <see cref="T:System.Windows.Data.CollectionView" /> объекта должны переопределять это свойство; все остальные производных классов следует использовать <see cref="M:System.Windows.Data.CollectionView.SetCurrent(System.Object,System.Int32)" /> метод, чтобы обновить текущие значения, хранящиеся в базовом классе.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="CurrentPosition">
      <MemberSignature Language="C#" Value="public virtual int CurrentPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 CurrentPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.CurrentPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CurrentPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int CurrentPosition { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение порядкового номера <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> в рамках представления (возможна сортировка и фильтрация).</summary>
        <value>Порядковый номер <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> в рамках представления (возможна сортировка и фильтрация).</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Только классы, которые передать валюты, обрабатывающих вызовы в другой внутренней <see cref="T:System.Windows.Data.CollectionView" /> объекта должны переопределять это свойство; все остальные производных классов следует использовать <see cref="M:System.Windows.Data.CollectionView.SetCurrent(System.Object,System.Int32)" /> метод, чтобы обновить текущие значения, хранящиеся в базовом классе.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DeferRefresh">
      <MemberSignature Language="C#" Value="public virtual IDisposable DeferRefresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IDisposable DeferRefresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.DeferRefresh" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeferRefresh () As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IDisposable ^ DeferRefresh();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вводит отложенный цикл, который можно использовать для слияния изменений с представлением и задержки автоматического обновления.</summary>
        <returns>Объект <see cref="T:System.IDisposable" />, который можно использовать для уничтожения вызывающего объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Типичным использованием является создание `using` область с помощью этого метода и затем поместить несколько изменяющих представление запросов в области. Это задерживает автоматическое обновление до выхода из отложенного цикла.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetachFromSourceCollection">
      <MemberSignature Language="C#" Value="public virtual void DetachFromSourceCollection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DetachFromSourceCollection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.DetachFromSourceCollection" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub DetachFromSourceCollection ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DetachFromSourceCollection();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет ссылку на базовую коллекцию из <see cref="T:System.Windows.Data.CollectionView" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, чтобы отказаться от подписки на события в базовой коллекции и разрешить <xref:System.Windows.Data.CollectionView> мусора.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Filter">
      <MemberSignature Language="C#" Value="public virtual Predicate&lt;object&gt; Filter { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Predicate`1&lt;object&gt; Filter" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.Filter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property Filter As Predicate(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Predicate&lt;System::Object ^&gt; ^ Filter { Predicate&lt;System::Object ^&gt; ^ get(); void set(Predicate&lt;System::Object ^&gt; ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Predicate&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает метод, который используется для определения того, подходит ли элемент для включения в представление.</summary>
        <value>Делегат, представляющий метод, который используется для определения того, подходит ли элемент для включения в представление.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не поддерживает фильтрацию и создавать более простой реализации <xref:System.NotSupportedException>. Используйте <xref:System.Windows.Data.CollectionView.CanFilter%2A> свойство для проверки, если фильтрация поддерживается перед назначением этого свойства значение отличное от null.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Текущая реализация не поддерживает фильтрацию.</exception>
        <altmember cref="E:System.Windows.Data.CollectionViewSource.Filter" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected virtual System.Collections.IEnumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.IEnumerator GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetEnumerator () As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Collections::IEnumerator ^ GetEnumerator();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возврат объекта, который можно использовать для перечисления элементов представления.</summary>
        <returns>Объект <see cref="T:System.Collections.IEnumerator" />, который можно использовать для перечисления элементов представления.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetItemAt">
      <MemberSignature Language="C#" Value="public virtual object GetItemAt (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetItemAt(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.GetItemAt(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetItemAt (index As Integer) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetItemAt(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Начинающийся с нуля индекс извлекаемого элемента.</param>
        <summary>Получение элемента в заданном начинающемся с нуля индексе представления.</summary>
        <returns>Элемент в заданном начинающемся с нуля индексе представления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод принимает индекс с любым <xref:System.Windows.Data.CollectionView.SortDescriptions%2A> или <xref:System.Windows.Data.CollectionView.Filter%2A> значения свойств, заданные в представлении.  
  
 Базовая коллекция имеет тип <xref:System.Collections.IEnumerable>, это является операцией o(1).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="index" /> меньше 0.</exception>
        <block subset="none" type="overrides">
          <para>При наследовании от <see cref="T:System.Windows.Data.CollectionView" />, переопределите этот метод для предоставления более эффективной реализации.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GroupDescriptions">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ObjectModel.ObservableCollection&lt;System.ComponentModel.GroupDescription&gt; GroupDescriptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ObservableCollection`1&lt;class System.ComponentModel.GroupDescription&gt; GroupDescriptions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.GroupDescriptions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GroupDescriptions As ObservableCollection(Of GroupDescription)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ObjectModel::ObservableCollection&lt;System::ComponentModel::GroupDescription ^&gt; ^ GroupDescriptions { System::Collections::ObjectModel::ObservableCollection&lt;System::ComponentModel::GroupDescription ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ObservableCollection&lt;System.ComponentModel.GroupDescription&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение коллекции объектов <see cref="T:System.ComponentModel.GroupDescription" />, описывающих группировку элементов коллекции в данном представлении.</summary>
        <value>
          Значение <see langword="null" /> во всех случаях.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этого свойства всегда равно `null` из-за <xref:System.Windows.Data.CollectionView> класс не поддерживает группировку по его базовой коллекции. Производные классы <xref:System.Windows.Data.ListCollectionView> и <xref:System.Windows.Data.BindingListCollectionView> поддерживает группировку.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.ListCollectionView.GroupDescriptions" />
      </Docs>
    </Member>
    <Member MemberName="Groups">
      <MemberSignature Language="C#" Value="public virtual System.Collections.ObjectModel.ReadOnlyObservableCollection&lt;object&gt; Groups { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.ObjectModel.ReadOnlyObservableCollection`1&lt;object&gt; Groups" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.Groups" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Groups As ReadOnlyObservableCollection(Of Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::ObjectModel::ReadOnlyObservableCollection&lt;System::Object ^&gt; ^ Groups { System::Collections::ObjectModel::ReadOnlyObservableCollection&lt;System::Object ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ObjectModel.ReadOnlyObservableCollection&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию групп высшего уровня, конструируемого на основе свойства <see cref="P:System.Windows.Data.CollectionView.GroupDescriptions" />.</summary>
        <value>
          Значение <see langword="null" /> во всех случаях.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этого свойства всегда равно `null` из-за <xref:System.Windows.Data.CollectionView> класс не поддерживает группировку по его базовой коллекции. Производные классы <xref:System.Windows.Data.ListCollectionView> и <xref:System.Windows.Data.BindingListCollectionView> поддерживает группировку.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IndexOf">
      <MemberSignature Language="C#" Value="public virtual int IndexOf (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 IndexOf(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.IndexOf(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IndexOf (item As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int IndexOf(System::Object ^ item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Искомый элемент.</param>
        <summary>Возврат индекса, в котором расположен заданный элемент.</summary>
        <returns>Индекс, в котором расположен заданный элемент, или -1, если элемент неизвестен.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот метод возвращает индекс, отличный от -1, всегда должно быть true, представление [индекс-1] < элемент < = представление [index], где выполняется сравнение с использованием <xref:System.Collections.IComparer.Compare%2A?displayProperty=nameWithType> метод представления, если он существует.  
  
 Данное конкретное поведение метода, используемый некоторыми <xref:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged> обработчики событий для ускорения реакции для вставки и удаления. Если производный класс не переопределяет этот метод, прослушиватель не выполняет двоичный поиск с помощью <xref:System.Collections.IComparer.Compare%2A?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCurrentAfterLast">
      <MemberSignature Language="C#" Value="public virtual bool IsCurrentAfterLast { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCurrentAfterLast" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsCurrentAfterLast" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsCurrentAfterLast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsCurrentAfterLast { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, показывающее, находится ли элемент <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> за концом коллекции.</summary>
        <value>
          <see langword="true" />, если <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> представления за конечной границей коллекции; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Представления коллекции поддерживают понятие указателя текущей записи. При переходе по объектам в представлении коллекции перемещается указатель записи, которая позволяет получить объект, который существует в определенном месте в коллекции.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.IsCurrentAfterLast" />
      </Docs>
    </Member>
    <Member MemberName="IsCurrentBeforeFirst">
      <MemberSignature Language="C#" Value="public virtual bool IsCurrentBeforeFirst { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCurrentBeforeFirst" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsCurrentBeforeFirst" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsCurrentBeforeFirst As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsCurrentBeforeFirst { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение значения, определяющего, выходит ли <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> представления за начальную границу коллекции.</summary>
        <value>
          <see langword="true" />, если <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> представления перед начальной границей коллекции; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Представления коллекции поддерживают понятие указателя текущей записи. При переходе по объектам в представлении коллекции перемещается указатель записи, которая позволяет получить объект, который существует в определенном месте в коллекции.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.IsCurrentAfterLast" />
      </Docs>
    </Member>
    <Member MemberName="IsCurrentInSync">
      <MemberSignature Language="C#" Value="protected bool IsCurrentInSync { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCurrentInSync" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsCurrentInSync" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsCurrentInSync As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsCurrentInSync { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение значения, которое определяет, находится ли <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> в <see cref="P:System.Windows.Data.CollectionView.CurrentPosition" />.</summary>
        <value>
          <see langword="true" />, если <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> находится в представлении и в <see cref="P:System.Windows.Data.CollectionView.CurrentPosition" />; в противном случае — <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="protected bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsDynamic" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsDynamic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsDynamic { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение значения, определяющего, предоставляет ли базовая коллекция уведомления об изменениях.</summary>
        <value>
          <see langword="true" />, если базовая коллекция предоставляет уведомления об изменениях; в противном случае — <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public virtual bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEmpty { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение значения, которое определяет, является ли пустым полученное (отфильтрованное) представление.</summary>
        <value>
          <see langword="true" />, если полученное представление является пустым; в противном случае — <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInUse">
      <MemberSignature Language="C#" Value="public virtual bool IsInUse { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInUse" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsInUse" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsInUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsInUse { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, подписывается ли какой-либо объект на события этого <see cref="T:System.Windows.Data.CollectionView" />.</summary>
        <value>
          Значение <see langword="true" />, если на события этого объекта <see cref="T:System.Windows.Data.CollectionView" /> подписывается какой-либо объект; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsRefreshDeferred">
      <MemberSignature Language="C#" Value="protected bool IsRefreshDeferred { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRefreshDeferred" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.IsRefreshDeferred" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsRefreshDeferred As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsRefreshDeferred { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, которое указывает, используется ли метод <see cref="M:System.Windows.Data.CollectionView.DeferRefresh" />.</summary>
        <value>
          Значение <see langword="true" />, если метод <see cref="M:System.Windows.Data.CollectionView.DeferRefresh" /> используется; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Производные классы следует избегать вызова функции <see cref="M:System.Windows.Data.CollectionView.Refresh" /> Если <see cref="P:System.Windows.Data.CollectionView.IsRefreshDeferred" /> возвращает <see langword="true" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentTo">
      <MemberSignature Language="C#" Value="public virtual bool MoveCurrentTo (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveCurrentTo(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.MoveCurrentTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveCurrentTo (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveCurrentTo(System::Object ^ item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Элемент, устанавливаемый в качестве <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</param>
        <summary>Задает указанный элемент в качестве <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> в представлении.</summary>
        <returns>
          Значение <see langword="true" />, если результирующий элемент <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> находится в представлении; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если указанный элемент не найден, метод возвращает `false` и <xref:System.Windows.Data.CollectionView.CurrentItem%2A> располагается перед началом коллекции в представлении.  
  
 Представления коллекции поддерживают понятие указателя текущей записи. При переходе по объектам в представлении коллекции перемещается указатель записи, которая позволяет получить объект, который существует в определенном месте в коллекции. Дополнительные сведения см. в разделе «Привязка к коллекции» в [Общие сведения о привязке данных](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 Дополнительные сведения о текущем элементе представления см. в разделе <xref:System.Windows.Data.CollectionView.CurrentItem%2A>.  
  
   
  
## Examples  
 В следующем примере показано использование этого метода.  
  
 [!code-csharp[Colors#NewColor](~/samples/snippets/csharp/VS_Snippets_Wpf/Colors/CSharp/Colors.xaml.cs#newcolor)]
 [!code-vb[Colors#NewColor](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Colors/visualbasic/colors.xaml.vb#newcolor)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.CurrentItem" />
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentToFirst">
      <MemberSignature Language="C#" Value="public virtual bool MoveCurrentToFirst ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveCurrentToFirst() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.MoveCurrentToFirst" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveCurrentToFirst () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveCurrentToFirst();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Задает первый элемент в представлении в качестве <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</summary>
        <returns>
          Значение <see langword="true" />, если получающееся свойство <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> является элементом в представлении; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Представления коллекции поддерживают понятие указателя текущей записи. При переходе по объектам в представлении коллекции перемещается указатель записи, которая позволяет получить объект, который существует в определенном месте в коллекции. Дополнительные сведения см. в разделе «Привязка к коллекции» в [Общие сведения о привязке данных](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.IsCurrentBeforeFirst" />
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentToLast">
      <MemberSignature Language="C#" Value="public virtual bool MoveCurrentToLast ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveCurrentToLast() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.MoveCurrentToLast" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveCurrentToLast () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveCurrentToLast();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Задает последний элемент в представлении в качестве <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</summary>
        <returns>
          Значение <see langword="true" />, если получающееся свойство <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> является элементом в представлении; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Представления коллекции поддерживают понятие указателя текущей записи. При переходе по объектам в представлении коллекции перемещается указатель записи, которая позволяет получить объект, который существует в определенном месте в коллекции. Дополнительные сведения см. в разделе «Привязка к коллекции» в [Общие сведения о привязке данных](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.IsCurrentAfterLast" />
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentToNext">
      <MemberSignature Language="C#" Value="public virtual bool MoveCurrentToNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveCurrentToNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.MoveCurrentToNext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveCurrentToNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveCurrentToNext();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Задает элемент после <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> в представлении в качестве элемента <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</summary>
        <returns>
          Значение <see langword="true" />, если получающееся свойство <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> является элементом в представлении; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Представления коллекции поддерживают понятие указателя текущей записи. При переходе по объектам в представлении коллекции перемещается указатель записи, которая позволяет получить объект, который существует в определенном месте в коллекции. Дополнительные сведения см. в разделе «Привязка к коллекции» в [Общие сведения о привязке данных](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.IsCurrentAfterLast" />
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentToPosition">
      <MemberSignature Language="C#" Value="public virtual bool MoveCurrentToPosition (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveCurrentToPosition(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.MoveCurrentToPosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveCurrentToPosition (position As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveCurrentToPosition(int position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">Индекс для задания элемента <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</param>
        <summary>Задает элемент по заданному индексу в качестве <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> в представлении.</summary>
        <returns>
          Значение <see langword="true" />, если получающееся свойство <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> является элементом в представлении; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Представления коллекции поддерживают понятие указателя текущей записи. При переходе по объектам в представлении коллекции перемещается указатель записи, которая позволяет получить объект, который существует в определенном месте в коллекции. Дополнительные сведения см. в разделе «Привязка к коллекции» в [Общие сведения о привязке данных](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveCurrentToPrevious">
      <MemberSignature Language="C#" Value="public virtual bool MoveCurrentToPrevious ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveCurrentToPrevious() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.MoveCurrentToPrevious" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveCurrentToPrevious () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveCurrentToPrevious();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Устанавливает элемент перед элементом <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> в качестве <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</summary>
        <returns>
          Значение <see langword="true" />, если получающееся свойство <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> является элементом в представлении; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Представления коллекции поддерживают понятие указателя текущей записи. При переходе по объектам в представлении коллекции перемещается указатель записи, которая позволяет получить объект, который существует в определенном месте в коллекции. Дополнительные сведения см. в разделе «Привязка к коллекции» в [Общие сведения о привязке данных](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionView.IsCurrentBeforeFirst" />
      </Docs>
    </Member>
    <Member MemberName="NeedsRefresh">
      <MemberSignature Language="C#" Value="public virtual bool NeedsRefresh { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NeedsRefresh" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.NeedsRefresh" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property NeedsRefresh As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool NeedsRefresh { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение значения, которое определяет, необходимо ли обновление представлению.</summary>
        <value>
          <see langword="true" />, если представлению необходимо обновление; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство указывает, если внутреннее состояние представления изменилось и требуется <xref:System.Windows.Data.CollectionView.Refresh%2A> вызова метода. Типичный сценарий — Если <xref:System.ComponentModel.SortDescription> или аналогичные был добавлен к представлению, пока цикл отложенного обновления представления (см. <xref:System.Windows.Data.CollectionView.DeferRefresh%2A>). В этом сценарии без явного вызова <xref:System.Windows.Data.CollectionView.Refresh%2A> требуется; как только цикл отложенного обновления завершится, представление вызывает обновление автоматически.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Data.CollectionView.Refresh" />
        <altmember cref="M:System.Windows.Data.CollectionView.DeferRefresh" />
      </Docs>
    </Member>
    <Member MemberName="NewItemPlaceholder">
      <MemberSignature Language="C#" Value="public static object NewItemPlaceholder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property object NewItemPlaceholder" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.NewItemPlaceholder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NewItemPlaceholder As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Object ^ NewItemPlaceholder { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект, находящийся в коллекции для представления нового элемента.</summary>
        <value>Объект, находящийся в коллекции для представления нового элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Windows.Data.CollectionView> , реализующий <xref:System.ComponentModel.IEditableCollectionView> имеет <xref:System.ComponentModel.IEditableCollectionView.NewItemPlaceholderPosition%2A> значение <xref:System.ComponentModel.NewItemPlaceholderPosition.AtBeginning> или <xref:System.ComponentModel.NewItemPlaceholderPosition.AtEnd>, <xref:System.Windows.Data.CollectionView.NewItemPlaceholder%2A> добавляется в коллекцию.  <xref:System.Windows.Data.CollectionView.NewItemPlaceholder%2A> Всегда отображается в коллекции; он не участвует в группирования, сортировки или фильтрации.  
  
 <xref:System.Windows.Data.CollectionView.CurrentItem%2A> Не может быть <xref:System.Windows.Data.CollectionView.NewItemPlaceholder%2A>. Методы, выполняющие относительный навигации, такие как <xref:System.Windows.Data.CollectionView.MoveCurrentToNext%2A>, пропустить <xref:System.Windows.Data.CollectionView.NewItemPlaceholder%2A>.  <xref:System.Windows.Data.CollectionView.MoveCurrentToFirst%2A> и <xref:System.Windows.Data.CollectionView.MoveCurrentToLast%2A> пропустить <xref:System.Windows.Data.CollectionView.NewItemPlaceholder%2A> Если <xref:System.ComponentModel.IEditableCollectionView.NewItemPlaceholderPosition%2A> равно <xref:System.ComponentModel.NewItemPlaceholderPosition.AtBeginning> или <xref:System.ComponentModel.NewItemPlaceholderPosition.AtEnd>соответственно. Методы, выполняющие абсолютный навигации, такие как <xref:System.Windows.Data.CollectionView.MoveCurrentToPosition%2A>, ничего не делать при <xref:System.Windows.Data.CollectionView.NewItemPlaceholder%2A> бы <xref:System.Windows.Data.CollectionView.CurrentItem%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OKToChangeCurrent">
      <MemberSignature Language="C#" Value="protected bool OKToChangeCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool OKToChangeCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OKToChangeCurrent" />
      <MemberSignature Language="VB.NET" Value="Protected Function OKToChangeCurrent () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool OKToChangeCurrent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращение значения, которое определяет, может ли представление менять то, какой элемент является <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</summary>
        <returns>
          <see langword="false" />, если слушатель отменяет изменение; в противном случае — <see langword="true" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnAllowsCrossThreadChangesChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnAllowsCrossThreadChangesChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnAllowsCrossThreadChangesChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnAllowsCrossThreadChangesChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnAllowsCrossThreadChangesChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnAllowsCrossThreadChangesChanged();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Происходит при изменении свойства <see cref="P:System.Windows.Data.CollectionView.AllowsCrossThreadChanges" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginChangeLogging">
      <MemberSignature Language="C#" Value="protected virtual void OnBeginChangeLogging (System.Collections.Specialized.NotifyCollectionChangedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnBeginChangeLogging(class System.Collections.Specialized.NotifyCollectionChangedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnBeginChangeLogging(System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnBeginChangeLogging (args As NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnBeginChangeLogging(System::Collections::Specialized::NotifyCollectionChangedEventArgs ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Replaced by OnAllowsCrossThreadChangesChanged")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Collections.Specialized.NotifyCollectionChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">Объект <see cref="T:System.Collections.Specialized.NotifyCollectionChangedEventArgs" />, который добавлен в журнал изменений.</param>
        <summary>Вызван базовым классом, чтобы уведомить производный класс, что событие <see cref="E:System.Collections.Specialized.INotifyCollectionChanged.CollectionChanged" /> было отправлено в очередь сообщений.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="args" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OnCollectionChanged">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Вызывает событие <see cref="E:System.Windows.Data.CollectionView.CollectionChanged" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnCollectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCollectionChanged (System.Collections.Specialized.NotifyCollectionChangedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCollectionChanged(class System.Collections.Specialized.NotifyCollectionChangedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCollectionChanged (args As NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCollectionChanged(System::Collections::Specialized::NotifyCollectionChangedEventArgs ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Collections.Specialized.NotifyCollectionChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">Объект <see cref="T:System.Collections.Specialized.NotifyCollectionChangedEventArgs" />, передаваемый в обработчик событий.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Data.CollectionView.CollectionChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Принимать любой сортировке, фильтрации и группирования критерии во внимание перед вызовом этого метода для вызова <xref:System.Windows.Data.CollectionView.CollectionChanged> событий.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCollectionChanged">
      <MemberSignature Language="C#" Value="protected void OnCollectionChanged (object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCollectionChanged(object sender, class System.Collections.Specialized.NotifyCollectionChangedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnCollectionChanged(System.Object,System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCollectionChanged (sender As Object, args As NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCollectionChanged(System::Object ^ sender, System::Collections::Specialized::NotifyCollectionChangedEventArgs ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.Collections.Specialized.NotifyCollectionChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">Отправитель события.</param>
        <param name="args">Объект <see cref="T:System.Collections.Specialized.NotifyCollectionChangedEventArgs" />, передаваемый в обработчик событий.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Data.CollectionView.CollectionChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывает метод <xref:System.Windows.Data.CollectionView.ProcessCollectionChanged%2A> на правильный [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] поток dispatcher никогда не был обновлен из другого потока и отправляет изменения в диспетчер его обработку в правильном потоке.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCurrentChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnCurrentChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCurrentChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnCurrentChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCurrentChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCurrentChanged();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывает событие <see cref="E:System.Windows.Data.CollectionView.CurrentChanged" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OnCurrentChanging">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Вызывает событие <see cref="E:System.Windows.Data.CollectionView.CurrentChanging" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnCurrentChanging">
      <MemberSignature Language="C#" Value="protected void OnCurrentChanging ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnCurrentChanging() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnCurrentChanging" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnCurrentChanging ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnCurrentChanging();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Порождение события <see cref="E:System.Windows.Data.CollectionView.CurrentChanging" />, которое не подлежит отмене.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод устанавливает <xref:System.Windows.Data.CollectionView.CurrentPosition%2A> значение -1. Этот метод вызывается методом сбора изменений, влияющих на <xref:System.Windows.Data.CollectionView.CurrentItem%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCurrentChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnCurrentChanging (System.ComponentModel.CurrentChangingEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCurrentChanging(class System.ComponentModel.CurrentChangingEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnCurrentChanging(System.ComponentModel.CurrentChangingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCurrentChanging (args As CurrentChangingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCurrentChanging(System::ComponentModel::CurrentChangingEventArgs ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.ComponentModel.CurrentChangingEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">Сведения о событии.</param>
        <summary>Порождение события <see cref="E:System.Windows.Data.CollectionView.CurrentChanging" /> посредством заданных аргументов.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.ComponentModel.PropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(class System.ComponentModel.PropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.OnPropertyChanged(System.ComponentModel.PropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (e As PropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::ComponentModel::PropertyChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.PropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Аргументы вызываемого события.</param>
        <summary>Порождение события <see cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" /> с помощью заданных аргументов.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PassesFilter">
      <MemberSignature Language="C#" Value="public virtual bool PassesFilter (object item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool PassesFilter(object item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.PassesFilter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PassesFilter (item As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool PassesFilter(System::Object ^ item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="item">Проверяемый элемент.</param>
        <summary>Возврат значения, определяющего, принадлежит ли заданный элемент в базовой коллекции представлению.</summary>
        <returns>
          <see langword="true" />, если заданный элемент принадлежит представлению или на представления коллекции не настроен фильтр; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от <xref:System.Windows.Data.CollectionView.Contains%2A> метода, этот метод предполагает, что заданный элемент принадлежит к коллекции. Этот метод учитывает фильтры. Обычно этот метод используется во время уведомлений об изменении коллекции, чтобы определить, требуется ли элемент добавляемых или удаляемых обработки.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessCollectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void ProcessCollectionChanged (System.Collections.Specialized.NotifyCollectionChangedEventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void ProcessCollectionChanged(class System.Collections.Specialized.NotifyCollectionChangedEventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.ProcessCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub ProcessCollectionChanged (args As NotifyCollectionChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void ProcessCollectionChanged(System::Collections::Specialized::NotifyCollectionChangedEventArgs ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Collections.Specialized.NotifyCollectionChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="args">Объект <see cref="T:System.Collections.Specialized.NotifyCollectionChangedEventArgs" />, который требуется обработать.</param>
        <summary>При переопределении в производном классе выполняется обработка одного изменения в потоке [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Данный метод должен быть переопределен в производном классе позволяет обработать одно изменение на [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] потока.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="ProcessPendingChanges">
      <MemberSignature Language="C#" Value="protected void ProcessPendingChanges ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProcessPendingChanges() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.ProcessPendingChanges" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProcessPendingChanges ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProcessPendingChanges();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Гарантирует, что были зафиксированы все ожидающие изменения в коллекции.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.PropertyChangedEventHandler PropertyChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Data.CollectionView.PropertyChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Event PropertyChanged As PropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual event System::ComponentModel::PropertyChangedEventHandler ^ PropertyChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.PropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении значения свойства.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="E:System.ComponentModel.INotifyPropertyChanged.PropertyChanged" />
      </Docs>
    </Member>
    <Member MemberName="Refresh">
      <MemberSignature Language="C#" Value="public virtual void Refresh ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Refresh() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.Refresh" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub Refresh ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Refresh();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Повторное создание представления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При задании <xref:System.Windows.Data.CollectionView.Filter%2A>, <xref:System.Windows.Data.CollectionView.SortDescriptions%2A>, или <xref:System.Windows.Data.CollectionView.GroupDescriptions%2A> свойство; обновление происходит.  Нет необходимости вызывать <xref:System.Windows.Data.CollectionView.Refresh%2A> метод сразу же после задать одно из этих свойств. Сведения о том, как задержки автоматического обновления см. в разделе <xref:System.Windows.Data.CollectionView.DeferRefresh%2A>.  
  
 Производные классы используют защищенный <xref:System.Windows.Data.CollectionView.RefreshOverride%2A> метод для переопределения поведения этот метод.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Data.CollectionView.DeferRefresh" />
        <altmember cref="P:System.Windows.Data.CollectionView.NeedsRefresh" />
      </Docs>
    </Member>
    <Member MemberName="RefreshOrDefer">
      <MemberSignature Language="C#" Value="protected void RefreshOrDefer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void RefreshOrDefer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.RefreshOrDefer" />
      <MemberSignature Language="VB.NET" Value="Protected Sub RefreshOrDefer ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void RefreshOrDefer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Обновление представления или указание на необходимость обновления представления после завершения отложенного цикла.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RefreshOverride">
      <MemberSignature Language="C#" Value="protected virtual void RefreshOverride ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RefreshOverride() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.RefreshOverride" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RefreshOverride ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RefreshOverride();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Повторное создание представления.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Производные классы должны переопределять этот метод, чтобы изменить поведение <see cref="M:System.Windows.Data.CollectionView.Refresh" /> метод.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetCurrent">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Задает текущий элемент объекта <see cref="T:System.Windows.Data.CollectionView" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetCurrent">
      <MemberSignature Language="C#" Value="protected void SetCurrent (object newItem, int newPosition);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetCurrent(object newItem, int32 newPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.SetCurrent(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetCurrent (newItem As Object, newPosition As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetCurrent(System::Object ^ newItem, int newPosition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newItem" Type="System.Object" />
        <Parameter Name="newPosition" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="newItem">Элемент, устанавливаемый в качестве <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</param>
        <param name="newPosition">Значение, устанавливаемое как значение свойства <see cref="P:System.Windows.Data.CollectionView.CurrentPosition" />.</param>
        <summary>Установка заданного элемента и индекса в качестве значений свойств <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> и <see cref="P:System.Windows.Data.CollectionView.CurrentPosition" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetCurrent">
      <MemberSignature Language="C#" Value="protected void SetCurrent (object newItem, int newPosition, int count);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetCurrent(object newItem, int32 newPosition, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.SetCurrent(System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetCurrent (newItem As Object, newPosition As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetCurrent(System::Object ^ newItem, int newPosition, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newItem" Type="System.Object" />
        <Parameter Name="newPosition" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="newItem">Элемент, устанавливаемый в качестве <see cref="P:System.Windows.Data.CollectionView.CurrentItem" />.</param>
        <param name="newPosition">Значение, устанавливаемое как значение свойства <see cref="P:System.Windows.Data.CollectionView.CurrentPosition" />.</param>
        <param name="count">Число элементов в объекте <see cref="T:System.Windows.Data.CollectionView" />.</param>
        <summary>Установка заданного элемента и индекса в качестве значений свойств <see cref="P:System.Windows.Data.CollectionView.CurrentItem" /> и <see cref="P:System.Windows.Data.CollectionView.CurrentPosition" />. Данный метод можно вызвать из конструктора производного класса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка вызывается из конструктора производного класса.  Не передавайте <xref:System.Windows.Data.CollectionView.Count%2A> свойство, которое является виртуальное свойство, как `count`. Вместо этого передать число внутренний <xref:System.Collections.IList> , представляющий коллекцию.  
  
 <xref:System.Windows.Data.CollectionView.SetCurrent%2A> впервые появился в платформе .NET Framework версии 3.5.  Дополнительные сведения см. в статье [Версии и зависимости платформы .NET Framework](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SortDescriptions">
      <MemberSignature Language="C#" Value="public virtual System.ComponentModel.SortDescriptionCollection SortDescriptions { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.SortDescriptionCollection SortDescriptions" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.SortDescriptions" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SortDescriptions As SortDescriptionCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::ComponentModel::SortDescriptionCollection ^ SortDescriptions { System::ComponentModel::SortDescriptionCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.SortDescriptionCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение коллекции структур <see cref="T:System.ComponentModel.SortDescription" />, описывающей сортировку коллекции в данном представлении.</summary>
        <value>Пустой <see cref="T:System.ComponentModel.SortDescriptionCollection" /> во всех случаях.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не удается добавить <xref:System.ComponentModel.SortDescription> в возвращаемой коллекции (пустой) так как базовый класс <xref:System.Windows.Data.CollectionView> не поддерживает сортировку. Вместо этого используйте производные классы <xref:System.Windows.Data.ListCollectionView> и <xref:System.Windows.Data.BindingListCollectionView> , которые поддерживают сортировку. Кроме того, проверьте <xref:System.Windows.Data.CollectionView.CanSort%2A> свойство перед добавлением или удалением <xref:System.ComponentModel.SortDescription> объектов, чтобы избежать исключений.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Data.CollectionViewSource.SortDescriptions" />
      </Docs>
    </Member>
    <Member MemberName="SourceCollection">
      <MemberSignature Language="C#" Value="public virtual System.Collections.IEnumerable SourceCollection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerable SourceCollection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.SourceCollection" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SourceCollection As IEnumerable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::IEnumerable ^ SourceCollection { System::Collections::IEnumerable ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возврат базовой неотфильтрованной коллекции.</summary>
        <value>Объект <see cref="T:System.Collections.IEnumerable" />, который является базовой коллекцией.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Data.CollectionView.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возврат объекта <see cref="T:System.Collections.IEnumerator" />, который можно использовать для перечисления элементов представления.</summary>
        <returns>Объект <see cref="T:System.Collections.IEnumerator" />, который можно использовать для перечисления элементов представления.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdatedOutsideDispatcher">
      <MemberSignature Language="C#" Value="protected bool UpdatedOutsideDispatcher { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UpdatedOutsideDispatcher" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Data.CollectionView.UpdatedOutsideDispatcher" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property UpdatedOutsideDispatcher As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool UpdatedOutsideDispatcher { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение значения, определяющего, стоит ли обновлять журнал записей из-за получения уведомления <see cref="E:System.Windows.Data.CollectionView.CollectionChanged" /> по другому потоку, не вводя сперва в диспетчер потока [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</summary>
        <value>
          Значение <see langword="true" />, если было необходимо обновить журнал изменений из-за получения уведомления <see cref="E:System.Windows.Data.CollectionView.CollectionChanged" /> в другом потоке без предварительного входа в диспетчер потока [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Data.CollectionView.OnBeginChangeLogging(System.Collections.Specialized.NotifyCollectionChangedEventArgs)" />
      </Docs>
    </Member>
  </Members>
</Type>