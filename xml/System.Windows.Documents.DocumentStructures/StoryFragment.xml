<Type Name="StoryFragment" FullName="System.Windows.Documents.DocumentStructures.StoryFragment">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c07ce239f829a4284d9ac8435e6c3247d7b18e65" />
    <Meta Name="ms.sourcegitcommit" Value="f9e3295b6cc303a611a73a84c4b27f9da792ad0d" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/26/2018" />
    <Meta Name="ms.locfileid" Value="31911484" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class StoryFragment : System.Collections.Generic.IEnumerable&lt;System.Windows.Documents.DocumentStructures.BlockElement&gt;, System.Windows.Markup.IAddChild" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit StoryFragment extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Documents.DocumentStructures.BlockElement&gt;, class System.Collections.IEnumerable, class System.Windows.Markup.IAddChild" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.DocumentStructures.StoryFragment" />
  <TypeSignature Language="VB.NET" Value="Public Class StoryFragment&#xA;Implements IAddChild, IEnumerable(Of BlockElement)" />
  <TypeSignature Language="C++ CLI" Value="public ref class StoryFragment : System::Collections::Generic::IEnumerable&lt;System::Windows::Documents::DocumentStructures::BlockElement ^&gt;, System::Windows::Markup::IAddChild" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Windows.Documents.DocumentStructures.BlockElement&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IAddChild</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.ContentProperty("BlockElementList")</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет статью или ее часть в документе XPS.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Расширенные хранимые Процедуры из статей [!INCLUDE[TLA2#tla_xps](~/includes/tla2sharptla-xps-md.md)] документа Приблизительный аналог истории в газете или журнале. Она представляет собой текст и графическое содержимое, обычно на один раздел, в одном [!INCLUDE[TLA2#tla_xps](~/includes/tla2sharptla-xps-md.md)] документа. Обычно оно занимает несколько страниц, но может быть короче, чем такие боковая панель страницы — текст в рамке, в журнале. Также можно как первой странице газеты с продолжением на странице 4 отдельные статьи. Следовательно Данная страница может иметь более одной статьи и частей нескольких статей. Верхний или нижний колонтитул также — это специальный описания функциональности, которая полностью содержится на одной странице.  
  
 Объект <xref:System.Windows.Documents.DocumentStructures.StoryFragment> представляет все или часть истории. Он не может занимать несколько страниц, но она может занимать всю страницу или делить ее с другими фрагментами. Если статья занимает несколько страниц, каждая часть его на каждой странице, является отдельным фрагментом. Хотя статьи могут раздельно размещенных фрагментов, фрагмент может быть дискретное.  
  
 Только <xref:System.Windows.Documents.DocumentStructures.StoryFragments> элемент может быть родителем <xref:System.Windows.Documents.DocumentStructures.StoryFragment>.  Расположение <xref:System.Windows.Documents.DocumentStructures.StoryBreak> элементы внутри <xref:System.Windows.Documents.DocumentStructures.StoryFragment> указывает, содержится в нескольких фрагментов истории и если дополнительные фрагменты предшествовать или следовать текущего фрагмента.  
  
 При <xref:System.Windows.Documents.DocumentStructures.StoryFragment> заканчивается в середине некоторых структурных элементов; например `<TableRowGroupStructure>`, затем [!INCLUDE[TLA2#tla_xps](~/includes/tla2sharptla-xps-md.md)] документы приложений необходимо вставить соответствующий закрывающий тег для элемента (в данном случае `</TableRowGroupStructure>`) перед `</StoryFragment>` тег, даже Хотя структуры продолжается в более поздней версии фрагмента. (Это необходимо, чтобы убедиться, что дерево элементов в пределах <xref:System.Windows.Documents.DocumentStructures.StoryFragment> является допустимым XML.) Фрагмент, содержащий продолжение статьи должен начинаться с открывающего тега для прерванной структуры. Все дерево прерванных структур должны обрабатываться одинаково (с одним исключением, описаны ниже): необходимо добавить закрывающие теги для каждого несовпадающие открывающий тег выше точки прерывания.  
  
 Исключение применяется при прерывания истории следует сразу же после `</TableCellStructure>` тег, генерирующее приложение необходимо вставить пустой табличную структуру ячейки (`<TableCellStructure></TableCellStructure>`) в точке соответствующий фрагмент, содержащий продолжение статьи. Это необходимо, чтобы получающее приложение, которому нужно соединить все фрагменты определенной статьи для этого можно использовать простой алгоритм.  
  
 Предположим, например, приложение желает добавить следующие материалы [!INCLUDE[TLA2#tla_xps](~/includes/tla2sharptla-xps-md.md)] документа:  
  
```  
<SectionStructure>  
   <TableStructure>  
      <TableRowGroupStructure>  
         <TableRowStructure>  
            <TableCellStructure>  
               <ParagraphStructure>  
                  <NamedElement NameReference="SomeContent" />  
               </ParagraphStructure>  
            </TableCellStructure>  
            <TableCellStructure>  
               <ParagraphStructure>  
                  <NamedElement NameReference="MoreContent" />  
               </ParagraphStructure>  
            </TableCellStructure>  
         </TableRowStructure>  
         <TableRowStructure>  
            <TableCellStructure>  
               <ParagraphStructure>  
                  <NamedElement NameReference="EvenMoreContent" />  
               </ParagraphStructure>  
            </TableCellStructure>  
            <TableCellStructure>  
               <ParagraphStructure>  
                  <NamedElement NameReference="LastContent" />  
               </ParagraphStructure>  
            </TableCellStructure>  
         </TableRowStructure>  
      </TableRowGroupStructure>  
   </TableStructure>  
</SectionStructure>  
```  
  
 Если разрыв страницы требует завершения фрагмента сразу после `</TableCellStructure>` для «SomeContent», приложение необходимо создать разбиение, как показано в следующем примере:  
  
```  
<StoryFragment StoryName="MyStory" FragmentType="Content">  
 <SectionStructure>  
    <TableStructure>  
       <TableRowGroupStructure>  
          <TableRowStructure>  
             <TableCellStructure>  
                <ParagraphStructure>  
                   <NamedElement NameReference="SomeContent" />  
                </ParagraphStructure>   
             </TableCellStructure>  
<!-- lines from here to end of fragment added by producer-->  
          </TableRowStructure>  
       </TableRowGroupStructure>  
    </TableStructure>  
 </SectionStructure>  
</StoryFragment>  
  
<StoryFragment StoryName="MyStory" FragmentType="Content">  
 <SectionStructure>  
    <TableStructure>  
       <TableRowGroupStructure>  
          <TableRowStructure>  
             <TableCellStructure>   
              <!-- extra cell added by producer-->  
             </TableCellStructure>  
<!-- lines from here to start of fragment added by producer-->  
             <TableCellStructure>  
                <ParagraphStructure>  
                   <NamedElement NameReference="MoreContent" />  
                </ParagraphStructure>  
             </TableCellStructure>  
          </TableRowStructure>  
          <TableRowStructure>  
             <TableCellStructure>  
                <ParagraphStructure>  
                   <NamedElement NameReference="EvenMoreContent" />  
                </ParagraphStructure>  
             </TableCellStructure>  
             <TableCellStructure>  
                <ParagraphStructure>  
                   <NamedElement NameReference="LastContent" />  
                </ParagraphStructure>  
             </TableCellStructure>  
          </TableRowStructure>  
       </TableRowGroupStructure>  
    </TableStructure>  
 </SectionStructure>  
</StoryFragment>  
```  
  
 Приложение, которое считывает документ может потребоваться слияние этого содержимого. Рассмотрим, например, с помощью средства просмотра XPS **Копировать всю статью в буфер обмена** кнопку; или **XPS для слепых** приложения, которые переданы истории синтезатора речи.  Некоторые приложения, считывающие документа может потребоваться слияние подмножество фрагменты статьи. Например, функция, копирующая весь абзац в буфер обмена, щелкнув triple-это потребуется выполнить слияние всякий раз, когда абзац пересекается разрывом страницы, поскольку абзац такой будет разделен между двумя <xref:System.Windows.Documents.DocumentStructures.StoryFragment>s.  
  
 **Чтобы объединить этот алгоритм использовать:**  
  
1.  Удалить `</StoryFragment>` первый фрагмент выполнить слияние и удаление в конце `<StoryFragment>` с самого начала второго.  
  
2.  Если последний закрывающий тег первого фрагмента того же типа как первый открывающий тег второго фрагмента (и они не являются `<NamedElement>` тегов), удалите оба.  
  
3.  Повторите шаг 2 до двух фрагментов в *либо* из этих состояний:  
  
    -   Больше не существует соответствия типов между последний закрывающий тег первого фрагмента первый открывающий тег второго фрагмента.  
  
    -   Последний конечный тег начальные фрагмент первый открывающий тег второго фрагмента оба `<NamedElement>` тегов.  
  
 В приведенном выше примере Если пустая ячейка еще не добавлена в генерирующее приложение затем слияния фрагментов должен создать таблицу, в первой строке имеет только одну ячейку, содержащую «SomeContent» и «MoreContent» ссылки вместо исходного сначала строки с двумя ячейками, каждый из которых содержит одну ссылку  
  
 При слиянии всю статью алгоритм должен повторяться для каждого последующего фрагмент, который входит в одной статье. Фрагменты, принадлежащие статье индексируются в `<Story>` элемент. В разделе 9.1.15 [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] спецификации, который можно получить в [XPS: спецификация и формировании](http://www.microsoft.com/whdc/xps/downloads.mspx). Будет иметь последнего фрагмента для определенной статьи <xref:System.Windows.Documents.DocumentStructures.StoryBreak> как его последний дочерний элемент.  
  
   
  
## Examples  
 В следующем примере показан `<StoryFragment>` частью [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] документа.  
  
 [!code-xaml[DocumentStructure#DocStructStoryFragContent1](~/samples/snippets/csharp/VS_Snippets_Wpf/DocumentStructure/CSharp/Content/FixedPage1_structure.xaml#docstructstoryfragcontent1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.DocumentStructures.StoryBreak" />
    <altmember cref="T:System.Windows.Documents.DocumentStructures.StoryFragments" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public StoryFragment ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.DocumentStructures.StoryFragment.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; StoryFragment();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Documents.DocumentStructures.StoryFragment" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (System.Windows.Documents.DocumentStructures.BlockElement element);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(class System.Windows.Documents.DocumentStructures.BlockElement element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.DocumentStructures.StoryFragment.Add(System.Windows.Documents.DocumentStructures.BlockElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (element As BlockElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::Windows::Documents::DocumentStructures::BlockElement ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.Documents.DocumentStructures.BlockElement" />
      </Parameters>
      <Docs>
        <param name="element">Добавляемый блок.</param>
        <summary>Добавляет блок во фрагмент истории.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">Переданный блок равен <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="FragmentName">
      <MemberSignature Language="C#" Value="public string FragmentName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FragmentName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.DocumentStructures.StoryFragment.FragmentName" />
      <MemberSignature Language="VB.NET" Value="Public Property FragmentName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FragmentName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя фрагмента статьи.</summary>
        <value>Значение типа <see cref="T:System.String" />, представляющее имя этого фрагмента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о `FragmentName` атрибут `</StoryFragment>` частью [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] документов см. в разделе главе 9 [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] спецификации, который можно получить в [XPS: спецификация и формировании](http://www.microsoft.com/whdc/xps/downloads.mspx).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.DocumentStructures.StoryFragment.FragmentType" />
        <altmember cref="P:System.Windows.Documents.DocumentStructures.StoryFragment.StoryName" />
      </Docs>
    </Member>
    <Member MemberName="FragmentType">
      <MemberSignature Language="C#" Value="public string FragmentType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FragmentType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.DocumentStructures.StoryFragment.FragmentType" />
      <MemberSignature Language="VB.NET" Value="Public Property FragmentType As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FragmentType { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает тип фрагмента.</summary>
        <value>Значение типа <see cref="T:System.String" />, представляющее тип фрагмента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возможными значениями являются «Заголовок», «Нижний колонтитул» и «Содержимое».  
  
 Дополнительные сведения о `FragmentType` атрибут `</StoryFragment>` частью [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] документов см. в разделе главе 9 [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] спецификации, который можно получить в [XPS: спецификация и формировании](http://www.microsoft.com/whdc/xps/downloads.mspx).  
  
   
  
## Examples  
 В следующем примере показан `FragmentType` атрибут `<StoryFragment>` частью [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] документа.  
  
 [!code-xaml[DocumentStructure#DocStructStoryFragContent1](~/samples/snippets/csharp/VS_Snippets_Wpf/DocumentStructure/CSharp/Content/FixedPage1_structure.xaml#docstructstoryfragcontent1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.DocumentStructures.StoryFragment.FragmentName" />
      </Docs>
    </Member>
    <Member MemberName="StoryName">
      <MemberSignature Language="C#" Value="public string StoryName { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string StoryName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.DocumentStructures.StoryFragment.StoryName" />
      <MemberSignature Language="VB.NET" Value="Public Property StoryName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ StoryName { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя статьи.</summary>
        <value>Значение типа <see cref="T:System.String" /> представляющее имя статьи.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все фрагменты определенной статьи должны иметь одинаковое значение для этого свойства. Он должен соответствовать `StoryName` атрибут `<Story>` элемента. В разделе 9.1.15 [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] спецификации, который можно получить в [XPS: спецификация и формировании](http://www.microsoft.com/whdc/xps/downloads.mspx).  
  
 Это свойство может быть не указан, если <xref:System.Windows.Documents.DocumentStructures.StoryFragment.FragmentType%2A> является верхний или нижний колонтитул.  
  
   
  
## Examples  
 В следующем примере показан `StoryName` атрибут `<StoryFragment>` частью [!INCLUDE[TLA#tla_xps](~/includes/tlasharptla-xps-md.md)] документа.  
  
 [!code-xaml[DocumentStructure#DocStructStoryFragContent1](~/samples/snippets/csharp/VS_Snippets_Wpf/DocumentStructure/CSharp/Content/FixedPage1_structure.xaml#docstructstoryfragcontent1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.DocumentStructures.StoryFragment.FragmentName" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Windows.Documents.DocumentStructures.BlockElement&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Windows.Documents.DocumentStructures.BlockElement&gt; IEnumerable&lt;BlockElement&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;class System.Windows.Documents.DocumentStructures.BlockElement&gt; System.Collections.Generic.IEnumerable&lt;System.Windows.Documents.DocumentStructures.BlockElement&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.DocumentStructures.StoryFragment.System#Collections#Generic#IEnumerable&lt;System#Windows#Documents#DocumentStructures#BlockElement&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of BlockElement) Implements IEnumerable(Of BlockElement).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Windows::Documents::DocumentStructures::BlockElement ^&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Windows.Documents.DocumentStructures.BlockElement&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Windows::Documents::DocumentStructures::BlockElement ^&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Windows.Documents.DocumentStructures.BlockElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Этот метод не был реализован.</summary>
        <returns>Всегда вызывает исключение <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.DocumentStructures.StoryFragment.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Этот метод не был реализован.</summary>
        <returns>Всегда вызывает исключение <see cref="T:System.NotSupportedException" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddChild">
      <MemberSignature Language="C#" Value="void IAddChild.AddChild (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddChild(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.DocumentStructures.StoryFragment.System#Windows#Markup#IAddChild#AddChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Sub AddChild (value As Object) Implements IAddChild.AddChild" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddChild(System::Object ^ value) = System::Windows::Markup::IAddChild::AddChild;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddChild(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Добавляемый дочерний объект <see cref="T:System.Object" />.</param>
        <summary>Данный член предназначен для поддержки платформы .NET Framework и не должен вызываться напрямую из кода приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Добавляет дочерний объект в класс <xref:System.Windows.Documents.DocumentStructures.StoryFragment>.  
  
 Должен быть по крайней мере одного дочернего элемента <xref:System.Windows.Documents.DocumentStructures.StoryFragment> и дочерние элементы можно только из этих типов: <xref:System.Windows.Documents.DocumentStructures.ParagraphStructure>, <xref:System.Windows.Documents.DocumentStructures.FigureStructure>, <xref:System.Windows.Documents.DocumentStructures.ListStructure>, <xref:System.Windows.Documents.DocumentStructures.TableStructure>, <xref:System.Windows.Documents.DocumentStructures.SectionStructure>, и <xref:System.Windows.Documents.DocumentStructures.StoryBreak>.  
  
 Объект <xref:System.Windows.Documents.DocumentStructures.StoryBreak> может быть только дочерним первой или последней <xref:System.Windows.Documents.DocumentStructures.StoryFragment>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Тип <paramref name="value" /> не принадлежит к числу типов, которые могут быть дочерними для данного класса. См. **Примечания**.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IAddChild.AddText">
      <MemberSignature Language="C#" Value="void IAddChild.AddText (string text);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Windows.Markup.IAddChild.AddText(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.DocumentStructures.StoryFragment.System#Windows#Markup#IAddChild#AddText(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub AddText (text As String) Implements IAddChild.AddText" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Windows.Markup.IAddChild.AddText(System::String ^ text) = System::Windows::Markup::IAddChild::AddText;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IAddChild.AddText(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Текст для добавления в объект.</param>
        <summary>Добавляет текстовое содержимое узла в объект.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>