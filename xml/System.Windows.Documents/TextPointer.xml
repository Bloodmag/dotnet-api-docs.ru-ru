<Type Name="TextPointer" FullName="System.Windows.Documents.TextPointer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d374acbfa59bece9a23ff4841ba74263d0c6fa42" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30630718" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TextPointer : System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TextPointer extends System.Windows.Documents.ContentPosition" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Documents.TextPointer" />
  <TypeSignature Language="VB.NET" Value="Public Class TextPointer&#xA;Inherits ContentPosition" />
  <TypeSignature Language="C++ CLI" Value="public ref class TextPointer : System::Windows::Documents::ContentPosition" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Documents.ContentPosition</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Представляет положение в <see cref="T:System.Windows.Documents.FlowDocument" /> или <see cref="T:System.Windows.Controls.TextBlock" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextPointer> Класс представлены следующие термины:  
  
-   Поместите - по своей природе, <xref:System.Windows.Documents.TextPointer> всегда указывает на *позиции* в содержимом.  Подобные положения находятся либо между символами в содержимом или потока содержимого тегами элемента, определение структуры для содержимого.  
  
-   Текущее положение — так как <xref:System.Windows.Documents.TextPointer> всегда указывает на позицию, а потому, что много операций, которые могут быть выполнены с помощью <xref:System.Windows.Documents.TextPointer> зависят от положения, в настоящее время, на который указывает <xref:System.Windows.Documents.TextPointer>, смысл просто см. позиции, указываемой параметром <xref:System.Windows.Documents.TextPointer> как *текущей позиции*.  
  
-   Позиция вставки - *позицию вставки* — положение, где может быть добавлено новое содержимое без нарушения любой семантических правил для соответствующего содержимого.  На практике положение вставки в любом месте — в содержимом положение курсора.  Примером является допустимым <xref:System.Windows.Documents.TextPointer> , не положение вставки — положение между двумя смежные <xref:System.Windows.Documents.Paragraph> теги (т. е между закрывающего тега элемента выше и открывающий тег следующего абзаца).  
  
-   Символ — в целях <xref:System.Windows.Documents.TextPointer> операции, включающие символы, следующие считается *символ*:  
  
    -   Открывающий или закрывающий тег для <xref:System.Windows.Documents.TextElement> элемента.  
  
    -   Объект <xref:System.Windows.UIElement> элементов, содержащихся в <xref:System.Windows.Documents.InlineUIContainer> или <xref:System.Windows.Documents.BlockUIContainer>.  Примечание такое <xref:System.Windows.UIElement> всегда считается ровно один символ; любое дополнительное содержимое или элементы, содержащиеся в <xref:System.Windows.UIElement> , не рассматриваются как символы.  
  
    -   Каждый 16-разрядное [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] символ внутри текстового <xref:System.Windows.Documents.Run> элемента.  
  
-   Контейнер текста - A *контейнера текста* элемент, который образует конечную границу для имеющегося содержимого потока; в позиции, указываемой параметром <xref:System.Windows.Documents.TextPointer> всегда попадает в текстовом контейнере.  В настоящее время текстовый контейнер должен быть либо <xref:System.Windows.Documents.FlowDocument> или <xref:System.Windows.Controls.TextBlock>.  В целом, операции между <xref:System.Windows.Documents.TextPointer> экземпляры в другой текстовой контейнеры не поддерживаются.  
  
-   Документ - содержимое в текстовом контейнере, называют *документа*, как в <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> метод и <xref:System.Windows.Documents.TextPointer.DocumentStart%2A> и <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A> свойства.  
  
 <xref:System.Windows.Documents.TextPointer> Класс предназначен для упрощения обхода и обработки содержимого, представленного [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] элементы потока содержимого; как правило, такие элементы, производные от <xref:System.Windows.Documents.TextElement>.  Некоторые операции, <xref:System.Windows.Documents.TextPointer> облегчает включают следующее:  
  
-   Выполняют порядковое сравнение текущего положения со вторым заданным положением.  В разделе <xref:System.Windows.Documents.TextPointer.CompareTo%2A> метод.  
  
-   Определите тип содержимого, рядом с текущей позиции в указанном направлении.  В разделе <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> метод и <xref:System.Windows.Documents.TextPointerContext> перечисления.  
  
-   Получить <xref:System.Windows.Documents.TextElement> , областей или рядом с текущей позиции.  В разделе <xref:System.Windows.Documents.Paragraph> и <xref:System.Windows.Documents.TextPointer.GetAdjacentElement%2A> метод.  
  
-   Получение контейнера текста, определяющего область текущего документа.  См. свойство <xref:System.Windows.Documents.TextPointer.Parent%2A>.  
  
-   Получите указанное число символов, перед или после текущего положения.  В разделе <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> метод.  
  
-   Вставьте строку символов в текущей позиции.  В разделе <xref:System.Windows.Documents.TextPointer.InsertTextInRun%2A> метод.  
  
-   Поиск границ строки в содержимом.  В разделе <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> метод и <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> свойства.  
  
-   Преобразование между <xref:System.Windows.Documents.TextPointer> позиций и символ смещений в содержимое.  В разделе <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> и <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> методы.  
  
-   Проверка visual нажатия путем преобразования между <xref:System.Windows.Documents.TextPointer> позиции и <xref:System.Windows.Point> представляющий относительных координат.  
  
-   Поиск ближайшего положения вставки или проверить, является ли текущая позиция вставки.  В разделе <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> и <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> методы и <xref:System.Windows.Documents.TextPointer.IsAtInsertionPosition%2A> свойства.  
  
 Положение и <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> обозначается <xref:System.Windows.Documents.TextPointer> объекта являются неизменяемыми.  Если содержимое редактирования или изменения позиции, указываемой параметром <xref:System.Windows.Documents.TextPointer> не изменяет относительно окружающего текста; скорее смещение данного положения от начала содержимого соответствующим образом корректируется, чтобы отразить новое относительное положение в содержимое.  Например <xref:System.Windows.Documents.TextPointer> указывает позицию в начале данного абзаца продолжает указывать на начало данного абзаца даже в том случае, когда содержимое является вставляются или удаляются до или после абзаца.  
  
 <xref:System.Windows.Documents.TextPointer> Класс не предоставляет каких-либо открытых конструкторов.  Экземпляр <xref:System.Windows.Documents.TextPointer> создается с помощью свойств или методов других объектов (включая другие <xref:System.Windows.Documents.TextPointer> объекты). Ниже приведены некоторые примеры методов и свойств, создания и возврата <xref:System.Windows.Documents.TextPointer>.  Этот список не является исчерпывающим.  
  
-   Из <xref:System.Windows.Documents.TextRange>: <xref:System.Windows.Documents.TextRange.Start%2A> и <xref:System.Windows.Documents.TextRange.End%2A>.  
  
-   Из <xref:System.Windows.Documents.TextElement>: <xref:System.Windows.Documents.TextElement.ContentStart%2A>, <xref:System.Windows.Documents.TextElement.ContentEnd%2A>, <xref:System.Windows.Documents.TextElement.ElementStart%2A>, и <xref:System.Windows.Documents.TextElement.ElementEnd%2A>.  
  
-   Из <xref:System.Windows.Controls.TextBlock> (контейнера текста): <xref:System.Windows.Controls.TextBlock.ContentStart%2A>, <xref:System.Windows.Controls.TextBlock.ContentEnd%2A>, и <xref:System.Windows.Controls.TextBlock.GetPositionFromPoint%2A>.  
  
-   Из <xref:System.Windows.Documents.FlowDocument> (контейнера текста): <xref:System.Windows.Documents.FlowDocument.ContentStart%2A>, и <xref:System.Windows.Documents.FlowDocument.ContentEnd%2A>  
  
-   Из существующего <xref:System.Windows.Documents.TextPointer>: <xref:System.Windows.Documents.TextPointer.DocumentStart%2A>, <xref:System.Windows.Documents.TextPointer.DocumentEnd%2A>, <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A>, и <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A>.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование <xref:System.Windows.Documents.TextPointer> для поиска позиции только внутри первого <xref:System.Windows.Documents.Run> элемента в контейнере указанного текста.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer1)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer1)]  
  
 В следующем примере реализуется алгоритм упрощен поиск с помощью <xref:System.Windows.Documents.TextPointer> средства.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_textpointer2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_TextPointer2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_textpointer2)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Documents.TextRange" />
    <altmember cref="T:System.Windows.Documents.TextPointerContext" />
    <altmember cref="T:System.Windows.Documents.TextElement" />
  </Docs>
  <Members>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.CompareTo(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::Windows::Documents::TextPointer ^ position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">
          <see cref="T:System.Windows.Documents.TextPointer" />, который указывает положение для сравнения с текущим положением.</param>
        <summary>Выполнение порядкового сравнения между положениями, указанными текущим <see cref="T:System.Windows.Documents.TextPointer" /> и вторым указанным <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>–1 если текущий <see cref="T:System.Windows.Documents.TextPointer" /> предшествует <paramref name="position" />; 0 если расположения те же; +1 если текущий <see cref="T:System.Windows.Documents.TextPointer" /> следует за <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение – 1 указывает, что должность, указанную в текущем <xref:System.Windows.Documents.TextPointer> предшествует позиции, указанной параметром `position`.  Значение 0 указывает, что указанные положения равны.  Значение положительное + 1 указывает на должность, указанную в текущем <xref:System.Windows.Documents.TextPointer> соответствует позиции, указанной параметром `position`.  
  
   
  
## Examples  
 В следующем примере показано использование этого метода.  В примере <xref:System.Windows.Documents.TextPointer.CompareTo%2A> метод используется в сочетании с <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> метод для проверки, действительно ли заданное <xref:System.Windows.Documents.TextElement> пуст.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="position" /> указывает положение за пределами текстового контейнера, связанного с текущим положением.</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="DeleteTextInRun">
      <MemberSignature Language="C#" Value="public int DeleteTextInRun (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 DeleteTextInRun(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeleteTextInRun (count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int DeleteTextInRun(int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Число символов, подлежащих удалению, начиная с текущего положения. Укажите положительное значение, чтобы удалить символы, следующие за текущим положением; укажите отрицательное значение, чтобы удалить символы, предшествующие текущему положению.</param>
        <summary>Удаление указанного числа символов, начиная с положения, указанного текущим <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>Число фактически удаленных символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Укажите положительное значение, чтобы удалить символы, соответствующие текущей позиции (как в <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>); укажите отрицательное значение, чтобы удалить символы, предшествующие текущему положению (как в <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 Число фактически удаленных символов может быть меньше, чем число, заданное `count`.  Это происходит в случаях, где `count` указывает больше символов, чем существует для удаления.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метод вызывается в положении, для которого текст не разрешен.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetTextInRun" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="DocumentEnd">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentEnd { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentEnd" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentEnd As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentEnd { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение <see cref="T:System.Windows.Documents.TextPointer" /> в конце содержимого в текстовом контейнере, связанном с текущим положением.</summary>
        <value>
          <see cref="T:System.Windows.Documents.TextPointer" /> в конце содержимого в текстовом контейнере, связанном с текущим положением.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextPointer.Parent%2A> Для возвращенного <xref:System.Windows.Documents.TextPointer> всегда представляет собой контейнер текста (<xref:System.Windows.Controls.TextBlock> или <xref:System.Windows.Documents.FlowDocument>), а не <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentStart" />
      </Docs>
    </Member>
    <Member MemberName="DocumentStart">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer DocumentStart { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.TextPointer DocumentStart" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.DocumentStart" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DocumentStart As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::TextPointer ^ DocumentStart { System::Windows::Documents::TextPointer ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение <see cref="T:System.Windows.Documents.TextPointer" /> в начале содержимого в текстовом контейнере, связанном с текущим положением.</summary>
        <value>
          <see cref="T:System.Windows.Documents.TextPointer" /> в начале содержимого в текстовом контейнере, связанном с текущим положением.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте положения, возвращаемого этим свойством, в качестве базового положения, из которого необходимо применить смещения в другое место.  <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> И <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> методы предоставляют способ преобразования между положениями и позиции смещения.  
  
 <xref:System.Windows.Documents.TextPointer.Parent%2A> Для возвращенного <xref:System.Windows.Documents.TextPointer> всегда представляет собой контейнер текста (<xref:System.Windows.Controls.TextBlock> или <xref:System.Windows.Documents.FlowDocument>), а не <xref:System.Windows.Documents.TextElement>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.DocumentEnd" />
      </Docs>
    </Member>
    <Member MemberName="GetAdjacentElement">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject GetAdjacentElement (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyObject GetAdjacentElement(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetAdjacentElement(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAdjacentElement (direction As LogicalDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyObject ^ GetAdjacentElement(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, которое указывает логическое направление, в котором осуществляется поиск примыкающих элементов.</param>
        <summary>Возвращение элемента, если таковой имеется, который граничит с текущим <see cref="T:System.Windows.Documents.TextPointer" /> в указанном логическом направлении.</summary>
        <returns>Примыкающий элемент в указанном <paramref name="direction" /> или <see langword="null" />, если не существует примыкающих элементов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обычно возвращаемый элемент является <xref:System.Windows.Documents.TextElement>.  Объект <xref:System.Windows.UIElement> могут быть возвращены при <xref:System.Windows.Documents.TextPointer> указывает на позицию внутри <xref:System.Windows.Documents.BlockUIContainer> элемент или <xref:System.Windows.Documents.InlineUIContainer> элемент.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetCharacterRect">
      <MemberSignature Language="C#" Value="public System.Windows.Rect GetCharacterRect (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Rect GetCharacterRect(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCharacterRect (direction As LogicalDirection) As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Rect GetCharacterRect(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetCharacterRect(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, задающее логическое направление, в котором осуществляется поиск ограничивающего прямоугольника содержимого.</param>
        <summary>Возвращение ограничивающего прямоугольника (<see cref="T:System.Windows.Rect" />) для содержимого, которое граничит с текущим <see cref="T:System.Windows.Documents.TextPointer" /> в указанном логическом направлении.</summary>
        <returns>Ограничивающий прямоугольник для содержимого, которое граничит с текущим <see cref="T:System.Windows.Documents.TextPointer" /> в указанном направлении или <see cref="P:System.Windows.Rect.Empty" />, если текущая допустимая информация о структуре недоступна.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Documents.TextElement> границы не учитываются содержимого в целях этого метода.  Если <xref:System.Windows.Documents.TextPointer> располагается перед <xref:System.Windows.Documents.TextElement> границей, возвращаемое значение является ограничивающего прямоугольника для следующей отличных<xref:System.Windows.Documents.TextElement> содержимого в указанном направлении.  Если в указанном направлении нулевой ширины не имеет содержимого <xref:System.Windows.Rect> возвращается с высотой, совпадающей с высотой все предшествующие содержимого.  
  
 Операцию, выполняемую с помощью данного метода зависит от допустимого макета.  При необходимости этот метод пытается автоматически восстановить допустимый макет перед продолжением операции.  Повторное создание макета может быть довольно дорогой операции.  Используйте <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> свойство для проверки допустимого макета перед выполнением операций, которые могут заново создать макет.  Дополнительные сведения см. в разделе [макета](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      </Docs>
    </Member>
    <Member MemberName="GetInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, которое указывает логическое направление, в котором осуществляется поиск ближайшего положения вставки.</param>
        <summary>Возвращение <see cref="T:System.Windows.Documents.TextPointer" /> к ближайшему положению вставки в заданном логическом направлении.</summary>
        <returns>
          <see cref="T:System.Windows.Documents.TextPointer" /> к ближайшему положению вставки в заданном направлении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Положение вставки — положение, где может быть добавлено новое содержимое без нарушения любой семантических правил для соответствующего содержимого.  На практике положение вставки в любом месте — в содержимом положение курсора.  Примером является допустимым <xref:System.Windows.Documents.TextPointer> , не положение вставки — положение между двумя смежные <xref:System.Windows.Documents.Paragraph> теги (т. е между закрывающего тега элемента выше и открывающий тег следующего абзаца).  
  
 Если <xref:System.Windows.Documents.TextPointer> уже указывает на допустимое положение вставки, однако закрывающий тег для непустой последовательности форматирования непосредственно следует за эту должность в заданном направлении, то <xref:System.Windows.Documents.TextPointer> возвращает этот метод корректируется для вставки положение сразу после закрытия последовательности форматирования. Например, рассмотрим последовательность разметки `<Bold>a</Bold>b`. Обратите внимание, что два положения вставки между буквами `a` и `b` — одна, которая предшествует закрывающий `Bold` тег и один непосредственно после закрывающего `Bold` тег. Если <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> будет вызван на <xref:System.Windows.Documents.TextPointer> на позицию сразу после буквы `a` и до закрытия `Bold` тега и с `direction` из <xref:System.Windows.Documents.LogicalDirection.Forward>, возвращенный <xref:System.Windows.Documents.TextPointer> корректируется для Позиция непосредственно перед буквой `b`, после закрывающего `Bold` тег. Аналогичные корректировки выполняются для открывающих тегов форматирования при работе в обратном направлении логических. Этот метод предназначен для предоставления средств устранения неоднозначности между позициями вставки в подобных случаев.  
  
 Этот метод можно использовать также для избирательно точек вставки, если участвует последовательность структурных тегов. Например, если на положение между закрытия и открытия тегов абзаца, направление параметра может использоваться выберите ближайший курсор в начало следующего абзаца (путем указания <xref:System.Windows.Documents.LogicalDirection.Forward?displayProperty=nameWithType>) или в конце предыдущего абзаца ( указав <xref:System.Windows.Documents.LogicalDirection.Backward?displayProperty=nameWithType>).  
  
 Если курсор уже находится в позиции курсора, и нет смежные форматирования тегов в указанном `direction`, возвращенный <xref:System.Windows.Documents.TextPointer> указывает на той же позиции, что и вызов метода <xref:System.Windows.Documents.TextPointer>.  
  
 Возможно, нет допустимое положение вставки существует относительно позиции, на который указывает <xref:System.Windows.Documents.TextPointer>.  Это может произойти, если ссылочное содержимое является структурно незавершенным, как пустой таблицы или списка.  В таком случае этот метод возвращает <xref:System.Windows.Documents.TextPointer> в той же позиции, что <xref:System.Windows.Documents.TextPointer> из которой был вызван этот метод.  Этот метод всегда возвращает допустимое <xref:System.Windows.Documents.TextPointer>.  
  
   
  
## Examples  
 В этом примере показано, как использовать <xref:System.Windows.Documents.TextPointer.GetInsertionPosition%2A> метод для проверки, действительно ли заданное <xref:System.Windows.Documents.TextElement> является пустым для печати содержимого.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLineStartPosition">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращение <see cref="T:System.Windows.Documents.TextPointer" /> в начало строки, задаваемое относительно текущего <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="count">Число маркеров начала строки, которые надо пропустить при определении строки, для которой требуется вернуть начальное положение. Отрицательные значения указывают предшествующие строки, 0 задает текущую строку, а положительные значения задают следующие строки.</param>
        <summary>Возвращение <see cref="T:System.Windows.Documents.TextPointer" /> в начало строки, задаваемое относительно текущего <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>
          <see cref="T:System.Windows.Documents.TextPointer" />, указывающий на начало указанной строки (при том, что для <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> задано значение <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />), или <see langword="null" />, если указанная строка выходит за пределы диапазона или не может быть обнаружена иным способом.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Windows.Documents.TextPointer> указывает неоднозначную позицию, например, между двумя строками строки в направлении, указанным <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> выбран в качестве относительного начальную строку.  
  
 Операцию, выполняемую с помощью данного метода зависит от допустимого макета.  При необходимости этот метод пытается автоматически восстановить допустимый макет перед продолжением операции.  Повторное создание макета может быть довольно дорогой операции.  Используйте <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> для проверки допустимого макета перед выполнением операций, которые могут заново создать макет.  Дополнительные сведения см. в разделе [макета](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLineStartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetLineStartPosition (int count, out int actualCount);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetLineStartPosition(int32 count, [out] int32&amp; actualCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetLineStartPosition(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLineStartPosition (count As Integer, ByRef actualCount As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetLineStartPosition(int count, [Runtime::InteropServices::Out] int % actualCount);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="actualCount" Type="System.Int32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="count">Число маркеров начала строки, которые надо пропустить при определении строки, для которой требуется вернуть начальное положение. Отрицательные значения указывают предшествующие строки, 0 задает текущую строку, а положительные значения задают следующие строки.</param>
        <param name="actualCount">При возврате данный метод включает фактическое число маркеров начала строки, которые были пропущены при определении строки, для которой возвращается начальное положение.  Это значение может оказаться меньше <c>count</c>, если начало или конец содержимого обнаружен до того, как указанное число строк было пропущено. Этот параметр передается неинициализированным.</param>
        <summary>Возвращение <see cref="T:System.Windows.Documents.TextPointer" /> в начало строки, задаваемое относительно текущего <see cref="T:System.Windows.Documents.TextPointer" />, и создание отчета о числе пропущенных строк.</summary>
        <returns>
          <see cref="T:System.Windows.Documents.TextPointer" />, указывающий на начало указанной строки (при том, что для <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" /> задано значение <see cref="F:System.Windows.Documents.LogicalDirection.Forward" />), или на начало строки, ближайшей к указанной строке, если указанная строка находится вне диапазона.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Windows.Documents.TextPointer> указывает неоднозначную позицию, например, между двумя строками строки в направлении, указанным <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> выбрано свойство как относительный начальную строку.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextContextPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextContextPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextContextPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextContextPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextContextPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextContextPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, которое указывает логическое направление, в котором осуществляется поиск следующего символа.</param>
        <summary>Возвращение указателя к следующему символу в указанном логическом направлении.</summary>
        <returns>
          <see cref="T:System.Windows.Documents.TextPointer" /> к следующему символу в требуемом направлении или <see langword="null" />, если текущий<see cref="T:System.Windows.Documents.TextPointer" /> граничит с началом или концом содержимого.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Одно из следующих рассматривается как символ:  
  
-   Открывающий или закрывающий тег для <xref:System.Windows.Documents.TextElement> элемента.  
  
-   Объект <xref:System.Windows.UIElement> элемента, содержащегося в <xref:System.Windows.Documents.InlineUIContainer> или <xref:System.Windows.Documents.BlockUIContainer>.  Примечание такое <xref:System.Windows.UIElement> всегда считается ровно один символ; любое дополнительное содержимое или элементы, содержащиеся в <xref:System.Windows.UIElement> , не рассматриваются как символы.  
  
-   16-разрядное [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] символ внутри текстового <xref:System.Windows.Documents.Run> элемента.  
  
 Если следующий символ отнесен <xref:System.Windows.Documents.TextPointerContext.EmbeddedElement>, <xref:System.Windows.Documents.TextPointerContext.ElementStart>, или <xref:System.Windows.Documents.TextPointerContext.ElementEnd> (с <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> метод), то <xref:System.Windows.Documents.TextPointer> возвращает этот метод перемещается вперед ровно один символ из текущей позиции.  
  
 Если следующий символ к категории <xref:System.Windows.Documents.TextPointerContext.Text>, то <xref:System.Windows.Documents.TextPointer> возвращает этот метод продвигается за текст к следующему символу нетекстовых (то есть следующей позиции <xref:System.Windows.Documents.TextPointerContext> не <xref:System.Windows.Documents.TextPointerContext.Text>).  Символ точное число пересекаемых можно вычислить заранее путем вызова <xref:System.Windows.Documents.TextPointer.GetTextRunLength%2A> метод.  
  
   
  
## Examples  
 В следующем примере показано использование этого метода.  В этом примере <xref:System.Windows.Documents.TextPointer.GetNextContextPosition%2A> в сочетании с <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> способ обхода и извлечь символы в указанном <xref:System.Windows.Documents.TextElement>.  
  
 Хотя приведенный пример можно использовать для извлечения [!INCLUDE[TLA#tla_titlexaml](~/includes/tlasharptla-titlexaml-md.md)] структуры для содержимого данного <xref:System.Windows.Documents.TextElement>, он предназначен исключительно для демонстрационных целей и не должен использоваться в рабочем коде.  В разделе <xref:System.Xml> пространство имен для широкий набор типов, предназначенных для работы с и обработки XML.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextcontextposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextContextPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextcontextposition)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNextInsertionPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetNextInsertionPosition (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetNextInsertionPosition(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNextInsertionPosition (direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetNextInsertionPosition(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, которое указывает логическое направление, в котором осуществляется поиск следующего положения вставки.</param>
        <summary>Возвращение <see cref="T:System.Windows.Documents.TextPointer" /> к следующему положению вставки в указанном логическом направлении.</summary>
        <returns>
          <see cref="T:System.Windows.Documents.TextPointer" />, который определяет следующее положение вставки в запрошенном направлении или <see langword="null" />, если невозможно найти следующее положение вставки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Позицию вставки* — положение, где может быть добавлено новое содержимое без нарушения любой семантических правил для соответствующего содержимого.  На практике положение вставки в любом месте — в содержимом положение курсора.  Примером является допустимым <xref:System.Windows.Documents.TextPointer> , не положение вставки — положение между двумя смежные <xref:System.Windows.Documents.Paragraph> теги (т. е между закрывающего тега элемента выше и открывающий тег следующего абзаца).  
  
   
  
## Examples  
 В следующем примере показано использование этого метода. В этом примере <xref:System.Windows.Documents.TextPointer.GetNextInsertionPosition%2A> метод необходимо пройти границы содержимого элемента, чтобы число <xref:System.Windows.Documents.Paragraph> представляют элементы между двумя указанными <xref:System.Windows.Documents.TextPointer> экземпляров.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getnextinsertionposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetNextInsertionPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getnextinsertionposition)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="GetOffsetToPosition">
      <MemberSignature Language="C#" Value="public int GetOffsetToPosition (System.Windows.Documents.TextPointer position);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetOffsetToPosition(class System.Windows.Documents.TextPointer position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetOffsetToPosition (position As TextPointer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetOffsetToPosition(System::Windows::Documents::TextPointer ^ position);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="position">
          <see cref="T:System.Windows.Documents.TextPointer" />, который задает положение, до которо٠надо найти расстояние (в символах).</param>
        <summary>Возвращение числа символов между текущим <see cref="T:System.Windows.Documents.TextPointer" /> и вторым указанным <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>Относительное число символов между текущим <see cref="T:System.Windows.Documents.TextPointer" /> и <paramref name="position" />.  Отрицательное значение показывает, что текущий <see cref="T:System.Windows.Documents.TextPointer" /> следует за положением, заданным <paramref name="position" />, 0 означает, что положения равны, а положительное значение показывает, что текущий <see cref="T:System.Windows.Documents.TextPointer" /> предшествует положению, указанному <paramref name="position" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Одно из следующих рассматривается как символ:  
  
-   Открывающий или закрывающий тег для <xref:System.Windows.Documents.TextElement> элемента.  
  
-   Объект <xref:System.Windows.UIElement> элемента, содержащегося в <xref:System.Windows.Documents.InlineUIContainer> или <xref:System.Windows.Documents.BlockUIContainer>.  Примечание такое <xref:System.Windows.UIElement> всегда считается ровно один символ; любое дополнительное содержимое или элементы, содержащиеся в <xref:System.Windows.UIElement> , не рассматриваются как символы.  
  
-   16-разрядное [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] символ внутри текстового <xref:System.Windows.Documents.Run> элемента.  
  
   
  
## Examples  
 В следующем примере показано использование этого метода. В этом примере <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> способ поиска смещения для двух <xref:System.Windows.Documents.TextPointer> экземпляров, а затем использует эти сведения для сохранения и восстановления в разделе <xref:System.Windows.Controls.RichTextBox>.  Предполагается, что содержимое <xref:System.Windows.Controls.RichTextBox> между выбора сохранения и восстановления выделения не изменились.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="position" /> указывает положение за пределами текстового контейнера, связанного с текущим положением.</exception>
        <altmember cref="Overload:System.Windows.Documents.TextPointer.GetPositionAtOffset" />
        <altmember cref="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPointerContext">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointerContext GetPointerContext (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Documents.TextPointerContext GetPointerContext(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPointerContext (direction As LogicalDirection) As TextPointerContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointerContext GetPointerContext(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetPointerContext(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointerContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, которое указывает логическое направление, в котором необходимо определить категорию примыкающего содержимого.</param>
        <summary>Возвращение индикатора категории для содержимого, примыкающего к текущему <see cref="T:System.Windows.Documents.TextPointer" /> в указанном логическом направлении.</summary>
        <returns>Одно из значений <see cref="T:System.Windows.Documents.TextPointerContext" />, которое определяет категорию примыкающего содержимого в указанном логическом направлении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере показано использование этого метода. В этом примере <xref:System.Windows.Documents.TextPointer.GetPointerContext%2A> метод, чтобы реализовать алгоритм для расчета баланса открывающих и закрывающих тегов элементов между двумя указанными <xref:System.Windows.Documents.TextPointer> позиций.  Каждый открывающий тег элемента считается + 1, а каждый закрывающий тег элемента считается – 1.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getoffsettoposition2)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetOffsetToPosition2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getoffsettoposition2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetPositionAtOffset">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращение <see cref="T:System.Windows.Documents.TextPointer" /> в положение, указанное заданным смещением в символах от начала содержимого.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="offset">Смещение (в символах) на которое необходимо рассчитывать и возвращать положение.  Если смещение отрицательное, положение рассчитывается в логическом направлении, противоположном заданному свойством <see cref="P:System.Windows.Documents.TextPointer.LogicalDirection" />.</param>
        <summary>Возвращение <see cref="T:System.Windows.Documents.TextPointer" /> в положение, указанное заданным смещением в символах от начала текущего <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
        <returns>Указатель <see cref="T:System.Windows.Documents.TextPointer" /> на положение, определенное заданным смещением, или <see langword="null" />, если невозможно найти соответствующее положение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Одно из следующих рассматривается как символ:  
  
-   Открывающий или закрывающий тег для <xref:System.Windows.Documents.TextElement> элемента.  
  
-   Объект <xref:System.Windows.UIElement> элемента, содержащегося в <xref:System.Windows.Documents.InlineUIContainer> или <xref:System.Windows.Documents.BlockUIContainer>.  Примечание такое <xref:System.Windows.UIElement> всегда считается ровно один символ; любое дополнительное содержимое или элементы, содержащиеся в <xref:System.Windows.UIElement> , не рассматриваются как символы.  
  
-   16-разрядное [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] символ внутри текстового <xref:System.Windows.Documents.Run> элемента.  
  
   
  
## Examples  
 В следующем примере показано использование этого метода. В этом примере <xref:System.Windows.Documents.TextPointer.GetPositionAtOffset%2A> метод для реализации пары методов, один для расчета смещения в указанную позицию относительно любого размещения абзаца, а другая — для возврата <xref:System.Windows.Documents.TextPointer> указанное смещение в указанный абзаца.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_getpositionatoffset)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetPositionAtOffset](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_getpositionatoffset)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionAtOffset">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer GetPositionAtOffset (int offset, System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer GetPositionAtOffset(int32 offset, valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetPositionAtOffset(System.Int32,System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPositionAtOffset (offset As Integer, direction As LogicalDirection) As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ GetPositionAtOffset(int offset, System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="offset">Смещение (в символах) на которое необходимо рассчитывать и возвращать положение.  Если смешение отрицательное, возвращенный <see cref="T:System.Windows.Documents.TextPointer" /> предшествует текущему <see cref="T:System.Windows.Documents.TextPointer" />; в противном случае, он идет следом.</param>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, которое указывает логическое направление возвращенного <see cref="T:System.Windows.Documents.TextPointer" />.</param>
        <summary>Возвращение <see cref="T:System.Windows.Documents.TextPointer" /> в положение, указанное заданным смещением в символах от начала текущего <see cref="T:System.Windows.Documents.TextPointer" />, а также в указанном направлении.</summary>
        <returns>Указатель <see cref="T:System.Windows.Documents.TextPointer" /> на положение, определяемое заданным смещением, или <see langword="null" />, если смещение выходит за рамки содержимого.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Одно из следующих рассматривается как символ:  
  
-   Открывающий или закрывающий тег для <xref:System.Windows.Documents.TextElement> элемента.  
  
-   Объект <xref:System.Windows.UIElement> элемента, содержащегося в <xref:System.Windows.Documents.InlineUIContainer> или <xref:System.Windows.Documents.BlockUIContainer>.  Примечание такое <xref:System.Windows.UIElement> всегда считается ровно один символ; любое дополнительное содержимое или элементы, содержащиеся в <xref:System.Windows.UIElement> , не рассматриваются как символы.  
  
-   16-разрядное [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] символ внутри текстового <xref:System.Windows.Documents.Run> элемента.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetOffsetToPosition(System.Windows.Documents.TextPointer)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTextInRun">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращение текста, примыкающего к текущему <see cref="T:System.Windows.Documents.TextPointer" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public string GetTextInRun (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetTextInRun(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, которое указывает логическое направление, в котором осуществляется поиск и возвращение любого примыкающего текста.</param>
        <summary>Возвращение строки, содержащей любой текст, примыкающий к текущему <see cref="T:System.Windows.Documents.TextPointer" /> в указанном логическом направлении.</summary>
        <returns>Строка, содержащая любой примыкающий текст в указанном логическом направлении, или <see cref="F:System.String.Empty" />, если не найдено примыкающего текста.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает только непрерывные текстовые выполнения.  Ничего не возвращается, если любой символ типа не <xref:System.Windows.Documents.TextPointerContext.Text> рядом с текущим <xref:System.Windows.Documents.TextPointer> в указанном направлении.  Аналогичным образом возвращается только до следующего нетекстового символа.  
  
   
  
## Examples  
 В следующем примере показано использование этого метода. В этом примере <xref:System.Windows.Documents.TextPointer.GetTextInRun%2A> метод для реализации извлечения простого текста.  Метод возвращает объединение строк весь текст между двумя указанными <xref:System.Windows.Documents.TextPointer> экземпляров.  
  
 Хотя приведенный пример можно использовать для извлечения любого текста между двумя <xref:System.Windows.Documents.TextPointer> экземпляров, он предназначен исключительно для демонстрационных целей и не должен использоваться в рабочем коде.  Вместо этого следует использовать свойство <xref:System.Windows.Documents.TextRange.Text%2A?displayProperty=nameWithType>.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_gettextinrun)]
 [!code-vb[TextPointer_Snippets#_TextPointer_GetTextInRun](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_gettextinrun)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextInRun">
      <MemberSignature Language="C#" Value="public int GetTextInRun (System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int startIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextInRun(valuetype System.Windows.Documents.LogicalDirection direction, char[] textBuffer, int32 startIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextInRun (direction As LogicalDirection, textBuffer As Char(), startIndex As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextInRun(System::Windows::Documents::LogicalDirection direction, cli::array &lt;char&gt; ^ textBuffer, int startIndex, int count);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextInRun(System.Windows.Documents.LogicalDirection,System.Char[],System.Int32,System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
        <Parameter Name="textBuffer" Type="System.Char[]" />
        <Parameter Name="startIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, которое указывает логическое направление, в котором осуществляется поиск и копирование любого примыкающего текста.</param>
        <param name="textBuffer">Буфер, в который копируется текст.</param>
        <param name="startIndex">Индекс в <c>textBuffer</c>, с которого должна начинаться запись копируемого текста.</param>
        <param name="count">Максимальное число символов для копирования.</param>
        <summary>Копирование в указанном направлении заданного максимального числа символов из примыкающего текста в массив символов, предоставленный вызывающим.</summary>
        <returns>Число фактически скопированных символов в <paramref name="textBuffer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает только непрерывные текстовые выполнения.  Ничего не возвращается, если любой символ типа не <xref:System.Windows.Documents.TextPointerContext.Text> рядом с текущим <xref:System.Windows.Documents.TextPointer> в указанном направлении.  Аналогичным образом возвращается только до следующего нетекстового символа.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="startIndex" /> меньше 0 или больше <see cref="P:System.Array.Length" /> свойства <paramref name="textBuffer" />.  
  
 - или -  
  
 <paramref name="count" /> меньше 0 или больше оставшегося пространства в <paramref name="textBuffer" /> (<paramref name="textBuffer" />.<see cref="P:System.Array.Length" /> минус <paramref name="startIndex" />).</exception>
        <altmember cref="M:System.Windows.Documents.TextPointer.DeleteTextInRun(System.Int32)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetTextRunLength">
      <MemberSignature Language="C#" Value="public int GetTextRunLength (System.Windows.Documents.LogicalDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetTextRunLength(valuetype System.Windows.Documents.LogicalDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTextRunLength (direction As LogicalDirection) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetTextRunLength(System::Windows::Documents::LogicalDirection direction);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.GetTextRunLength(System.Windows.Documents.LogicalDirection)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Documents.LogicalDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Одно из значений <see cref="T:System.Windows.Documents.LogicalDirection" />, которое указывает логическое направление, в котором осуществляется подсчет числа символов.</param>
        <summary>Возвращение числа знаков Юникода между текущим <see cref="T:System.Windows.Documents.TextPointer" /> и следующим нетекстовым символом в указанном логическом направлении.</summary>
        <returns>Число знаков Юникода между текущим <see cref="T:System.Windows.Documents.TextPointer" /> и следующим нетекстовым символом.  Данное число может быть равно 0, если примыкающего текста нет.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Одно из следующих рассматривается как символ:  
  
-   Открывающий или закрывающий тег для <xref:System.Windows.Documents.TextElement> элемента.  
  
-   Объект <xref:System.Windows.UIElement> элемента, содержащегося в <xref:System.Windows.Documents.InlineUIContainer> или <xref:System.Windows.Documents.BlockUIContainer>.  Примечание такое <xref:System.Windows.UIElement> всегда считается ровно один символ; любое дополнительное содержимое или элементы, содержащиеся в <xref:System.Windows.UIElement> , не рассматриваются как символы.  
  
-   16-разрядное [!INCLUDE[TLA#tla_unicode](~/includes/tlasharptla-unicode-md.md)] символ внутри текстового <xref:System.Windows.Documents.Run> элемента.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasValidLayout">
      <MemberSignature Language="C#" Value="public bool HasValidLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValidLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.HasValidLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasValidLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasValidLayout { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.HasValidLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение значения, указывающего, имеется ли для текстового контейнера, связанного с текущим положением, допустимый (современным) макет.</summary>
        <value>
          <see langword="true" />, если макет является текущим и допустимым; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При необходимости операций, зависящих от допустимого макета (таких как <xref:System.Windows.Documents.TextPointer.GetLineStartPosition%2A> метод, <xref:System.Windows.Documents.TextPointer.GetCharacterRect%2A> метода, и <xref:System.Windows.Documents.TextPointer.IsAtLineStartPosition%2A> свойство) попытка автоматически создать заново допустимый макет перед продолжением операции.  Повторное создание макета может быть довольно дорогой операции.  Используйте это свойство для проверки допустимого макета перед выполнением операций, которые могут заново создать макет.  Дополнительные сведения см. в разделе [макета](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertLineBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertLineBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertLineBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertLineBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertLineBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertLineBreak();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вставка разрыва строки в текущем положении.</summary>
        <returns>
          <see cref="T:System.Windows.Documents.TextPointer" />, располагающийся сразу за элементом <see cref="T:System.Windows.Documents.LineBreak" />, вставленным данным методом.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InsertParagraphBreak">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.TextPointer InsertParagraphBreak ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Documents.TextPointer InsertParagraphBreak() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertParagraphBreak" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertParagraphBreak () As TextPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Documents::TextPointer ^ InsertParagraphBreak();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.TextPointer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вставка разрыва абзаца в текущем положении.</summary>
        <returns>
          <see cref="T:System.Windows.Documents.TextPointer" /> к началу (<see cref="P:System.Windows.Documents.TextElement.ContentStart" />) нового абзаца.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот метод вызывается в том случае, если текущее положение находится внутри существующего <xref:System.Windows.Documents.Paragraph> элемент, существующий абзац и любое содержимое, он содержит разбиваются на два абзаца в текущем положении.  Если этот метод вызывается, когда текущее положение находится за рамками существующего абзаца, вставляется новый, пустой абзац.  Если этот метод вызывается в позиции непригодным для разделения или вставки абзаца (например, в том случае, если текущее положение находится внутри <xref:System.Windows.Documents.Hyperlink> элемент), создается исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Данный метод вызывается для положения, которое невозможно разделить для размещения нового абзаца, как в области <see cref="T:System.Windows.Documents.Hyperlink" /> или <see cref="T:System.Windows.Documents.InlineUIContainer" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="InsertTextInRun">
      <MemberSignature Language="C#" Value="public void InsertTextInRun (string textData);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InsertTextInRun(string textData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.InsertTextInRun(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InsertTextInRun (textData As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InsertTextInRun(System::String ^ textData);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Documents.ITextPointer.InsertTextInRun(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textData" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="textData">Текст для вставки.</param>
        <summary>Вставка указанного текста в текст <see cref="T:System.Windows.Documents.Run" /> в текущее положение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Windows.Documents.TextPointer> не ограничивается <xref:System.Windows.Documents.Run> элемент, <xref:System.Windows.Documents.Run> вставляется вместе с `textData`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Текущее положение находится за пределами элемента <see cref="T:System.Windows.Documents.Run" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="textData" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsAtInsertionPosition">
      <MemberSignature Language="C#" Value="public bool IsAtInsertionPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtInsertionPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtInsertionPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtInsertionPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtInsertionPosition { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.IsAtInsertionPosition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение значения, указывающего, является ли положение вставки текущим положением.</summary>
        <value>
          <see langword="true" />, если текущее положение является положением вставки; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Положение вставки — положение, где может быть добавлено новое содержимое без нарушения любой семантических правил для соответствующего содержимого.  На практике положение вставки в любом месте — в содержимом положение курсора.  Примером является допустимым <xref:System.Windows.Documents.TextPointer> , не положение вставки — положение между двумя смежные <xref:System.Windows.Documents.Paragraph> теги (т. е между закрывающего тега элемента выше и открывающий тег следующего абзаца).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Documents.TextPointer.GetInsertionPosition(System.Windows.Documents.LogicalDirection)" />
        <altmember cref="M:System.Windows.Documents.TextPointer.GetNextInsertionPosition(System.Windows.Documents.LogicalDirection)" />
      </Docs>
    </Member>
    <Member MemberName="IsAtLineStartPosition">
      <MemberSignature Language="C#" Value="public bool IsAtLineStartPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAtLineStartPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAtLineStartPosition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAtLineStartPosition { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение значения, указывающего, находится ли текущее положение в начале строки.</summary>
        <value>
          <see langword="true" />, если текущее положение находится в начале строки; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Windows.Documents.TextPointer> указывает неоднозначную позицию, например, между двумя строками строки в направлении, указанным <xref:System.Windows.Documents.TextPointer.LogicalDirection%2A> выбрано свойство как относительный начальную строку.  
  
 Операция, выполняемая это свойство зависит от допустимого макета.  При необходимости этот метод пытается автоматически восстановить допустимый макет перед продолжением операции.  Повторное создание макета может быть довольно дорогой операции.  Используйте <xref:System.Windows.Documents.TextPointer.HasValidLayout%2A> свойство для проверки допустимого макета перед выполнением операций, которые могут заново создать макет.  Дополнительные сведения см. в разделе [макета](~/docs/framework/wpf/advanced/layout.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.IsAtLineStartPosition" />
      </Docs>
    </Member>
    <Member MemberName="IsInSameDocument">
      <MemberSignature Language="C#" Value="public bool IsInSameDocument (System.Windows.Documents.TextPointer textPosition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsInSameDocument(class System.Windows.Documents.TextPointer textPosition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.IsInSameDocument(System.Windows.Documents.TextPointer)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsInSameDocument (textPosition As TextPointer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsInSameDocument(System::Windows::Documents::TextPointer ^ textPosition);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textPosition" Type="System.Windows.Documents.TextPointer" />
      </Parameters>
      <Docs>
        <param name="textPosition">
          <see cref="T:System.Windows.Documents.TextPointer" />, который указывает положение для сравнения с текущим положением.</param>
        <summary>Определение, находится ли указанное положение в том же текстовом контейнере, что и текущее положение.</summary>
        <returns>
          <see langword="true" />, если <paramref name="textPosition" /> указывает положение, которое располагается в том же текстовом контейнере, что и текущее положение; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Большинство операций, которые включают несколько <xref:System.Windows.Documents.TextPointer> экземпляров допустимы только в случае, если данные экземпляры указывают положения, которые находятся в одной и той же области действия контейнера текста.  Например <xref:System.Windows.Documents.TextPointer.CompareTo%2A> и <xref:System.Windows.Documents.TextPointer.GetOffsetToPosition%2A> методов не может использоваться с <xref:System.Windows.Documents.TextPointer> позицию за пределами текстового контейнера, связанного с текущей позиции.  Используйте этот метод, чтобы убедиться, что указанный <xref:System.Windows.Documents.TextPointer> совместима с текущей позиции для таких операций.  
  
   
  
## Examples  
 В следующем примере показано использование этого метода.  В этом примере <xref:System.Windows.Documents.TextPointer.IsInSameDocument%2A> метод для проверки, действительно ли заданное <xref:System.Windows.Documents.TextPointer> располагается между двумя для других из указанного <xref:System.Windows.Documents.TextPointer> экземпляров в ситуации, когда нет никакой гарантии, всех трех позиций входит в том же текстовом контейнере.  
  
 [!code-csharp[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/csharp/VS_Snippets_Wpf/TextPointer_Snippets/CSharp/Window1.xaml.cs#_textpointer_isinsamedocument)]
 [!code-vb[TextPointer_Snippets#_TextPointer_IsInSameDocument](~/samples/snippets/visualbasic/VS_Snippets_Wpf/TextPointer_Snippets/visualbasic/window1.xaml.vb#_textpointer_isinsamedocument)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="textPosition" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="LogicalDirection">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.LogicalDirection LogicalDirection { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Documents.LogicalDirection LogicalDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.LogicalDirection" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogicalDirection As LogicalDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::LogicalDirection LogicalDirection { System::Windows::Documents::LogicalDirection get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Documents.ITextPointer.LogicalDirection</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.LogicalDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение логического направления, связанного с текущим положением, которое используется для снятия неоднозначности в отношении содержимого, связанного с текущим положением.</summary>
        <value>Значение <see cref="T:System.Windows.Documents.LogicalDirection" />, которое связано с текущим положением.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В качестве примера использования этого свойства <xref:System.Windows.Documents.LogicalDirection> из <xref:System.Windows.Documents.TextPointer> возвращается путем нажатия метод дает попадания в точку между двумя символов текста. Логическое направление указывает, какой из двух символов был нажат — влево или вправо.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Paragraph">
      <MemberSignature Language="C#" Value="public System.Windows.Documents.Paragraph Paragraph { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Documents.Paragraph Paragraph" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Paragraph" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Paragraph As Paragraph" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Documents::Paragraph ^ Paragraph { System::Windows::Documents::Paragraph ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Documents.Paragraph</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение абзаца, в области которого находится текущее положение, если таковой имеется.</summary>
        <value>
          <see cref="T:System.Windows.Documents.Paragraph" /> , Области текущей позиции или <see langword="null" /> Если такие абзац не существует.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Parent" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Documents.TextPointer.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение логического родительского элемента, задающего область для текущего положения.</summary>
        <value>Логический родительский элемент, задающий область для текущего положения.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Documents.TextPointer.Paragraph" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Documents.TextPointer.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Данный тип или член поддерживает инфраструктуру [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] и не предназначен для непосредственного использования из кода.</summary>
        <returns>Строка, представляющая объект.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>