<Type Name="Form" FullName="System.Windows.Forms.Form">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1f3fc084a02f774d87fefe2646b5cb5ad6cc9733" />
    <Meta Name="ms.sourcegitcommit" Value="058bfa0b75b777d3171411d35da8f11617fc06b0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="05/04/2018" />
    <Meta Name="ms.locfileid" Value="33659946" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Form : System.Windows.Forms.ContainerControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Form extends System.Windows.Forms.ContainerControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.Form" />
  <TypeSignature Language="VB.NET" Value="Public Class Form&#xA;Inherits ContainerControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class Form : System::Windows::Forms::ContainerControl" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.ContainerControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Load")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.FormDocumentDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", typeof(System.ComponentModel.Design.IRootDesigner))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignerCategory("Form")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.InitializationEvent("Load")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItemFilter("System.Windows.Forms.Control.TopLevel")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет окно или диалоговое окно, которое составляет пользовательский интерфейс приложения.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Windows.Forms.Form> является представлением любого окна, отображаемого в приложении. <xref:System.Windows.Forms.Form> Класс может использоваться для создания стандартных, средства, не имеет границ и windows с плавающей запятой. Можно также использовать <xref:System.Windows.Forms.Form> класса для создания модальных окон, например диалоговое окно. Специальный вид формы, для формы многодокументного интерфейса (MDI) может содержать другие формы, называемые дочерних MDI-форм. MDI-формы создается путем задания <xref:System.Windows.Forms.Form.IsMdiContainer%2A> свойства `true`. Дочерние MDI-формы создаются с помощью установки <xref:System.Windows.Forms.Form.MdiParent%2A> свойства родительской MDI-формы, который будет содержать дочерней формы.  
  
 С помощью свойств, доступных в <xref:System.Windows.Forms.Form> класса, можно определить внешний вид, размер, цвет и окно компоненты управления окна или диалогового окна, вы создаете. <xref:System.Windows.Forms.Control.Text%2A> Свойство позволяет указать заголовок окна в строке заголовка. <xref:System.Windows.Forms.Form.Size%2A> И <xref:System.Windows.Forms.Form.DesktopLocation%2A> свойства позволяют определить размер и положение окна при его отображении. Можно использовать <xref:System.Windows.Forms.Control.ForeColor%2A> свойство цвета, чтобы изменить цвет переднего плана по умолчанию для всех элементов управления, помещенных в форму. <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, И <xref:System.Windows.Forms.Form.MaximizeBox%2A> свойства позволяют управлять ли формы можно сворачивать, разворачивать и размеров во время выполнения.  
  
 Помимо свойств методов класса можно использовать для управления формой. Например, можно использовать <xref:System.Windows.Forms.Form.ShowDialog%2A> метод для отображения формы как модального диалогового окна. Можно использовать <xref:System.Windows.Forms.Form.SetDesktopLocation%2A> метод для размещения формы на рабочем столе.  
  
 События <xref:System.Windows.Forms.Form> позволяют реагировать на действия, выполняемые в форме. Можно использовать <xref:System.Windows.Forms.Form.Activated> событий для выполнения операций, таких как обновление данных, отображаемых в элементах управления формы при активации данной формы.  
  
 Можно использовать форму в качестве начального класса в приложении, поместив метод с именем `Main` в классе. В `Main` метода добавьте код для создания и отображения формы. Также необходимо будет добавить `STAThread` атрибут `Main` метод для формы для запуска. Когда закрывается начальная форма, приложение также закрывается.  
  
 Если задать <xref:System.Windows.Forms.Control.Enabled%2A> свойства `false` перед <xref:System.Windows.Forms.Form> является видимым (например, установка <xref:System.Windows.Forms.Control.Enabled%2A> значение false в [!INCLUDE[TLA#tla_visualstu](~/includes/tlasharptla-visualstu-md.md)] конструктора), свернуть, максимизировать, закройте и остаются включенными системные кнопки. Если задать <xref:System.Windows.Forms.Control.Enabled%2A> для `false` после <xref:System.Windows.Forms.Form> является видимым (например, при возникновении события нагрузки), эти кнопки недоступны.  
  
   
  
## Examples  
 В следующем примере кода создается новый экземпляр <xref:System.Windows.Forms.Form> и вызывает <xref:System.Windows.Forms.Form.ShowDialog%2A> метод для отображения формы в виде диалогового окна. В примере устанавливается <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, и <xref:System.Windows.Forms.Form.StartPosition%2A> свойства, чтобы изменить внешний вид и функциональные возможности формы диалогового окна. В примере также используется <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> методом формы <xref:System.Windows.Forms.Control.Controls%2A> коллекции для добавления двух <xref:System.Windows.Forms.Button> элементов управления. В этом примере <xref:System.Windows.Forms.Form.HelpButton%2A> свойство для отображения кнопки справки в строке заголовка диалогового окна.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Form ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Form();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Forms.Form" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Размер формы по умолчанию — 300 пикселей в высоту и 300 пикселей в ширину.  
  
   
  
## Examples  
 В следующем примере кода создается новый экземпляр <xref:System.Windows.Forms.Form> и вызывает <xref:System.Windows.Forms.Form.ShowDialog%2A> метод для отображения формы в виде диалогового окна. В примере устанавливается <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, и <xref:System.Windows.Forms.Form.StartPosition%2A> свойства, чтобы изменить внешний вид и функциональные возможности формы диалогового окна. В данном примере также используется <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> методом формы <xref:System.Windows.Forms.Control.Controls%2A> коллекции для добавления двух <xref:System.Windows.Forms.Button> элементов управления. В этом примере <xref:System.Windows.Forms.Form.HelpButton%2A> свойство для отображения кнопки справки в строке заголовка диалогового окна.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AcceptButton">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IButtonControl AcceptButton { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.IButtonControl AcceptButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AcceptButton" />
      <MemberSignature Language="VB.NET" Value="Public Property AcceptButton As IButtonControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::IButtonControl ^ AcceptButton { System::Windows::Forms::IButtonControl ^ get(); void set(System::Windows::Forms::IButtonControl ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IButtonControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает кнопку в форме, которая срабатывает при нажатии клавиши ВВОД.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.IButtonControl" />, представляющий кнопку, используемую в качестве кнопки "Принять" для формы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство позволяет указать действие по умолчанию в случае, когда пользователь нажимает клавишу ВВОД в приложении. Кнопка, назначенный этому свойству должно быть <xref:System.Windows.Forms.IButtonControl> , находится в текущей форме или расположен в контейнере на текущей форме.  
  
 Это свойство используется для быстрого перехода к простой форме, позволяя им просто нажмите клавишу ВВОД для завершения работы вместо ручного нажатия кнопки "Принять" мышью данных.  
  
 Кнопки "Принять" не могут быть включены, если текущего выбранного элемента управления на форме перехватывает клавишу ВВОД и обрабатывает его. Например элемент управления многострочного текстового поля позволяет клавиши ВВОД нажатия, при этом для вставки символ новой строки в элементе управления.  
  
   
  
## Examples  
 В следующем примере кода создается новый экземпляр <xref:System.Windows.Forms.Form> и вызывает <xref:System.Windows.Forms.Form.ShowDialog%2A> метод для отображения формы в виде диалогового окна. В примере устанавливается <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, и <xref:System.Windows.Forms.Form.StartPosition%2A> свойства, чтобы изменить внешний вид и функциональные возможности формы диалогового окна. В примере также используется <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> методом формы <xref:System.Windows.Forms.Control.Controls%2A> коллекции для добавления двух <xref:System.Windows.Forms.Button> элементов управления. В этом примере <xref:System.Windows.Forms.Form.HelpButton%2A> свойство для отображения кнопки справки в строке заголовка диалогового окна.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.CancelButton" />
        <altmember cref="T:System.Windows.Forms.IButtonControl" />
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public void Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Activate" />
      <MemberSignature Language="VB.NET" Value="Public Sub Activate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Activate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Активирует форму и перемещает на нее фокус.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Активация формы переводит ее в на передний план, если это приложение active или мигает заголовок окна, если это не активное приложение. Формы должны быть видимыми для этого метода не влияет на. Чтобы определить активную форму в приложении, используйте <xref:System.Windows.Forms.Form.ActiveForm%2A> свойство или <xref:System.Windows.Forms.Form.ActiveMdiChild%2A> свойства, если формы находятся в приложении многодокументного интерфейса (MDI).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.Form.SetDesktopLocation%2A>, <xref:System.Windows.Forms.Form.Load> и <xref:System.Windows.Forms.Form.Activate%2A> члены. Чтобы запустить пример, вставьте следующий код в форму с именем `Form1` содержит кнопку с именем `Button1` и два `Label` элементов управления `Label1` и `Label2`.  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения фокуса. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
        <altmember cref="P:System.Windows.Forms.Form.ActiveForm" />
        <altmember cref="P:System.Windows.Forms.Form.ActiveMdiChild" />
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при активизации формы, определенной в коде или заданной пользователем.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Если приложение активно и имеет несколько форм, активной формы — это форма с фокусом ввода. Форма, которая не видна, не может быть активной формы. Чтобы активировать форму видимой проще щелкните его или соответствующие сочетания клавиш.  
  
 Чтобы активировать форму во время выполнения с помощью кода, вызовите <xref:System.Windows.Forms.Form.Activate%2A> метод. Это событие можно использовать для выполнения задач, таких как обновление содержимого формы на основе изменений, внесенных в данные формы при формы не был активирован.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.Form.SetDesktopLocation%2A>, <xref:System.Windows.Forms.Form.Closed>, <xref:System.Windows.Forms.Form.Load>, <xref:System.Windows.Forms.Form.Activated>, и <xref:System.Windows.Forms.Form.Activate%2A> члены. Чтобы запустить пример, вставьте следующий код в форму с именем Form1 содержащий <xref:System.Windows.Forms.Button> вызывается `Button1` и два <xref:System.Windows.Forms.Label> элементов управления `Label1` и `Label2`.  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ActivateMdiChild">
      <MemberSignature Language="C#" Value="protected void ActivateMdiChild (System.Windows.Forms.Form form);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ActivateMdiChild(class System.Windows.Forms.Form form) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ActivateMdiChild(System.Windows.Forms.Form)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ActivateMdiChild(System::Windows::Forms::Form ^ form);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="form" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="form">Активируемая дочерняя форма.</param>
        <summary>Активирует дочерний MDI-объект формы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `form` параметр уже активной дочерней формы MDI, то <xref:System.Windows.Forms.Form.ActivateMdiChild%2A> метод просто возвращает. Если `form` не `null`, то он задается активной дочерней формы MDI.  
  
 Ли `form` параметр `null` или нет, <xref:System.Windows.Forms.Form.ActivateMdiChild%2A> вызывает <xref:System.Windows.Forms.Form.MdiChildActivate> событий.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.ActiveMdiChild" />
        <altmember cref="P:System.Windows.Forms.Form.ActiveForm" />
        <altmember cref="E:System.Windows.Forms.Form.MdiChildActivate" />
      </Docs>
    </Member>
    <Member MemberName="ActiveForm">
      <MemberSignature Language="C#" Value="public static System.Windows.Forms.Form ActiveForm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Windows.Forms.Form ActiveForm" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ActiveForm" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ActiveForm As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Windows::Forms::Form ^ ActiveForm { System::Windows::Forms::Form ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает текущую активную форму для этого приложения.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.Form" />, который представляет текущую активную форму, или <see langword="null" />, если активные формы отсутствуют.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для получения ссылки на текущую активную форму для выполнения действий на формы или ее элементов управления.  
  
 Если приложение является приложением многодокументного интерфейса (MDI), используйте <xref:System.Windows.Forms.Form.ActiveMdiChild%2A> свойство для получения текущей активной дочерней формы MDI.  
  
   
  
## Examples  
 В следующем примере кода возвращает активную форму и отключает все элементы управления в форме. В этом примере <xref:System.Windows.Forms.Control.Controls%2A> коллекции для итерации по всем элементам управления в форме и отключить элементы управления формы.  
  
 [!code-cpp[Classic Form.ActiveForm Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ActiveForm Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ActiveForm Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ActiveForm Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ActiveForm Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ActiveForm Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для запроса формы. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
        <altmember cref="P:System.Windows.Forms.Form.ActiveMdiChild" />
      </Docs>
    </Member>
    <Member MemberName="ActiveMdiChild">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form ActiveMdiChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form ActiveMdiChild" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ActiveMdiChild" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActiveMdiChild As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Form ^ ActiveMdiChild { System::Windows::Forms::Form ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает дочернее окно текущего активного интерфейса MDI.</summary>
        <value>Возвращает объект <see cref="T:System.Windows.Forms.Form" />, который представляет дочернее окно текущего активного интерфейса MDI, или <see langword="null" />, если в настоящий момент дочерние окна отсутствуют.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для выявления любых дочерних форм MDI открытых в приложении MDI. Этот метод также можно использовать для выполнения операций над дочернего окна MDI из родительской формы MDI-приложения или из другой формы, которое отображается в приложении.  
  
 Если текущую активную форму не является дочерней MDI-формы, можно использовать <xref:System.Windows.Forms.Form.ActiveForm%2A> , чтобы получить ссылку на него.  
  
   
  
## Examples  
 В следующем примере кода получает ссылку на активной дочерней MDI-формы и обрабатывает в цикле все <xref:System.Windows.Forms.TextBox> элементов управления в форме Сброс их <xref:System.Windows.Forms.TextBoxBase.Text%2A> свойства. Этот пример требует создания родительской формы MDI и что этот метод вызов из родительской формы MDI.  
  
 [!code-cpp[Classic Form.ActiveMdiChild Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ActiveMdiChild Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ActiveMdiChild Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ActiveMdiChild Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ActiveMdiChild Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ActiveMdiChild Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.ActiveForm" />
      </Docs>
    </Member>
    <Member MemberName="AddOwnedForm">
      <MemberSignature Language="C#" Value="public void AddOwnedForm (System.Windows.Forms.Form ownedForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddOwnedForm(class System.Windows.Forms.Form ownedForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.AddOwnedForm(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddOwnedForm (ownedForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddOwnedForm(System::Windows::Forms::Form ^ ownedForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownedForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="ownedForm">Объект <see cref="T:System.Windows.Forms.Form" />, которым будет владеть эта форма.</param>
        <summary>Добавляет в эту форму собственную форму.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Форма, назначенного форме владельца сохраняется до <xref:System.Windows.Forms.Form.RemoveOwnedForm%2A> вызывается метод. Вы также можете формы, принадлежащей другой, задав <xref:System.Windows.Forms.Form.Owner%2A> свойство со ссылкой на его форму-владельца.  
  
 Когда владеет другой вид формы, закрыт или скрытым с формой-владельцем. Например, рассмотрим форму с именем `Form2` , владельцем которой является форму с именем `Form1`. Если `Form1` закрывается или сворачивается, `Form2` также закрывается или скрыты. Собственные формы также никогда не отображаются сзади формы-владельца. Можно использовать собственные формы для windows, таких как найти и заменить окон, которые не должны отображаться для владельца формы при выборе формы-владельца.  
  
> [!NOTE]
>  Если форма является родительской формой многодокументного интерфейса (MDI), это свойство возвращает все отображаемые формы, за исключением любых дочерних форм MDI, которые в данный момент открытых. Чтобы получить дочерние формы MDI, открытых в родительской формы MDI, используйте <xref:System.Windows.Forms.Form.MdiChildren%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.Form.AddOwnedForm%2A> метод для отображения формы как собственную форму из другой формы. После отображения собственную форму, можно свести к минимуму его форму-владельца и минимизировать собственную форму с ним. В примере предполагается, что код в примере вызывается из другого события или метода формы.  
  
 [!code-cpp[Form.AddOwnedForm#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.AddOwnedForm/CPP/form1.cpp#1)]
 [!code-csharp[Form.AddOwnedForm#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AddOwnedForm/CS/form1.cs#1)]
 [!code-vb[Form.AddOwnedForm#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AddOwnedForm/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.OwnedForms" />
        <altmember cref="M:System.Windows.Forms.Form.RemoveOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="P:System.Windows.Forms.Form.Owner" />
      </Docs>
    </Member>
    <Member MemberName="AdjustFormScrollbars">
      <MemberSignature Language="C#" Value="protected override void AdjustFormScrollbars (bool displayScrollbars);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void AdjustFormScrollbars(bool displayScrollbars) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.AdjustFormScrollbars(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub AdjustFormScrollbars (displayScrollbars As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void AdjustFormScrollbars(bool displayScrollbars);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="displayScrollbars" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="displayScrollbars">
          Значение <see langword="true" /> для отображения полос прокрутки; в противном случае — значение <see langword="false" />. </param>
        <summary>Настраивает полосы прокрутки в контейнере на основе текущей позиции элемента управления и выбранного в данный момент элемента управления.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowTransparency">
      <MemberSignature Language="C#" Value="public bool AllowTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AllowTransparency" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowTransparency As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowTransparency { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, можно ли изменить степень непрозрачности формы.</summary>
        <value>
          Значение <see langword="true" />, если уровень непрозрачности формы можно изменить; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство автоматически присваивается `true` Если `Opacity` изменяется. При прозрачности формы задается с помощью `Opacity` свойство, форма будет многоуровневое расположение объектов в форме. Если задать <xref:System.Windows.Forms.Form.AllowTransparency%2A> свойства `false` формы не будет в многоуровневый режим, который улучшит производительность отображения формы.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAutoScaling">
      <MemberSignature Language="C#" Value="protected void ApplyAutoScaling ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ApplyAutoScaling() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ApplyAutoScaling" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ApplyAutoScaling ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ApplyAutoScaling();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated. Use the ApplyAutoScaling method instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Изменяет размеры формы в соответствии с текущим значением свойства <see cref="P:System.Windows.Forms.Form.AutoScaleBaseSize" /> и размером текущего шрифта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод определяет размер формы, используя значение <xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A> свойство и <xref:System.Windows.Forms.Form.Size%2A> значения, возвращенного <xref:System.Windows.Forms.Form.GetAutoScaleSize%2A> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoScale">
      <MemberSignature Language="C#" Value="public bool AutoScale { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoScale" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoScale" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoScale As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoScale { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This property has been deprecated. Use the AutoScaleMode property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, подгоняется ли размер формы под высоту шрифта, используемого в форме, и масштабируются ли ее элементы управления.</summary>
        <value>
          Значение <see langword="true" />, если форма и ее элементы управления масштабируется автоматически на основе текущего шрифта, назначенного форме; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Form.AutoScale%2A> Устарела и была сохранена для обеспечения обратной совместимости. Альтернативой устаревшим функциям служит метод <xref:System.Windows.Forms.ContainerControl.AutoScaleMode%2A?displayProperty=nameWithType>. Дополнительные сведения об автоматическом масштабировании см. в разделе [автоматическое масштабирование в Windows Forms](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md).  
  
 Это свойство позволяет разрешить формы и ее элементов управления, чтобы автоматически настроить в соответствии с изменениями в шрифте. Это может быть полезно в приложениях, где шрифт может увеличиваться или уменьшаться в зависимости от языка, указанного для использования операционной системой Windows.  
  
 Для получения размера, форма будет автоматически масштабироваться, используется <xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A> свойство. Если вы хотите определить размер формы будет автоматически масштабироваться в зависимости от определенного шрифта, используется <xref:System.Windows.Forms.Form.GetAutoScaleSize%2A> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoScaleBaseSize">
      <MemberSignature Language="C#" Value="public virtual System.Drawing.Size AutoScaleBaseSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size AutoScaleBaseSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoScaleBaseSize" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property AutoScaleBaseSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size AutoScaleBaseSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает базовый размер, используемый для автоматического масштабирования формы.</summary>
        <value>Объект <see cref="T:System.Drawing.Size" />, который представляет основной размер, используемый этой формой для автоматического масштабирования.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Этот член был сохранен для обратной совместимости. Дополнительные сведения об автоматическом масштабировании см. в разделе [автоматическое масштабирование в Windows Forms](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md).  
  
 Значение <xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A> свойство используется во время отображения формы вычисляет коэффициент масштабирования для формы. Размер базы данных автоматического масштабирования используется форма за основу для сравнения с размером шрифта системы чтобы определить, какой объем масштабирования формы при использовании автоматического масштабирования. Если вы хотите определить размер формы будет автоматически масштабироваться в зависимости от определенного шрифта, используется <xref:System.Windows.Forms.Form.GetAutoScaleSize%2A> метод.  
  
> [!NOTE]
>  Значение этого свойства используется при создании формы. Если свойство задано, его нельзя изменить.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.AutoScale" />
        <altmember cref="M:System.Windows.Forms.Form.GetAutoScaleSize(System.Drawing.Font)" />
      </Docs>
    </Member>
    <Member MemberName="AutoScroll">
      <MemberSignature Language="C#" Value="public override bool AutoScroll { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoScroll" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoScroll" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoScroll As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoScroll { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее, разрешена ли в форме автоматическая прокрутка.</summary>
        <value>
          <see langword="true" /> для включения автопрокрутки на форме; в противном случае — <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если это свойство имеет значение `true`, все элементы управления, находящихся за пределами клиентской области формы в форме отображаются полосы прокрутки. Кроме того Если включена автопрокрутка, клиентской области формы автоматически прокручивается для отображения элемента управления с фокусом ввода.  
  
 Это свойство можно использовать, чтобы запретить пользователям возможности для просмотра элементов управления при установке с низким разрешением экрана.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.Form.AutoScroll%2A> свойство для отображения элементов управления, размер клиентской области формы. В примере создается новая форма и добавляет <xref:System.Windows.Forms.Button> на форму элемент управления. <xref:System.Windows.Forms.Button> Элемент управления является больше места, чем клиентской области новую форму. <xref:System.Windows.Forms.Form.AutoScroll%2A> Задано значение true для отображения полосы прокрутки на форме, чтобы предоставить возможность пользователю выполнять прокрутку к элементу управления. В этом примере требуется, что метод, определенный в этом примере вызывается из другой формы в обработчик событий или другой метод.  
  
 [!code-cpp[Form.AutoScroll#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.AutoScroll/CPP/form1.cpp#1)]
 [!code-csharp[Form.AutoScroll#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AutoScroll/CS/form1.cs#1)]
 [!code-vb[Form.AutoScroll#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AutoScroll/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public override bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Изменяет размеры формы в соответствии со значением <see cref="P:System.Windows.Forms.Form.AutoSizeMode" />.</summary>
        <value>
          Значение <see langword="true" />, если размеры формы будут автоматически изменены; <see langword="false" />, если их необходимо изменять вручную.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Windows.Forms.Form.AutoSize%2A> для принудительного форму для изменения размера в соответствии с содержимым.  
  
 Формы не изменяется в конструкторе форм Visual Studio, независимо от значения <xref:System.Windows.Forms.Form.AutoSize%2A> и <xref:System.Windows.Forms.Form.AutoSizeMode%2A> свойства. Форма правильно изменяет собственные размеры во время выполнения в соответствии со значениями этих свойств. В отличие от этого, настраиваемый <xref:System.Windows.Forms.UserControl> автоматически изменять свои размеры во время разработки и во время выполнения.  
  
 При использовании <xref:System.Windows.Forms.Form.AutoSize%2A>, <xref:System.Windows.Forms.Control.MinimumSize%2A> и <xref:System.Windows.Forms.Control.MaximumSize%2A> свойства учитываются, но текущее значение <xref:System.Windows.Forms.Control.Size%2A> свойство игнорируется. С помощью <xref:System.Windows.Forms.Form.AutoSize%2A> и <xref:System.Windows.Forms.Form.AutoSizeMode%2A> также отображает <xref:System.Windows.Forms.Form.AutoScroll%2A> свойство излишним, поскольку нет возможности для сжатия формы для скрытия содержащиеся в нем элементы из представления.  
  
 В разделе <xref:System.Windows.Forms.AutoSizeMode> перечисления сведения о форме поведение при <xref:System.Windows.Forms.Form.AutoSize%2A> — `true`.  
  
   
  
## Examples  
 В следующем примере кода показана форма, созданный с помощью кода, который автоматически изменяет размеры в соответствии с содержимым. При выполнении, отображаются в форме <xref:System.Windows.Forms.Label>, <xref:System.Windows.Forms.TextBox> для URL-адреса и <xref:System.Windows.Forms.Button> для отображения этого URL-адреса в веб-браузере пользователя по умолчанию. В примере кода используется <xref:System.Windows.Forms.FlowLayoutPanel> для размещения содержащегося управляет один за другим. Кроме того, задается <xref:System.Windows.Forms.Control.AutoSize%2A> и <xref:System.Windows.Forms.AutoSizeMode> для увеличения и уменьшения размера по содержимому его форме.  
  
 [!code-csharp[Form.AutoSize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AutoSize/CS/Form1.cs#1)]
 [!code-vb[Form.AutoSize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AutoSize/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.AutoSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoSizeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении свойства <see cref="P:System.Windows.Forms.Form.AutoSize" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.AutoSizeMode AutoSizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AutoSizeMode AutoSizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoSizeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoSizeMode As AutoSizeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::AutoSizeMode AutoSizeMode { System::Windows::Forms::AutoSizeMode get(); void set(System::Windows::Forms::AutoSizeMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoSizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает режим, с помощью которого форма может автоматически изменять свои размеры.</summary>
        <value>Перечислимое значение <see cref="T:System.Windows.Forms.AutoSizeMode" />. Значение по умолчанию: <see cref="F:System.Windows.Forms.AutoSizeMode.GrowOnly" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Параметр <xref:System.Windows.Forms.Form.AutoSizeMode%2A> форму, располагаться снова вызывает новое значение свойства.  
  
 Формы не изменяется в конструкторе форм Visual Studio, независимо от значения <xref:System.Windows.Forms.Form.AutoSize%2A> и <xref:System.Windows.Forms.Form.AutoSizeMode%2A> свойства. Форма правильно изменяет собственные размеры во время выполнения в соответствии со значениями этих свойств. В отличие от этого, настраиваемый <xref:System.Windows.Forms.UserControl> автоматически изменять свои размеры во время разработки и во время выполнения.  
  
   
  
## Examples  
 В следующем примере кода показана форма, созданный с помощью кода, который автоматически изменяет размеры в соответствии с содержимым. При запуске формы отображается <xref:System.Windows.Forms.Label>, <xref:System.Windows.Forms.TextBox> для URL-адреса и <xref:System.Windows.Forms.Button> для отображения этого URL-адреса в веб-браузере пользователя по умолчанию. В примере кода используется <xref:System.Windows.Forms.FlowLayoutPanel> для размещения содержащегося управляет один за другим. Кроме того, задается <xref:System.Windows.Forms.Control.AutoSize%2A> и <xref:System.Windows.Forms.AutoSizeMode> для увеличения и уменьшения размера по содержимому его форме.  
  
 [!code-csharp[Form.AutoSize#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.AutoSize/CS/Form1.cs#1)]
 [!code-vb[Form.AutoSize#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.AutoSize/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Значение не является допустимым значением <see cref="T:System.Windows.Forms.AutoSizeMode" />.</exception>
        <altmember cref="T:System.Windows.Forms.AutoSizeMode" />
        <altmember cref="P:System.Windows.Forms.Form.AutoSize" />
        <altmember cref="M:System.Windows.Forms.Form.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="AutoValidate">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.AutoValidate AutoValidate { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.AutoValidate AutoValidate" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.AutoValidate" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoValidate As AutoValidate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::AutoValidate AutoValidate { System::Windows::Forms::AutoValidate get(); void set(System::Windows::Forms::AutoValidate value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.AutoValidate</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, будут ли элементы управления в этом контейнере автоматически проверены при изменении фокуса.</summary>
        <value>Перечисленное значение <see cref="T:System.Windows.Forms.AutoValidate" />, которое указывает, проверяются ли вложенные элементы управления неявно при изменении фокуса. Значение по умолчанию — наследовать (Inherit).</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.ContainerControl.AutoValidate" />
      </Docs>
    </Member>
    <Member MemberName="AutoValidateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler AutoValidateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler AutoValidateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.AutoValidateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AutoValidateChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ AutoValidateChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении свойства <see cref="P:System.Windows.Forms.Form.AutoValidate" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает цвет фона для элемента управления.</summary>
        <value>Объект <see cref="T:System.Drawing.Color" />, представляющий цвет фона элемента управления. Значением по умолчанию является значение свойства <see cref="P:System.Windows.Forms.Control.DefaultBackColor" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.BackColor" />
      </Docs>
    </Member>
    <Member MemberName="CancelButton">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.IButtonControl CancelButton { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.IButtonControl CancelButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.CancelButton" />
      <MemberSignature Language="VB.NET" Value="Public Property CancelButton As IButtonControl" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::IButtonControl ^ CancelButton { System::Windows::Forms::IButtonControl ^ get(); void set(System::Windows::Forms::IButtonControl ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.IButtonControl</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает кнопку, которая срабатывает при нажатии клавиши ESC.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.IButtonControl" />, который представляет кнопку "Отмена" для формы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Кнопка "Отмена" для формы — это кнопка, которую щелкнули всякий раз, когда пользователь нажимает клавишу ESC. Кнопка, назначенный этому свойству должно быть <xref:System.Windows.Forms.IButtonControl> , находится в текущей форме или расположен в контейнере на текущей форме.  
  
 Это свойство позволяет указать действие по умолчанию должно происходить при нажатии клавиши ESC в приложении. Это свойство можно использовать, чтобы разрешить пользователю быстро перемещаться простая форма, позволяя им просто нажмите клавишу ESC, чтобы закрыть окно без фиксации изменений, а не вручную, нажав кнопку "Отмена" мышью.  
  
 <xref:System.Windows.Forms.Form.CancelButton%2A> могут не работать, если другой элемент управления на форме перехватывает клавишу ESC. Например, если у вас есть <xref:System.Windows.Forms.ComboBox> закройте открытые формы, ESC <xref:System.Windows.Forms.ComboBox> вместо закрытия формы.  
  
 <xref:System.Windows.Forms.IButtonControl> Объект, присвоенный <xref:System.Windows.Forms.Form.CancelButton%2A> должен быть видим в форме, в противном случае нажатие клавиши ESC ключ не будет действовать.  
  
   
  
## Examples  
 В следующем примере кода создается новый экземпляр <xref:System.Windows.Forms.Form> и вызывает <xref:System.Windows.Forms.Form.ShowDialog%2A> метод для отображения формы в виде диалогового окна. В примере устанавливается <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, и <xref:System.Windows.Forms.Form.StartPosition%2A> свойства, чтобы изменить внешний вид и функциональные возможности формы диалогового окна. В примере также используется <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> методом формы <xref:System.Windows.Forms.Control.Controls%2A> коллекции для добавления двух <xref:System.Windows.Forms.Button> элементов управления. В этом примере <xref:System.Windows.Forms.Form.HelpButton%2A> свойство для отображения кнопки справки в строке заголовка диалогового окна.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.AcceptButton" />
        <altmember cref="T:System.Windows.Forms.IButtonControl" />
      </Docs>
    </Member>
    <Member MemberName="CenterToParent">
      <MemberSignature Language="C#" Value="protected void CenterToParent ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CenterToParent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CenterToParent" />
      <MemberSignature Language="VB.NET" Value="Protected Sub CenterToParent ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void CenterToParent();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Выравнивает позицию формы по центру в границах родительской формы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не вызывайте <xref:System.Windows.Forms.Form.CenterToParent%2A> метод непосредственно из программного кода. Вместо этого задайте <xref:System.Windows.Forms.Form.StartPosition%2A> свойства <xref:System.Windows.Forms.FormStartPosition.CenterParent>.  
  
 Если формы или диалогового окна верхнего уровня, затем <xref:System.Windows.Forms.Form.CenterToParent%2A> выравнивает форму по отношению к экрана или рабочего стола.  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Forms.FormStartPosition.CenterParent" />
        <altmember cref="M:System.Windows.Forms.Form.CenterToScreen" />
      </Docs>
    </Member>
    <Member MemberName="CenterToScreen">
      <MemberSignature Language="C#" Value="protected void CenterToScreen ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CenterToScreen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CenterToScreen" />
      <MemberSignature Language="VB.NET" Value="Protected Sub CenterToScreen ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void CenterToScreen();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Выравнивает форму по центру текущего экрана.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не вызывайте это непосредственно из программного кода. Вместо этого задайте <xref:System.Windows.Forms.Form.StartPosition%2A> свойства <xref:System.Windows.Forms.FormStartPosition.CenterScreen>.  
  
 <xref:System.Windows.Forms.Form.CenterToScreen%2A> Метод использует перечисленные ниже приоритет, чтобы определить экран, используемый по центру формы:  
  
1.  <xref:System.Windows.Forms.Form.Owner%2A> Свойства формы.  
  
2.  Владелец HWND формы.  
  
3.  Экран, который в данный момент находится указатель мыши.  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.Forms.FormStartPosition.CenterScreen" />
        <altmember cref="P:System.Windows.Forms.Form.Owner" />
      </Docs>
    </Member>
    <Member MemberName="ClientSize">
      <MemberSignature Language="C#" Value="public System.Drawing.Size ClientSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size ClientSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ClientSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ClientSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size ClientSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает размер клиентской области формы.</summary>
        <value>Объект <see cref="T:System.Drawing.Size" />, который представляет размер клиентской области формы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Размер клиентской области формы — размер, за исключением границ и в строке заголовка формы. Клиентской области формы — это область в форме, куда можно поместить элементы управления. Это свойство можно использовать для получения надлежащих размеров при выполнении графических операций или при изменении размера и положения элементов управления на форме. Для получения размера всей формы используйте <xref:System.Windows.Forms.Form.Size%2A> свойства или используйте отдельные свойства <xref:System.Windows.Forms.Control.Height%2A> и <xref:System.Windows.Forms.Control.Width%2A>.  
  
> [!NOTE]
>  В настоящее время нельзя привязать к этому свойству, используя параметры приложения. Дополнительные сведения о параметрах приложения см. в разделе [Общие сведения о параметрах приложения](~/docs/framework/winforms/advanced/application-settings-overview.md).  
  
   
  
## Examples  
 В следующем примере кода создается обработчик событий для <xref:System.Windows.Forms.Control.Resize> события формы. Используется в обработчике событий <xref:System.Windows.Forms.Form.ClientSize%2A> свойства формы, чтобы сделать <xref:System.Windows.Forms.Button> управления с именем `button1` заполняет всю клиентскую область формы.  
  
 [!code-cpp[Classic Form.ClientSize Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ClientSize Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ClientSize Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ClientSize Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ClientSize Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ClientSize Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.Size" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Windows.Forms.Control.Width" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Закрывает форму.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При закрытии формы, закрываются все ресурсы, созданные внутри объекта, и форма удаляется. Закрытие формы во время выполнения можно предотвратить путем обработки <xref:System.Windows.Forms.Form.Closing> событий и параметр <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> свойство <xref:System.ComponentModel.CancelEventArgs> передан в качестве параметра обработчику событий. Если форма Закрываемая форму запуска приложения, приложение закрывается.  
  
 Два условия, при формы не уничтожается на `Close` при (1) он входит в состав приложения многодокументного интерфейса (MDI) и форма не является видимым; и (2) отображаемый формы использует <xref:System.Windows.Forms.Form.ShowDialog%2A>. В этих случаях необходимо вызвать <xref:System.Windows.Forms.Form.Dispose%2A> вручную, чтобы пометить все элементы управления формы для сборки мусора.  
  
> [!NOTE]
>  Когда <xref:System.Windows.Forms.Form.Close%2A> метод будет вызван на <xref:System.Windows.Forms.Form> отображается в виде немодального окна, не удается вызвать <xref:System.Windows.Forms.Control.Show%2A> метод для отображения формы, поскольку ресурсы формы уже был осуществлен. Чтобы скрыть форму, а затем сделать его видимым, используйте <xref:System.Windows.Forms.Control.Hide%2A?displayProperty=nameWithType> метод.  
  
> [!CAUTION]
>  До появления [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] 2.0, <xref:System.Windows.Forms.Form.Closed?displayProperty=nameWithType> и <xref:System.Windows.Forms.Form.Closing?displayProperty=nameWithType> событий не возникает, когда <xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType> метод вызывается для выхода из приложения. Если у вас есть код проверки в любом из этих событий, которые должны быть выполнены, необходимо вызвать <xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType> метод для каждой открытой формы по отдельности перед вызовом <xref:System.Windows.Forms.Application.Exit%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Форма была закрыта при создании дескриптора.</exception>
        <exception cref="T:System.ObjectDisposedException">Нельзя вызывать этот метод из события <see cref="E:System.Windows.Forms.Form.Activated" />, если свойство <see cref="P:System.Windows.Forms.Form.WindowState" /> задано как <see cref="F:System.Windows.Forms.FormWindowState.Maximized" />.</exception>
        <altmember cref="P:System.ComponentModel.CancelEventArgs.Cancel" />
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
        <altmember cref="T:System.Windows.Forms.CloseReason" />
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Closed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при закрытой форме.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.Closed> Событий является устаревшим в .NET Framework версии 2.0; используйте <xref:System.Windows.Forms.Form.FormClosed> события вместо него.  
  
 Это событие возникает после закрытия формы пользователем или с <xref:System.Windows.Forms.Form.Close%2A> методом формы. Для предотвращения закрытия формы, обрабатывать <xref:System.Windows.Forms.Form.Closing> событий и набор <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> свойство <xref:System.ComponentModel.CancelEventArgs> передается в обработчик событий для `true`.  
  
 Это событие можно использовать для выполнения задач, например высвобождает ресурсы, используемые формой для сохранения данных, введенных в форму или на обновление родительской формы.  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.Closed?displayProperty=nameWithType> И <xref:System.Windows.Forms.Form.Closing?displayProperty=nameWithType> событий не возникает, когда <xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType> метод вызывается для выхода из приложения. Если у вас есть код проверки в любом из этих событий, которые должны быть выполнены, необходимо вызвать <xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType> метод для каждой открытой формы по отдельности перед вызовом <xref:System.Windows.Forms.Application.Exit%2A> метод.  
  
 Если форма является родительской формы MDI, <xref:System.Windows.Forms.Form.Closing> всех дочерних MDI-форм событий перед родительской MDI-формы <xref:System.Windows.Forms.Form.Closing> события. Кроме того <xref:System.Windows.Forms.Form.Closed> всех дочерних MDI-форм событий перед <xref:System.Windows.Forms.Form.Closed> события родительской формы MDI.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.Form.SetDesktopLocation%2A>, <xref:System.Windows.Forms.Form.Closed>, <xref:System.Windows.Forms.Form.Load>, <xref:System.Windows.Forms.Form.Activated>, и <xref:System.Windows.Forms.Form.Activate%2A> члены. Чтобы запустить пример, вставьте следующий код в форму с именем `Form1` содержащий <xref:System.Windows.Forms.Button> вызывается `Button1` и два <xref:System.Windows.Forms.Label> элементов управления `Label1` и `Label2`.  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" />
        <altmember cref="E:System.Windows.Forms.Form.Load" />
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Closing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closing As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Closing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при закрытии формы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.Closing> Событий является устаревшим в .NET Framework версии 2.0; используйте <xref:System.Windows.Forms.Form.FormClosing> события вместо него.  
  
 <xref:System.Windows.Forms.Form.Closing> Событие возникает при закрытии формы. При закрытии формы, освобождаются все ресурсы, созданные внутри объекта, а форма удаляется. При отмене этого события форма остается открытой. Чтобы отменить закрытие формы, задать <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> свойство <xref:System.ComponentModel.CancelEventArgs> передается в обработчик событий для `true`.  
  
 Если форма отображается как модальное диалоговое окно, нажав кнопку **закрыть** (кнопка со знаком X в правом верхнем углу формы) приводит к скрываться формы и <xref:System.Windows.Forms.Form.DialogResult%2A> свойству будет присвоено `DialogResult.Cancel`. Можно переопределить значение, присваиваемое <xref:System.Windows.Forms.Form.DialogResult%2A> свойства, когда пользователь щелкает **закрыть** кнопку, задав <xref:System.Windows.Forms.Form.DialogResult%2A> свойство в обработчике событий для <xref:System.Windows.Forms.Form.Closing> событие в формате.  
  
> [!NOTE]
>  Когда <xref:System.Windows.Forms.Form.Close%2A> метод будет вызван на <xref:System.Windows.Forms.Form> отображается в виде немодального окна, не удается вызвать <xref:System.Windows.Forms.Control.Show%2A> метод для отображения формы, поскольку ресурсы формы уже был осуществлен. Чтобы скрыть форму, а затем сделать его видимым, используйте <xref:System.Windows.Forms.Control.Hide%2A?displayProperty=nameWithType> метод.  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.Closed?displayProperty=nameWithType> И <xref:System.Windows.Forms.Form.Closing?displayProperty=nameWithType> событий не возникает, когда <xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType> метод вызывается для выхода из приложения. Если у вас есть код проверки в любом из этих событий, которые должны быть выполнены, необходимо вызвать <xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType> метод для каждой открытой формы по отдельности перед вызовом <xref:System.Windows.Forms.Application.Exit%2A> метод.  
  
 Если форма является родительской формы MDI, <xref:System.Windows.Forms.Form.Closing> всех дочерних MDI-форм событий перед родительской MDI-формы <xref:System.Windows.Forms.Form.Closing> события. Кроме того <xref:System.Windows.Forms.Form.Closed> всех дочерних MDI-форм событий перед <xref:System.Windows.Forms.Form.Closed> события родительской формы MDI. Отмена <xref:System.Windows.Forms.Form.Closing> событий дочерней формы MDI не препятствует <xref:System.Windows.Forms.Form.Closing> родительской MDI-формы из возникшее событие. Тем не менее, отмены события будет значение `true` <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> свойство <xref:System.ComponentModel.CancelEventArgs> , передается в качестве параметра родительской формы. Чтобы выполнить все родительские и дочерние формы MDI для закрытия, укажите <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> свойства `false` в MDI родительской формы.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Windows.Forms.Form.Closing> для проверки, если текст в <xref:System.Windows.Forms.TextBox> изменилось. Если у него есть запрашивает у пользователя, следует ли сохранить изменения в файл.  
  
 [!code-cpp[Form.Closing#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Closing/CPP/form1.cpp#1)]
 [!code-csharp[Form.Closing#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Closing/CS/form1.cs#1)]
 [!code-vb[Form.Closing#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Closing/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ControlBox">
      <MemberSignature Language="C#" Value="public bool ControlBox { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ControlBox" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ControlBox" />
      <MemberSignature Language="VB.NET" Value="Public Property ControlBox As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ControlBox { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, отображается ли кнопка оконного меню в строке заголовка формы.</summary>
        <value>
          <see langword="true" /> Если в форме отображается кнопка оконного меню в правом верхнем углу формы; в противном случае <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Windows.Forms.Form.ControlBox%2A> свойству `true`, в поле со списком отображается в правом верхнем углу заголовка окна. В поле со списком может содержать свести к минимуму, максимально и кнопки справки в дополнение к кнопку Закрыть. Для `ControlBox` свойство в действие, необходимо также задать формы <xref:System.Windows.Forms.Form.FormBorderStyle%2A> свойства <xref:System.Windows.Forms.FormBorderStyle.FixedSingle?displayProperty=nameWithType>, <xref:System.Windows.Forms.FormBorderStyle.Sizable?displayProperty=nameWithType>, <xref:System.Windows.Forms.FormBorderStyle.Fixed3D?displayProperty=nameWithType>, или <xref:System.Windows.Forms.FormBorderStyle.FixedDialog?displayProperty=nameWithType>.  
  
 Если задать <xref:System.Windows.Forms.Form.ControlBox%2A> для `false` и также задать <xref:System.Windows.Forms.Form.Location%2A> свойства <xref:System.Windows.Forms.Form.Size%2A> формы не обновляется для отражения скрыта неклиентской области формы. Чтобы устранить эту проблему, поместите код, который изменяет <xref:System.Windows.Forms.Form.Location%2A> свойства <xref:System.Windows.Forms.Control.HandleCreated> обработчика событий.  
  
> [!NOTE]
>  Если задано значение `false`, <xref:System.Windows.Forms.Form.ControlBox%2A> свойство не оказывает влияния на дочерняя форма многодокументного интерфейса (MDI), которая отображается развернутой во время создания.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Windows.Forms.Form.ControlBox%2A>, <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, и <xref:System.Windows.Forms.Form.StartPosition%2A> свойства, чтобы создать форму, которая не поддерживает все границы или окна заголовка. Формы, созданное в этом примере может использоваться для создания экрана-заставки для приложения. В примере требуется, что используемый в примере метод определен в классе формы и вызывается при инициализации формы.  
  
 [!code-cpp[Classic Form.ControlBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ControlBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ControlBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ControlBox Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ControlBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ControlBox Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MaximizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.MinimizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.ShowIcon" />
        <altmember cref="P:System.Windows.Forms.Form.FormBorderStyle" />
        <altmember cref="P:System.Windows.Forms.Form.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="CreateControlsInstance">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.Control.ControlCollection CreateControlsInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Forms.Control/ControlCollection CreateControlsInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CreateControlsInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateControlsInstance () As Control.ControlCollection" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Forms::Control::ControlCollection ^ CreateControlsInstance();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Control+ControlCollection</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает новый экземпляр коллекции элементов управления для данного элемента управления.</summary>
        <returns>Новый экземпляр коллекции <see cref="T:System.Windows.Forms.Control.ControlCollection" />, назначенной элементу управления.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.CreateControlsInstance" />
      </Docs>
    </Member>
    <Member MemberName="CreateHandle">
      <MemberSignature Language="C#" Value="protected override void CreateHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CreateHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.CreateHandle" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CreateHandle ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CreateHandle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает дескриптор для формы. Если производный класс переопределяет эту функцию, необходим вызов базовой реализации.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Обработчик для этого объекта <see cref="T:System.Windows.Forms.Form" /> уже создан.</exception>
        <altmember cref="M:System.Windows.Forms.Control.CreateHandle" />
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает параметры, необходимые для создания дескриптора элемента управления.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.CreateParams" />, содержащий необходимые параметры процедуры создания дескриптора элемента управления.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.ContainerControl.CreateParams" />
      </Docs>
    </Member>
    <Member MemberName="Deactivate">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivate;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivate" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Deactivate" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivate As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivate;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при потере фокуса формой, когда она становится неактивной.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие можно использовать для выполнения задач, таких как обновление другого окна в приложении с данными в форме отключено.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.Form.Deactivate> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.Form> с именем `Form1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.Form.Deactivate> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#393](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#393)]
 [!code-vb[System.Windows.Forms.EventExamples#393](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#393)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Form.Activated" />
        <altmember cref="M:System.Windows.Forms.Form.Activate" />
        <altmember cref="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DefaultImeMode">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.ImeMode DefaultImeMode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImeMode DefaultImeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DefaultImeMode" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultImeMode As ImeMode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::ImeMode DefaultImeMode { System::Windows::Forms::ImeMode get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает стандартный режим редактора методов ввода, поддерживаемый данным элементом управления.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Windows.Forms.ImeMode" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Редактор метода ввода (IME) — это программа, которая позволяет пользователям вводить сложные символы и знаки, например символы японского иероглифического письма Кандзи, используя стандартную клавиатуру.  
  
 Как осуществляется в <xref:System.Windows.Forms.Form> класса, это свойство всегда возвращает <xref:System.Windows.Forms.ImeMode.NoControl?displayProperty=nameWithType> значение. Значение этого свойства присваивается <xref:System.Windows.Forms.Control.ImeMode%2A?displayProperty=nameWithType> свойство.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ImeMode" />
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает размер элемента управления по умолчанию.</summary>
        <value>
          <see cref="T:System.Drawing.Size" /> по умолчанию для элемента управления.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.DefaultSize" />
      </Docs>
    </Member>
    <Member MemberName="DefWndProc">
      <MemberSignature Language="C#" Value="protected override void DefWndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void DefWndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.DefWndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub DefWndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void DefWndProc(System::Windows::Forms::Message % m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Сообщение <see cref="T:System.Windows.Forms.Message" /> Windows для обработки.</param>
        <summary>Отправляет заданное сообщение процедуре окна, используемой по умолчанию.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.DefWndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="DesktopBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle DesktopBounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle DesktopBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DesktopBounds" />
      <MemberSignature Language="VB.NET" Value="Public Property DesktopBounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle DesktopBounds { System::Drawing::Rectangle get(); void set(System::Drawing::Rectangle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает размер или расположение формы на рабочем столе Windows.</summary>
        <value>Объект <see cref="T:System.Drawing.Rectangle" />, представляющий границы формы на рабочем столе Windows с помощью координат рабочего стола.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Координаты рабочего стола основаны на рабочей области экрана, что исключает панели задач. Система координат рабочего стола базируется на точках. Если приложение выполняется в системе с несколькими мониторами, координаты формы являются координатами для объединенного рабочего стола.  
  
 Это свойство можно использовать для определения размеров и положения формы относительно других форм или приложений на рабочем столе Windows.  
  
   
  
## Examples  
 В следующем примере кода задает размер и положение формы, таким образом, чтобы форма занимала 50 точек от левой границы рабочего стола и 50 пикселей от верхнего края рабочего стола. В этом примере требуется, что метод определен внутри класса формы.  
  
 [!code-cpp[Classic Form.DesktopBounds Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.DesktopBounds Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.DesktopBounds Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.DesktopBounds Example/CS/source.cs#1)]
 [!code-vb[Classic Form.DesktopBounds Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.DesktopBounds Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.DesktopLocation" />
      </Docs>
    </Member>
    <Member MemberName="DesktopLocation">
      <MemberSignature Language="C#" Value="public System.Drawing.Point DesktopLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point DesktopLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DesktopLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property DesktopLocation As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point DesktopLocation { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает расположение формы на рабочем столе Windows.</summary>
        <value>Объект <see cref="T:System.Drawing.Point" />, представляющий расположение формы на рабочем столе.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Координаты рабочего стола основаны на рабочей области экрана, что исключает панели задач. Задана система координат рабочего стола базируется на точках. Если приложение выполняется в системе с несколькими мониторами, координаты формы являются координатами для объединенного рабочего стола.  
  
 Это свойство можно использовать для определения расположения формы относительно других форм и приложений на рабочем столе Windows.  
  
 При вызове метода <xref:System.Windows.Forms.Form.SetDesktopLocation%2A> метод перед вызовом метода <xref:System.Windows.Forms.Form.Show%2A> метода, форма будет располагаться в расположении по умолчанию, который определяется операционной системой. Дополнительные сведения о размещении окна см. в разделе «Размер и положение окна» документа «Компоненты окна» в библиотеке MSDN по http://msdn.microsoft.com/library.  
  
 При вызове метода <xref:System.Windows.Forms.Form.SetDesktopLocation%2A> после вызова <xref:System.Windows.Forms.Form.Show%2A>, форма будет располагаться в указанном месте.  
  
   
  
## Examples  
 В следующем примере кода задает положение формы так, чтобы форма занимала 100 пикселов от левой границы рабочего стола и 100 пикселей от верхнего края рабочего стола. В этом примере требуется, что метод определен внутри класса формы.  
  
 [!code-cpp[Classic Form.DesktopLocation Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.DesktopLocation Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.DesktopLocation Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.DesktopLocation Example/CS/source.cs#1)]
 [!code-vb[Classic Form.DesktopLocation Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.DesktopLocation Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.DesktopBounds" />
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DialogResult DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.DialogResult DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.DialogResult" />
      <MemberSignature Language="VB.NET" Value="Public Property DialogResult As DialogResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::DialogResult DialogResult { System::Windows::Forms::DialogResult get(); void set(System::Windows::Forms::DialogResult value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DialogResult</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает результат диалога для формы.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.DialogResult" />, представляющий результат формы при использовании в качестве диалогового окна.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Результат диалогового окна формы является значение, которое возвращается из формы при ее отображении в виде модального диалогового окна. Если форма отображается как диалоговое окно, задание этого свойства со значением от <xref:System.Windows.Forms.DialogResult> перечисления задает значение результат диалогового окна для формы, скрывает модального диалогового окна и возвращает управление вызывающей форме. Это свойство обычно задается <xref:System.Windows.Forms.Button.DialogResult%2A> свойства <xref:System.Windows.Forms.Button> элемента управления в форме. Когда пользователь щелкает <xref:System.Windows.Forms.Button> управления значение, присваиваемое <xref:System.Windows.Forms.Button.DialogResult%2A> свойство <xref:System.Windows.Forms.Button> назначается <xref:System.Windows.Forms.Form.DialogResult%2A> свойства формы.  
  
 Если форма отображается как модальное диалоговое окно, нажав кнопку **закрыть** (кнопка со значком X в правом верхнем углу формы) приводит к скрываться формы и <xref:System.Windows.Forms.Form.DialogResult%2A> свойству будет присвоено `DialogResult.Cancel`. <xref:System.Windows.Forms.Form.Close%2A> Метод не вызывается автоматически при нажатии **закрыть** кнопка диалогового окна или устанавливает значение <xref:System.Windows.Forms.Form.DialogResult%2A> свойства. Вместо этого форма является скрытым и может отображаться без создания нового экземпляра диалогового окна. Из-за этого поведения, необходимо вызвать метод <xref:System.Windows.Forms.Control.Dispose%2A> методом формы, когда форма больше не используется приложением.  
  
 Это свойство можно использовать для определения того, как диалоговое окно закрывается для надлежащей обработки действия, выполненные в диалоговом окне.  
  
> [!NOTE]
>  Можно переопределить значение, присваиваемое <xref:System.Windows.Forms.Form.DialogResult%2A> свойства, когда пользователь щелкает **закрыть** кнопку, задав <xref:System.Windows.Forms.Form.DialogResult%2A> свойство в обработчике событий для <xref:System.Windows.Forms.Form.Closing> событие в формате.  
  
> [!NOTE]
>  Если <xref:System.Windows.Forms.Form> отображается в виде немодального окна, значение, возвращаемое <xref:System.Windows.Forms.Form.DialogResult%2A> свойство не может возвращать значения, назначенного форме, поскольку ресурсы формы, автоматически снимаются при закрытии формы.  
  
   
  
## Examples  
 В следующем примере кода отображает форму как диалоговое окно и отображает окно сообщения, указывающее, была ли нажата кнопка OK или "Отмена" формы, с помощью ссылки на <xref:System.Windows.Forms.Form.DialogResult%2A> свойства формы.  
  
 [!code-cpp[Classic Form.DialogResult Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.DialogResult Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.DialogResult Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.DialogResult Example/CS/source.cs#1)]
 [!code-vb[Classic Form.DialogResult Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.DialogResult Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Заданное значение находится вне диапазона допустимых значений.</exception>
        <altmember cref="T:System.Windows.Forms.DialogResult" />
        <altmember cref="P:System.Windows.Forms.Button.DialogResult" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          Значение <see langword="true" /> позволяет освободить как управляемые, так и неуправляемые ресурсы; значение <see langword="false" /> освобождает только неуправляемые ресурсы.</param>
        <summary>Уничтожает ресурсы (кроме памяти), используемые классом <see cref="T:System.Windows.Forms.Form" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается методом открытые `Dispose` метод и <xref:System.Object.Finalize%2A> метод. `Dispose` вызывает защищенный `Dispose(Boolean)` метод с `disposing` равным `true`. <xref:System.Object.Finalize%2A> вызывает `Dispose` с `disposing` значение `false`.  
  
 Если параметр `disposing` имеет значение `true`, то данный метод освобождает все ресурсы, занятые любыми управляемыми объектами, на которые ссылается этот объект <xref:System.Windows.Forms.Form>. Этот метод вызывает метод `Dispose` каждого объекта, на который есть ссылка.  
  
 <xref:System.Windows.Forms.Form.Dispose%2A> будет вызван автоматически, если форма отображается с помощью <xref:System.Windows.Forms.Form.Show%2A> метод. Если другой метод, такой как <xref:System.Windows.Forms.Form.ShowDialog%2A> используется, или форма никогда не отображается вообще, необходимо вызвать <xref:System.Windows.Forms.Form.Dispose%2A> самостоятельно в приложении.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            Метод <see langword="Dispose" /> может вызываться несколько раз другими объектами. При переопределении метода <see langword="Dispose(Boolean)" /> нужно избегать ссылок на объекты, которые были уничтожены предыдущими вызовами метода <see langword="Dispose" />. Дополнительные сведения о реализации <see langword="Dispose(Boolean)" />, в разделе [метода](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
 Дополнительные сведения о <see langword="Dispose" /> и <see cref="M:System.Object.Finalize" />, в разделе [очистки неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md) и [переопределение метода Finalize](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.DpiChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChanged As DpiChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DpiChangedEventHandler ^ DpiChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении настройки DPI на устройстве, на котором в данный момент отображается форма.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FormBorderStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.FormBorderStyle FormBorderStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.FormBorderStyle FormBorderStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.FormBorderStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FormBorderStyle As FormBorderStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::FormBorderStyle FormBorderStyle { System::Windows::Forms::FormBorderStyle get(); void set(System::Windows::Forms::FormBorderStyle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-504)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormBorderStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает стиль границы формы.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.FormBorderStyle" />, представляющий стиль отображаемой границы для формы. Значение по умолчанию: <see langword="FormBorderStyle.Sizable" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Стиль границы формы определяет, как отображается внешнего края формы. Помимо изменения отображения границы формы, определенные стили границ предотвратить размер формы. Например `FormBorderStyle.FixedDialog` стиль границы формы, диалоговое окно изменения и предотвращает изменение размера формы. Стиль границы могут также влиять на размер и доступность секции строки заголовка формы.  
  
> [!NOTE]
>  С <xref:System.Windows.Forms.FormBorderStyle.Sizable> стиля, невозможен изменить размер окна ниже определенного минимального значения, даже если вы задали <xref:System.Windows.Forms.Form.ControlBox%2A> для `false` и назначенных ему строку нулевой длины для <xref:System.Windows.Forms.Form.Text%2A>. Рассмотрите возможность обойти это, используя <xref:System.Windows.Forms.FormBorderStyle.SizableToolWindow> стиль.  
  
   
  
## Examples  
 В следующем примере кода создается новый экземпляр <xref:System.Windows.Forms.Form> и вызывает <xref:System.Windows.Forms.Form.ShowDialog%2A> метод для отображения формы в виде диалогового окна. В примере устанавливается <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, и <xref:System.Windows.Forms.Form.StartPosition%2A> свойства, чтобы изменить внешний вид и функциональные возможности формы диалогового окна. В примере также используется <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> методом формы <xref:System.Windows.Forms.Control.Controls%2A> коллекции для добавления двух <xref:System.Windows.Forms.Button> элементов управления. В этом примере <xref:System.Windows.Forms.Form.HelpButton%2A> свойство для отображения кнопки справки в строке заголовка диалогового окна.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Заданное значение находится вне диапазона допустимых значений.</exception>
        <altmember cref="T:System.Windows.Forms.FormBorderStyle" />
      </Docs>
    </Member>
    <Member MemberName="FormClosed">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.FormClosedEventHandler FormClosed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.FormClosedEventHandler FormClosed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.FormClosed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FormClosed As FormClosedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::FormClosedEventHandler ^ FormClosed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormClosedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после закрытия формы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.FormClosed> Событие возникает после закрытия формы пользователем или с <xref:System.Windows.Forms.Form.Close%2A> метода или <xref:System.Windows.Forms.Application.Exit%2A> метод <xref:System.Windows.Forms.Application> класса. Для предотвращения закрытия формы, обрабатывать <xref:System.Windows.Forms.Form.FormClosing> событий и набор <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> свойство <xref:System.ComponentModel.CancelEventArgs> передается в обработчик событий для `true`.  
  
 Это событие можно использовать для выполнения задач, например высвобождает ресурсы, используемые формой для сохранения данных, введенных в форму или на обновление родительской формы.  
  
 Если форма является родительской формой многодокументного интерфейса (MDI), <xref:System.Windows.Forms.Form.FormClosing> всех дочерних MDI-форм событий перед родительской MDI-формы <xref:System.Windows.Forms.Form.FormClosing> события. Аналогичным образом <xref:System.Windows.Forms.Form.FormClosed> всех дочерних MDI-форм событий перед <xref:System.Windows.Forms.Form.FormClosed> события родительской формы MDI.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.Form.FormClosed> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.Form> с именем `Form1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.Form.FormClosed> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#395](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#395)]
 [!code-vb[System.Windows.Forms.EventExamples#395](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#395)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.Close" />
        <altmember cref="M:System.Windows.Forms.Application.Exit" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="E:System.Windows.Forms.Form.FormClosing" />
        <altmember cref="E:System.Windows.Forms.Form.Load" />
        <altmember cref="E:System.Windows.Forms.Form.Shown" />
        <altmember cref="T:System.Windows.Forms.CloseReason" />
      </Docs>
    </Member>
    <Member MemberName="FormClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.FormClosingEventHandler FormClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.FormClosingEventHandler FormClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.FormClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FormClosing As FormClosingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::FormClosingEventHandler ^ FormClosing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormClosingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит перед закрытием формы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.FormClosing> Событие возникает при закрытии формы. При закрытии формы, она удаляется, освобождая все ресурсы, связанные с формой. При отмене этого события форма остается открытой. Чтобы отменить закрытие формы, задать <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> свойство <xref:System.Windows.Forms.FormClosingEventArgs> передается в обработчик событий для `true`.  
  
 Если форма отображается как модальное диалоговое окно, нажав кнопку **закрыть** (кнопка со знаком X в правом верхнем углу формы) приводит к скрываться формы и <xref:System.Windows.Forms.Form.DialogResult%2A> свойству будет присвоено `DialogResult.Cancel`. Можно переопределить значение, присваиваемое <xref:System.Windows.Forms.Form.DialogResult%2A> свойства, когда пользователь щелкает **закрыть** кнопку, задав <xref:System.Windows.Forms.Form.DialogResult%2A> свойство в обработчике событий для <xref:System.Windows.Forms.Form.FormClosing> событие в формате.  
  
> [!NOTE]
>  Когда <xref:System.Windows.Forms.Form.Close%2A> метод будет вызван на <xref:System.Windows.Forms.Form> отображается в виде немодального окна, не удается вызвать <xref:System.Windows.Forms.Control.Show%2A> метод для отображения формы, поскольку ресурсы формы уже был осуществлен. Чтобы скрыть форму, а затем сделать его видимым, используйте <xref:System.Windows.Forms.Control.Hide%2A> метод.  
  
 Если форма является родительской формой многодокументного интерфейса (MDI), <xref:System.Windows.Forms.Form.FormClosing> всех дочерних MDI-форм событий перед родительской MDI-формы <xref:System.Windows.Forms.Form.FormClosing> события. Аналогичным образом <xref:System.Windows.Forms.Form.FormClosed> всех дочерних MDI-форм событий перед <xref:System.Windows.Forms.Form.FormClosed> события родительской формы MDI. Отмена <xref:System.Windows.Forms.Form.FormClosing> событий дочерней формы MDI не препятствует <xref:System.Windows.Forms.Form.FormClosing> родительской MDI-формы из возникшее событие. Тем не менее, отмены события будет значение `true` <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> свойство <xref:System.Windows.Forms.FormClosingEventArgs> класс, который передается как параметр родительской формы. Чтобы выполнить все родительские и дочерние формы MDI для закрытия, укажите <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> свойства `false` в MDI родительской формы.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.Form.FormClosing> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.Form> с именем `Form1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.Form.FormClosing> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#394](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#394)]
 [!code-vb[System.Windows.Forms.EventExamples#394](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#394)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="M:System.Windows.Forms.Form.Close" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Form.FormClosed" />
        <altmember cref="E:System.Windows.Forms.Form.Load" />
        <altmember cref="E:System.Windows.Forms.Form.Shown" />
        <altmember cref="T:System.Windows.Forms.CloseReason" />
      </Docs>
    </Member>
    <Member MemberName="GetAutoScaleSize">
      <MemberSignature Language="C#" Value="public static System.Drawing.SizeF GetAutoScaleSize (System.Drawing.Font font);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Drawing.SizeF GetAutoScaleSize(class System.Drawing.Font font) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.GetAutoScaleSize(System.Drawing.Font)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Drawing::SizeF GetAutoScaleSize(System::Drawing::Font ^ font);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Obsolete("This method has been deprecated. Use the AutoScaleDimensions property instead.  http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.SizeF</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="font" Type="System.Drawing.Font" />
      </Parameters>
      <Docs>
        <param name="font">Объект <see cref="T:System.Drawing.Font" />, представляющий шрифт для определения автомасштабированного базового размера формы.</param>
        <summary>Возвращает размер при автоматическом масштабировании формы на основе указанного шрифта.</summary>
        <returns>Объект <see cref="T:System.Drawing.SizeF" />, представляющий автомасштабированный размер формы.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <xref:System.Windows.Forms.Form.GetAutoScaleSize%2A> Метод является устаревшим in.NET Framework версии 2.0. Этот член был сохранен для обратной совместимости. Дополнительные сведения об автоматическом масштабировании см. в разделе [автоматическое масштабирование в Windows Forms](~/docs/framework/winforms/automatic-scaling-in-windows-forms.md).  
  
 Этот метод можно использовать для определения размера, формы будет автоматически масштабироваться определенного шрифта до применения на форму. Если вы хотите определить размер формы является автомасштабированного к на основе шрифта, назначенного форме в настоящее время, используйте <xref:System.Windows.Forms.Form.AutoScaleBaseSize%2A> свойство.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.AutoScaleBaseSize" />
      </Docs>
    </Member>
    <Member MemberName="GetScaledBounds">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Rectangle GetScaledBounds (System.Drawing.Rectangle bounds, System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Drawing.Rectangle GetScaledBounds(valuetype System.Drawing.Rectangle bounds, valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetScaledBounds (bounds As Rectangle, factor As SizeF, specified As BoundsSpecified) As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Drawing::Rectangle GetScaledBounds(System::Drawing::Rectangle bounds, System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bounds" Type="System.Drawing.Rectangle" />
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="bounds">Объект <see cref="T:System.Drawing.Rectangle" />, определяющий область, для которой возвращаются границы области отображения.</param>
        <param name="factor">Высота и ширина границ элемента управления.</param>
        <param name="specified">Одно из значений объекта <see cref="T:System.Windows.Forms.BoundsSpecified" />, задающее границы элемента управления, используемые для определения его размеров и положения.</param>
        <summary>Возвращает границы, внутри которых масштабируется элемент управления.</summary>
        <returns>Объект <see cref="T:System.Drawing.Rectangle" />, представляющий границы, внутри которых масштабируется элемент управления.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.GetScaledBounds(System.Drawing.Rectangle,System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="HelpButton">
      <MemberSignature Language="C#" Value="public bool HelpButton { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HelpButton" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.HelpButton" />
      <MemberSignature Language="VB.NET" Value="Public Property HelpButton As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HelpButton { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, отображать ли кнопку "Справка" в заголовке формы.</summary>
        <value>
          Значение <see langword="true" /> для отображения кнопки "Справка" в заголовке формы; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение этого свойства `true`, Маленькая кнопка с вопросительным знаком отображается в строке заголовка слева от **закрыть** кнопки. Можно использовать эту кнопку, чтобы отобразить справку для вашего приложения. Можно создать обработчик событий для <xref:System.Windows.Forms.Control.HelpRequested> события, чтобы отображать справочную информацию для пользователя, при нажатии кнопки «Справка» в форму.  

Чтобы отобразить кнопку "Справка", значение в формате <xref:System.Windows.Forms.Form.ControlBox> свойство должно быть `true`, его значение по умолчанию. <xref:System.Windows.Forms.Form.ControlBox> Свойство определяет, содержится ли в правом верхнем углу заголовка окна элементы управления, такие как кнопка развертывания, кнопка свертывания, кнопку "Справка" и кнопка закрытия. Кроме того, необходимо также задать формы <xref:System.Windows.Forms.Form.FormBorderStyle%2A> свойства <xref:System.Windows.Forms.FormBorderStyle.FixedSingle?displayProperty=nameWithType>, <xref:System.Windows.Forms.FormBorderStyle.Sizable?displayProperty=nameWithType>, <xref:System.Windows.Forms.FormBorderStyle.Fixed3D?displayProperty=nameWithType>, или <xref:System.Windows.Forms.FormBorderStyle.FixedDialog?displayProperty=nameWithType>.  


> [!IMPORTANT]
>  Значение <xref:System.Windows.Forms.Form.HelpButton%2A> свойство игнорируется, если **развернуть** или **свернуть** отображаются кнопки.  
  
   
  
## Examples  
 В следующем примере кода создается новый экземпляр <xref:System.Windows.Forms.Form> и вызывает <xref:System.Windows.Forms.Form.ShowDialog%2A> метод для отображения формы в виде диалогового окна. В примере устанавливается <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, и <xref:System.Windows.Forms.Form.StartPosition%2A> свойства, чтобы изменить внешний вид и функциональные возможности формы диалогового окна. В примере также используется <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> методом формы <xref:System.Windows.Forms.Control.Controls%2A> коллекции для добавления двух <xref:System.Windows.Forms.Button> элементов управления. В этом примере <xref:System.Windows.Forms.Form.HelpButton%2A> свойство для отображения кнопки справки в строке заголовка диалогового окна.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MinimizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.MaximizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
        <altmember cref="E:System.Windows.Forms.Form.HelpButtonClicked" />
      </Docs>
    </Member>
    <Member MemberName="HelpButtonClicked">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler HelpButtonClicked;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler HelpButtonClicked" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.HelpButtonClicked" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HelpButtonClicked As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ HelpButtonClicked;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при нажатии кнопки **Справка**.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.HelpButtonClicked> Событие возникает при **справки** по нажатию кнопки в строке заголовка формы. **Справки** кнопка отображается при <xref:System.Windows.Forms.Form.HelpButton%2A> свойству `true`. <xref:System.Windows.Forms.Form.HelpButtonClicked> может быть отменено.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.Form.HelpButtonClicked> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.Form> с именем `Form1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.Form.HelpButtonClicked> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#388](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#388)]
 [!code-vb[System.Windows.Forms.EventExamples#388](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#388)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.HelpButton" />
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
        <altmember cref="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" />
        <altmember cref="E:System.Windows.Forms.Control.HelpRequested" />
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Drawing.Icon Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Icon Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Icon" />
      <MemberSignature Language="VB.NET" Value="Public Property Icon As Icon" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Icon ^ Icon { System::Drawing::Icon ^ get(); void set(System::Drawing::Icon ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.AmbientValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Icon</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значок для формы.</summary>
        <value>Объект <see cref="T:System.Drawing.Icon" />, который представляет значок для формы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значок формы назначает рисунок, который представляет форма в панели задач, а также значок, отображаемый для поля элемента управления формы.  
  
 Это свойство не будет действовать при <xref:System.Windows.Forms.Form.FormBorderStyle%2A> равно <xref:System.Windows.Forms.FormBorderStyle.FixedDialog>. В этом случае в форме не будет отображаться значок.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
      </Docs>
    </Member>
    <Member MemberName="InputLanguageChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.InputLanguageChangedEventHandler InputLanguageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.InputLanguageChangedEventHandler InputLanguageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.InputLanguageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event InputLanguageChanged As InputLanguageChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::InputLanguageChangedEventHandler ^ InputLanguageChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguageChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после изменения языка заполнения формы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие используется для внесения изменений в внешний вид и текст, основанный на изменения, внесенные в язык ввода формы в форму.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.Form.InputLanguageChanged> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.Form> с именем `Form1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.Form.InputLanguageChanged> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#400](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#400)]
 [!code-vb[System.Windows.Forms.EventExamples#400](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#400)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Form.InputLanguageChanging" />
        <altmember cref="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InputLanguageChanging">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.InputLanguageChangingEventHandler InputLanguageChanging;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.InputLanguageChangingEventHandler InputLanguageChanging" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.InputLanguageChanging" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event InputLanguageChanging As InputLanguageChangingEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::InputLanguageChangingEventHandler ^ InputLanguageChanging;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.InputLanguageChangingEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь пытается изменить язык заполнения формы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает перед выполнением изменения языка ввода для формы. Изменение языка можно отменить, задав <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> свойство <xref:System.Windows.Forms.InputLanguageChangingEventArgs> передается в обработчик событий для `false`. Если событие отменяется, язык ввода не изменяется. Это событие можно использовать, чтобы определить, подходит ли изменение запрошенного языка ввода приложения.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.Form.InputLanguageChanging> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.Form> с именем `Form1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.Form.InputLanguageChanging> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#401](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#401)]
 [!code-vb[System.Windows.Forms.EventExamples#401](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#401)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Form.InputLanguageChanged" />
        <altmember cref="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="IsMdiChild">
      <MemberSignature Language="C#" Value="public bool IsMdiChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMdiChild" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.IsMdiChild" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMdiChild As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMdiChild { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, является ли форма дочерней MDI-формой.</summary>
        <value>
          <see langword="true" />, если форма является дочерней MDI-формой; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Во время выполнения дочерние MDI-формы отображаются внутри клиентской области родительской формы MDI. Дочерней формы MDI можно развернуть, свести к минимуму и перемещен в пределах родительской MDI-формы. Чтобы создать дочернюю форму MDI, назначьте <xref:System.Windows.Forms.Form> , который будет родительской MDI-формы для <xref:System.Windows.Forms.Form.MdiParent%2A> свойства дочерней формы. Можно использовать <xref:System.Windows.Forms.Form.IsMdiContainer%2A> свойство, чтобы определить, является ли форма MDI родительской формы.  
  
 Можно использовать <xref:System.Windows.Forms.Form.IsMdiChild%2A> свойства, чтобы определить, является ли форма, возвращенная методом или свойством дочерней формы MDI или стандартную форму в приложении, такие как диалоговое окно.  
  
> [!NOTE]
>  Все дочерние формы MDI имеют изменяемые границы, поле меню управления и сворачивания и **развернуть** кнопки, независимо от настроек <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.ControlBox%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, и <xref:System.Windows.Forms.Form.MaximizeBox%2A> свойства.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MdiParent" />
        <altmember cref="P:System.Windows.Forms.Form.MdiChildren" />
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
      </Docs>
    </Member>
    <Member MemberName="IsMdiContainer">
      <MemberSignature Language="C#" Value="public bool IsMdiContainer { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMdiContainer" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.IsMdiContainer" />
      <MemberSignature Language="VB.NET" Value="Public Property IsMdiContainer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMdiContainer { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, является ли форма контейнером для дочерних MDI-форм.</summary>
        <value>
          Значение <see langword="true" />, если форма является контейнером для дочерних MDI-форм; в противном случае — значение <see langword="false" />.  Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство изменяет отображение и поведение формы для родительской формы MDI. Если значение этого свойства `true`, форма отображает утопленную клиентскую область с рельефной границей. Все дочерние MDI-формы, назначенные родительской формы отображаются в клиентской области.  
  
 При закрытии родительской формы MDI <xref:System.Windows.Forms.Form.Closing> всех дочерних MDI-форм событий перед родительской MDI-формы <xref:System.Windows.Forms.Form.Closing> события. Кроме того <xref:System.Windows.Forms.Form.Closed> всех дочерних MDI-форм событий перед <xref:System.Windows.Forms.Form.Closed> события родительской формы MDI.  
  
> [!NOTE]
>  Если имеются два <xref:System.Windows.Forms.MenuStrip> элементов управления в дочерней форме MDI, установка <xref:System.Windows.Forms.Form.IsMdiContainer%2A> для `true` для родительской формы объединяет содержимое только одного из <xref:System.Windows.Forms.MenuStrip> элементов управления. Используйте <xref:System.Windows.Forms.ToolStripManager.Merge%2A> слияния содержимого дополнительные дочерние <xref:System.Windows.Forms.MenuStrip> элементов управления в родительской MDI-формы.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Windows.Forms.Form.IsMdiContainer%2A> свойства, а также изменение `BackColor` свойство MDI-формы. Чтобы выполнить этот пример, вставьте следующий код в новую форму.  
  
 [!code-csharp[System.Windows.Forms.MdiClientExample#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MdiClientExample/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MdiClientExample#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MdiClientExample/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiChild" />
        <altmember cref="P:System.Windows.Forms.Form.MdiParent" />
        <altmember cref="P:System.Windows.Forms.Form.MdiChildren" />
      </Docs>
    </Member>
    <Member MemberName="IsRestrictedWindow">
      <MemberSignature Language="C#" Value="public bool IsRestrictedWindow { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsRestrictedWindow" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.IsRestrictedWindow" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsRestrictedWindow As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsRestrictedWindow { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, могут ли в форме использоваться все окна и события пользовательского ввода без каких-либо ограничений.</summary>
        <value>
          Значение <see langword="true" />, если в форме есть ограничения, в противном случае — <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.IsRestrictedWindow%2A> Свойство определяет, является ли <xref:System.Security.Permissions.UIPermissionWindow.AllWindows> разрешение. Это свойство устанавливается во время выполнения в конструкторе формы и кэшируется на время существования формы. Приложения Windows Forms с частичным доверием не удается избежать этой проверки, как общеязыковая среда выполнения гарантирует, что родительский конструктор всегда вызывается в режиме частичного доверия.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyPreview">
      <MemberSignature Language="C#" Value="public bool KeyPreview { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool KeyPreview" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.KeyPreview" />
      <MemberSignature Language="VB.NET" Value="Public Property KeyPreview As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool KeyPreview { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, получит ли форма события клавиш перед передачей событий элементу управления, на который установлен фокус.</summary>
        <value>
          Значение <see langword="true" />, если форма получит все события клавиш; значение <see langword="false" />, если выбранный в настоящее время элемент управления в форме получает события клавиш. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение этого свойства `true`, форма получит все <xref:System.Windows.Forms.Control.KeyPress>, <xref:System.Windows.Forms.Control.KeyDown>, и <xref:System.Windows.Forms.Control.KeyUp> события. По завершении обработки нажатия кнопки обработчиками событий формы нажатие кнопки назначается элементу управления с фокусом. Например если <xref:System.Windows.Forms.Form.KeyPreview%2A> свойству `true` и текущего выбранного элемента управления является <xref:System.Windows.Forms.TextBox>, то после нажатия кнопки обрабатывается обработчики событий в форме <xref:System.Windows.Forms.TextBox> элемент управления получает нажатую клавишу. Чтобы обработать события клавиатуры только на уровне формы и не поддерживает элементы управления для получения событий клавиатуры, задайте <xref:System.Windows.Forms.KeyPressEventArgs.Handled%2A?displayProperty=nameWithType> свойства на форме <xref:System.Windows.Forms.Control.KeyPress> обработчик событий `true`.  
  
 Это свойство можно использовать для обработки большинства нажатий клавиш в приложении и либо обработки нажатия клавиши, либо вызова соответствующего элемента управления для обработки нажатия клавиши. Например если в приложении используются сочетания клавиш, можно обработать нажатий клавиш на уровне формы вместо написания кода для каждого элемента управления, который может принимать события клавиатуры.  
  
> [!NOTE]
>  Если в форме имеется элементы управления не видна или включена, она автоматически получает все события клавиатуры.  
  
> [!NOTE]
>  Элемент управления в форме может быть запрограммирован для отмены получаемых нажатий клавиш. Так как элемент управления никогда не отправляет нажатия клавиш в форму, форма не увидите их независимо от значения <xref:System.Windows.Forms.Form.KeyPreview%2A>.  
  
   
  
## Examples  
 В следующем примере кода показано задание формы <xref:System.Windows.Forms.Form.KeyPreview%2A> свойство в значение true и обработка события клавиш на уровне формы. Чтобы запустить пример, вставьте следующий код в пустую форму.  
  
 [!code-cpp[System.Windows.Forms.ProcessMnemonic#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.ProcessMnemonic#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.ProcessMnemonic#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.ProcessMnemonic/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.Control.KeyPress" />
        <altmember cref="E:System.Windows.Forms.Control.KeyDown" />
        <altmember cref="E:System.Windows.Forms.Control.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="LayoutMdi">
      <MemberSignature Language="C#" Value="public void LayoutMdi (System.Windows.Forms.MdiLayout value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LayoutMdi(valuetype System.Windows.Forms.MdiLayout value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.LayoutMdi(System.Windows.Forms.MdiLayout)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LayoutMdi (value As MdiLayout)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LayoutMdi(System::Windows::Forms::MdiLayout value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Windows.Forms.MdiLayout" />
      </Parameters>
      <Docs>
        <param name="value">Одно из значений <see cref="T:System.Windows.Forms.MdiLayout" />, которое определяет структуру дочерних MDI-форм.</param>
        <summary>Располагает дочерние MDI-формы внутри родительской MDI-формы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод позволяет упорядочить дочерние формы MDI в вашей родительской формы MDI, позволяющие упростить переход и управление дочерних MDI-форм. Дочерние MDI-формы могут накладываться по горизонтали и вертикали, каскадом или как значки внутри родительской MDI-формы.  
  
   
  
## Examples  
 В следующем примере кода показаны обработчики событий для пунктов меню окон в родительской формы MDI-приложения. Вызывает каждый обработчик событий <xref:System.Windows.Forms.Form.LayoutMdi%2A> метод для расположения любых дочерних форм, открытых в данный момент в приложении.  
  
 [!code-cpp[Classic Form.LayoutMdi Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.LayoutMdi Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.LayoutMdi Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.LayoutMdi Example/CS/source.cs#1)]
 [!code-vb[Classic Form.LayoutMdi Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.LayoutMdi Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MdiLayout" />
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public event EventHandler Load;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Load" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Load" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Load As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Load;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит до первоначального отображения формы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие можно использовать для выполнения задач, например выделение ресурсов, используемые формой.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.Form.SetDesktopLocation%2A>, <xref:System.Windows.Forms.Form.Load>, <xref:System.Windows.Forms.Form.Activated>, и <xref:System.Windows.Forms.Form.Activate%2A> члены. Чтобы запустить пример, вставьте следующий код в форму с именем `Form1` содержащий <xref:System.Windows.Forms.Button> вызывается `Button1` и два <xref:System.Windows.Forms.Label> элементов управления `Label1` и `Label2`.  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.Close" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public System.Drawing.Point Location { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Point Location" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Location" />
      <MemberSignature Language="VB.NET" Value="Public Property Location As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Point Location { System::Drawing::Point get(); void set(System::Drawing::Point value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает объект <see cref="T:System.Drawing.Point" />, который представляет собой верхний левый угол формы <see cref="T:System.Windows.Forms.Form" /> в экранных координатах.</summary>
        <value>Объект <see cref="T:System.Drawing.Point" />, который представляет собой верхний левый угол формы <see cref="T:System.Windows.Forms.Form" /> в экранных координатах.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Point> представляет собой структуру, это означает, что тип значения. При доступе к свойству в <xref:System.Drawing.Point>, возвращается копия свойства. Таким образом, изменение <xref:System.Drawing.Point.X%2A> или <xref:System.Drawing.Point.Y%2A> свойства <xref:System.Drawing.Point> , возвращенные <xref:System.Windows.Forms.Control.Location%2A> не влияет на свойства <xref:System.Windows.Forms.Control.Left%2A>, <xref:System.Windows.Forms.Control.Right%2A>, <xref:System.Windows.Forms.Control.Top%2A>, или <xref:System.Windows.Forms.Control.Bottom%2A> значения свойств <xref:System.Windows.Forms.Form>. Чтобы настроить эти свойства, значение каждого свойства по отдельности или <xref:System.Windows.Forms.Form.Location%2A> свойство с новым <xref:System.Drawing.Point>.  
  
 <xref:System.Windows.Forms.Form.Location%2A> Свойство Возвращает или задает <xref:System.Windows.Forms.Control.Location%2A> свойство <xref:System.Windows.Forms.Control> базового класса и наборы <xref:System.ComponentModel.SettingsBindableAttribute.Bindable%2A> свойства `true`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.Form" />
        <altmember cref="T:System.Windows.Forms.ContainerControl" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
      </Docs>
    </Member>
    <Member MemberName="MainMenuStrip">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MenuStrip MainMenuStrip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.MenuStrip MainMenuStrip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MainMenuStrip" />
      <MemberSignature Language="VB.NET" Value="Public Property MainMenuStrip As MenuStrip" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MenuStrip ^ MainMenuStrip { System::Windows::Forms::MenuStrip ^ get(); void set(System::Windows::Forms::MenuStrip ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ReferenceConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuStrip</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает основной контейнер меню для формы.</summary>
        <value>Элемент управления <see cref="T:System.Windows.Forms.MenuStrip" />, который представляет контейнер для структуры меню формы. Значение по умолчанию: <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В дополнение к параметру <xref:System.Windows.Forms.Form.MainMenuStrip%2A> свойство, сначала необходимо <xref:System.Windows.Forms.Control.ControlCollection.Add%2A> <xref:System.Windows.Forms.MenuStrip> управления <xref:System.Windows.Forms.Control.Controls%2A> коллекции формы.  
  
 <xref:System.Windows.Forms.MenuStrip> Заменяет класс <xref:System.Windows.Forms.MainMenu> класса в предыдущих версиях платформы .NET Framework.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MenuStrip" />
        <altmember cref="P:System.Windows.Forms.Control.Controls" />
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Padding Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Padding Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Padding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Padding Margin { System::Windows::Forms::Padding get(); void set(System::Windows::Forms::Padding value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Padding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает расстояние между элементами управления.</summary>
        <value>Значение, представляющее расстояние между элементами управления.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MarginChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MarginChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MarginChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MarginChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MarginChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MarginChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении свойства <see cref="P:System.Windows.Forms.Form.Margin" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximizeBox">
      <MemberSignature Language="C#" Value="public bool MaximizeBox { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MaximizeBox" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MaximizeBox" />
      <MemberSignature Language="VB.NET" Value="Public Property MaximizeBox As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MaximizeBox { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, отображается ли кнопка **Развернуть** в строке заголовка формы.</summary>
        <value>
          <see langword="true" /> для отображения **развернуть** кнопки для формы; в противном случае <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

 Объект **развернуть** кнопка позволяет пользователям увеличить окно в полноэкранном режиме. Для отображения **развернуть** кнопку в форме значение <xref:System.Windows.Forms.Form.ControlBox> свойство должно быть `true`, его значение по умолчанию.  <xref:System.Windows.Forms.Form.ControlBox> Свойство определяет, содержится ли в правом верхнем углу заголовка окна элементы управления, такие как кнопка развертывания, кнопка свертывания, кнопку "Справка" и кнопка закрытия. Кроме того, необходимо также задать формы <xref:System.Windows.Forms.Form.FormBorderStyle%2A> свойства <xref:System.Windows.Forms.FormBorderStyle.FixedSingle?displayProperty=nameWithType>, <xref:System.Windows.Forms.FormBorderStyle.Sizable?displayProperty=nameWithType>, <xref:System.Windows.Forms.FormBorderStyle.Fixed3D?displayProperty=nameWithType>, или <xref:System.Windows.Forms.FormBorderStyle.FixedDialog?displayProperty=nameWithType>.  
  
 Объект **развернуть** кнопка автоматически становится кнопкой восстановления, если окно развернуто. При свертывании или восстановлении окна автоматически меняется кнопка «Восстановить» к **развернуть** кнопки.  
  
> [!NOTE]
>  Развертывание формы во время выполнения приводит к возникновению ошибки <xref:System.Windows.Forms.Control.Resize> событий. <xref:System.Windows.Forms.Form.WindowState%2A> Свойство отражает текущее состояние окна. Если задать <xref:System.Windows.Forms.Form.WindowState%2A> свойства `FormWindowState.Maximized`, форма разворачивается вне зависимости от параметров в силе для <xref:System.Windows.Forms.Form.MaximizeBox%2A> и <xref:System.Windows.Forms.Form.FormBorderStyle%2A> свойства.  
  
   
  
## Examples  
 В следующем примере кода создается новый экземпляр <xref:System.Windows.Forms.Form> и вызывает <xref:System.Windows.Forms.Form.ShowDialog%2A> метод для отображения формы в виде диалогового окна. В примере устанавливается <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, и <xref:System.Windows.Forms.Form.StartPosition%2A> свойства, чтобы изменить внешний вид и функциональные возможности формы диалогового окна. В примере также используется <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> методом формы <xref:System.Windows.Forms.Control.Controls%2A> коллекции для добавления двух <xref:System.Windows.Forms.Button> элементов управления. В этом примере <xref:System.Windows.Forms.Form.HelpButton%2A> свойство для отображения кнопки справки в строке заголовка диалогового окна.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MinimizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
      </Docs>
    </Member>
    <Member MemberName="MaximizedBounds">
      <MemberSignature Language="C#" Value="protected System.Drawing.Rectangle MaximizedBounds { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle MaximizedBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MaximizedBounds" />
      <MemberSignature Language="VB.NET" Value="Protected Property MaximizedBounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Drawing::Rectangle MaximizedBounds { System::Drawing::Rectangle get(); void set(System::Drawing::Rectangle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает размер формы в развернутом состоянии.</summary>
        <value>Объект <see cref="T:System.Drawing.Rectangle" />, представляющий границы формы, когда она развернута.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение свойства <see cref="P:System.Drawing.Rectangle.Top" /> больше высоты формы.  
  
 - или -  
  
 Значение свойства <see cref="P:System.Drawing.Rectangle.Left" /> больше ширины формы.</exception>
        <block subset="none" type="overrides">
          <para>Классы, наследующие от <see cref="T:System.Windows.Forms.Form" /> можно переопределить этот метод, чтобы предоставить новые границы для формы, когда она развернута. Класс устанавливает это свойство и внутри при формы **развернуть** кнопки.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximizedBoundsChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MaximizedBoundsChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MaximizedBoundsChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MaximizedBoundsChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MaximizedBoundsChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MaximizedBoundsChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит в результате изменения значения свойства <see cref="P:System.Windows.Forms.Form.MaximizedBounds" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.Form.MaximizedBoundsChanged> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.Form> с именем `Form1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.Form.MaximizedBoundsChanged> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#389](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#389)]
 [!code-vb[System.Windows.Forms.EventExamples#389](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#389)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MaximizedBounds" />
        <altmember cref="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MaximumSize">
      <MemberSignature Language="C#" Value="public override System.Drawing.Size MaximumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MaximumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MaximumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property MaximumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MaximumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(typeof(System.Drawing.Size), "0, 0")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает максимальный размер, до которого может быть увеличена форма.</summary>
        <value>Объект <see cref="T:System.Drawing.Size" />, представляющий максимальный размер формы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство позволяет ограничить размер формы до указанного максимального размера. Эту функцию можно использовать при отображении нескольких окон одновременно, чтобы удостовериться, что одно окно других окон как скрытые. Если это свойство имеет значение <xref:System.Drawing.Size> , являющийся высотой и шириной, форма будет иметь максимальный размер не превышает предел, установленный операционной системой Windows.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется настройка <xref:System.Windows.Forms.Form.MaximumSize%2A> свойство.  
  
 [!code-cpp[System.Windows.Forms.FormExample#3](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CPP/form1.cpp#3)]
 [!code-csharp[System.Windows.Forms.FormExample#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CS/form1.cs#3)]
 [!code-vb[System.Windows.Forms.FormExample#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormExample/VB/form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значения высоты и ширины внутри объекта <see cref="T:System.Drawing.Size" /> меньше нуля.</exception>
        <altmember cref="P:System.Windows.Forms.Form.MaximizedBounds" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
        <altmember cref="P:System.Windows.Forms.SystemInformation.MaxWindowTrackSize" />
      </Docs>
    </Member>
    <Member MemberName="MaximumSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MaximumSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MaximumSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MaximumSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MaximumSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MaximumSizeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит в результате изменения значения свойства <see cref="P:System.Windows.Forms.Form.MaximumSize" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.Form.MaximumSizeChanged> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.Form> с именем `Form1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.Form.MaximumSizeChanged> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#390](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#390)]
 [!code-vb[System.Windows.Forms.EventExamples#390](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#390)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MdiChildActivate">
      <MemberSignature Language="C#" Value="public event EventHandler MdiChildActivate;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MdiChildActivate" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MdiChildActivate" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MdiChildActivate As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MdiChildActivate;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда дочерняя MDI-форма активируется или закрывается внутри MDI-приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие можно использовать для выполнения задач, таких как обновление содержимого дочерней MDI-формы и изменение параметров меню в родительской MDI-формы на основе состояния дочерней MDI-формы, которая активируется.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.Form.MdiChildActivate> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.Form> с именем `Form1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.Form.MdiChildActivate> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#397](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#397)]
 [!code-vb[System.Windows.Forms.EventExamples#397](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#397)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MdiChildren">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form[] MdiChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form[] MdiChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MdiChildren" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MdiChildren As Form()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Windows::Forms::Form ^&gt; ^ MdiChildren { cli::array &lt;System::Windows::Forms::Form ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает массив форм, представляющий дочерние MDI-формы, родителем которых является данная форма.</summary>
        <value>Массив объектов <see cref="T:System.Windows.Forms.Form" />, каждый из которых идентифицирует одну из дочерних MDI-форм формы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство позволяет получать ссылки на все дочерние формы MDI открытых в данный момент в родительской формы MDI. Чтобы создать дочернюю форму MDI, назначьте <xref:System.Windows.Forms.Form> , который будет родительской MDI-формы для <xref:System.Windows.Forms.Form.MdiParent%2A> свойства дочерней формы.  
  
 Это свойство можно использовать для перебора всех дочерних MDI-форм для выполнения операции, такие как сохранение данных в базе данных при закрытии родительской MDI-формы или обновить поля для дочерних форм на основе действий, выполненных в приложении.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.Form.MdiChildren%2A> свойства для перечисления элементов списка дочерних MDI-форм и добавления <xref:System.Windows.Forms.Button> каждого элемента управления.  
  
 [!code-cpp[Form.MDIChildren#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.MDIChildren/CPP/form1.cpp#1)]
 [!code-csharp[Form.MDIChildren#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.MDIChildren/CS/form1.cs#1)]
 [!code-vb[Form.MDIChildren#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.MDIChildren/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiChild" />
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="P:System.Windows.Forms.Form.MdiParent" />
      </Docs>
    </Member>
    <Member MemberName="MdiParent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form MdiParent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form MdiParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MdiParent" />
      <MemberSignature Language="VB.NET" Value="Public Property MdiParent As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Form ^ MdiParent { System::Windows::Forms::Form ^ get(); void set(System::Windows::Forms::Form ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает текущую родительскую MDI-форму этой формы.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.Form" />, представляющий родительскую MDI-форму.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы создать дочернюю форму MDI, назначьте <xref:System.Windows.Forms.Form> , который будет родительской MDI-формы для <xref:System.Windows.Forms.Form.MdiParent%2A> свойства дочерней формы. Это свойство из дочерней формы MDI можно использовать для получения общих сведений, которые должны все дочерние формы или для вызова методов, которые выполняют действия для всех дочерних форм.  
  
> [!NOTE]
>  Если имеются два <xref:System.Windows.Forms.MenuStrip> элементов управления в дочерней форме MDI, установка <xref:System.Windows.Forms.Form.IsMdiContainer%2A> для `true` для родительской формы объединяет содержимое только одного из <xref:System.Windows.Forms.MenuStrip> элементов управления. Используйте <xref:System.Windows.Forms.ToolStripManager.Merge%2A> слияния содержимого дополнительные дочерние <xref:System.Windows.Forms.MenuStrip> элементов управления в родительской MDI-формы.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется создание дочерних форм в MDI-приложения. В примере кода создается форма с уникальным текстом для идентификации дочерней формы. В этом примере <xref:System.Windows.Forms.Form.MdiParent%2A> свойство, чтобы указать, что форма является дочерней формы. В этом примере требуется, что код в примере вызывается из формы с его <xref:System.Windows.Forms.Form.IsMdiContainer%2A> свойство `true` и форма имеет закрытый класс целочисленную переменную на уровне с именем `childCount`.  
  
 [!code-cpp[Form.MDIParent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.MDIParent/CPP/form1.cpp#1)]
 [!code-csharp[Form.MDIParent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.MDIParent/CS/form1.cs#1)]
 [!code-vb[Form.MDIParent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.MDIParent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">
          <see cref="T:System.Windows.Forms.Form" />, назначенная этому свойству, не помечен как контейнер MDI.  
  
 - или -  
  
 <see cref="T:System.Windows.Forms.Form" />, назначенная этому свойству, является и дочерней формой, и формой контейнера MDI.  
  
 - или -  
  
 <see cref="T:System.Windows.Forms.Form" />, назначенная этому свойству, расположен в другом потоке.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для запроса формы. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
        <altmember cref="P:System.Windows.Forms.Form.IsMdiChild" />
        <altmember cref="P:System.Windows.Forms.Form.IsMdiContainer" />
        <altmember cref="P:System.Windows.Forms.Form.MdiChildren" />
      </Docs>
    </Member>
    <Member MemberName="Menu">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MainMenu Menu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.MainMenu Menu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Menu" />
      <MemberSignature Language="VB.NET" Value="Public Property Menu As MainMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MainMenu ^ Menu { System::Windows::Forms::MainMenu ^ get(); void set(System::Windows::Forms::MainMenu ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.ComponentModel.ReferenceConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MainMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает меню <see cref="T:System.Windows.Forms.MainMenu" />, которое отображается в форме.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.MainMenu" />, представляющий меню для отображения в форме.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство можно использовать для переключения между наборами полных меню во время выполнения. Например, можно определить один <xref:System.Windows.Forms.MainMenu> для отображения при имеет форму многодокументного интерфейса (MDI) нет активной дочерней MDI-формы, а другой <xref:System.Windows.Forms.MainMenu> для отображения при отображении дочернего окна. Можно также использовать другой <xref:System.Windows.Forms.MainMenu> при определенных условиях существует в приложении, которые требуют отображения другого набора меню.  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Windows.Forms.MainMenu>, назначаются два <xref:System.Windows.Forms.MenuItem> объектов <xref:System.Windows.Forms.MainMenu> и привязывает его к форме. В этом примере требуется наличие <xref:System.Windows.Forms.Form> созданный с именем `Form1`.  
  
 [!code-cpp[Classic MainMenu.MainMenu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MainMenu.MainMenu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MainMenu.MainMenu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MainMenu.MainMenu Example/CS/source.cs#1)]
 [!code-vb[Classic MainMenu.MainMenu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MainMenu.MainMenu Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MainMenu" />
        <altmember cref="T:System.Windows.Forms.MenuItem" />
        <altmember cref="T:System.Windows.Forms.Menu" />
      </Docs>
    </Member>
    <Member MemberName="MenuComplete">
      <MemberSignature Language="C#" Value="public event EventHandler MenuComplete;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MenuComplete" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MenuComplete" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MenuComplete As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MenuComplete;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при потере фокуса меню формы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает при нажатии на любой элемент меню в меню в результате которого выполняется команда, а меню теряет фокус. Это событие можно использовать для выполнения задач, таких как обновление текст <xref:System.Windows.Forms.StatusBar> управления или включение и отключение кнопок на <xref:System.Windows.Forms.ToolBar>.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.Form.MenuComplete> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.Form> с именем `Form1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.Form.MenuComplete> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#398](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#398)]
 [!code-vb[System.Windows.Forms.EventExamples#398](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#398)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MenuStart">
      <MemberSignature Language="C#" Value="public event EventHandler MenuStart;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MenuStart" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MenuStart" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MenuStart As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MenuStart;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при получении фокуса меню формы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает при выборе любого элемента меню в меню пользователь. Это событие можно использовать для выполнения задач, таких как включение и отключение элементов управления в форме, не должны быть доступны пользователю при обращении к меню.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.Form.MenuStart> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.Form> с именем `Form1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.Form.MenuStart> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#399](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#399)]
 [!code-vb[System.Windows.Forms.EventExamples#399](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#399)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="MergedMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MainMenu MergedMenu { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.MainMenu MergedMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MergedMenu" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MergedMenu As MainMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MainMenu ^ MergedMenu { System::Windows::Forms::MainMenu ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MainMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объединенное меню для формы.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.MainMenu" />, представляющий объединенное меню для формы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется главным образом в том случае, когда форма является дочерней формы многодокументного интерфейса (MDI), который объединяет меню с меню родительской формы. Это свойство можно использовать для получения текущей структуры меню в приложении MDI, чтобы внести изменения или дополнения к структуре меню. Для получения nonmerged <xref:System.Windows.Forms.MainMenu> присвоить форме, используйте <xref:System.Windows.Forms.Form.Menu%2A> свойство.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.MainMenu" />
        <altmember cref="T:System.Windows.Forms.MenuItem" />
        <altmember cref="P:System.Windows.Forms.Form.Menu" />
      </Docs>
    </Member>
    <Member MemberName="MinimizeBox">
      <MemberSignature Language="C#" Value="public bool MinimizeBox { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MinimizeBox" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MinimizeBox" />
      <MemberSignature Language="VB.NET" Value="Public Property MinimizeBox As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MinimizeBox { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, отображается ли кнопка **Свернуть** в строке заголовка формы.</summary>
        <value>
          <see langword="true" /> для отображения **свернуть** кнопки для формы; в противном случае <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект **свернуть** кнопка позволяет пользователям Свертывание окна в значок. Для отображения **свернуть** кнопку в форме значение <xref:System.Windows.Forms.Form.ControlBox> свойство должно быть `true`, его значение по умолчанию.  <xref:System.Windows.Forms.Form.ControlBox> Свойство определяет, содержится ли в правом верхнем углу заголовка окна элементы управления, такие как кнопка развертывания, кнопка свертывания, кнопку "Справка" и кнопка закрытия. Кроме того, необходимо также задать формы <xref:System.Windows.Forms.Form.FormBorderStyle%2A> свойства <xref:System.Windows.Forms.FormBorderStyle.FixedSingle?displayProperty=nameWithType>, <xref:System.Windows.Forms.FormBorderStyle.Sizable?displayProperty=nameWithType>, <xref:System.Windows.Forms.FormBorderStyle.Fixed3D?displayProperty=nameWithType>, или <xref:System.Windows.Forms.FormBorderStyle.FixedDialog?displayProperty=nameWithType>.  
  
> [!NOTE]
>  Свертывание формы во время выполнения приводит к возникновению ошибки <xref:System.Windows.Forms.Control.Resize> событий. <xref:System.Windows.Forms.Form.WindowState%2A> Свойство отражает текущее состояние окна. Если задать <xref:System.Windows.Forms.Form.WindowState%2A> свойства `FormWindowState.Minimized`, форма свернута вне зависимости от параметров в силе для <xref:System.Windows.Forms.Form.MinimizeBox%2A> и <xref:System.Windows.Forms.Form.FormBorderStyle%2A> свойства.  
  
   
  
## Examples  
 В следующем примере кода создается новый экземпляр <xref:System.Windows.Forms.Form> и вызывает <xref:System.Windows.Forms.Form.ShowDialog%2A> метод для отображения формы в виде диалогового окна. В примере устанавливается <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, <xref:System.Windows.Forms.Form.MinimizeBox%2A>, <xref:System.Windows.Forms.Form.MaximizeBox%2A>, и <xref:System.Windows.Forms.Form.StartPosition%2A> свойства, чтобы изменить внешний вид и функциональные возможности формы диалогового окна. В примере также используется <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> методом формы <xref:System.Windows.Forms.Control.Controls%2A> коллекции для добавления двух <xref:System.Windows.Forms.Button> элементов управления. В этом примере <xref:System.Windows.Forms.Form.HelpButton%2A> свойство для отображения кнопки справки в строке заголовка диалогового окна.  
  
 [!code-cpp[Classic Form.AcceptButton Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.AcceptButton Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.AcceptButton Example/CS/source.cs#1)]
 [!code-vb[Classic Form.AcceptButton Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.AcceptButton Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.MaximizeBox" />
        <altmember cref="P:System.Windows.Forms.Form.ControlBox" />
      </Docs>
    </Member>
    <Member MemberName="MinimumSize">
      <MemberSignature Language="C#" Value="public override System.Drawing.Size MinimumSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size MinimumSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.MinimumSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property MinimumSize As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Size MinimumSize { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает минимальный размер, до которого может быть уменьшена форма.</summary>
        <value>Объект <see cref="T:System.Drawing.Size" />, представляющий минимальный размер формы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство позволяет ограничить размер формы до указанного минимального размера. Эту функцию можно использовать, чтобы пользователь нежелательного размера окна. Если это свойство имеет значение <xref:System.Drawing.Size> , являющийся высотой и шириной, форма будет иметь минимальный размер, не превышает предел, установленный операционной системой Windows.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значения высоты и ширины внутри объекта <see cref="T:System.Drawing.Size" /> меньше нуля.</exception>
      </Docs>
    </Member>
    <Member MemberName="MinimumSizeChanged">
      <MemberSignature Language="C#" Value="public event EventHandler MinimumSizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler MinimumSizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.MinimumSizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MinimumSizeChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ MinimumSizeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит в результате изменения значения свойства <see cref="P:System.Windows.Forms.Form.MinimumSize" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.Form.MinimumSizeChanged> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.Form> с именем `Form1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.Form.MinimumSizeChanged> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#391](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#391)]
 [!code-vb[System.Windows.Forms.EventExamples#391](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#391)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
      </Docs>
    </Member>
    <Member MemberName="Modal">
      <MemberSignature Language="C#" Value="public bool Modal { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Modal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Modal" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Modal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Modal { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, отображается ли форма как модальная.</summary>
        <value>
          Значение <see langword="true" />, если форма отображается как модальная; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если форма отображается как модальная, ввод (нажатие клавиш клавиатуры или мыши) невозможен, за исключением объектов в модальной форме. Программа должна скрыть или закрыть модальное форму (обычно в ответ на некоторое действие пользователя) перед ввод в другую форму. Формы, которые отображаются как модальная обычно используются как диалоговые окна в приложении.  
  
 Это свойство можно использовать для определения, был ли форму, полученным от метод или свойство отображается как модальная.  
  
 Для отображения формы как модальная используйте <xref:System.Windows.Forms.Form.ShowDialog%2A> метод.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Windows.Forms.Form.Modal%2A> свойства, чтобы определить, если форма отображается как модальная. Если это не <xref:System.Windows.Forms.Form.FormBorderStyle%2A> и <xref:System.Windows.Forms.Form.TopLevel%2A> изменяются свойства, чтобы сделать форму формы верхнего уровня с границей окна инструментов.  
  
 [!code-cpp[Form.Modal#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Modal/CPP/form1.cpp#1)]
 [!code-csharp[Form.Modal#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Modal/CS/form1.cs#1)]
 [!code-vb[Form.Modal#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Modal/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.ShowDialog" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Form.Activated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Form.OnActivated%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Переопределение этого метода — предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Activated" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageChanged">
      <MemberSignature Language="C#" Value="protected override void OnBackgroundImageChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBackgroundImageChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnBackgroundImageChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnBackgroundImageChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnBackgroundImageChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.EventArgs" />, содержащий данные.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.BackgroundImageChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Form.OnBackgroundImageChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.Form.OnBackgroundImageChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Form.OnBackgroundImageChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnBackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="protected override void OnBackgroundImageLayoutChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBackgroundImageLayoutChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnBackgroundImageLayoutChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnBackgroundImageLayoutChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.BackgroundImageLayoutChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Form.OnBackgroundImageLayoutChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные о событии.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Form.Closed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.OnClosed%2A> Метод является устаревшим в .NET Framework версии 2.0; используйте <xref:System.Windows.Forms.Form.OnFormClosed%2A> метод вместо него.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Form.OnFormClosed%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Переопределение этого метода — предпочтительная методика обработки событий в производном классе.  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.OnClosed%2A> И <xref:System.Windows.Forms.Form.OnClosing%2A> методы не вызываются при <xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType> метод вызывается для выхода из приложения. Если у вас есть код проверки в любом из этих методов, которые необходимо выполнить, необходимо вызвать <xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType> метод для каждой открытой формы по отдельности перед вызовом <xref:System.Windows.Forms.Application.Exit%2A> метод.  
  
   
  
## Examples  
 В следующем примере кода показано, как переопределить <xref:System.Windows.Forms.Form.OnClosed%2A> метод в классе, производным от <xref:System.Windows.Forms.Form> .  
  
 [!code-cpp[System.Drawing.PointsAndSizes#6](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Drawing.PointsAndSizes/CPP/form1.cpp#6)]
 [!code-csharp[System.Drawing.PointsAndSizes#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Drawing.PointsAndSizes/CS/form1.cs#6)]
 [!code-vb[System.Drawing.PointsAndSizes#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Drawing.PointsAndSizes/VB/form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Form.OnClosed(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Closed" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosing (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosing(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.ComponentModel.CancelEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Form.Closing" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.OnClosing%2A> Метод является устаревшим в .NET Framework версии 2.0; используйте <xref:System.Windows.Forms.Form.OnFormClosing%2A> метод вместо него.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Form.OnClosing%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Переопределение этого метода — предпочтительная методика обработки событий в производном классе.  
  
> [!CAUTION]
>  <xref:System.Windows.Forms.Form.OnClosed%2A> И <xref:System.Windows.Forms.Form.OnClosing%2A> методы не вызываются при <xref:System.Windows.Forms.Application.Exit%2A?displayProperty=nameWithType> метод вызывается для выхода из приложения. Если у вас есть код проверки в любом из этих методов, которые необходимо выполнить, необходимо вызвать <xref:System.Windows.Forms.Form.Close%2A?displayProperty=nameWithType> метод для каждой открытой формы по отдельности перед вызовом <xref:System.Windows.Forms.Application.Exit%2A> метод.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Windows.Forms.Form.Closing> для проверки, если текст в <xref:System.Windows.Forms.TextBox> изменилось. Если у него есть запрашивает у пользователя, следует ли сохранить изменения в файл.  
  
 [!code-cpp[Form.Closing#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Closing/CPP/form1.cpp#1)]
 [!code-csharp[Form.Closing#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Closing/CS/form1.cs#1)]
 [!code-vb[Form.Closing#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Closing/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Form.OnClosing(System.ComponentModel.CancelEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Closing" />
        <altmember cref="T:System.ComponentModel.CancelEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateControl">
      <MemberSignature Language="C#" Value="protected override void OnCreateControl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnCreateControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnCreateControl" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnCreateControl ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnCreateControl();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывает событие <see langword="CreateControl" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.Form.OnCreateControl" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Windows.Forms.Form.OnCreateControl" /> метод.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivate">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivate (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivate(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivate (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivate(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные о событии.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Form.Deactivate" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Form.OnDeactivate%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Form.OnDeactivate(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Deactivate" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnDpiChanged (System.Windows.Forms.DpiChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDpiChanged(class System.Windows.Forms.DpiChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnDpiChanged(System.Windows.Forms.DpiChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDpiChanged (e As DpiChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDpiChanged(System::Windows::Forms::DpiChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DpiChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.Windows.Forms.DpiChangedEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Form.DpiChanged" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEnabledChanged">
      <MemberSignature Language="C#" Value="protected override void OnEnabledChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEnabledChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnEnabledChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnEnabledChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnEnabledChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.EnabledChanged" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnEnabledChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnEnter">
      <MemberSignature Language="C#" Value="protected override void OnEnter (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEnter(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnEnter(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnEnter (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnEnter(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.Enter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Form.OnEnter%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.Form.OnEnter(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Form.OnEnter(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnFontChanged">
      <MemberSignature Language="C#" Value="protected override void OnFontChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnFontChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnFontChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnFontChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnFontChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.FontChanged" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.OnFontChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFormClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnFormClosed (System.Windows.Forms.FormClosedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFormClosed(class System.Windows.Forms.FormClosedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFormClosed (e As FormClosedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFormClosed(System::Windows::Forms::FormClosedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.FormClosedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Forms.FormClosedEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Form.FormClosed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.OnFormClosing%2A> Метод удаляет из текущей формы <xref:System.Windows.Forms.Application.OpenForms%2A> коллекции связанного <xref:System.Windows.Forms.Application>.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Form.OnFormClosed%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Переопределение этого метода — предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.FormClosed" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnFormClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnFormClosing (System.Windows.Forms.FormClosingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnFormClosing(class System.Windows.Forms.FormClosingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnFormClosing (e As FormClosingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnFormClosing(System::Windows::Forms::FormClosingEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.FormClosingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Forms.FormClosingEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Form.FormClosing" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Form.OnFormClosing%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.FormClosing" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnActivated(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnGetDpiScaledSize">
      <MemberSignature Language="C#" Value="protected virtual bool OnGetDpiScaledSize (int deviceDpiOld, int deviceDpiNew, ref System.Drawing.Size desiredSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool OnGetDpiScaledSize(int32 deviceDpiOld, int32 deviceDpiNew, valuetype System.Drawing.Size&amp; desiredSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnGetDpiScaledSize(System.Int32,System.Int32,System.Drawing.Size@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnGetDpiScaledSize (deviceDpiOld As Integer, deviceDpiNew As Integer, ByRef desiredSize As Size) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool OnGetDpiScaledSize(int deviceDpiOld, int deviceDpiNew, System::Drawing::Size % desiredSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="deviceDpiOld" Type="System.Int32" />
        <Parameter Name="deviceDpiNew" Type="System.Int32" />
        <Parameter Name="desiredSize" Type="System.Drawing.Size&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="deviceDpiOld">Значение DPI для устройства, на котором ранее отображалась форма.</param>
        <param name="deviceDpiNew">Значение DPI для устройства, на котором будет отображаться форма.</param>
        <param name="desiredSize">Объект <see cref="T:System.Drawing.Size" />, представляющий новый размер формы, основанный на новом значении DPI.</param>
        <summary>Вызывает событие GetDpiScaledSize.</summary>
        <returns>
          Значение <see langword="true" /> в случае успешного выполнения; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected override void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleCreated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.HandleCreated" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnHandleCreated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected override void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.HandleDestroyed" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnHandleDestroyed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnHelpButtonClicked">
      <MemberSignature Language="C#" Value="protected virtual void OnHelpButtonClicked (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHelpButtonClicked(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHelpButtonClicked (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHelpButtonClicked(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.ComponentModel.CancelEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Form.HelpButtonClicked" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Form.OnHelpButtonClicked%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Form.OnHelpButtonClicked(System.ComponentModel.CancelEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.HelpButtonClicked" />
        <altmember cref="E:System.Windows.Forms.Control.QueryAccessibilityHelp" />
        <altmember cref="M:System.Windows.Forms.Control.OnHelpRequested(System.Windows.Forms.HelpEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnInputLanguageChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnInputLanguageChanged (System.Windows.Forms.InputLanguageChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInputLanguageChanged(class System.Windows.Forms.InputLanguageChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInputLanguageChanged (e As InputLanguageChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInputLanguageChanged(System::Windows::Forms::InputLanguageChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.InputLanguageChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.Windows.Forms.InputLanguageChangedEventArgs" />, содержащий данные о событии.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Form.InputLanguageChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Form.OnInputLanguageChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanged(System.Windows.Forms.InputLanguageChangedEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.InputLanguageChanged" />
        <altmember cref="T:System.Windows.Forms.InputLanguageChangedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnInputLanguageChanging">
      <MemberSignature Language="C#" Value="protected virtual void OnInputLanguageChanging (System.Windows.Forms.InputLanguageChangingEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInputLanguageChanging(class System.Windows.Forms.InputLanguageChangingEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInputLanguageChanging (e As InputLanguageChangingEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInputLanguageChanging(System::Windows::Forms::InputLanguageChangingEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.InputLanguageChangingEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.Windows.Forms.InputLanguageChangingEventArgs" />, содержащий данные о событии.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Form.InputLanguageChanging" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Form.OnInputLanguageChanging%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Form.OnInputLanguageChanging(System.Windows.Forms.InputLanguageChangingEventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.InputLanguageChanging" />
        <altmember cref="T:System.Windows.Forms.InputLanguageChangingEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnLayout">
      <MemberSignature Language="C#" Value="protected override void OnLayout (System.Windows.Forms.LayoutEventArgs levent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnLayout(class System.Windows.Forms.LayoutEventArgs levent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnLayout(System.Windows.Forms.LayoutEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnLayout (levent As LayoutEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnLayout(System::Windows::Forms::LayoutEventArgs ^ levent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="levent" Type="System.Windows.Forms.LayoutEventArgs" />
      </Parameters>
      <Docs>
        <param name="levent">Данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.Layout" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Form.Load" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Form.OnLoad%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Load" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMaximizedBoundsChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMaximizedBoundsChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMaximizedBoundsChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMaximizedBoundsChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMaximizedBoundsChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные о событии.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Form.MaximizedBoundsChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Form.OnMaximizedBoundsChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Form.OnMaximizedBoundsChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Form.MaximizedBounds" />
        <altmember cref="E:System.Windows.Forms.Form.MaximizedBoundsChanged" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMaximumSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMaximumSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMaximumSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMaximumSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMaximumSizeChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные о событии.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Form.MaximumSizeChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Form.OnMaximumSizeChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="E:System.Windows.Forms.Form.MaximumSizeChanged" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMdiChildActivate">
      <MemberSignature Language="C#" Value="protected virtual void OnMdiChildActivate (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMdiChildActivate(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMdiChildActivate (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMdiChildActivate(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные о событии.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Form.MdiChildActivate" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Form.OnMdiChildActivate%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Form.OnMdiChildActivate(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.MdiChildActivate" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMenuComplete">
      <MemberSignature Language="C#" Value="protected virtual void OnMenuComplete (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMenuComplete(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMenuComplete (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMenuComplete(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные о событии.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Form.MenuComplete" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Form.OnMenuComplete%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Form.OnMenuComplete(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.MenuComplete" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMenuStart">
      <MemberSignature Language="C#" Value="protected virtual void OnMenuStart (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMenuStart(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMenuStart (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMenuStart(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные о событии.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Form.MenuStart" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Form.OnMenuStart%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Form.OnMenuStart(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.MenuStart" />
        <altmember cref="T:System.EventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnMinimumSizeChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnMinimumSizeChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMinimumSizeChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMinimumSizeChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMinimumSizeChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Form.MinimumSizeChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Form.OnMinimumSizeChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Form.OnMinimumSizeChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.MinimumSizeChanged" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
      </Docs>
    </Member>
    <Member MemberName="OnPaint">
      <MemberSignature Language="C#" Value="protected override void OnPaint (System.Windows.Forms.PaintEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPaint(class System.Windows.Forms.PaintEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPaint (e As PaintEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPaint(System::Windows::Forms::PaintEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.PaintEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Forms.PaintEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.Paint" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnPaint(System.Windows.Forms.PaintEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnResize">
      <MemberSignature Language="C#" Value="protected override void OnResize (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnResize(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnResize(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnResize (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnResize(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.Resize" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnResize(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnResizeBegin">
      <MemberSignature Language="C#" Value="protected virtual void OnResizeBegin (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResizeBegin(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResizeBegin (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResizeBegin(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Form.ResizeBegin" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ResizeBegin> Событие будет вызываться, только если формы <xref:System.Windows.Forms.Control.CanRaiseEvents%2A> свойству `true`.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Form.OnResizeBegin%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.ResizeBegin" />
        <altmember cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnResizeEnd">
      <MemberSignature Language="C#" Value="protected virtual void OnResizeEnd (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnResizeEnd(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnResizeEnd (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnResizeEnd(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Form.ResizeEnd" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ResizeEnd> Событие будет вызываться, только если формы <xref:System.Windows.Forms.Control.CanRaiseEvents%2A> свойству `true`.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Form.OnResizeEnd%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.ResizeEnd" />
        <altmember cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Control.OnMove(System.EventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnMaximumSizeChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnRightToLeftLayoutChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnRightToLeftLayoutChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnRightToLeftLayoutChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnRightToLeftLayoutChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnRightToLeftLayoutChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущей формы или один из его родительских объектов освобождение ресурсов, <xref:System.Windows.Forms.Form.OnRightToLeftLayoutChanged%2A> метод возвращает не выполняя никаких действий. Если <xref:System.Windows.Forms.Control.RightToLeft%2A> свойства формы имеет значение <xref:System.Windows.Forms.RightToLeft.Yes>, то дескрипторы формы и его дочерние элементы будут созданы повторно через вызовы <xref:System.Windows.Forms.Control.RecreateHandle%2A> метод.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Form.OnRightToLeftLayoutChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" />
        <altmember cref="P:System.Windows.Forms.Form.RightToLeftLayout" />
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="Overload:System.Windows.Forms.Form.Dispose" />
        <altmember cref="M:System.Windows.Forms.Control.RecreateHandle" />
      </Docs>
    </Member>
    <Member MemberName="OnShown">
      <MemberSignature Language="C#" Value="protected virtual void OnShown (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnShown(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnShown (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnShown(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Form.Shown" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.Shown> Событие происходит при первом отображении формы.  
  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Form.OnShown%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.Form.Shown" />
        <altmember cref="Overload:System.Windows.Forms.Form.Show" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosing(System.Windows.Forms.FormClosingEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnFormClosed(System.Windows.Forms.FormClosedEventArgs)" />
        <altmember cref="M:System.Windows.Forms.Form.OnLoad(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected override void OnStyleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnStyleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnStyleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnStyleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnStyleChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.StyleChanged" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnStyleChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnTextChanged">
      <MemberSignature Language="C#" Value="protected override void OnTextChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnTextChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnTextChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnTextChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnTextChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.TextChanged" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnTextChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnVisibleChanged">
      <MemberSignature Language="C#" Value="protected override void OnVisibleChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnVisibleChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.OnVisibleChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnVisibleChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnVisibleChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные о событии.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.VisibleChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.Form.OnVisibleChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.Form.OnVisibleChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызывается метод <see cref="M:System.Windows.Forms.Form.OnVisibleChanged(System.EventArgs)" /> базового класса, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="E:System.Windows.Forms.Control.VisibleChanged" />
      </Docs>
    </Member>
    <Member MemberName="Opacity">
      <MemberSignature Language="C#" Value="public double Opacity { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Opacity" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Opacity" />
      <MemberSignature Language="VB.NET" Value="Public Property Opacity As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Opacity { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.Forms.OpacityConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает уровень непрозрачности формы.</summary>
        <value>Уровень непрозрачности для формы. Значение по умолчанию — 1,00.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.Opacity%2A> Свойство позволяет задать уровень прозрачности для формы и ее элементов управления. Если этому свойству присвоено значение меньше 100% (1,00), вся форма, включая границы, становится более прозрачной. Этому свойству присвоить значение 0% (0,00), форма становится полностью невидимым. Это свойство можно использовать для предоставления различных уровней прозрачности или для предоставления таких эффектов, как поэтапно формы в или из представления. Например, этап формы в представление, задав <xref:System.Windows.Forms.Form.Opacity%2A> свойство в значение 0% (0,00) и постепенного увеличения значения, пока не достигнет значения 100% (1,00).  
  
 <xref:System.Windows.Forms.Form.Opacity%2A> отличается от прозрачности, предоставленной <xref:System.Windows.Forms.Form.TransparencyKey%2A>, который делает формы и ее элементов управления полностью прозрачна в том случае, если они имеют тот же цвет, как значение, указанное в <xref:System.Windows.Forms.Form.TransparencyKey%2A> свойство.  
  
 Данное свойство не поддерживается при <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> — `true`.  
  
 <xref:System.Windows.Forms.Form.Opacity%2A> Свойство зависит от многоуровневых API Windows, появившийся в Windows 2000. Дополнительные сведения см. в разделе «Многоуровневая: новый способ для использования прозрачность и прозрачности эффекты в Windows приложений Windows» в документации Platform SDK в [ http://msdn.microsoft.com ](http://msdn.microsoft.com/).  
  
   
  
## Examples  
 В следующем примере кода показано, как создать форму, которая отображается с уровнем непрозрачности 75 процентов. В примере кода создается новая форма, размещенная в центре экрана с <xref:System.Windows.Forms.Form.Opacity%2A> задать свойство, чтобы изменить уровень непрозрачности формы. В примере кода также задает <xref:System.Windows.Forms.Form.Size%2A> свойства для обеспечения увеличения размера формы по сравнению с размером по умолчанию формы. Этот пример кода был написан исходя из предположения, что метод, определенный в этом примере вызывается из другой формы в обработчик событий или другой метод.  
  
 [!code-cpp[Form.Opacity#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Opacity/CPP/form1.cpp#1)]
 [!code-csharp[Form.Opacity#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Opacity/CS/form1.cs#1)]
 [!code-vb[Form.Opacity#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Opacity/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.TransparencyKey" />
        <altmember cref="F:System.Windows.Forms.OSFeature.LayeredWindows" />
      </Docs>
    </Member>
    <Member MemberName="OwnedForms">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form[] OwnedForms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form[] OwnedForms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.OwnedForms" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnedForms As Form()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Windows::Forms::Form ^&gt; ^ OwnedForms { cli::array &lt;System::Windows::Forms::Form ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает массив объектов <see cref="T:System.Windows.Forms.Form" />, который представляет все формы, принадлежащие этой форме.</summary>
        <value>Массив <see cref="T:System.Windows.Forms.Form" />, который представляет все собственные формы для этой формы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает массив, содержащий все формы, принадлежащие этой форме. Для создания формы, принадлежащей другой форме, вызовите <xref:System.Windows.Forms.Form.AddOwnedForm%2A> метод. Форма, назначенного форме владельца сохраняется до <xref:System.Windows.Forms.Form.RemoveOwnedForm%2A> вызывается метод. Вы также можете формы, принадлежащей другой, задав <xref:System.Windows.Forms.Form.Owner%2A> свойство со ссылкой на его форму-владельца.  
  
 Когда владеет другой вид формы, закрыт или скрытым с формой-владельцем. Например, рассмотрим форму с именем `Form2` , владельцем которой является форму с именем `Form1`. Если `Form1` закрывается или сворачивается, `Form2` также закрывается или скрыты. Собственные формы также никогда не отображаются сзади формы-владельца. Можно использовать собственные формы для windows, таких как найти и заменить окон, которые не должны отображаться для владельца формы при выборе формы-владельца.  
  
> [!NOTE]
>  Если форма является родительской формой многодокументного интерфейса (MDI), это свойство будет возвращать все отображаемые формы, за исключением любых дочерних форм MDI, которые в настоящее время являются открытыми. Чтобы получить дочерние формы MDI, открытых в родительской формы MDI, используйте <xref:System.Windows.Forms.Form.MdiChildren%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.Form.OwnedForms%2A> свойство для изменения всех форм, принадлежащих форме-владельцу. Первый метод в этом примере добавляет формы в массив собственных форм, связанных с собственной формой. Второй метод просматривает все собственные формы и изменяет заголовок. В этом примере требуется, что оба метода вызываются событием или другим методом формы.  
  
 [!code-cpp[Form.OwnedForms#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.OwnedForms/CPP/form1.cpp#1)]
 [!code-csharp[Form.OwnedForms#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.OwnedForms/CS/form1.cs#1)]
 [!code-vb[Form.OwnedForms#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.OwnedForms/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.AddOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="M:System.Windows.Forms.Form.RemoveOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="P:System.Windows.Forms.Form.Owner" />
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Form Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Form Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Owner" />
      <MemberSignature Language="VB.NET" Value="Public Property Owner As Form" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Form ^ Owner { System::Windows::Forms::Form ^ get(); void set(System::Windows::Forms::Form ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Form</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает форму, владеющую этой формой.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.Form" />, представляющий форму, которая является владельцем этой формы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для создания формы, принадлежащей другой форме, назначить его <xref:System.Windows.Forms.Form.Owner%2A> свойству ссылкой на форму, которая станет владельцем.  
  
 Когда владеет другой вид формы, закрыт или скрытым с формой-владельцем. Например, рассмотрим форму с именем `Form2` , владельцем которой является форму с именем `Form1`. Если `Form1` закрывается или сворачивается, `Form2` также закрывается или скрыты. Собственные формы также никогда не отображаются сзади формы-владельца. Можно использовать собственные формы для windows, таких как найти и заменить windows, которые не должны исчезать при выборе формы-владельца. Чтобы определить формы, принадлежащие родительской формы, используйте <xref:System.Windows.Forms.Form.OwnedForms%2A> свойство.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Окно верхнего уровня не может иметь владельца.</exception>
        <altmember cref="M:System.Windows.Forms.Form.AddOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="M:System.Windows.Forms.Form.RemoveOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="P:System.Windows.Forms.Form.OwnedForms" />
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessCmdKey (ref System.Windows.Forms.Message msg, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; msg, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessCmdKey (ByRef msg As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessCmdKey(System::Windows::Forms::Message % msg, System::Windows::Forms::Keys keyData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="msg" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="msg">Передаваемый по ссылке объект <see cref="T:System.Windows.Forms.Message" />, который представляет сообщение Win32 для обработки.</param>
        <param name="keyData">Одно из значений <see cref="T:System.Windows.Forms.Keys" />, представляющее обрабатываемую клавишу.</param>
        <summary>Обрабатывает клавишу для команд.</summary>
        <returns>
          Значение <see langword="true" />, если нажатие клавиши было обработано и принято элементом управления; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ProcessCmdKey%2A> Метод переопределяет базовый  
  
 <xref:System.Windows.Forms.ContainerControl.ProcessCmdKey%2A?displayProperty=nameWithType> Реализация для предоставления дополнительной обработки ключи команды главного меню и сочетания клавиш MDI.  
  
 Сведения о перехвата нажатия клавиш. в разделе «Как для перехвата нажатия клавиш в элементах управления с помощью Visual C#» и «Способы обработки нажатия клавиш в .NET управляет на языке Visual Basic .NET» в базе знаний Майкрософт в http://support.microsoft.com.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
        <altmember cref="T:System.Windows.Forms.Message" />
        <altmember cref="M:System.Windows.Forms.Form.ProcessDialogKey(System.Windows.Forms.Keys)" />
        <altmember cref="M:System.Windows.Forms.Form.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessMnemonic(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogChar">
      <MemberSignature Language="C#" Value="protected override bool ProcessDialogChar (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessDialogChar(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessDialogChar(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessDialogChar (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessDialogChar(char charCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Символ, подлежащий обработке.</param>
        <summary>Обрабатывает символ диалогового окна.</summary>
        <returns>
          Значение <see langword="true" />, если знак был обработан элементом управления; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessDialogKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessDialogKey (System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessDialogKey(valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessDialogKey(System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessDialogKey (keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessDialogKey(System::Windows::Forms::Keys keyData);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="keyData">Одно из значений <see cref="T:System.Windows.Forms.Keys" />, представляющее обрабатываемую клавишу.</param>
        <summary>Обрабатывает нажатие кнопки диалогового окна.</summary>
        <returns>
          Значение <see langword="true" />, если нажатие клавиши было обработано и принято элементом управления; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ProcessDialogKey%2A> Метод переопределяет базовый <xref:System.Windows.Forms.ContainerControl.ProcessDialogKey%2A?displayProperty=nameWithType> реализацию, предоставляя дополнительную обработку возврата и ESCAPE ключей в диалоговых окнах. Метод не выполняет обработку нажатия клавиш, включающие модификаторы ALT или CONTROL.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessDialogKey(System.Windows.Forms.Keys)" />
        <altmember cref="M:System.Windows.Forms.Form.ProcessDialogChar(System.Char)" />
        <altmember cref="M:System.Windows.Forms.Form.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessMnemonic(System.Char)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessKeyPreview">
      <MemberSignature Language="C#" Value="protected override bool ProcessKeyPreview (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessKeyPreview(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessKeyPreview(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessKeyPreview (ByRef m As Message) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessKeyPreview(System::Windows::Forms::Message % m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Передаваемый по ссылке объект <see cref="T:System.Windows.Forms.Message" />, который представляет сообщение окна для обработки.</param>
        <summary>Выполняет предварительный просмотр сообщения клавиатуры.</summary>
        <returns>
          Значение <see langword="true" />, если сообщение было обработано элементом управления; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.ProcessKeyPreview(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
    <Member MemberName="ProcessMnemonic">
      <MemberSignature Language="C#" Value="protected internal override bool ProcessMnemonic (char charCode);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance bool ProcessMnemonic(char charCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessMnemonic(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function ProcessMnemonic (charCode As Char) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override bool ProcessMnemonic(char charCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="charCode" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="charCode">Символ, подлежащий обработке.</param>
        <summary>Обрабатывает назначенный символ.</summary>
        <returns>
          Значение <see langword="true" />, если символ был обработан элементом управления как назначенный; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProcessTabKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessTabKey (bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessTabKey(bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ProcessTabKey(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessTabKey (forward As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessTabKey(bool forward);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forward">
          Значение <see langword="true" />, чтобы проходить в цикле вперед по элементам управления в ContainerControl; в противном случае значение <see langword="false" />.</param>
        <summary>Выбирает следующий доступный элемент управления и активизирует его.</summary>
        <returns>
          Значение <see langword="true" />, если элемент управления выбран; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ProcessTabKey(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveOwnedForm">
      <MemberSignature Language="C#" Value="public void RemoveOwnedForm (System.Windows.Forms.Form ownedForm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveOwnedForm(class System.Windows.Forms.Form ownedForm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.RemoveOwnedForm(System.Windows.Forms.Form)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveOwnedForm (ownedForm As Form)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveOwnedForm(System::Windows::Forms::Form ^ ownedForm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownedForm" Type="System.Windows.Forms.Form" />
      </Parameters>
      <Docs>
        <param name="ownedForm">Объект <see cref="T:System.Windows.Forms.Form" />, представляющий форму, удаляемую из списка собственных форм для этой формы.</param>
        <summary>Удаляет собственную форму из этой формы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Форма, назначенного форме владельца сохраняется до <xref:System.Windows.Forms.Form.RemoveOwnedForm%2A> вызывается метод. Кроме удаления собственной формы из списка собственной формы, этот метод также устанавливает формы-владельца для `null`.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.AddOwnedForm(System.Windows.Forms.Form)" />
        <altmember cref="P:System.Windows.Forms.Form.Owner" />
        <altmember cref="P:System.Windows.Forms.Form.OwnedForms" />
      </Docs>
    </Member>
    <Member MemberName="ResizeBegin">
      <MemberSignature Language="C#" Value="public event EventHandler ResizeBegin;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ResizeBegin" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.ResizeBegin" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResizeBegin As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ResizeBegin;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда форма входит в режим изменения размеров.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ResizeBegin> Событие возникает, когда пользователь начинает изменять размеры формы, как правило, щелкнув и перетащив один границы или захвата изменения размера, расположенного в правом нижнем углу формы. Это действие переводит форму в цикл модального изменения размеров, до завершения операции изменения размера. Как правило следующий набор событий возникает во время операции изменения размера:  
  
1.  Один <xref:System.Windows.Forms.Form.ResizeBegin> событие возникает при вводе режим изменения размеров формы.  
  
2.  Ноль или более пар <xref:System.Windows.Forms.Control.Resize> и <xref:System.Windows.Forms.Control.SizeChanged> события происходят в том, что и форма <xref:System.Windows.Forms.Form.Size%2A> изменяется.  
  
3.  Один <xref:System.Windows.Forms.Form.ResizeEnd> событие возникает при выходе формы из режима изменения размеров.  
  
> [!NOTE]
>  Просто щелкнуть без перетаскивания на границу или захват для изменения размера создаст <xref:System.Windows.Forms.Form.ResizeBegin> и <xref:System.Windows.Forms.Form.ResizeEnd> события без любого промежуточного <xref:System.Windows.Forms.Control.Resize> и <xref:System.Windows.Forms.Control.SizeChanged> пары событий.  
  
 <xref:System.Windows.Forms.Form.ResizeBegin> И <xref:System.Windows.Forms.Form.ResizeEnd> пары событий также возникает, когда пользователь перемещает формы, как правило, щелкнув и перетащив в заголовке окна. Эти события не создаются путем программного управления формы, например изменив <xref:System.Windows.Forms.Form.Size%2A> или <xref:System.Windows.Forms.Control.Location%2A> свойства.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.Form.ResizeBegin> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.Form> с именем `Form1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.Form.ResizeBegin> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#404](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#404)]
 [!code-vb[System.Windows.Forms.EventExamples#404](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#404)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnResizeBegin(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Form.AutoSize" />
        <altmember cref="P:System.Windows.Forms.Form.ClientSize" />
        <altmember cref="P:System.Windows.Forms.Form.DesktopBounds" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
        <altmember cref="P:System.Windows.Forms.Control.PreferredSize" />
        <altmember cref="P:System.Windows.Forms.Form.Size" />
        <altmember cref="P:System.Windows.Forms.Form.SizeGripStyle" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
        <altmember cref="E:System.Windows.Forms.Form.ResizeEnd" />
        <altmember cref="E:System.Windows.Forms.Control.SizeChanged" />
      </Docs>
    </Member>
    <Member MemberName="ResizeEnd">
      <MemberSignature Language="C#" Value="public event EventHandler ResizeEnd;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ResizeEnd" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.ResizeEnd" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResizeEnd As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ResizeEnd;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при выходе формы из режима изменения размеров.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ResizeEnd> Событие возникает, когда пользователь завершает изменение размера формы, как правило, перетащив один границы или захвата изменения размера, расположенного в правом нижнем углу формы и затем освобождая его. Дополнительные сведения об операции изменения размера см. в разделе <xref:System.Windows.Forms.Form.ResizeBegin> событий.  
  
 <xref:System.Windows.Forms.Form.ResizeEnd> Событие также создается при перемещении формы, как правило, щелкнув и перетащив в заголовке окна. Это событие не формируется программной обработки формы, например изменив <xref:System.Windows.Forms.Form.Size%2A> или <xref:System.Windows.Forms.Control.Location%2A> свойства.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.Form.ResizeEnd> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.Form> с именем `Form1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.Form.ResizeEnd> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#405](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#405)]
 [!code-vb[System.Windows.Forms.EventExamples#405](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#405)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnResizeEnd(System.EventArgs)" />
        <altmember cref="P:System.Windows.Forms.Form.AutoSize" />
        <altmember cref="P:System.Windows.Forms.Form.ClientSize" />
        <altmember cref="P:System.Windows.Forms.Form.DesktopBounds" />
        <altmember cref="P:System.Windows.Forms.Control.Location" />
        <altmember cref="P:System.Windows.Forms.Form.MaximumSize" />
        <altmember cref="P:System.Windows.Forms.Form.MinimumSize" />
        <altmember cref="P:System.Windows.Forms.Control.PreferredSize" />
        <altmember cref="P:System.Windows.Forms.Form.Size" />
        <altmember cref="P:System.Windows.Forms.Form.SizeGripStyle" />
        <altmember cref="E:System.Windows.Forms.Control.Click" />
        <altmember cref="E:System.Windows.Forms.Control.Resize" />
        <altmember cref="E:System.Windows.Forms.Form.ResizeBegin" />
        <altmember cref="E:System.Windows.Forms.Control.SizeChanged" />
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.RestoreBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestoreBounds As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle RestoreBounds { System::Drawing::Rectangle get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает расположение и размеры формы в обычном состоянии окна.</summary>
        <value>Объект <see cref="T:System.Drawing.Rectangle" />, содержащий расположение и размеры формы в обычном состоянии окна.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Как правило, используется <xref:System.Windows.Forms.Form.RestoreBounds%2A> свойство, чтобы отслеживать размер окна пользователя и установите настройки формы в обычном состоянии окна. Необходимо отслеживать значения параметра <xref:System.Windows.Forms.Form.WindowState%2A> и <xref:System.Windows.Forms.Form.RestoreBounds%2A> свойства при отслеживании окна настроек пользователя.  
  
> [!NOTE]
>  Значение <xref:System.Windows.Forms.Form.RestoreBounds%2A> доступен, только если свойство <xref:System.Windows.Forms.Form.WindowState%2A> свойство <xref:System.Windows.Forms.Form> класса не равно <xref:System.Windows.Forms.FormWindowState.Normal>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightToLeftLayout">
      <MemberSignature Language="C#" Value="public virtual bool RightToLeftLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeftLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.RightToLeftLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Property RightToLeftLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool RightToLeftLayout { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, включено ли зеркальное размещение справа налево.</summary>
        <value>
          Значение <see langword="true" />, если включено зеркальное размещение справа налево; в противном случае — <see langword="false" /> для стандартного размещения дочерних элементов управления. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> Свойство в основном полезно для разработки международных форм для всемирной аудитории. Многие формы разработаны, чтобы элементы управления располагаются на форме в форме слева направо. Эти формы совместимы с языками, в которых используется это направление записи. Однако при отображении тех же форм для пользователей языков справа налево, часто бывает предпочтительнее изменить порядок элементов управления в форме. Если оба <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> и <xref:System.Windows.Forms.Control.RightToLeft%2A> свойства `true`, зеркальное отображение будет включена для формы, и размещения элементов управления и потока текста справа налево.  
  
 В отличие от <xref:System.Windows.Forms.Control.RightToLeft%2A>, <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> не наследуется. Если требуется для вступления в силу для дочерних элементов управления, необходимо задать для каждого дочернего элемента управления, должны быть отражены.  
  
 Owner draw не поддерживаются, если <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> равно `Yes`. События рисования владельцем по-прежнему будет выполняться, а поведение любого кода, которые можно создать в этих событиях не определено. Кроме того <xref:System.Windows.Forms.Control.BackgroundImage%2A>, <xref:System.Windows.Forms.Form.Opacity%2A>, <xref:System.Windows.Forms.Form.TransparencyKey%2A>, и события рисования, не поддерживаются.  
  
 <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> И <xref:System.Windows.Forms.Control.RightToLeft%2A> свойства вызывают следующие стили окна API-интерфейса Win32, задаваемый:  
  
-   При <xref:System.Windows.Forms.Control.RightToLeft%2A> равно `Yes` и <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> равно `true`, Windows Forms задает `WS_EX_LAYOUTRTL` стиль окна и удаляет `WS_EX_RIGHT` и `WS_EX_RTLREADING` стили.  
  
-   При <xref:System.Windows.Forms.Control.RightToLeft%2A> равно `Yes` , но <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> равно `No`, Windows Forms задает `WS_EX_RIGHT` и `WS_EX_RTLREADING` стили окна.  
  
 Изменение значения этого свойства вызывает <xref:System.Windows.Forms.Form.RightToLeftLayoutChanged> событий.  
  
 Дополнительные сведения о проблемах глобализации см. в разделе [советы и рекомендации по разработке международных приложений](~/docs/standard/globalization-localization/best-practices-for-developing-world-ready-apps.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.RightToLeft" />
        <altmember cref="Overload:System.Windows.Forms.Control.PerformLayout" />
        <altmember cref="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" />
      </Docs>
    </Member>
    <Member MemberName="RightToLeftLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler RightToLeftLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler RightToLeftLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.RightToLeftLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RightToLeftLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ RightToLeftLayoutChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после изменения значения свойства <see cref="P:System.Windows.Forms.Form.RightToLeftLayout" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Control.RightToLeft%2A> И <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> свойства обычно используются в разработке международных приложений.  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.Form.RightToLeftLayoutChanged> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.Form> с именем `Form1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.Form.RightToLeftLayoutChanged> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#402](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#402)]
 [!code-vb[System.Windows.Forms.EventExamples#402](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#402)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.RightToLeftLayout" />
        <altmember cref="M:System.Windows.Forms.Form.OnRightToLeftLayoutChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ScaleControl">
      <MemberSignature Language="C#" Value="protected override void ScaleControl (System.Drawing.SizeF factor, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ScaleControl(valuetype System.Drawing.SizeF factor, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ScaleControl(System.Drawing.SizeF,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ScaleControl (factor As SizeF, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ScaleControl(System::Drawing::SizeF factor, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="factor" Type="System.Drawing.SizeF" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="factor">Коэффициент масштабирования высоты и ширины элемента управления.</param>
        <param name="specified">Значение <see cref="T:System.Windows.Forms.BoundsSpecified" />, задающее границы элемента управления, используемые для определения его размеров и положения.</param>
        <summary>Выполняет масштабирование расположения, размеров, заполнения и полей элемента управления.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ScaleCore">
      <MemberSignature Language="C#" Value="protected override void ScaleCore (float x, float y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ScaleCore(float32 x, float32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ScaleCore(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ScaleCore (x As Single, y As Single)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ScaleCore(float x, float y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Single" />
        <Parameter Name="y" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="x">Процент масштабирования формы по горизонтали.</param>
        <param name="y">Процент масштабирования формы по вертикали.</param>
        <summary>Выполняет масштабирование формы.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.ScaleCore(System.Single,System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="protected override void Select (bool directed, bool forward);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Select(bool directed, bool forward) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Select(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Select (directed As Boolean, forward As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Select(bool directed, bool forward);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directed" Type="System.Boolean" />
        <Parameter Name="forward" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="directed">Если значение равно true, изменяется активный элемент управления.</param>
        <param name="forward">Если значение параметра directed равно true, это задает направление перемещения фокуса. Если это значение равно <see langword="true" />, выбирается следующий элемент управления; в противном случае выбирается предыдущий элемент управления.</param>
        <summary>Выбирает эту форму, а также дополнительно выбирает следующий или предыдущий элемент управления.</summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения фокуса. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetBoundsCore">
      <MemberSignature Language="C#" Value="protected override void SetBoundsCore (int x, int y, int width, int height, System.Windows.Forms.BoundsSpecified specified);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetBoundsCore(int32 x, int32 y, int32 width, int32 height, valuetype System.Windows.Forms.BoundsSpecified specified) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetBoundsCore (x As Integer, y As Integer, width As Integer, height As Integer, specified As BoundsSpecified)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetBoundsCore(int x, int y, int width, int height, System::Windows::Forms::BoundsSpecified specified);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
        <Parameter Name="specified" Type="System.Windows.Forms.BoundsSpecified" />
      </Parameters>
      <Docs>
        <param name="x">Новое значение свойства <see cref="P:System.Windows.Forms.Control.Left" /> элемента управления.</param>
        <param name="y">Новое значение свойства <see cref="P:System.Windows.Forms.Control.Top" /> элемента управления.</param>
        <param name="width">Новое значение свойства <see cref="P:System.Windows.Forms.Control.Width" /> элемента управления.</param>
        <param name="height">Новое значение свойства <see cref="P:System.Windows.Forms.Control.Height" /> элемента управления.</param>
        <param name="specified">Поразрядное сочетание значений <see cref="T:System.Windows.Forms.BoundsSpecified" />.</param>
        <summary>Задает указанные границы данного элемента управления.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetBoundsCore(System.Int32,System.Int32,System.Int32,System.Int32,System.Windows.Forms.BoundsSpecified)" />
      </Docs>
    </Member>
    <Member MemberName="SetClientSizeCore">
      <MemberSignature Language="C#" Value="protected override void SetClientSizeCore (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetClientSizeCore(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetClientSizeCore(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetClientSizeCore (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetClientSizeCore(int x, int y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Требуемая ширина клиентской области.</param>
        <param name="y">Требуемая высота клиентской области.</param>
        <summary>Задает размер формы для клиента. Это приведет к коррекции границ формы для установки клиентского раздела в качестве требуемого.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Form.ClientSize" />
      </Docs>
    </Member>
    <Member MemberName="SetDesktopBounds">
      <MemberSignature Language="C#" Value="public void SetDesktopBounds (int x, int y, int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDesktopBounds(int32 x, int32 y, int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetDesktopBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDesktopBounds (x As Integer, y As Integer, width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDesktopBounds(int x, int y, int width, int height);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Координата X расположения формы.</param>
        <param name="y">Координата Y расположения формы.</param>
        <param name="width">Ширина формы.</param>
        <param name="height">Высота формы.</param>
        <summary>Задает границы формы в координатах рабочего стола.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Координаты рабочего стола основаны на рабочей области экрана, что исключает панели задач. Этот метод можно использовать для задания положения и размера формы на рабочем столе. Поскольку координаты рабочего стола основаны на рабочей области формы, этот метод можно использовать для обеспечения полностью отображается на рабочем столе в форму.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Windows.Forms.Form.SetDesktopBounds%2A> метода. Чтобы выполнить этот пример, вставьте следующий код в форму, содержащую кнопку с именем `Button2`. Убедитесь, что все события, связанные с их обработчики событий.  
  
 [!code-cpp[System.Windows.Forms.FormExample#2](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CPP/form1.cpp#2)]
 [!code-csharp[System.Windows.Forms.FormExample#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormExample/CS/form1.cs#2)]
 [!code-vb[System.Windows.Forms.FormExample#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormExample/VB/form1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.SetDesktopLocation(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SetDesktopLocation">
      <MemberSignature Language="C#" Value="public void SetDesktopLocation (int x, int y);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDesktopLocation(int32 x, int32 y) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetDesktopLocation(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDesktopLocation (x As Integer, y As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDesktopLocation(int x, int y);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="x" Type="System.Int32" />
        <Parameter Name="y" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="x">Координата X расположения формы.</param>
        <param name="y">Координата Y расположения формы.</param>
        <summary>Задает расположение формы в координатах рабочего стола.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Координаты рабочего стола основаны на рабочей области экрана, что исключает панели задач. Этот метод можно использовать для определения расположения формы на рабочем столе. Поскольку координаты рабочего стола основаны на рабочей области формы, этот метод можно использовать для обеспечения полностью отображается на рабочем столе в форму. Этот метод предназначен для использования главным образом для форм верхнего уровня; Используйте <xref:System.Windows.Forms.Form.LayoutMdi%2A> метод, чтобы изменить расположение дочерних форм многодокументного интерфейса (MDI).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.Form.SetDesktopLocation%2A>, <xref:System.Windows.Forms.Form.Load> и <xref:System.Windows.Forms.Form.Activate%2A> члены. Чтобы запустить пример, вставьте следующий код в форму с именем `Form1` содержит кнопку с именем `Button1` и два `Label` элементов управления `Label1` и `Label2`.  
  
 [!code-cpp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.FormsActivate#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.FormsActivate#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.FormsActivate/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.SetDesktopBounds(System.Int32,System.Int32,System.Int32,System.Int32)" />
        <altmember cref="M:System.Windows.Forms.Form.LayoutMdi(System.Windows.Forms.MdiLayout)" />
      </Docs>
    </Member>
    <Member MemberName="SetVisibleCore">
      <MemberSignature Language="C#" Value="protected override void SetVisibleCore (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void SetVisibleCore(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.SetVisibleCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub SetVisibleCore (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void SetVisibleCore(bool value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">
          Значение <see langword="true" />, чтобы сделать элемент управления видимым; в противном случае — значение <see langword="false" />.</param>
        <summary>Задает для элемента управления указанное видимое состояние.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.SetVisibleCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show (System.Windows.Forms.IWin32Window owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show(class System.Windows.Forms.IWin32Window owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.Show(System.Windows.Forms.IWin32Window)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show (owner As IWin32Window)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show(System::Windows::Forms::IWin32Window ^ owner);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Windows.Forms.IWin32Window" />
      </Parameters>
      <Docs>
        <param name="owner">Любой объект, который реализует <see cref="T:System.Windows.Forms.IWin32Window" />, представляющий окно верхнего уровня, которое станет владельцем этой формы.</param>
        <summary>Показывает форму с указанным владельцем.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для отображения формы немодальном. При использовании этого метода <xref:System.Windows.Forms.Form.Owner%2A> формы свойству `owner`. Форма немодальном можно использовать <xref:System.Windows.Forms.Form.Owner%2A> свойства для получения сведений о владельце формы.  Вызов этого метода эквивалентен параметр <xref:System.Windows.Forms.Form.Owner%2A> свойство немодальном и последующего вызова <xref:System.Windows.Forms.Control.Show> метод.  
  
 Отображение формы эквивалентно заданию для <xref:System.Windows.Forms.Control.Visible%2A> свойства `true`. После <xref:System.Windows.Forms.Form.Show%2A> вызывается метод, <xref:System.Windows.Forms.Control.Visible%2A> свойство возвращает значение `true` до <xref:System.Windows.Forms.Control.Hide%2A> вызывается метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Отображаемая форма уже отображена.  
  
 - или -  
  
 Форма, указанная в параметре <paramref name="owner" />, совпадает с отображаемой формой.  
  
 - или -  
  
 Отображаемая форма отключена.  
  
 - или -  
  
 Отображаемая форма не является окном верхнего уровня.  
  
 - или -  
  
 Отображаемая в виде диалогового окна форма уже является модальной формой.  
  
 - или -  
  
 Текущий процесс не выполняется в интерактивном пользовательском режиме (дополнительные сведения см. в описании свойства <see cref="P:System.Windows.Forms.SystemInformation.UserInteractive" />).</exception>
        <altmember cref="Overload:System.Windows.Forms.Form.ShowDialog" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="P:System.Windows.Forms.Form.WindowState" />
        <altmember cref="P:System.Windows.Forms.Form.ShowInTaskbar" />
        <altmember cref="P:System.Windows.Forms.Form.ShowIcon" />
        <altmember cref="E:System.Windows.Forms.Form.Shown" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ShowDialog">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Отображает форму как модальное диалоговое окно.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DialogResult ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.DialogResult ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ShowDialog" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog () As DialogResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::DialogResult ShowDialog();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DialogResult</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отображает форму как модальное диалоговое окно.</summary>
        <returns>Одно из значений перечисления <see cref="T:System.Windows.Forms.DialogResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для отображения модального диалогового окна в приложении. При вызове этого метода последующий код не выполняется до после закрытия диалоговым окном. Диалоговое окно можно назначить одно из значений <xref:System.Windows.Forms.DialogResult> перечисления путем назначения их <xref:System.Windows.Forms.Button.DialogResult%2A> свойство <xref:System.Windows.Forms.Button> в форме или установив <xref:System.Windows.Forms.Form.DialogResult%2A> свойства формы в коде. Затем это значение возвращается этим методом. Это возвращаемое значение можно использовать для определения способа обработки действий, выполненных в диалоговом окне. Например, если диалоговое окно было закрыто и возвращается `DialogResult.Cancel` значение через этот метод может помешать код, следующий вызов <xref:System.Windows.Forms.Form.ShowDialog%2A> выполнение.  
  
 Если форма отображается как модальное диалоговое окно, нажав кнопку **закрыть** (кнопка со знаком X в правом верхнем углу формы) приводит к скрываться формы и <xref:System.Windows.Forms.Form.DialogResult%2A> свойству будет присвоено `DialogResult.Cancel`. В отличие от форм немодальном <xref:System.Windows.Forms.Form.Close%2A> метод не вызывается платформой .NET Framework, когда пользователь нажимает кнопку закрытия формы диалогового окна или устанавливает значение <xref:System.Windows.Forms.Form.DialogResult%2A> свойства. Вместо этого форма является скрытым и может отображаться без создания нового экземпляра диалогового окна. Поскольку форма отображается как диалоговое окно скрывается вместо закрытия, необходимо вызвать метод <xref:System.Windows.Forms.Control.Dispose%2A> методом формы, когда форма больше не используется приложением.  
  
 Эта версия <xref:System.Windows.Forms.Form.ShowDialog%2A> не указать метод формы или элемента управления его владельцем. При вызове этой версии текущее активное окно становится владельцем диалогового окна. Если вы хотите указать определенного владельца, используйте другую версию этого метода.  
  
   
  
## Examples  
 В следующем примере кода отображает форму как модальное диалоговое окно и вычисляет возвращаемое значение диалогового окна, прежде чем определить, следует ли считать значение <xref:System.Windows.Forms.TextBox> элемента управления в форме диалогового окна. В этом примере требуется, <xref:System.Windows.Forms.Form> с именем `testDialog` создается и что он содержит <xref:System.Windows.Forms.TextBox> управления с именем `TextBox1`. Кроме того, в примере требуется, в данном примере кода содержится и вызывается из другого <xref:System.Windows.Forms.Form> для отображения `testDialog` как модальное диалоговое окно. В примере используется версия <xref:System.Windows.Forms.Form.ShowDialog%2A> , указывающая владельца диалогового окна.  
  
 [!code-cpp[Classic Form.ShowDialog Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ShowDialog Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ShowDialog Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ShowDialog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Отображаемая форма уже отображена.  
  
 - или -  
  
 Отображаемая форма отключена.  
  
 - или -  
  
 Отображаемая форма не является окном верхнего уровня.  
  
 - или -  
  
 Отображаемая в виде диалогового окна форма уже является модальной формой.  
  
 - или -  
  
 Текущий процесс не выполняется в интерактивном пользовательском режиме (дополнительные сведения см. в описании свойства <see cref="P:System.Windows.Forms.SystemInformation.UserInteractive" />).</exception>
        <altmember cref="P:System.Windows.Forms.Form.DialogResult" />
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.DialogResult ShowDialog (System.Windows.Forms.IWin32Window owner);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Forms.DialogResult ShowDialog(class System.Windows.Forms.IWin32Window owner) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ShowDialog(System.Windows.Forms.IWin32Window)" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog (owner As IWin32Window) As DialogResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::DialogResult ShowDialog(System::Windows::Forms::IWin32Window ^ owner);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DialogResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="owner" Type="System.Windows.Forms.IWin32Window" />
      </Parameters>
      <Docs>
        <param name="owner">Любой объект, который реализует <see cref="T:System.Windows.Forms.IWin32Window" />, представляющий окно верхнего уровня, которое станет владельцем модального диалогового окна.</param>
        <summary>Отображает эту форму в виде модального диалогового окна с указанным владельцем.</summary>
        <returns>Одно из значений перечисления <see cref="T:System.Windows.Forms.DialogResult" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для отображения модального диалогового окна в приложении. При вызове этого метода последующий код не выполняется до после закрытия диалоговым окном. Диалоговое окно можно назначить одно из значений <xref:System.Windows.Forms.DialogResult> путем назначения их <xref:System.Windows.Forms.Button.DialogResult%2A> свойство <xref:System.Windows.Forms.Button> в форме или установив <xref:System.Windows.Forms.Form.DialogResult%2A> свойства формы в коде. Затем это значение возвращается этим методом. Это возвращаемое значение можно использовать для определения способа обработки действий, выполненных в диалоговом окне. Например, если диалоговое окно было закрыто и возвращается `DialogResult.Cancel` значение через этот метод может помешать код, следующий вызов <xref:System.Windows.Forms.Form.ShowDialog%2A> выполнение.  
  
 Если форма отображается как модальное диалоговое окно, нажав кнопку **закрыть** (кнопка со знаком X в правом верхнем углу формы) приводит к скрываться формы и <xref:System.Windows.Forms.Form.DialogResult%2A> свойству будет присвоено `DialogResult.Cancel`. В отличие от немодальных форм <xref:System.Windows.Forms.Form.Close%2A> метод не вызывается платформой .NET Framework, когда пользователь нажимает кнопку закрытия формы диалогового окна или устанавливает значение <xref:System.Windows.Forms.Form.DialogResult%2A> свойства. Вместо этого форма является скрытым и может отображаться без создания нового экземпляра диалогового окна. Поскольку форма отображается как диалоговое окно скрывается вместо закрытия, необходимо вызвать метод <xref:System.Windows.Forms.Control.Dispose%2A> методом формы, когда форма больше не используется приложением.  
  
 Эта версия <xref:System.Windows.Forms.Form.ShowDialog%2A> метод позволяет указать определенной формы, которая будет владеть диалоговым окном, которое отображается.  
  
   
  
## Examples  
 В следующем примере кода отображает форму как модальное диалоговое окно и вычисляет возвращаемое значение диалогового окна, прежде чем определить, следует ли считать значение <xref:System.Windows.Forms.TextBox> элемента управления в форме диалогового окна. В этом примере требуется, <xref:System.Windows.Forms.Form> с именем `Form2` создается и что он содержит <xref:System.Windows.Forms.TextBox> управления с именем `TextBox1`. В примере используется версия <xref:System.Windows.Forms.Form.ShowDialog%2A> , указывающая владельца диалогового окна.  
  
 [!code-cpp[Classic Form.ShowDialog Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.ShowDialog Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.ShowDialog Example/CS/source.cs#1)]
 [!code-vb[Classic Form.ShowDialog Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.ShowDialog Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Форма, указанная в параметре <paramref name="owner" />, совпадает с отображаемой формой.</exception>
        <exception cref="T:System.InvalidOperationException">Отображаемая форма уже отображена.  
  
 - или -  
  
 Отображаемая форма отключена.  
  
 - или -  
  
 Отображаемая форма не является окном верхнего уровня.  
  
 - или -  
  
 Отображаемая в виде диалогового окна форма уже является модальной формой.  
  
 - или -  
  
 Текущий процесс не выполняется в интерактивном пользовательском режиме (дополнительные сведения см. в описании свойства <see cref="P:System.Windows.Forms.SystemInformation.UserInteractive" />).</exception>
        <altmember cref="P:System.Windows.Forms.Form.DialogResult" />
      </Docs>
    </Member>
    <Member MemberName="ShowIcon">
      <MemberSignature Language="C#" Value="public bool ShowIcon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowIcon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ShowIcon" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowIcon As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowIcon { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, отображать ли значок в строке заголовка формы.</summary>
        <value>
          Значение <see langword="true" />, если в строке заголовка формы отображается значок; в противном случае — <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.ShowIcon%2A> Свойство содержит <xref:System.Boolean> значение, указывающее, является ли форма <xref:System.Windows.Forms.Form.Icon%2A> отображается в строке заголовка формы. Если <xref:System.Windows.Forms.Form.ControlBox%2A> свойство `false`, значок и управления поле, будут блокироваться.  
  
 Если <xref:System.Windows.Forms.Form.ShowIcon%2A> — `false` при отображении основная форма универсальный значок будет отображаться на кнопке панели задач для приложения.  
  
 Это свойство имеет смысл, если <xref:System.Windows.Forms.Form.FormBorderStyle%2A> равно <xref:System.Windows.Forms.FormBorderStyle.FixedDialog>. В этом случае в форме не отображаться значок.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.Icon" />
        <altmember cref="P:System.Windows.Forms.Form.ShowInTaskbar" />
        <altmember cref="P:System.Windows.Forms.Form.FormBorderStyle" />
        <altmember cref="P:System.Windows.Forms.Form.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ShowInTaskbar" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowInTaskbar As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowInTaskbar { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, отображается ли форма в панели задач Windows.</summary>
        <value>
          Значение <see langword="true" />, если форма должна отображаться в панели задач Windows во время выполнения; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если форма порождается в другой форме, порождаемая форма не отображается на панели задач Windows.  
  
 Это свойство можно использовать, чтобы запретить пользователям выбор формы с помощью панели задач Windows. Например если в приложении отображается окно инструментов поиска и замены, может потребоваться предотвращении этого окна выбора с помощью панели задач Windows, так как потребуется главное окно приложения и окно инструментов поиск и замена отображается для соответствующей обработки поиска.  
  
 Часто требуется использовать это свойство при создании формы с <xref:System.Windows.Forms.FormBorderStyle.FixedToolWindow> стиля. Параметр <xref:System.Windows.Forms.FormBorderStyle.FixedToolWindow> стиль не отдельно гарантирует, что окна не будут отображаться в панели задач.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.Form.ShowInTaskbar%2A> свойство для создания диалогового окна, не отображается на панели задач Windows.  
  
 [!code-cpp[Form.ShowInTaskbar#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.ShowInTaskbar/CPP/form1.cpp#1)]
 [!code-csharp[Form.ShowInTaskbar#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.ShowInTaskbar/CS/form1.cs#1)]
 [!code-vb[Form.ShowInTaskbar#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.ShowInTaskbar/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Shown">
      <MemberSignature Language="C#" Value="public event EventHandler Shown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Shown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.Shown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Shown As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Shown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при первом отображении формы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.Shown> Событие вызывается только при первом отображении формы; впоследствии сводя к минимуму, развертывание, восстановление, скрытие, отображение, перерисовка и Отмена не создает этого события. Дополнительные сведения о порядке событий формы см. в разделе [порядок событий в Windows Forms](~/docs/framework/winforms/order-of-events-in-windows-forms.md).  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.Form.Shown> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.Form> с именем `Form1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.Form.Shown> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#403](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#403)]
 [!code-vb[System.Windows.Forms.EventExamples#403](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#403)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.Form.OnShown(System.EventArgs)" />
        <altmember cref="Overload:System.Windows.Forms.Form.Show" />
        <altmember cref="M:System.Windows.Forms.Form.Close" />
        <altmember cref="P:System.Windows.Forms.Control.Visible" />
        <altmember cref="M:System.Windows.Forms.Control.Hide" />
        <altmember cref="E:System.Windows.Forms.Form.Load" />
        <altmember cref="E:System.Windows.Forms.Form.Activated" />
        <altmember cref="E:System.Windows.Forms.Form.FormClosing" />
        <altmember cref="E:System.Windows.Forms.Form.FormClosed" />
        <altmember cref="M:System.Windows.Forms.Form.LayoutMdi(System.Windows.Forms.MdiLayout)" />
        <altmember cref="E:System.Windows.Forms.Control.Paint" />
      </Docs>
    </Member>
    <Member MemberName="ShowWithoutActivation">
      <MemberSignature Language="C#" Value="protected virtual bool ShowWithoutActivation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowWithoutActivation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.ShowWithoutActivation" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property ShowWithoutActivation As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool ShowWithoutActivation { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, будет ли окно активироваться при его отображении.</summary>
        <value>
          Значение <see langword="True" />, если окно не будет активировано при отображении; в противном случае — <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство используется в том случае, если нужно показать окно верхнего уровня, но не следует прерывать работу пользователя путем перевода фокуса ввода из текущего окна. Это может быть информационным всплывающим окном или всплывающего окна, такие как палитра "Сервис" в приложении Paint.  
  
 Так как это свойство доступно только для чтения, его значение можно изменить только путем переопределения <xref:System.Windows.Forms.Form.ShowWithoutActivation%2A> в собственную форму и программирования на возврат `true`.  
  
 Если окно не активируется должен использовать элементы управления пользовательского интерфейса, можно использовать <xref:System.Windows.Forms.ToolStrip> элементы управления, такие как <xref:System.Windows.Forms.ToolStripDropDown>. Эти элементы управления без окон и не приведет к активации при их выборе окна.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Windows.Forms.Form.Show" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public System.Drawing.Size Size { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size Size" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Size" />
      <MemberSignature Language="VB.NET" Value="Public Property Size As Size" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Size Size { System::Drawing::Size get(); void set(System::Drawing::Size value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает размер формы.</summary>
        <value>Объект <see cref="T:System.Drawing.Size" />, представляющий размер формы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство можно задать высоту и ширину (в пикселях) формы, в то же время, а не параметр <xref:System.Windows.Forms.Control.Height%2A> и <xref:System.Windows.Forms.Control.Width%2A> свойства по отдельности. Если вы хотите установить размер и расположение формы, можно использовать <xref:System.Windows.Forms.Form.DesktopBounds%2A> на основе свойства для размера и расположения формы в координатах рабочего стола или используйте <xref:System.Windows.Forms.Control.Bounds%2A> свойства <xref:System.Windows.Forms.Control> задать размер и расположение формы на основе координат экрана inates.  
  
> [!NOTE]
>  Максимальное значение этого свойства ограничено разрешения экрана, на котором выполняется формы. Значение не может превышать 12 точек выше каждого размера экрана (горизонтальная + 12 и вертикальной + 12).  
  
> [!NOTE]
>  На устройствах Pocket PC размерах окна можно создать, присвоив <xref:System.Windows.Forms.Form.FormBorderStyle%2A> для `None` и удаление любого <xref:System.Windows.Forms.MainMenu> элемента управления. На устройствах смартфон, никогда не может изменить размер <xref:System.Windows.Forms.Form> -всегда заполнит весь экран.  
  
   
  
## Examples  
 В следующем примере кода показано, как создать форму, которая отображается с уровнем непрозрачности 75 процентов. В примере кода создается новая форма, размещенная в центре экрана с <xref:System.Windows.Forms.Form.Opacity%2A> задать свойство, чтобы изменить уровень непрозрачности формы. В примере кода также задает <xref:System.Windows.Forms.Form.Size%2A> свойства для обеспечения увеличения размера формы по сравнению с размером по умолчанию формы. В этом примере требуется, что метод, определенный в этом примере вызывается из другой формы в обработчик событий или другой метод.  
  
 [!code-cpp[Form.Opacity#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Opacity/CPP/form1.cpp#1)]
 [!code-csharp[Form.Opacity#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Opacity/CS/form1.cs#1)]
 [!code-vb[Form.Opacity#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Opacity/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Control.Width" />
        <altmember cref="P:System.Windows.Forms.Control.Height" />
        <altmember cref="P:System.Windows.Forms.Form.DesktopBounds" />
        <altmember cref="P:System.Windows.Forms.Control.Bounds" />
      </Docs>
    </Member>
    <Member MemberName="SizeGripStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.SizeGripStyle SizeGripStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.SizeGripStyle SizeGripStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.SizeGripStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property SizeGripStyle As SizeGripStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::SizeGripStyle SizeGripStyle { System::Windows::Forms::SizeGripStyle get(); void set(System::Windows::Forms::SizeGripStyle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.SizeGripStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает стиль захвата для изменения размера, отображаемого в правом нижнем углу формы.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.SizeGripStyle" />, представляющий стиль отображаемого захвата для изменения размера окна. Значение по умолчанию — <see cref="F:System.Windows.Forms.SizeGripStyle.Auto" /></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство позволяет определить, когда захват для изменения размера отображается в форме. Можно задать это свойство для отображения захвата для изменения размера или иметь он автоматически отображается в зависимости от настройки <xref:System.Windows.Forms.Form.FormBorderStyle%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода показано, как скрыть захвата для изменения размера <xref:System.Windows.Forms.Form> при <xref:System.Windows.Forms.Form> которого не изменяются.  
  
 [!code-cpp[Form.SizeGripStyle#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.SizeGripStyle/CPP/form1.cpp#1)]
 [!code-csharp[Form.SizeGripStyle#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.SizeGripStyle/CS/form1.cs#1)]
 [!code-vb[Form.SizeGripStyle#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.SizeGripStyle/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Заданное значение находится вне диапазона допустимых значений.</exception>
        <altmember cref="P:System.Windows.Forms.Form.FormBorderStyle" />
        <altmember cref="T:System.Windows.Forms.SizeGripStyle" />
      </Docs>
    </Member>
    <Member MemberName="StartPosition">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.FormStartPosition StartPosition { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.FormStartPosition StartPosition" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.StartPosition" />
      <MemberSignature Language="VB.NET" Value="Public Property StartPosition As FormStartPosition" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::FormStartPosition StartPosition { System::Windows::Forms::FormStartPosition get(); void set(System::Windows::Forms::FormStartPosition value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormStartPosition</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает начальное положение формы в режиме выполнения.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.FormStartPosition" />, представляющий начальное положение формы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство позволяет установить начальное положение формы при отображении во время выполнения. Положение формы можно указать вручную, задав <xref:System.Windows.Forms.Form.Location%2A> свойства или использовать папку по умолчанию, указанную операционной системой Windows. Также можно разместить в форму для отображения в центре экрана или в центре ее родительской формы например дочерних форм многодокументного интерфейса (MDI).  
  
 Это свойство должно быть установлено перед отображением формы.  Это свойство можно задать до вызова <xref:System.Windows.Forms.Form.Show%2A> или <xref:System.Windows.Forms.Form.ShowDialog%2A> метода или в конструкторе формы.  
  
   
  
## Examples  
 В следующем примере кода создается новый экземпляр <xref:System.Windows.Forms.Form> и вызывает <xref:System.Windows.Forms.Form.ShowDialog%2A> метод для отображения формы в виде диалогового окна. В примере устанавливается <xref:System.Windows.Forms.Form.FormBorderStyle%2A>, <xref:System.Windows.Forms.Form.AcceptButton%2A>, <xref:System.Windows.Forms.Form.CancelButton%2A>, и <xref:System.Windows.Forms.Form.StartPosition%2A> свойства, чтобы изменить внешний вид и функциональные возможности формы диалогового окна. В примере также используется <xref:System.Windows.Forms.Form.ControlCollection.Add%2A> методом формы <xref:System.Windows.Forms.Control.Controls%2A> коллекции для добавления двух <xref:System.Windows.Forms.Button> элементов управления. В этом примере <xref:System.Windows.Forms.Form.HelpButton%2A> свойство для отображения кнопки справки в строке заголовка диалогового окна.  
  
 [!code-cpp[Classic Form.StartPosition Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.StartPosition Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.StartPosition Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.StartPosition Example/CS/source.cs#1)]
 [!code-vb[Classic Form.StartPosition Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.StartPosition Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Заданное значение находится вне диапазона допустимых значений.</exception>
        <altmember cref="T:System.Windows.Forms.FormStartPosition" />
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public int TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TabIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property TabIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int TabIndex { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает последовательность перехода по клавише TAB между элементами управления внутри контейнера.</summary>
        <value>Значение <see cref="T:System.Int32" />, содержащее индекс элемента управления внутри набора элементов управления в контейнере, включенных в последовательность табуляции.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Формы не включены в последовательности табуляции. Параметр <xref:System.Windows.Forms.Form.TabIndex%2A> свойство не выполняет никаких действий.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIndexChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabIndexChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabIndexChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.TabIndexChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabIndexChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabIndexChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении значения свойства <see cref="P:System.Windows.Forms.Form.TabIndex" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TabStop">
      <MemberSignature Language="C#" Value="public bool TabStop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TabStop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TabStop" />
      <MemberSignature Language="VB.NET" Value="Public Property TabStop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TabStop { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.DispId(-516)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, может ли пользователь перевести фокус на данный элемент управления при помощи клавиши TAB.</summary>
        <value>
          Значение <see langword="true" />, если с помощью клавиши TAB можно перевести фокус на элемент управления; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TabStopChanged">
      <MemberSignature Language="C#" Value="public event EventHandler TabStopChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler TabStopChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.Form.TabStopChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TabStopChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ TabStopChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении свойства <see cref="P:System.Windows.Forms.Form.TabStop" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.SettingsBindable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает текст, связанный с этим элементом управления.</summary>
        <value>Текст, связанный с этим элементом управления.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.Text" />
      </Docs>
    </Member>
    <Member MemberName="TopLevel">
      <MemberSignature Language="C#" Value="public bool TopLevel { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TopLevel" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TopLevel" />
      <MemberSignature Language="VB.NET" Value="Public Property TopLevel As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TopLevel { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее режим отображения формы в качестве окна верхнего уровня.</summary>
        <value>
          <see langword="true" /> для отображения формы в качестве окна верхнего уровня; в противном случае — <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Формы верхнего уровня — это окно, которое не имеет родительской формы, или, родительская форма которого является окном рабочего стола. Окон верхнего уровня обычно используется в качестве главной формы приложения.  
  
   
  
## Examples  
 В следующем примере кода, например, используйте <xref:System.Windows.Forms.Form.Modal%2A> свойство, чтобы определить, если форма отображается как модальная. Если это не <xref:System.Windows.Forms.Form.FormBorderStyle%2A> и <xref:System.Windows.Forms.Form.TopLevel%2A> изменяются свойства, чтобы форма формы верхнего уровня с границей окна инструментов.  
  
 [!code-cpp[Form.Modal#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.Modal/CPP/form1.cpp#1)]
 [!code-csharp[Form.Modal#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.Modal/CS/form1.cs#1)]
 [!code-vb[Form.Modal#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.Modal/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Exception">Необходимо, чтобы родительская MDI-форма являлась окном верхнего уровня.</exception>
        <altmember cref="P:System.Windows.Forms.Form.TopMost" />
      </Docs>
    </Member>
    <Member MemberName="TopMost">
      <MemberSignature Language="C#" Value="public bool TopMost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool TopMost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TopMost" />
      <MemberSignature Language="VB.NET" Value="Public Property TopMost As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool TopMost { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, отображать ли форму как форму переднего плана.</summary>
        <value>
          Значение <see langword="true" /> для отображения формы как формы переднего плана; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Формы переднего плана — это форма, перекрывающая все (не верхний) формы, даже если она не активна или формы. Формы переднего плана всегда отображаются в самой верхней точке z порядка окон на рабочем столе. Это свойство можно использовать для создания формы, которая всегда отображается в приложении, такие как окна инструментов поиска и замены.  
  
   
  
## Examples  
 В следующем примере кода показано, как создать форму переднего плана. В примере создается две формы, один из которых развернута, а другой будет отображаться как форму переднего плана. Первая форма с именем `bottomForm`, отображается развернутой с помощью <xref:System.Windows.Forms.Form.WindowState%2A> свойство для лучшей демонстрации возможностей формы переднего плана. Вторая форма, с именем `topMostForm`, задает <xref:System.Windows.Forms.Form.TopMost%2A> свойства `true` для отображения формы как формы переднего плана. При выполнении этого кода, щелкнув на развернутой форме не вызовет формы переднего плана для отображения под развернутой формой. В примере предполагается, что метод, определенный в примере вызывается из другой формы.  
  
 [!code-cpp[Form.TopMost#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Form.TopMost/CPP/form1.cpp#1)]
 [!code-csharp[Form.TopMost#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Form.TopMost/CS/form1.cs#1)]
 [!code-vb[Form.TopMost#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Form.TopMost/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.Form.TopLevel" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает строку, представляющую текущий экземпляр формы.</summary>
        <returns>Строка, состоящая из полного имени класса объекта формы со свойством формы <see cref="P:System.Windows.Forms.Form.Text" /> в конце. Например, если эта форма является производной из класса <c>MyForm</c> в пространстве имен <c>MyNamespace</c> и значение свойства <see cref="P:System.Windows.Forms.Form.Text" /> равно <c>Hello, World</c>, этот метод будет возвращать <c>MyNamespace.MyForm, Text: Hello, World</c>.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TransparencyKey">
      <MemberSignature Language="C#" Value="public System.Drawing.Color TransparencyKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color TransparencyKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.TransparencyKey" />
      <MemberSignature Language="VB.NET" Value="Public Property TransparencyKey As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color TransparencyKey { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает цвет, представляющий прозрачные области формы.</summary>
        <value>Объект <see cref="T:System.Drawing.Color" />, представляющий цвет прозрачных областей на форме.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Windows.Forms.Form.TransparencyKey%2A> присваивается <xref:System.Drawing.Color>, области формы с одинаковым <xref:System.Windows.Forms.Control.BackColor%2A> отображаются прозрачными. Любые действия с мышью, например, щелчок мышью, выполняемые на прозрачные области формы будут передаваться окна, расположенные под прозрачной областью. Например если клиентская область формы прозрачна, щелчок мышью на этой области отправит уведомление о событии щелчка любого окна, расположенные под ней. Если назначено цвет <xref:System.Windows.Forms.Form.TransparencyKey%2A> имеет то же, как все элементы управления на форме, они также отображаются прозрачными. Например, если у вас есть <xref:System.Windows.Forms.Button> элемента управления в форме, которая содержит его <xref:System.Windows.Forms.Form.TransparencyKey%2A> свойство `SystemColors.Control`, элемент управления отображается прозрачно Если <xref:System.Windows.Forms.Control.BackColor%2A> свойства <xref:System.Windows.Forms.Button> элемента управления изменяется цвет.  
  
 Данное свойство не поддерживается при <xref:System.Windows.Forms.Form.RightToLeftLayout%2A> — `true`.  
  
   
  
## Examples  
 В следующем примере кода создается окно, имеющее прозрачную клиентскую область независимо от того, цвет фона формы. В этом примере требуется, что в примере метод определен внутри класса формы.  
  
 [!code-cpp[Classic Form.TransparencyKey Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Form.TransparencyKey Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Form.TransparencyKey Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Form.TransparencyKey Example/CS/source.cs#1)]
 [!code-vb[Classic Form.TransparencyKey Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Form.TransparencyKey Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultButton">
      <MemberSignature Language="C#" Value="protected override void UpdateDefaultButton ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void UpdateDefaultButton() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.UpdateDefaultButton" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub UpdateDefaultButton ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void UpdateDefaultButton();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Обновляет сведения о том, какая кнопка является кнопкой по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.Form.UpdateDefaultButton%2A> Метод определяет, какие кнопки в форме вызывает его события щелчка кнопкой мыши, когда пользователь нажимает клавишу ВВОД, в соответствии с приоритетом следующие:  
  
1.  Если <xref:System.Windows.Forms.ContainerControl.ActiveControl%2A> реализует свойство <xref:System.Windows.Forms.IButtonControl> интерфейс, что элемент управления является кнопкой по умолчанию.  
  
2.  <xref:System.Windows.Forms.Form.AcceptButton%2A> Свойство является кнопкой по умолчанию.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.ContainerControl.ActiveControl" />
        <altmember cref="P:System.Windows.Forms.Form.AcceptButton" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ValidateChildren">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Проверяет все доступные для выбора дочерние элементы управления в форме.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ValidateChildren">
      <MemberSignature Language="C#" Value="public override bool ValidateChildren ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool ValidateChildren() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ValidateChildren" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ValidateChildren () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool ValidateChildren();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Заставляет все дочерние элементы управления в поддерживающем проверку элементе управления проверить свои данные.</summary>
        <returns>
          Значение <see langword="true" />, если все дочерние объекты были успешно проверены; в противном случае значение <see langword="false" />. При вызове из обработчиков событий <see cref="E:System.Windows.Forms.Control.Validating" /> или <see cref="E:System.Windows.Forms.Control.Validated" /> этот метод всегда будет возвращать значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ValidateChildren" />
      </Docs>
    </Member>
    <Member MemberName="ValidateChildren">
      <MemberSignature Language="C#" Value="public override bool ValidateChildren (System.Windows.Forms.ValidationConstraints validationConstraints);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool ValidateChildren(valuetype System.Windows.Forms.ValidationConstraints validationConstraints) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.ValidateChildren(System.Windows.Forms.ValidationConstraints)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool ValidateChildren(System::Windows::Forms::ValidationConstraints validationConstraints);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Always)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="validationConstraints" Type="System.Windows.Forms.ValidationConstraints" />
      </Parameters>
      <Docs>
        <param name="validationConstraints">Устанавливает ограничения на вызов события <see cref="E:System.Windows.Forms.Control.Validating" /> элементами управления.</param>
        <summary>Заставляет все дочерние элементы управления в поддерживающем проверку элементе управления проверить свои данные.</summary>
        <returns>
          Значение <see langword="true" />, если все дочерние объекты были успешно проверены; в противном случае значение <see langword="false" />. При вызове из обработчиков событий <see cref="E:System.Windows.Forms.Control.Validating" /> или <see cref="E:System.Windows.Forms.Control.Validated" /> этот метод всегда будет возвращать значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.ValidateChildren(System.Windows.Forms.ValidationConstraints)" />
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.FormWindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.FormWindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.Form.WindowState" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowState As FormWindowState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::FormWindowState WindowState { System::Windows::Forms::FormWindowState get(); void set(System::Windows::Forms::FormWindowState value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.FormWindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, находится ли форма в свернутом, развернутом или обычном состоянии.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.FormWindowState" />, который представляет свернута ли форма, развернута на весь экран или находится в обычном состоянии. Значение по умолчанию: <see langword="FormWindowState.Normal" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Перед отображением формы <xref:System.Windows.Forms.Form.WindowState%2A> свойство всегда имеет значение `FormWindowState.Normal`, независимо от начальной установки. Это отражено в <xref:System.Windows.Forms.Control.Height%2A>, <xref:System.Windows.Forms.Control.Left%2A>, <xref:System.Windows.Forms.Control.Top%2A>, и <xref:System.Windows.Forms.Control.Width%2A> параметры свойств. Если формы скрыт после его показали, эти свойства отражают предыдущее состояние, пока форма отображается еще раз, независимо от того, любые изменения, внесенные <xref:System.Windows.Forms.Form.WindowState%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода показано, как задать <xref:System.Windows.Forms.Form.WindowState%2A> в развернутом виде. Данный код вызывается из <xref:System.Windows.Forms.Form.Shown> обработчик событий после создания формы.  
  
```csharp  
private void Form1_Shown(object sender, EventArgs e)  
        {  
            this.WindowState = System.Windows.Forms.FormWindowState.Maximized;  
        }  
```  
  
```vb  
Private  Sub Form1_Shown(ByVal sender As Object, ByVal e As EventArgs)  
            Me.WindowState = System.Windows.Forms.FormWindowState.Maximized  
End Sub  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Заданное значение находится вне диапазона допустимых значений.</exception>
        <altmember cref="T:System.Windows.Forms.FormWindowState" />
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.Form.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void WndProc(System::Windows::Forms::Message % m);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Сообщение <see cref="T:System.Windows.Forms.Message" /> Windows для обработки.</param>
        <summary>Обрабатывает сообщения Windows.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.ContainerControl.WndProc(System.Windows.Forms.Message@)" />
      </Docs>
    </Member>
  </Members>
</Type>