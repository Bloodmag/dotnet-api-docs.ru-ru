<Type Name="HtmlDocument" FullName="System.Windows.Forms.HtmlDocument">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6d6ea42599f937798371ada9988169189c5fb02d" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30641138" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HtmlDocument" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HtmlDocument extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.HtmlDocument" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HtmlDocument" />
  <TypeSignature Language="C++ CLI" Value="public ref class HtmlDocument sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Обеспечивает программный доступ верхнего уровня к HTML-документу, который размещается в элементе управления <see cref="T:System.Windows.Forms.WebBrowser" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument> Предоставляет управляемую оболочку вокруг объекта документов Internet Explorer, также известные как HTML документа объектной модели (DOM). Получение экземпляра <xref:System.Windows.Forms.HtmlDocument> через <xref:System.Windows.Forms.WebBrowser.Document%2A> свойства <xref:System.Windows.Forms.WebBrowser> элемента управления.  
  
 HTML-теги в HTML-документа могут быть вложенными друг в друга. <xref:System.Windows.Forms.HtmlDocument> Таким образом представляет дерева документов, дочерние элементы которого являются экземплярами из <xref:System.Windows.Forms.HtmlElement> класса. В следующем примере кода показан простой HTML-файл.  
  
```  
<HTML>  
    <BODY>  
        <DIV name="Span1">Simple HTML Form</DIV>  
        <FORM>  
            <SPAN name="TextLabel">Enter Your Name:</SPAN>  
            <INPUT type="text" size="20" name="Text1">  
        </FORM>  
    </BODY>  
</HTML>  
```  
  
 В этом примере <xref:System.Windows.Forms.HtmlDocument> представляет весь документ внутри `HTML` тегов. `BODY`, `DIV`, `FORM` И `SPAN` теги представлены отдельные <xref:System.Windows.Forms.HtmlElement> объектов.  
  
 Существует несколько способов получить доступ к элементам в этом дереве. Используйте <xref:System.Windows.Forms.HtmlDocument.Body%2A> свойство для доступа к `BODY` тег и всех его дочерних элементов. <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> Предоставляет свойство <xref:System.Windows.Forms.HtmlElement> для элемента на странице HTML, который имеет фокус ввода. Все элементы HTML-страницы могут иметь имя; <xref:System.Windows.Forms.HtmlDocument.All%2A> коллекции обеспечивает доступ к каждому <xref:System.Windows.Forms.HtmlElement> по имени в качестве индекса. <xref:System.Windows.Forms.HtmlDocument.GetElementsByTagName%2A> Возвращает <xref:System.Windows.Forms.HtmlElementCollection> всех <xref:System.Windows.Forms.HtmlElement> объекты заданного имени тега HTML, такие как `DIV` или `TABLE`. <xref:System.Windows.Forms.HtmlDocument.GetElementById%2A> Возвращает один <xref:System.Windows.Forms.HtmlElement> соответствующий уникальный идентификатор, указываемое. <xref:System.Windows.Forms.HtmlDocument.GetElementFromPoint%2A> Возвращает <xref:System.Windows.Forms.HtmlElement> , можно найти на экране указанного координатам указателя.  
  
 Можно также использовать <xref:System.Windows.Forms.HtmlDocument.Forms%2A> и <xref:System.Windows.Forms.HtmlDocument.Images%2A> коллекции для перебора элементов этого пользователя представляют ввода формы или изображения, соответственно.  
  
 <xref:System.Windows.Forms.HtmlDocument> основан на неуправляемые интерфейсы, реализованные в Internet Explorer DHTML DOM: `IHTMLDocument`, `IHTMLDocument2`, `IHTMLDocument3`, и `IHTMLDocument4`. Только наиболее часто используемые свойства и методы в эти неуправляемые интерфейсы, предоставляемые <xref:System.Windows.Forms.HtmlDocument>. Можно получить доступ к все свойства и методы непосредственно с помощью <xref:System.Windows.Forms.HtmlDocument.DomDocument%2A> свойство, которое можно привести к указателю нужного неуправляемый интерфейс.  
  
 HTML-документ может содержать кадры, которые находятся в различных окнах внутри <xref:System.Windows.Forms.WebBrowser> элемента управления. Каждый кадр отображает собственную HTML-страницу. <xref:System.Windows.Forms.HtmlWindow.Frames%2A> Коллекции доступна через <xref:System.Windows.Forms.HtmlDocument.Window%2A> свойство. Можно также использовать <xref:System.Windows.Forms.HtmlDocument.Window%2A> свойства для изменения размера отображаемой страницы, прокрутить документ или отображения предупреждений и предлагает пользователю.  
  
 <xref:System.Windows.Forms.HtmlDocument> предоставляет наиболее распространенные события, необходимые для обработки при размещении HTML-страниц. Для событий, не доступные непосредственно в интерфейсе, можно добавить обработчик для события с помощью <xref:System.Windows.Forms.HtmlDocument.AttachEventHandler%2A>.  
  
 HTML-файлы могут содержать `SCRIPT` теги, которые содержат код, написанный на одном из языков активных сценариев, таких как JScript или VBScript. <xref:System.Windows.Forms.HtmlDocument.InvokeScript%2A> Предоставляет метод для выполнения свойств и методов, определенных в `SCRIPT` тег.  
  
> [!NOTE]
>  Хотя большинство свойств, методов и событий на <xref:System.Windows.Forms.HtmlDocument> имеют сохранены те же имена, у них на неуправляемый DOM, некоторые были изменены для обеспечения согласованности с [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].  
  
   
  
## Examples  
 В следующем примере кода использует данные из базы данных "Борей" для создания `HTML TABLE` динамически с помощью <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A>. <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> Метод также позволяет, сначала добавить ячейки (`TD` элементы) для строк (`TR` элементов), то для добавления строк в таблице и, наконец, для добавления таблицы в конец текущего документа. В примере кода требуется наличие приложения <xref:System.Windows.Forms.WebBrowser> управления с именем `WebBrowser1`. Код должен вызываться после загрузки документа.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#10)]
 [!code-vb[System.Windows.Forms.HtmlDocument#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#10)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ActiveElement">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement ActiveElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement ActiveElement" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.ActiveElement" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActiveElement As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ ActiveElement { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Предоставляет объект <see cref="T:System.Windows.Forms.HtmlElement" />, который в текущий момент находится в фокусе пользовательского ввода.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.HtmlElement" />, который в текущий момент находится в фокусе пользовательского ввода.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если документ имеет фокус, но ни один элемент документа не получил фокус, <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> возвращает элемент, соответствующий `<BODY>` тег.  
  
 Если документ имеет фокус, <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> возвращает `null`.  
  
 Если текущий элемент с фокусом ввода является ячейкой (`TD`) в HTML- `TABLE` тег, <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> возвращает элемент, содержащий `TABLE` элемента.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActiveLinkColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color ActiveLinkColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ActiveLinkColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.ActiveLinkColor" />
      <MemberSignature Language="VB.NET" Value="Public Property ActiveLinkColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color ActiveLinkColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает объект <see cref="T:System.Drawing.Color" /> гиперссылки по щелчку.</summary>
        <value>Объект <see cref="T:System.Drawing.Color" /> для активных ссылок.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Связь активна, когда пользователь щелкнул ее. Измените это свойство для изменения цвета ссылки перед выполнением перехода.  
  
 <xref:System.Drawing.Color> Введите [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] поддерживает `Alpha` значение, а HTML DOM — нет. Таким образом `Alpha` не будет действовать при присвоении этому свойству.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection All { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection All" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.All" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property All As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ All { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает экземпляр класса <see cref="T:System.Windows.Forms.HtmlElementCollection" />, который хранит все объекты <see cref="T:System.Windows.Forms.HtmlElement" /> для документа.</summary>
        <value>Коллекция <see cref="T:System.Windows.Forms.HtmlElementCollection" /> всех элементов в документе.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.All%2A> Коллекции предоставляет произвольный доступ к любому элементу в HTML-документе, независимо от его положение в дереве документа. Используйте для доступа к любой элемент в HTML-документе по имени, Идентификатору или индекса. Можно также выполнить перебор всех элементов в документе.  
  
 Некоторые элементы, такие как `HEAD` и `TITLE`, никогда не будут иметь имена, связанные с ними. Все остальные элементы будут иметь имена только в том случае, если им назначено автору HTML-файла. Можно получить доступ к элементам без имени, Идентификатору или индексу.  
  
 Не удается добавить элементы непосредственно в <xref:System.Windows.Forms.HtmlDocument.All%2A> коллекции, так как все элементы в HTML-файл за пределами `HTML` тег должен содержать родительского элемента. Используйте <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> метода или <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> свойство <xref:System.Windows.Forms.HtmlElement> для добавления новых элементов в дерево.  
  
   
  
## Examples  
 В следующем примере кода выполняется перебор всех элементов в документе и устанавливается `Enabled=True`, включение любые элементы, которые могли быть отключены по умолчанию, чтобы предотвратить ввод данных пользователем во время загрузки документа. В примере кода требуется, чтобы ваше приложение содержит <xref:System.Windows.Forms.WebBrowser> управления с именем `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.HtmlDocument#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AttachEventHandler">
      <MemberSignature Language="C#" Value="public void AttachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.AttachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AttachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">Имя события для обработки.</param>
        <param name="eventHandler">Управляемый код, обрабатывающий событие.</param>
        <summary>Добавляет обработчик событий для именованного события HTML DOM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не следует присоединять событие документа или одного из его объектов, пока не завершится загрузка документа. Является самой ранней этот метод следует вызывать в <xref:System.Windows.Forms.WebBrowser.DocumentCompleted> событие <xref:System.Windows.Forms.WebBrowser> элемента управления.  
  
 Этот метод позволяет присоединить обработчики для неуправляемого события DOM, не предоставляемые <xref:System.Windows.Forms.HtmlDocument>. Дополнительные сведения о доступных неуправляемых событий DOM см. в разделе [доступ к не предоставленным явно членов управляемых объектной модели документов HTML](~/docs/framework/winforms/controls/accessing-unexposed-members-on-the-managed-html-document-object-model.md) и интерфейсы IHTMLDocument: [IHTMLDocument](http://go.microsoft.com/fwlink/?LinkId=104882), [IHTMLDocument2](http://go.microsoft.com/fwlink/?LinkId=104884), [IHTMLDocument3](http://go.microsoft.com/fwlink/?LinkId=104886), [IHTMLDocument4](http://go.microsoft.com/fwlink/?LinkId=104887), [IHTMLDocument5](http://go.microsoft.com/fwlink/?LinkId=104888).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color BackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color BackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.BackColor" />
      <MemberSignature Language="VB.NET" Value="Public Property BackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color BackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает цвет фона для HTML-документа.</summary>
        <value>Объект <see cref="T:System.Drawing.Color" /> фона документа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.BackColor%2A> отображается, когда нет другого элемента занимает этой области экрана.  
  
 <xref:System.Drawing.Color> Введите [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] поддерживает `Alpha` значение, а HTML DOM — нет. Таким образом `Alpha` не будет действовать при присвоении этому свойству.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.ForeColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.LinkColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
      </Docs>
    </Member>
    <Member MemberName="Body">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement Body { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement Body" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Body" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Body As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ Body { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Windows.Forms.HtmlElement" /> для тега <c>BODY</c>.</summary>
        <value>
          <see cref="T:System.Windows.Forms.HtmlElement" /> Для объекта <c>текст</c> тег.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML-документ состоит из двух основных разделов:  
  
-   `HEAD`, который содержит название документа, любой документ метаданных, и `SCRIPT` элементы.  
  
-   `BODY`, которое содержит все элементы, используемые на экране внешний вид документа.  
  
 Нет эквивалента `Head` свойство <xref:System.Windows.Forms.HtmlDocument>. Для получения `HEAD` элемент, используйте <xref:System.Windows.Forms.HtmlDocument.GetElementsByTagName%2A>.  
  
   
  
## Examples  
 В следующем примере кода создается новый `DIV` элемент и добавляет его в нижнюю часть документа с помощью <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> метод.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#13)]
 [!code-vb[System.Windows.Forms.HtmlDocument#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Click;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при щелчке документа пользователем.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода определяет в документе, щелкните пункт, находит элемент и использует <xref:System.Windows.Forms.HtmlElement.ScrollIntoView%2A> выравнивание элемента по верхнему краю веб-страницы.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlDocument#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuShowing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler ContextMenuShowing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler ContextMenuShowing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.ContextMenuShowing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuShowing As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ ContextMenuShowing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь запрашивает отображение контекстного меню документа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию при щелчке правой кнопкой мыши документ или элемент в документе, он будет отображаться определенный по умолчанию контекстное меню элемента. Это событие используется для отмены отображения контекстного меню и отображения своим собственным.  
  
   
  
## Examples  
 В следующем примере кода в примере захваты <xref:System.Windows.Forms.HtmlDocument.ContextMenuShowing> событий и использует его для отображения <xref:System.Windows.Forms.ContextMenuStrip>.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cookie">
      <MemberSignature Language="C#" Value="public string Cookie { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Cookie" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Cookie" />
      <MemberSignature Language="VB.NET" Value="Public Property Cookie As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Cookie { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает файлы cookie HTTP, связанные с данным документом.</summary>
        <value>Объект <see cref="T:System.String" />, содержащий список файлов cookie, разделенных точкой с запятой.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.Cookie%2A> Свойство <xref:System.Windows.Forms.HtmlDocument> предоставляет все файлы cookie для веб-страницы.  
  
 Объект *cookie* представляет собой пару произвольное имя/значение, связанное с заданной веб-странице. Веб-разработчики используют файлы cookie для отслеживания, когда пользователи посетите или вернуться на веб-сайта. Файл cookie состоит из нескольких частей, называемых блоками "cookie", которые определяют следующие:  
  
-   Набор документов, к которым применяется cookie; домен и путь.  
  
-   Имя и значение файла cookie.  
  
-   Срок действия файла cookie.  
  
-   Является ли файл cookie может быть отправлено только через безопасное соединение.  
  
 <xref:System.Windows.Forms.HtmlDocument.Cookie%2A> Свойство может содержать несколько файлов cookie.  
  
 Можно использовать только <xref:System.Windows.Forms.HtmlDocument.Cookie%2A> свойство для задания одного файла cookie за раз.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateElement">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement CreateElement (string elementTag);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement CreateElement(string elementTag) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.CreateElement(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateElement (elementTag As String) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ CreateElement(System::String ^ elementTag);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elementTag" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="elementTag">Имя создаваемого HTML-элемента.</param>
        <summary>Создает новый объект <see langword="HtmlElement" /> указанного типа HTML-тега.</summary>
        <returns>Новый элемент с указанным типом тега.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `elementTag` может принимать одно из любой из поддерживаемых HTML-теги в Internet Explorer, за исключением `FRAME` или `IFRAME`.  
  
 <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> Возвращает элемент присоединен к дереву текущего документа. Чтобы добавить элемент к документу, используйте <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> или <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> методы.  
  
 Этот метод не влияет на состояние существующего документа исходного кода при использовании <xref:System.Windows.Forms.WebBrowser> элемента управления **источник** команды контекстного меню или <xref:System.Windows.Forms.WebBrowser.DocumentText%2A> и <xref:System.Windows.Forms.WebBrowser.DocumentStream%2A> свойства <xref:System.Windows.Forms.WebBrowser> элемент управления.  
  
 При создании новых элементов <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A>, вы не сможете установить определенные свойства, такие как `Name`. В случаях, когда необходимо указать атрибут Name, присвойте их в качестве HTML для <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> свойства другого объекта в документе.  
  
   
  
## Examples  
 Следующий пример кода использует данные из базы данных "Борей" для создания HTML таблицу с помощью <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A>. <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> Метод также позволяет, сначала добавить ячейки (`TD` элементы) для строк (`TR` элементов), то для добавления строк в таблице и, наконец, для добавления таблицы в конец текущего документа. В примере кода требуется наличие приложения <xref:System.Windows.Forms.WebBrowser> управления с именем `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#10](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#10)]
 [!code-vb[System.Windows.Forms.HtmlDocument#10](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultEncoding">
      <MemberSignature Language="C#" Value="public string DefaultEncoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DefaultEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.DefaultEncoding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultEncoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DefaultEncoding { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает кодировку, используемую по умолчанию для текущего документа.</summary>
        <value>Объект <see cref="T:System.String" />, который представляет кодировку, используемую браузером при выводе страницы в первый раз.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Кодировка по умолчанию является кодировку управляемого объектной модели (DOM) HTML документа попытается использовать при начальной загрузке страницы. Эта кодировка определяется либо из Internet Explorer **кодировка** параметры, или из `META` тег внедренного на страницу.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DetachEventHandler">
      <MemberSignature Language="C#" Value="public void DetachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DetachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.DetachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DetachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">Имя события, обработку которого нужно прекратить.</param>
        <param name="eventHandler">Управляемый код, обрабатывающий событие.</param>
        <summary>Удаляет обработчик событий из именованного события модели DOM HTML.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Domain">
      <MemberSignature Language="C#" Value="public string Domain { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Domain" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Domain" />
      <MemberSignature Language="VB.NET" Value="Public Property Domain As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Domain { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает строку, описывающую домен этого документа в целях безопасности.</summary>
        <value>Допустимый домен.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию две веб-страницы в разных кадрах запрещен доступ друг к другу по содержимое с помощью скрипта; даже www.microsoft.com и msdn.microsoft.com в данном экземпляре, считаются различными доменами. Чтобы включить использование скриптов между кадрами для страниц из одного домена верхнего уровня, можно присвоить новое значение для <xref:System.Windows.Forms.HtmlDocument.Domain%2A> свойства. В примере предыдущей URL-адрес, параметр <xref:System.Windows.Forms.HtmlDocument.Domain%2A> на сайт microsoft.com позволит обе страницы для взаимодействия друг с другом.  
  
 Строки, назначенный <xref:System.Windows.Forms.HtmlDocument.Domain%2A> свойство должно быть допустимым доменов верхнего уровня. В предыдущем примере URL-адрес можно задать <xref:System.Windows.Forms.HtmlDocument.Domain%2A> microsoft.com, но не .com, который позволит любой страницы в Интернете, чтобы содержимое страницы сценария.  
  
 Нельзя использовать <xref:System.Windows.Forms.HtmlDocument.Domain%2A> свойство, чтобы включить использование скриптов между кадрами для страниц, которые доступны с помощью двух различных протоколов. Если один кадр страницы предоставляется веб-сервером (протокол http://), а другой – протокол файловой системы (file://), они не смогут взаимодействовать друг с другом независимо от значения <xref:System.Windows.Forms.HtmlDocument.Domain%2A> свойство.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Аргумент свойства <c>Domain</c> должен быть допустимым именем домена, созданным с использованием соглашений службы доменных имен (DNS).</exception>
      </Docs>
    </Member>
    <Member MemberName="DomDocument">
      <MemberSignature Language="C#" Value="public object DomDocument { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DomDocument" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.DomDocument" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomDocument As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DomDocument { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает указатель на неуправляемый интерфейс для данного объекта <see cref="T:System.Windows.Forms.HtmlDocument" />.</summary>
        <value>
          <see cref="T:System.Object" /> Представляющий <c>IDispatch</c> указатель на неуправляемый документ.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument> является оболочкой для Internet Explorer документа объектной модели (DOM), который будет записан в модели COM. Если необходимо получить доступ к свойствам или методам базовых интерфейсов модели COM, такие как `IHTMLDocument2`, этот объект для запроса можно использовать для них.  
  
 Чтобы использовать неуправляемые интерфейсы, импортируйте библиотеку MSHTML (mshtml.dll) приложения. Тем не менее, можно также выполнить свойствам и методам с помощью `IDispatch::Invoke` метод.  
  
   
  
## Examples  
 Следующий пример кода преобразует пример <xref:System.Windows.Forms.HtmlDocument.DomDocument%2A> для `IHTMLDocument2` указателя и отображает значение `lastModified` свойства, которое указывает время последнего обновления владельца документа его содержимое. В примере кода требуется наличие <xref:System.Windows.Forms.Button> формы с именем `Button6`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#3)]
 [!code-vb[System.Windows.Forms.HtmlDocument#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Для <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /> разрешение. Связанное перечисление: <see cref="T:System.Security.Permissions.SecurityPermissionFlag" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Encoding">
      <MemberSignature Language="C#" Value="public string Encoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Encoding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Encoding" />
      <MemberSignature Language="VB.NET" Value="Public Property Encoding As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Encoding { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает кодировку для этого документа.</summary>
        <value>Объект <see cref="T:System.String" />, который представляет текущую кодировку.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект для тестирования.</param>
        <summary>Тестирует объект на равенство с текущим объектом.</summary>
        <returns>
          Значение <see langword="true" />, если объекты равны, в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExecCommand">
      <MemberSignature Language="C#" Value="public void ExecCommand (string command, bool showUI, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ExecCommand(string command, bool showUI, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.ExecCommand(System.String,System.Boolean,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExecCommand (command As String, showUI As Boolean, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ExecCommand(System::String ^ command, bool showUI, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="command" Type="System.String" />
        <Parameter Name="showUI" Type="System.Boolean" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="command">Имя команды, которую требуется выполнить.</param>
        <param name="showUI">Должны ли выводиться для пользователя диалоговые окна конкретных команд или окна сообщений.</param>
        <param name="value">Значение, которое должно быть присвоено с использованием этой команды. Применимо не для всех команд.</param>
        <summary>Выполняет заданную команду в отношении документа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.ExecCommand%2A> предоставляет доступ к большой массив команд, для которого являются не методы, предоставляемые на <xref:System.Windows.Forms.HtmlDocument>. С помощью <xref:System.Windows.Forms.HtmlDocument.ExecCommand%2A> вставки новых элементов HTML, выберите и форматирование текста и удалить все кэшированные учетные данные проверки подлинности. Полный список команд см. в разделе [идентификаторы команд](http://go.microsoft.com/fwlink/?LinkId=198814).  
  
> [!NOTE]
>  Некоторые команды, такие как копирование, имеют возвращаемых значений. В текущей реализации <xref:System.Windows.Forms.HtmlDocument.ExecCommand%2A>, не удается получить значение, возвращаемое из вызова. Для получения возвращаемого значения, используйте соответствующий неуправляемый метод на <xref:System.Windows.Forms.HtmlDocument.DomDocument%2A> вместо этого используйте ссылки.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Focus();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Помещает фокус ввода на текущий документ.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Windows.Forms.HtmlDocument.Focus%2A> будет установить фокус на <xref:System.Windows.Forms.WebBrowser> управление, если элемент управления в данный момент имеет фокус. Если документ размещается внутри `FRAME`, этот метод будет поместить фокус на этот `FRAME` в `FRAMESET`.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">Для <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /> разрешений для установки фокуса на форме. Связанное перечисление: <see cref="T:System.Security.Permissions.UIPermissionWindow" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Focused">
      <MemberSignature Language="C#" Value="public bool Focused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Focused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Focused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Focused { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, показывающее, имеет ли документ фокус ввода пользователя.</summary>
        <value>
          Значение <see langword="true" />, если документ имеет фокус; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.Focus" />
        <altmember cref="E:System.Windows.Forms.HtmlDocument.Focusing" />
        <altmember cref="E:System.Windows.Forms.HtmlDocument.LosingFocus" />
      </Docs>
    </Member>
    <Member MemberName="Focusing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Focusing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Focusing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.Focusing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Focusing As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Focusing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит перед установкой фокуса на документе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.HtmlDocument.Focusing> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlDocument> с именем `HtmlDocument1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlDocument.Focusing> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#424](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#424)]
 [!code-vb[System.Windows.Forms.EventExamples#424](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#424)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает цвет текста для документа.</summary>
        <value>Цвет текста документа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Color> <xref:System.Drawing.Color> Введите [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] поддерживает `Alpha` значение, а HTML DOM — нет. Таким образом `Alpha` не будет действовать при присвоении этому свойству.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.BackColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.LinkColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
      </Docs>
    </Member>
    <Member MemberName="Forms">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection Forms { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection Forms" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Forms" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Forms As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ Forms { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает коллекцию всех элементов <c>&lt;FORM&gt;</c> в документе.</summary>
        <value>
          <see cref="T:System.Windows.Forms.HtmlElementCollection" /> Из <c> &lt;формы&gt; </c> элементов в документе.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 HTML-документ может иметь один или несколько `FORM` элементы с полями ввода для предоставления данных обратно на сервер.  
  
 Программным путем можно отправить `FORM` путем получения его <xref:System.Windows.Forms.HtmlElement> и вызов его `Submit` с помощью метода <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> метод.  
  
 Чтобы добавить новый `FORM` на документ, можно создать новый `FORM` пометить как строка и назначьте его <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> ранее добавлено свойство элемента HTML DOM; или можно использовать <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> метод, его свойства настраиваются в <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A>, и добавить его в качестве дочернего элемента существующего элемента с помощью <xref:System.Windows.Forms.HtmlElement.AppendChild%2A>.  
  
   
  
## Examples  
 В следующем примере кода выполняется итерация по всем `Form` элементов на веб-страницы и очищаются все введенные пользователем, значения в форме к значениям по умолчанию.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.HtmlDocument#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementById">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement GetElementById (string id);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement GetElementById(string id) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.GetElementById(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetElementById (id As String) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ GetElementById(System::String ^ id);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="id" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="id">Атрибут идентификации извлекаемого элемента.</param>
        <summary>Извлекает единственный элемент <see cref="T:System.Windows.Forms.HtmlElement" /> с использованием атрибута <c>ID</c> этого элемента в качестве ключа поиска.</summary>
        <returns>Возвращает первый объект с атрибутом <c>ID</c>, совпадающим с указанным значением, или значение <see langword="null" />, если идентификатор <paramref name="id" /> не удалось найти.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если имеется несколько элементов в документ с тем же значением идентификатора <xref:System.Windows.Forms.HtmlDocument.GetElementById%2A> вернет находит первый из них.  
  
   
  
## Examples  
 В следующем примере кода извлекается именованный `TABLE` из документа, подсчитывается количество строк, а результаты отображаются в веб-странице. В примере кода требуется наличие <xref:System.Windows.Forms.WebBrowser> управления в проект с именем `WebBrowser1`, и вы загрузили веб-страницы с `TABLE` которого `ID` атрибут `Table1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#5](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#5)]
 [!code-vb[System.Windows.Forms.HtmlDocument#5](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementFromPoint">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement GetElementFromPoint (System.Drawing.Point point);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement GetElementFromPoint(valuetype System.Drawing.Point point) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.GetElementFromPoint(System.Drawing.Point)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ GetElementFromPoint(System::Drawing::Point point);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="point" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="point">Положение элемента на экране по осям X и Y относительно верхнего левого угла документа.</param>
        <summary>Возвращает HTML-элемент, расположенный по указанным клиентским координатам.</summary>
        <returns>Объект <see cref="T:System.Windows.Forms.HtmlElement" /> в заданной точке экрана в документе.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.GetElementFromPoint%2A> использует клиентские координаты, в которых верхнего левого угла документа присваивается значение (0,0). Клиентские координаты текущего положения курсора можно получить с помощью <xref:System.Windows.Forms.HtmlWindow.Position%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода определяет в документе, щелкните пункт, находит элемент и использует <xref:System.Windows.Forms.HtmlElement.ScrollIntoView%2A> выравнивание элемента по верхнему краю веб-страницы.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlDocument#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection GetElementsByTagName (string tagName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElementCollection GetElementsByTagName(string tagName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.GetElementsByTagName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetElementsByTagName (tagName As String) As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElementCollection ^ GetElementsByTagName(System::String ^ tagName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tagName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tagName">Имя HTML-тега для объектов <see cref="T:System.Windows.Forms.HtmlElement" />, которые нужно извлечь.</param>
        <summary>Возвращает коллекцию элементов с указанным HTML-тегом.</summary>
        <returns>Коллекция элементов, имя тега которых равно аргументу <paramref name="tagName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 HTML-страницы часто используют `META` тег для внедрения произвольных сведений о документе. В следующем примере кода HTML извлекает все `META` документ HTML-тегов находит `META` тег с именем `Description`и отображает его пользователю. В примере кода требуется наличие приложения <xref:System.Windows.Forms.WebBrowser> управления с именем `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код для данного объекта.</summary>
        <returns>Объект <see cref="T:System.Int32" />, представляющий хэш в памяти для этого объекта.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Images">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection Images { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection Images" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Images" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Images As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ Images { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию всех тегов изображений в документе.</summary>
        <value>Коллекция объектов <see cref="T:System.Windows.Forms.HtmlElement" />, по одному для каждого тега IMG в документе. Элементы возвращаются из коллекции в исходном порядке.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.Images%2A> Возвращает коллекцию <xref:System.Windows.Forms.HtmlElement> объектов. Для доступа к атрибутам, такие как `ALT` и `SRC`, напрямую, не предоставляются службами <xref:System.Windows.Forms.HtmlElement>, используйте <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> метод.  
  
 Чтобы добавить новое изображение в документ, необходимо создать новый `IMG` пометить как строка и назначьте его <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> свойства элемента, ранее добавленный HTML DOM; или используйте <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> метод, его свойства настраиваются в <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A>и добавьте его как дочерний существующего элемента с помощью <xref:System.Windows.Forms.HtmlElement.AppendChild%2A>.  
  
   
  
## Examples  
 Рассматриваются в следующем примере кода `ALT` атрибут всех изображений в документе и задает значение по умолчанию `ALT` атрибута, если значение еще не установлено.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlDocument#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeScript">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет функцию Active Scripting, определенную на HTML-странице.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода выполняется содержимое сценария на веб-странице. В примере кода требуется, вы загрузили следующей веб-странице.  
  
```  
<HTML>  
<SCRIPT>  
function test(name, address) {  
window.alert("Name is " + name + "; address is " + address);  
}  
</SCRIPT>  
  
<BODY>  
</BODY>  
</HTML>  
  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#9)]
 [!code-vb[System.Windows.Forms.HtmlDocument#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeScript">
      <MemberSignature Language="C#" Value="public object InvokeScript (string scriptName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeScript(string scriptName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.InvokeScript(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeScript (scriptName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeScript(System::String ^ scriptName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scriptName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="scriptName">Имя вызываемого метода скрипта.</param>
        <summary>Выполняет функцию Active Scripting, определенную на HTML-странице.</summary>
        <returns>Объект, возвращаемый в результате вызова Active Scripting.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовый тип объекта, возвращенного <xref:System.Windows.Forms.HtmlDocument.InvokeScript%2A> будет различным. Если вызванная функция Active Scripting возвращает скалярные данные, такие как строка или целое число, оно будет возвращаться в виде строки. Если он возвращает объект на основе сценария, например объект, созданный с помощью JScript или VBScript `new` оператор, он будет иметь тип `Object`. (Можно вызывать для таких объектов, вызвав <xref:System.Object.GetType%2A> и с помощью <xref:System.Type.InvokeMember%2A>.) Если он возвращает элемент HTML DOM, таких как `DIV` или `TABLE`, он будет иметь тип `Object`; Если вы добавили ссылку на проект в MSHTML. DLL-Библиотеке, он будет приведен к конкретному неуправляемому DOM типу.  
  
 Может вызвать любую функцию, написанные на любом языке Active Scripting, установлены на компьютере пользователя, включая JScript и VBScript.  
  
 <xref:System.Windows.Forms.HtmlDocument.InvokeScript%2A> Будет выполнять никаких действий в том случае, если пользователь явным образом отключил выполнение скриптов в Internet Explorer или если это не разрешено текущей конфигурации безопасности для веб-страницы.  
  
   
  
## Examples  
 В следующем примере кода выполняется содержимое сценария на веб-странице. В примере кода требуется наличие <xref:System.Windows.Forms.WebBrowser> с именем `WebBrowser1`, и вы загрузили следующей веб-странице.  
  
```  
<HTML>  
  
    <HEAD>  
        <TITLE>Invoke Script Sample</TITLE>  
  
        <SCRIPT>  
            function MyObject() {  
                this.Data = "Data for my private object.";  
            }  
            // Return a string.  
            function test() {  
                return("This is a test.");  
            }  
            // Return a JScript object.  
            function testJScriptObject() {  
                return(new(MyObject));  
            }  
            // Return a DOM element.  
            function testElement() {  
                return(div1);  
            }  
        </SCRIPT>  
    </HEAD>  
  
    <BODY>  
  
        <DIV id="div1">  
        </DIV>  
  
    </BODY>  
  
</HTML>  
  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#12)]
 [!code-vb[System.Windows.Forms.HtmlDocument#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeScript">
      <MemberSignature Language="C#" Value="public object InvokeScript (string scriptName, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeScript(string scriptName, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.InvokeScript(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeScript (scriptName As String, args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeScript(System::String ^ scriptName, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scriptName" Type="System.String" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="scriptName">Имя вызываемого метода скрипта.</param>
        <param name="args">Аргументы для передачи в метод скрипта.</param>
        <summary>Выполняет функцию Active Scripting, определенную на HTML-странице.</summary>
        <returns>Объект, возвращаемый в результате вызова Active Scripting.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовый тип объекта, возвращенного <xref:System.Windows.Forms.HtmlDocument.InvokeScript%2A> будет различным. Если вызванная функция Active Scripting возвращает скалярные данные, такие как строка или целое число, оно будет возвращаться в виде строки. Если он возвращает объект на основе сценария, например объект, созданный с помощью JScript или VBScript `new` оператор, он будет иметь тип `Object`. (Можно вызывать для таких объектов, вызвав <xref:System.Object.GetType%2A> и с помощью <xref:System.Type.InvokeMember%2A>.) Если он возвращает элемент HTML DOM, таких как `DIV` или `TABLE`, он будет иметь тип `Object`; Если вы добавили ссылку на проект в MSHTML. DLL-Библиотеке, он будет приведен к конкретному неуправляемому DOM типу.  
  
 Может вызвать любую функцию, написанные на любом языке Active Scripting, установленный на компьютере пользователя, включая JScript и VBScript.  
  
 Этот метод будет выполнять никаких действий в том случае, если пользователь явным образом отключил выполнение скриптов в Internet Explorer или если это не разрешено текущей конфигурации безопасности для веб-страницы.  
  
   
  
## Examples  
 В следующем примере кода выполняется содержимое сценария на веб-странице. В примере кода требуется наличие <xref:System.Windows.Forms.WebBrowser> с именем `WebBrowser1`, и вы загрузили следующей веб-странице.  
  
```  
<HTML>  
    <SCRIPT>  
        function test(name, address) {  
            window.alert("Name is " + name + "; address is " + address);  
        }  
    </SCRIPT>  
  
    <BODY>  
    </BODY>  
</HTML>  
  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#9)]
 [!code-vb[System.Windows.Forms.HtmlDocument#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LinkColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color LinkColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color LinkColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.LinkColor" />
      <MemberSignature Language="VB.NET" Value="Public Property LinkColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color LinkColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает цвет гиперссылок.</summary>
        <value>Цвет гиперссылок в текущем документе.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Drawing.Color> Введите [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] поддерживает `Alpha` значение, а HTML DOM — нет. Таким образом `Alpha` не будет действовать при присвоении этому свойству.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.ForeColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.BackColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
      </Docs>
    </Member>
    <Member MemberName="Links">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection Links { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection Links" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Links" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Links As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ Links { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает список всех гиперссылок в этом HTML-документе.</summary>
        <value>Коллекция <see cref="T:System.Windows.Forms.HtmlElementCollection" /> объектов <see cref="T:System.Windows.Forms.HtmlElement" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта коллекция будет содержать все ссылки, созданные с помощью `A`, `LINK`, и `AREA` теги в HTML.  
  
 <xref:System.Windows.Forms.HtmlElement> Инкапсулируют неуправляемые объекты, содержащиеся в этой коллекции `IHTMLLinkElement` интерфейса. Для безопасного доступа к свойствам базового интерфейса, используйте <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LosingFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler LosingFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler LosingFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.LosingFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LosingFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ LosingFocus;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при переходе фокуса с элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.HtmlDocument.LosingFocus> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlDocument> с именем `HtmlDocument1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlDocument.LosingFocus> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#425](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#425)]
 [!code-vb[System.Windows.Forms.EventExamples#425](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#425)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при нажатии пользователем левой кнопки мыши.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.MouseDown> Событие возникает перед <xref:System.Windows.Forms.HtmlDocument.Click> событий.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.HtmlDocument.MouseDown> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlDocument> с именем `HtmlDocument1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlDocument.MouseDown> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#426](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#426)]
 [!code-vb[System.Windows.Forms.EventExamples#426](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#426)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseLeave;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после того, как указатель мыши покинул область документа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.HtmlDocument.MouseLeave> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlDocument> с именем `HtmlDocument1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlDocument.MouseLeave> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#427](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#427)]
 [!code-vb[System.Windows.Forms.EventExamples#427](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#427)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseMove;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при перемещении указателя мыши по документу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.HtmlDocument.MouseMove> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlDocument> с именем `HtmlDocument1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlDocument.MouseMove> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#428](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#428)]
 [!code-vb[System.Windows.Forms.EventExamples#428](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#428)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseOver As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseOver;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при перемещении указателя мыши по документу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке событий [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.HtmlDocument.MouseOver> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlDocument> с именем `HtmlDocument1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlDocument.MouseOver> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#429](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#429)]
 [!code-vb[System.Windows.Forms.EventExamples#429](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#429)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при отпускании пользователем левой кнопки мыши.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.HtmlDocument.MouseUp> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlDocument> с именем `HtmlDocument1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlDocument.MouseUp> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#430](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#430)]
 [!code-vb[System.Windows.Forms.EventExamples#430](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#430)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.Forms.HtmlDocument left, System.Windows.Forms.HtmlDocument right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Windows.Forms.HtmlDocument left, class System.Windows.Forms.HtmlDocument right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.op_Equality(System.Windows.Forms.HtmlDocument,System.Windows.Forms.HtmlDocument)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As HtmlDocument, right As HtmlDocument) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::Forms::HtmlDocument ^ left, System::Windows::Forms::HtmlDocument ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlDocument" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlDocument" />
      </Parameters>
      <Docs>
        <param name="left">Первый экземпляр для сравнения.</param>
        <param name="right">Второй экземпляр для сравнения.</param>
        <summary>Возвращает значение, указывающее, представляют ли заданные экземпляры <see cref="T:System.Windows.Forms.HtmlDocument" /> одно и то же значение.</summary>
        <returns>
          Значение <see langword="true" />, если заданные экземпляры равны; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[Эквивалентный метод для этого оператора <xref:System.Windows.Forms.HtmlDocument.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.Forms.HtmlDocument left, System.Windows.Forms.HtmlDocument right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Windows.Forms.HtmlDocument left, class System.Windows.Forms.HtmlDocument right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.op_Inequality(System.Windows.Forms.HtmlDocument,System.Windows.Forms.HtmlDocument)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As HtmlDocument, right As HtmlDocument) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::Forms::HtmlDocument ^ left, System::Windows::Forms::HtmlDocument ^ right);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlDocument" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlDocument" />
      </Parameters>
      <Docs>
        <param name="left">Первый экземпляр для сравнения.</param>
        <param name="right">Второй экземпляр для сравнения.</param>
        <summary>Возвращает значение, указывающее, представляют ли заданные экземпляры <see cref="T:System.Windows.Forms.HtmlDocument" /> разные значения.</summary>
        <returns>
          Значение <see langword="true" />, если заданные экземпляры не равны; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OpenNew">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlDocument OpenNew (bool replaceInHistory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlDocument OpenNew(bool replaceInHistory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.OpenNew(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function OpenNew (replaceInHistory As Boolean) As HtmlDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlDocument ^ OpenNew(bool replaceInHistory);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlDocument</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="replaceInHistory" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="replaceInHistory">Должен ли элемент навигации нового окна заменить предыдущий элемент в журнале навигации модели DOM.</param>
        <summary>Получает новый объект <see cref="T:System.Windows.Forms.HtmlDocument" /> для использования в методе <see cref="M:System.Windows.Forms.HtmlDocument.Write(System.String)" />.</summary>
        <returns>Новый документ для записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.OpenNew%2A> очистит предыдущих загруженного документа, включая все связанные состояния, такие как переменные. Это не вызовет события навигации в <xref:System.Windows.Forms.WebBrowser> вызываемого.  
  
 <xref:System.Windows.Forms.HtmlDocument.OpenNew%2A> всегда создает новый документ в текущем окне. Чтобы открыть документ в новом окне, используйте <xref:System.Windows.Forms.HtmlWindow.Open%2A> метод <xref:System.Windows.Forms.HtmlWindow> класса.  
  
   
  
## Examples  
 В следующем примере кода подготавливает DOM для записи и записывает новый документ с помощью <xref:System.Windows.Forms.HtmlDocument.Write%2A> метод.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#11)]
 [!code-vb[System.Windows.Forms.HtmlDocument#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightToLeft">
      <MemberSignature Language="C#" Value="public bool RightToLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RightToLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.RightToLeft" />
      <MemberSignature Language="VB.NET" Value="Public Property RightToLeft As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RightToLeft { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает направление текста в текущем документе.</summary>
        <value>
          Значение <see langword="true" />, если текст ориентирован справа налево, в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlDocument.RightToLeft%2A> не будет иметь любое значение, если оно было задано явно, либо в коде, либо в формате HTML.  
  
 В отличие от <xref:System.Windows.Forms.HtmlDocument.RightToLeft%2A> свойства в элементах управления Windows Forms, <xref:System.Windows.Forms.HtmlDocument.RightToLeft%2A> на управляемый HTML DOM не влияет на направление латиницы.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Stop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Stop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlDocument.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Stop As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Stop;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при приостановке перехода на другую веб-страницу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Загрузка веб-страницы будет остановлено, если программный код вызывает <xref:System.Windows.Forms.WebBrowser.Stop%2A> метод <xref:System.Windows.Forms.WebBrowser> элемента управления. Навигации сбои, вызванные сбои в работе сети или неисправен веб-сайтов не вызывали <xref:System.Windows.Forms.HtmlDocument.Stop> возникновения.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода сбрасывает строки состояния в приложении Windows Forms при `Stop` события. В примере кода требуется наличие <xref:System.Windows.Forms.StatusBar> управления с именем `StatusBar1` в приложении.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает текстовое значение тега <c>&lt;TITLE&gt;</c> в текущем HTML-документе.</summary>
        <value>Заголовок текущего документа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Windows.Forms.HtmlDocument.Title%2A> свойство для идентификации документа посредством понятное имя.  
  
 Изменения этого свойства также будут отражены в <xref:System.Windows.Forms.WebBrowser.DocumentTitle%2A> свойства <xref:System.Windows.Forms.WebBrowser> элемента управления.  
  
   
  
## Examples  
 В следующем примере кода создается гиперссылку HTML в текущий документ с использованием URL-адрес документа в качестве URL-адрес и заголовок документа в качестве текста ссылки. В примере кода требуется наличие приложения <xref:System.Windows.Forms.WebBrowser> управления с именем `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#14](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#14)]
 [!code-vb[System.Windows.Forms.HtmlDocument#14](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#14)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.WebBrowser.DocumentTitle" />
        <altmember cref="T:System.Windows.Forms.WebBrowser" />
      </Docs>
    </Member>
    <Member MemberName="Url">
      <MemberSignature Language="C#" Value="public Uri Url { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Uri Url" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Url" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Url As Uri" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Uri ^ Url { Uri ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Uri</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает URL-адрес, указывающий расположение этого документа.</summary>
        <value>Объект <see cref="T:System.Uri" />, представляющий URL-адрес этого документа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство доступно только для чтения. Чтобы перейти в новый документ, используйте <xref:System.Windows.Forms.WebBrowser.Url%2A> свойства <xref:System.Windows.Forms.WebBrowser> элемента управления.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VisitedLinkColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color VisitedLinkColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color VisitedLinkColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.VisitedLinkColor" />
      <MemberSignature Language="VB.NET" Value="Public Property VisitedLinkColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color VisitedLinkColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает цвет ссылок на HTML-страницы, которые пользователь уже посетил.</summary>
        <value>Цвет ссылок на посещенные страницы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `Color` Введите [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] поддерживает `Alpha` значение, а HTML DOM — нет. Таким образом `Alpha` не будет действовать при присвоении этому свойству.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.BackColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.ForeColor" />
        <altmember cref="P:System.Windows.Forms.HtmlDocument.LinkColor" />
      </Docs>
    </Member>
    <Member MemberName="Window">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlWindow Window { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlWindow Window" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlDocument.Window" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Window As HtmlWindow" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlWindow ^ Window { System::Windows::Forms::HtmlWindow ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlWindow</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Windows.Forms.HtmlWindow" />, связанный с данным документом.</summary>
        <value>Окно для этого документа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все HTML-документы имеют объект HTML DOM, называемый окном, который может использоваться для изменения размера документа и открытия новых окон, а также доступ к другим важным объектам, таких как <xref:System.Windows.Forms.HtmlHistory>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public void Write (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Write(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlDocument.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Write(System::String ^ text);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">HTML-текст, который должен быть записан в документ.</param>
        <summary>Записывает новую HTML-страницу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все вызовы <xref:System.Windows.Forms.HtmlDocument.Write%2A> должно предшествовать вызов <xref:System.Windows.Forms.HtmlDocument.OpenNew%2A>, что приведет к очистке текущего документа и всех его переменных. Вызовы <xref:System.Windows.Forms.HtmlDocument.Write%2A> вместо него создается новый документ HTML. Чтобы изменить определенные части документа, получить соответствующий <xref:System.Windows.Forms.HtmlElement> и задайте его <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> свойство.  
  
 Рекомендуется записывать все допустимые HTML-документа с использованием <xref:System.Windows.Forms.HtmlDocument.Write%2A> метода, включая `HTML` и `BODY` тегов. Однако при написании только HTML-элементы объектной модели документа (DOM) предоставит эти элементы автоматически.  
  
   
  
## Examples  
 В следующем примере кода открывается новый <xref:System.Windows.Forms.HtmlDocument> и записывает в файл HTML.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#11)]
 [!code-vb[System.Windows.Forms.HtmlDocument#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.OpenNew(System.Boolean)" />
      </Docs>
    </Member>
  </Members>
</Type>