<Type Name="HtmlElement" FullName="System.Windows.Forms.HtmlElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="24f68fe9746a2bd5695f7d4beb4bfc865d8bd0bc" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36521134" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class HtmlElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit HtmlElement extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.HtmlElement" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class HtmlElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class HtmlElement sealed" />
  <TypeSignature Language="F#" Value="type HtmlElement = class" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Представляет элемент HTML на веб-странице.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement> Представляет любых возможных типов элемента в документ HTML, такие как `BODY`, `TABLE`, и `FORM`, среди прочего. Класс предоставляет наиболее общих свойств, которые можно ожидать для поиска во всех элементах.  
  
 Большинство элементов могут иметь *дочерние элементы*: другие элементы HTML, помещаемые под ними. Используйте <xref:System.Windows.Forms.HtmlElement.CanHaveChildren%2A> свойство для проверки наличия дочерних элементов данного элемента и <xref:System.Windows.Forms.HtmlElement.Children%2A> выполнять через них итерацию коллекции. <xref:System.Windows.Forms.HtmlElement.Parent%2A> Возвращает <xref:System.Windows.Forms.HtmlElement> , в который вложен текущий элемент.  
  
 Часто требуется доступ на атрибуты, свойства и методы базового элемента, не предоставляются непосредственно с <xref:System.Windows.Forms.HtmlElement>, такие как `SRC` атрибут `IMG` элемент или `Submit` метод `FORM`. <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> И <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> методы можно использовать для получения и изменения любой атрибут или свойство для определенного элемента, пока <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> предоставляет доступ ко всем методам, не отображаемые в управляемый объект модели DOM документа. Если приложение разрешение неуправляемого кода, может быть открыто свойствам и методам с <xref:System.Windows.Forms.HtmlElement.DomElement%2A> атрибута.  
  
 Используйте <xref:System.Windows.Forms.HtmlElement.TagName%2A> свойство, чтобы проверить, является ли элемент определенного типа.  
  
 Любой HTML-документ может изменяться во время выполнения. Можно создавать новые <xref:System.Windows.Forms.HtmlElement> объекты с <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> метод <xref:System.Windows.Forms.HtmlDocument>и добавить их в другой элемент с помощью <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> или <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> методы. Можно также создать элементы, как HTML-тегов и назначить их с существующим элементом <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода показано, как можно проанализировать произвольный HTML-документа и получается строка HTML, описывающая элементы с отступами и указывает, насколько глубоко номера уровней вложенных элементов в документе. Данный пример кода требует, узлы приложения <xref:System.Windows.Forms.WebBrowser> управления с именем `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.HtmlElement#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection All { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection All" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.All" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property All As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ All { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.All : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlElement.All" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию <see cref="T:System.Windows.Forms.HtmlElementCollection" /> всех элементов, расположенных под текущим элементом.</summary>
        <value>Коллекция всех элементов, которые являются прямыми или косвенными потомками текущего. Если текущий элемент является <c>таблицы</c>, например, <see cref="P:System.Windows.Forms.HtmlElement.All" /> вернет каждый <c>TH</c>, <c>TR</c>, и <c>TD</c> элемент в таблице также как и любые другие элементы, такие как <c>DIV</c> и <c>диапазон</c> элементы, содержащиеся в ячейках.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы получить только те элементы, имеющие родительских прямой текущего элемента, используйте <xref:System.Windows.Forms.HtmlElement.Children%2A> коллекции вместо него.  
  
 Элементы в этой коллекции не обязательно возвращаются в исходном порядке.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.Children" />
      </Docs>
    </Member>
    <Member MemberName="AppendChild">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement AppendChild (System.Windows.Forms.HtmlElement newElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement AppendChild(class System.Windows.Forms.HtmlElement newElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.AppendChild(System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function AppendChild (newElement As HtmlElement) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ AppendChild(System::Windows::Forms::HtmlElement ^ newElement);" />
      <MemberSignature Language="F#" Value="member this.AppendChild : System.Windows.Forms.HtmlElement -&gt; System.Windows.Forms.HtmlElement" Usage="htmlElement.AppendChild newElement" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newElement" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="newElement">Объект <see cref="T:System.Windows.Forms.HtmlElement" />, добавляемый в это расположение в дереве.</param>
        <summary>Добавляет элемент в поддерево другого элемента.</summary>
        <returns>Элемент после добавления в дерево.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объектной модели HTML документа (DOM) можно изменить во время выполнения содержимое HTML-файл в следующих случаях. Используйте <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> для добавления новых элементов к существующему документу или переместить элемент на странице.  
  
 Если элемент уже имеют родителей, присоединение элемента к другому элементу автоматически удалит элемента из его предыдущего родителя.  
  
 Любые дополнения, внесенные в документ во время выполнения с помощью <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> не будут сохранены при вызове <xref:System.Windows.Forms.WebBrowser.ShowSaveAsDialog%2A> метод <xref:System.Windows.Forms.WebBrowser> элемента управления.  
  
   
  
## Examples  
 В следующем примере кода создается новый гиперссылки с помощью <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A> метода и добавляет его до конца страницы с помощью `AppendChild` на `BODY` элемент. В этом примере предполагается, что приложение содержит <xref:System.Windows.Forms.WebBrowser> управления с именем `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlElement#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.CreateElement(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="AttachEventHandler">
      <MemberSignature Language="C#" Value="public void AttachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AttachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.AttachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AttachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.AttachEventHandler : string * EventHandler -&gt; unit" Usage="htmlElement.AttachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">Имя события для обработки.</param>
        <param name="eventHandler">Управляемый код, обрабатывающий событие.</param>
        <summary>Добавляет обработчик событий для события с заданным именем в модели HTML DOM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Управляемый объект модели DOM документа предоставляет выберите количество событий. Большую часть событий, не предоставленные явно определены только для определенных типов элементов; Например, `submit` события, который может использоваться только в `FORM` элементов. Используйте <xref:System.Windows.Forms.HtmlElement.AttachEventHandler%2A> для добавления обработчика событий для этих событий, не предоставленные явно.  
  
 Не следует присоединять событие документа или одного из его объектов, пока не завершится загрузка документа. Является самой ранней этот метод следует вызывать в <xref:System.Windows.Forms.WebBrowser.DocumentCompleted> событие <xref:System.Windows.Forms.WebBrowser> элемента управления.  
  
 Дополнительные сведения о доступных неуправляемых событий см. в разделе [доступ к не предоставленным явно членов управляемых объектной модели документов HTML](~/docs/framework/winforms/controls/accessing-unexposed-members-on-the-managed-html-document-object-model.md) и интерфейсы IHTMLElement: [IHTMLElement](http://go.microsoft.com/fwlink/?LinkId=104876), [IHTMLElement2](http://go.microsoft.com/fwlink/?LinkId=104877), [IHTMLElement3](http://go.microsoft.com/fwlink/?LinkId=104878), [IHTMLElement4](http://go.microsoft.com/fwlink/?LinkId=104879).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanHaveChildren">
      <MemberSignature Language="C#" Value="public bool CanHaveChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanHaveChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.CanHaveChildren" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanHaveChildren As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanHaveChildren { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanHaveChildren : bool" Usage="System.Windows.Forms.HtmlElement.CanHaveChildren" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, может ли текущий элемент иметь дочерние элементы.</summary>
        <value>Значение <see langword="true" />, если элемент может иметь дочерние элементы, и значение <see langword="false" /> в противном случае.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые элементы, такие как `IMG` и `SCRIPT`, не может иметь дочерние элементы. Это свойство используется перед вызовом метода <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> или <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> на произвольный элемент.  
  
   
  
## Examples  
 В следующем примере кода обрабатывается <xref:System.Windows.Forms.HtmlElement.Click> события <xref:System.Windows.Forms.HtmlDocument>. Если элемент не был выбран щелчком мыши, код присваивает элемент закрытой переменной класса с именем `MoveElement`. Если элемент был выбран, код пытается добавить в элемент, на котором выполнен щелчок. Данный пример кода требует, узлов приложения <xref:System.Windows.Forms.WebBrowser> управления с именем `WebBrowser1`, и у вас уже есть добавлен обработчик событий для <xref:System.Windows.Forms.HtmlElement.Click> событий на <xref:System.Windows.Forms.HtmlDocument>.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#2](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#2)]
 [!code-vb[System.Windows.Forms.HtmlElement#2](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Children">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection Children { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElementCollection Children" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Children" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Children As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElementCollection ^ Children { System::Windows::Forms::HtmlElementCollection ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Children : System.Windows.Forms.HtmlElementCollection" Usage="System.Windows.Forms.HtmlElement.Children" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию <see cref="T:System.Windows.Forms.HtmlElementCollection" /> всех дочерних элементов для текущего элемента.</summary>
        <value>Коллекция всех объектов <see cref="T:System.Windows.Forms.HtmlElement" />, для которых текущий элемент является родительским.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Многие элементы внутри HTML-файл может иметь другие элементы HTML под ними. <xref:System.Windows.Forms.HtmlElement.Children%2A> Коллекция предоставляет простой механизм для изучения структуры дерева документа.  
  
 <xref:System.Windows.Forms.HtmlElement.Children%2A> предоставляет только элементы, родительский объект которой прямой является текущим элементом. Если у вас есть <xref:System.Windows.Forms.HtmlElement> для `TABLE` элемент, <xref:System.Windows.Forms.HtmlElement.Children%2A> выдаст все `TR` элементы (строки) внутри `TABLE`. Для получения `TD` (ячейка) элементов, содержащихся в словаре `TR` элементов, необходимо будет использовать любой <xref:System.Windows.Forms.HtmlElement.Children%2A> коллекции для каждого отдельного `TR` элемент или используйте <xref:System.Windows.Forms.HtmlElement.All%2A> коллекции <xref:System.Windows.Forms.HtmlElement>.  
  
 Элементы в этой коллекции, не обязательно будут в исходном порядке.  
  
 Если <xref:System.Windows.Forms.HtmlElement.CanHaveChildren%2A> — `false`, `Children` всегда будет пустым.  
  
   
  
## Examples  
 В следующем примере кода проверяет произвольного HTML-документа и получается строка, описывающая элементы с отступами и указывает, насколько глубоко номера уровней вложенных элементов в документе. Это делается путем поиска `Children` коллекцию всех элементов рекурсивно, начиная с HTML-элемент в верхней части документа. Данный пример кода требуется наличие приложения <xref:System.Windows.Forms.WebBrowser> управления с именем `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#1)]
 [!code-vb[System.Windows.Forms.HtmlElement#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.All" />
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Click;" />
      <MemberSignature Language="F#" Value="member this.Click : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Click : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь щелкает элемент левой кнопкой мыши.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вы можете отменить действие по умолчанию для <xref:System.Windows.Forms.HtmlElement.Click> событий для элемента, задав <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класса `true`.  
  
 Объект <xref:System.Windows.Forms.HtmlElement.Click> событий для элемента также может возникнуть в родительские элементы этого элемента а в <xref:System.Windows.Forms.HtmlDocument> класса, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класса `true`.  
  
 При нажатии на элемент, который не в данный момент имеет фокус ввода, <xref:System.Windows.Forms.HtmlElement.Click> событие будет происходить после <xref:System.Windows.Forms.HtmlElement.Focusing> событий, но перед <xref:System.Windows.Forms.HtmlElement.LostFocus> событий для этого элемента.  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.HtmlElement.Click> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.Click> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#432](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#432)]
 [!code-vb[System.Windows.Forms.EventExamples#432](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#432)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ClientRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ClientRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ClientRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ClientRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ClientRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle ClientRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.ClientRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.HtmlElement.ClientRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает границы клиентской области элемента в HTML-документе.</summary>
        <value>Клиентская область, занимаемая элементом, минус области, занятые границами и полосами прокрутки. Чтобы получить расположение и размеры элемента с учетом крайних элементов, используйте свойство <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.ClientRectangle%2A> Возвращает позицию данные только для элементов, которые были назначены точные значения высоты и ширины или элементы, использующие абсолютное позиционирование. Документ имеет абсолютное положение, если задан стиль его положение `absolute`, после которой он может располагаться по любым координатам на HTML-странице.  
  
   
  
## Examples  
 Предположим, вы загрузили следующей HTML-страницы в размещенный экземпляр <xref:System.Windows.Forms.WebBrowser> элемента управления.  
  
```  
<HTML>  
  
    <BODY>  
  
        <DIV id="div1" style="position:absolute;top:100px;left:100px;border-      style:solid;border-width:1px;">  
            Edit this text.  
        </DIV>  
  
    </BODY>  
  
</HTML>  
```  
  
 В следующем примере кода демонстрируется извлечение этот элемент и увеличить его размеры, если клиентской области является менее 400 пикселей 50 пикселей в высоту, а также задает `DIV` для `contentEditable` состояния, чтобы пользователь мог вводить текст.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#3](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#3)]
 [!code-vb[System.Windows.Forms.HtmlElement#3](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" />
      </Docs>
    </Member>
    <Member MemberName="DetachEventHandler">
      <MemberSignature Language="C#" Value="public void DetachEventHandler (string eventName, EventHandler eventHandler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DetachEventHandler(string eventName, class System.EventHandler eventHandler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.DetachEventHandler(System.String,System.EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DetachEventHandler(System::String ^ eventName, EventHandler ^ eventHandler);" />
      <MemberSignature Language="F#" Value="member this.DetachEventHandler : string * EventHandler -&gt; unit" Usage="htmlElement.DetachEventHandler (eventName, eventHandler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
        <Parameter Name="eventHandler" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="eventName">Имя события для обработки.</param>
        <param name="eventHandler">Управляемый код, обрабатывающий событие.</param>
        <summary>Удаляет обработчик событий из события с заданным именем в модели HTML DOM.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Document">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlDocument Document { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlDocument Document" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Document" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Document As HtmlDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlDocument ^ Document { System::Windows::Forms::HtmlDocument ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Document : System.Windows.Forms.HtmlDocument" Usage="System.Windows.Forms.HtmlElement.Document" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает объект <see cref="T:System.Windows.Forms.HtmlDocument" />, к которому принадлежит данный элемент.</summary>
        <value>Родительский документ для этого элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Некоторые HTML-страницы можно размещать кадров с помощью `FRAMESET` тегов. В этом случае каждый отдельный `FRAME` будет содержать свой собственный экземпляр <xref:System.Windows.Forms.HtmlDocument>. Это свойство особенно полезен при получении ссылки на элемент в обработчике событий из <xref:System.Windows.Forms.HtmlElementEventArgs>и необходимо выполнить некоторые действия в документе, в которой находится элемент.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.HtmlDocument" />
      </Docs>
    </Member>
    <Member MemberName="DomElement">
      <MemberSignature Language="C#" Value="public object DomElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DomElement" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.DomElement" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomElement As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DomElement { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomElement : obj" Usage="System.Windows.Forms.HtmlElement.DomElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает указатель на неуправляемый интерфейс для этого элемента.</summary>
        <value>COM <c>IUnknown</c> указателя на элемент, который можно привести к одному из HTML-элемента, интерфейсы, такие как <c>IHTMLElement</c>.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement> является оболочкой для Internet Explorer документа объектной модели (DOM), который записывается с помощью модели объектов компонентов (COM). Если необходимо получить доступ к свойствам или методам базовых интерфейсов модели COM, такие как `IHTMLElement`, этот объект для запроса можно использовать для них.  
  
 Чтобы использовать неуправляемые интерфейсы, необходимо импортировать библиотеку MSHTML (mshtml.dll) приложения. Тем не менее, можно также выполнить свойствам и методам с помощью `Invoke` метод.  
  
   
  
## Examples  
 В следующем примере кода использует неуправляемые интерфейсы, чтобы получить текущий выделенный текст и преобразовать его в виде гиперссылки на URL-адрес, выбранного пользователем. Этот код был написан в предположении, что имеет форму <xref:System.Windows.Forms.WebBrowser> управления с именем `WebBrowser1`, и, были добавлены на неуправляемую библиотеку MSHTML как ссылка на проект.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#4](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#4)]
 [!code-vb[System.Windows.Forms.HtmlElement#4](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlDocument.DomDocument" />
      </Docs>
    </Member>
    <Member MemberName="DoubleClick">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DoubleClick;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DoubleClick" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DoubleClick" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DoubleClick As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DoubleClick;" />
      <MemberSignature Language="F#" Value="member this.DoubleClick : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DoubleClick : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь дважды в течение короткого промежутка времени щелкает элемент левой кнопкой мыши.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Двойной щелчок определяется настройками мыши в операционной системе пользователя. Пользователь может задать время между нажатиями кнопки мыши, которые будут считаться двойным щелчком, а не двумя отдельными щелчками.  
  
 Вы можете отменить действие по умолчанию для <xref:System.Windows.Forms.HtmlElement.DoubleClick> событий для элемента, задав <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класса `true`.  
  
 Объект <xref:System.Windows.Forms.HtmlElement.DoubleClick> событий для элемента также может возникнуть в родительские элементы этого элемента а в <xref:System.Windows.Forms.HtmlDocument> класса, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класса `true`.  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.HtmlElement.DoubleClick> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.DoubleClick> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#433](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#433)]
 [!code-vb[System.Windows.Forms.EventExamples#433](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#433)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Drag">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Drag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Drag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.Drag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Drag As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Drag;" />
      <MemberSignature Language="F#" Value="member this.Drag : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Drag : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь перетаскивает текст в различные места.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие возникает при перетаскивании текста в следующие расположения:  
  
-   В пределах или между HTML-страницами в <xref:System.Windows.Forms.WebBrowser> управления или Internet Explorer  
  
-   В другое приложение  
  
-   Рабочий стол Windows  
  
 Вы можете отменить действие по умолчанию для <xref:System.Windows.Forms.HtmlElement.Drag> событий для элемента, задав <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класса `true`.  
  
 Объект <xref:System.Windows.Forms.HtmlElement.Drag> событий для элемента также может возникнуть в родительские элементы этого элемента а в <xref:System.Windows.Forms.HtmlDocument> класса, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класса `true`.  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.HtmlElement.Drag> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.Drag> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#434](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#434)]
 [!code-vb[System.Windows.Forms.EventExamples#434](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#434)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragEnd">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DragEnd;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DragEnd" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DragEnd" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnd As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DragEnd;" />
      <MemberSignature Language="F#" Value="member this.DragEnd : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DragEnd : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь завершает операцию перетаскивания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вы можете отменить действие по умолчанию для <xref:System.Windows.Forms.HtmlElement.DragEnd> событий для элемента, задав <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класса `true`.  
  
 Объект <xref:System.Windows.Forms.HtmlElement.DragEnd> событий для элемента также может возникнуть в родительские элементы этого элемента а в <xref:System.Windows.Forms.HtmlDocument> класса, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класса `true`.  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.HtmlElement.DragEnd> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.DragEnd> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#435](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#435)]
 [!code-vb[System.Windows.Forms.EventExamples#435](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#435)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DragLeave : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь прекращает перетаскивание объекта через этот элемент.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.HtmlElement.DragLeave> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.DragLeave> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#436](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#436)]
 [!code-vb[System.Windows.Forms.EventExamples#436](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#436)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.DragOver : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь перетаскивает текст на элемент.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вы можете отменить действие по умолчанию для <xref:System.Windows.Forms.HtmlElement.DragOver> событий для элемента, задав <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класса `true`.  
  
 Объект <xref:System.Windows.Forms.HtmlElement.DragOver> событий для элемента также может возникнуть в родительские элементы этого элемента а в <xref:System.Windows.Forms.HtmlDocument> класса, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класса `true`.  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.HtmlElement.DragOver> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.DragOver> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#437](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#437)]
 [!code-vb[System.Windows.Forms.EventExamples#437](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#437)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Enabled : bool with get, set" Usage="System.Windows.Forms.HtmlElement.Enabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает параметр, определяющий возможность ввода пользователем данных в этот элемент.</summary>
        <value>Значение <see langword="true" />, если элемент допускает ввод данных пользователем; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для `FORM` элементы, такие как текстовые поля и переключатели, установка <xref:System.Windows.Forms.HtmlElement.Enabled%2A> для `false` сделает невозможным пользователя с помощью этих полей формы. Для других элементов таких как `DIV` или `SPAN`, параметр <xref:System.Windows.Forms.HtmlElement.Enabled%2A> для `false` вызовет весь текст в элемент, затенены; Однако текст по-прежнему, могут быть выделены. Чтобы отменить выделение, добавьте обработчик событий для скрытой `onselectstart` события с помощью <xref:System.Windows.Forms.HtmlElement.AttachEventHandler%2A> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="htmlElement.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект для проверки на равенство.</param>
        <summary>Проверяет, равен ли переданный объект текущему элементу.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="obj" /> является элементом <see cref="T:System.Windows.Forms.HtmlElement" />, и значение <see langword="false" /> в противном случае.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FirstChild">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement FirstChild { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement FirstChild" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.FirstChild" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FirstChild As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ FirstChild { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FirstChild : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.FirstChild" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает следующий элемент, расположенный под этим элементом в дереве документа.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.HtmlElement" />, представляющий первый элемент, расположенный под текущим элементом (в исходном порядке).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Windows.Forms.HtmlElement.FirstChild%2A> в сочетании с <xref:System.Windows.Forms.HtmlElement.NextSibling%2A> для прохода по дереву документа HTML-документа.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public void Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Sub Focus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Focus();" />
      <MemberSignature Language="F#" Value="member this.Focus : unit -&gt; unit" Usage="htmlElement.Focus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Помещает фокус ввода на текущий элемент.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Задание фокуса для элемента перемещает в него фокус и делает элемент активным. Например, элемент, имеющий фокус вернет <xref:System.Windows.Forms.HtmlDocument.ActiveElement%2A> свойство <xref:System.Windows.Forms.HtmlDocument>.  
  
 Все нажатия клавиш, введенные пользователем после <xref:System.Windows.Forms.HtmlElement.Focus%2A> был вызван будут отправляться на этот элемент.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focusing">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler Focusing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler Focusing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.Focusing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Focusing As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ Focusing;" />
      <MemberSignature Language="F#" Value="member this.Focusing : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.Focusing : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда элемент впервые получает фокус ввода пользователя.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элемент, получившем фокус, прежде чем пользователь переключается на другое приложение, с помощью панели задач или клавиши ALT + TAB получит <xref:System.Windows.Forms.HtmlElement.Focusing> и <xref:System.Windows.Forms.HtmlElement.GotFocus> события еще раз при переключении обратно в приложение.  
  
 Невозможно отменить поведение по умолчанию для данного события. Чтобы убрать фокус с элемента, вызовите <xref:System.Windows.Forms.HtmlElement.Focus%2A> на другой элемент внутри <xref:System.Windows.Forms.HtmlElement.GotFocus> событий.  
  
 Объект <xref:System.Windows.Forms.HtmlElement.Focusing> событий для элемента также может возникнуть в родительских элементов этого элемента а в <xref:System.Windows.Forms.HtmlDocument> класса, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класса `true`.  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.HtmlElement.Focusing> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.Focusing> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#438](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#438)]
 [!code-vb[System.Windows.Forms.EventExamples#438](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#438)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public string GetAttribute (string attributeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string GetAttribute(string attributeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.GetAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttribute (attributeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ GetAttribute(System::String ^ attributeName);" />
      <MemberSignature Language="F#" Value="member this.GetAttribute : string -&gt; string" Usage="htmlElement.GetAttribute attributeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="attributeName">Имя атрибута. В этом аргументе не учитывается регистр.</param>
        <summary>Возвращает значение атрибута с заданным именем в элементе.</summary>
        <returns>Значение этого атрибута в элементе, например значение <see cref="T:System.String" />. Если указанный атрибут не существует в этом элементе, возвращает пустую строку.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Атрибут в формате HTML — каждая пара допустимое имя/значение для этого элемента. <xref:System.Windows.Forms.HtmlElement> предоставляет только те атрибуты, которые являются общими для всех элементов, а не к тем, которые применяются только к определенным типам элементов; `SRC` предопределенный атрибут для `IMG` тег, например, но не для `DIV` тег. Используйте <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> и <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> для работы с атрибутами, которые не представлены на управляемый объект модели DOM документа.  
  
 <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> и <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> регистр не учитывается.  
  
   
  
## Examples  
 В следующем примере кода извлекает все `META` HTML-тегов документ, используя <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> найти `META` тег с именем `Description`. В этом примере предполагается, что приложение имеет <xref:System.Windows.Forms.WebBrowser> управления с именем `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlDocument#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlDocument/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetElementsByTagName">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElementCollection GetElementsByTagName (string tagName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElementCollection GetElementsByTagName(string tagName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.GetElementsByTagName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetElementsByTagName (tagName As String) As HtmlElementCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElementCollection ^ GetElementsByTagName(System::String ^ tagName);" />
      <MemberSignature Language="F#" Value="member this.GetElementsByTagName : string -&gt; System.Windows.Forms.HtmlElementCollection" Usage="htmlElement.GetElementsByTagName tagName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementCollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tagName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="tagName">Имя тега, объекты <see cref="T:System.Windows.Forms.HtmlElement" /> которого требуется извлечь.</param>
        <summary>Возвращает коллекцию элементов, представленных в HTML-коде, по заданному тегу <c>HTML</c>.</summary>
        <returns>Коллекция <see cref="T:System.Windows.Forms.HtmlElementCollection" />, содержащая все элементы, у которых имя тега <c>HTML</c> совпадает с <paramref name="tagName" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="htmlElement.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Служит хэш-функцией для определенного типа.</summary>
        <returns>Хэш-код для текущего объекта <see cref="T:System.Object" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ GotFocus;" />
      <MemberSignature Language="F#" Value="member this.GotFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.GotFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда элемент получил фокус ввода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Невозможно ни отменить это событие по умолчанию, ни предотвратить восходящей. Чтобы убрать фокус с элемента, вызовите <xref:System.Windows.Forms.HtmlElement.Focus%2A> на другой элемент внутри <xref:System.Windows.Forms.HtmlElement.GotFocus> событий.  
  
   
  
## Examples  
 Сохранить в файл следующий код HTML и загрузите файл в <xref:System.Windows.Forms.WebBrowser> управления в проекте Windows Forms.  
  
```  
<HTML>  
    <BODY>  
        <FORM name="form1">  
            <INPUT type="text" size=20 name="text1">  
            <INPUT type="text" size=20 name="text2">  
            <INPUT type="text" size=20 name="text3">  
        </FORM>  
    </BODY>  
</HTML>  
```  
  
 В следующем примере кода запрещается следующего `INPUT` элементу в последовательности табуляции получать фокус ввода, если предыдущий элемент содержит менее пяти символов. В этом примере предполагается, что ранее упомянутых HTML-файл загружается в экземпляр <xref:System.Windows.Forms.WebBrowser> управления с именем `WebBrowser1`.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#15](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#15)]
 [!code-vb[System.Windows.Forms.HtmlElement#15](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#15)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public string Id { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Id" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Id" />
      <MemberSignature Language="VB.NET" Value="Public Property Id As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Id { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Id : string with get, set" Usage="System.Windows.Forms.HtmlElement.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает метку, по которой определяется элемент.</summary>
        <value>Уникальный идентификатор элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.Id%2A> должно быть уникальным; не может иметь два элемента с тем же <xref:System.Windows.Forms.HtmlElement.Id%2A> внутри того же документа. Используйте <xref:System.Windows.Forms.HtmlElement.Name%2A> свойство, чтобы предоставить тот же идентификатор группы логически связанных элементов.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="InnerHtml">
      <MemberSignature Language="C#" Value="public string InnerHtml { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerHtml" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.InnerHtml" />
      <MemberSignature Language="VB.NET" Value="Public Property InnerHtml As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ InnerHtml { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerHtml : string with get, set" Usage="System.Windows.Forms.HtmlElement.InnerHtml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает разметку HTML, расположенную под этим элементом.</summary>
        <value>Разметка HTML, определяющая дочерние элементы текущего элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Существует несколько способов для добавления новых элементов к существующей HTML-страницы, такие как <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> и <xref:System.Windows.Forms.HtmlElement.InsertAdjacentElement%2A> методы. С помощью <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> часто является самым быстрым способом добавления нового содержимого при наличии задайте многие атрибуты и стили для новых элементов.  
  
 <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> отличается от <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> в том, что <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> не будет содержать код HTML, который представляет объект, который вы вызываете. В разделе <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> Дополнительные сведения о различиях между этими двумя свойствами.  
  
 Параметр <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> удаляет все дочерние элементы, ранее добавляется к элементу. При извлечении элемента из DOM, а затем назначьте новый HTML его родительских объектов <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> , бесполезны справочной информации для этого элемента и его поведение при вызове его свойства и методы не определено.  
  
 Для некоторых элементов, установка <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> не является недопустимой операцией. Некоторые HTML-теги имеют отсутствует закрывающий тег, такой как `IMG` теги и поэтому не может содержать вложенные элементы. Некоторые теги, такие как `SCRIPT` тег, может содержать только текстовое содержимое; установка <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> приведет к ошибке. Для обоих типов тегов <xref:System.Windows.Forms.HtmlElement.CanHaveChildren%2A> свойство будет возвращать `false`. Тем не менее, также нельзя задать <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> на `TABLE` и `TR` элементы, как код HTML неправильного формата назначение этих элементов может привести к повреждению документа для подготовки к просмотру. Используйте <xref:System.Windows.Forms.HtmlElement.AppendChild%2A> или `insertRow` и `insertCell` методов в неуправляемой `IHTMLTable` интерфейса для добавления строк и ячеек для `TABLE`.  
  
 Если вам нужно только назначьте текст элемента и не HTML-разметка, используйте <xref:System.Windows.Forms.HtmlElement.InnerText%2A> свойство вместо него.  
  
 Присвоения значения <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> будут уничтожены все текстовые значения, назначенного ранее с помощью <xref:System.Windows.Forms.HtmlElement.InnerText%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Создание дочерних элементов данного элемента не допускается.</exception>
        <altmember cref="M:System.Windows.Forms.HtmlElement.AppendChild(System.Windows.Forms.HtmlElement)" />
        <altmember cref="M:System.Windows.Forms.HtmlElement.InsertAdjacentElement(System.Windows.Forms.HtmlElementInsertionOrientation,System.Windows.Forms.HtmlElement)" />
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerText" />
      </Docs>
    </Member>
    <Member MemberName="InnerText">
      <MemberSignature Language="C#" Value="public string InnerText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string InnerText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.InnerText" />
      <MemberSignature Language="VB.NET" Value="Public Property InnerText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ InnerText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.InnerText : string with get, set" Usage="System.Windows.Forms.HtmlElement.InnerText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает текст, назначенный элементу.</summary>
        <value>Текст элемента, не содержащий разметки HTML. Если элемент содержит дочерние элементы, будет сохраняться только текст этих элементов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При попытке назначить HTML для элемента с <xref:System.Windows.Forms.HtmlElement.InnerText%2A>, HTML-код будет отображаться как литералы в документе, как если бы Просмотр HTML в текстовый файл. Если назначить HTML для элемента с помощью <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> свойства <xref:System.Windows.Forms.HtmlElement.InnerText%2A> возвращает весь текст в том, что удален HTML разметкой.  
  
 Присвоения значения <xref:System.Windows.Forms.HtmlElement.InnerText%2A> приведет к удалению всех дочерних элементов, принадлежащих к элементу.  
  
   
  
## Examples  
 В следующем коде создается новый гиперссылки с помощью <xref:System.Windows.Forms.HtmlDocument.CreateElement%2A>и назначает текст ссылки с помощью <xref:System.Windows.Forms.HtmlElement.InnerText%2A> свойство.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#8](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#8)]
 [!code-vb[System.Windows.Forms.HtmlElement#8](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Указанный элемент не может содержать текст (например, элемент <c>IMG</c>).</exception>
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerHtml" />
      </Docs>
    </Member>
    <Member MemberName="InsertAdjacentElement">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement InsertAdjacentElement (System.Windows.Forms.HtmlElementInsertionOrientation orient, System.Windows.Forms.HtmlElement newElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Forms.HtmlElement InsertAdjacentElement(valuetype System.Windows.Forms.HtmlElementInsertionOrientation orient, class System.Windows.Forms.HtmlElement newElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.InsertAdjacentElement(System.Windows.Forms.HtmlElementInsertionOrientation,System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function InsertAdjacentElement (orient As HtmlElementInsertionOrientation, newElement As HtmlElement) As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Forms::HtmlElement ^ InsertAdjacentElement(System::Windows::Forms::HtmlElementInsertionOrientation orient, System::Windows::Forms::HtmlElement ^ newElement);" />
      <MemberSignature Language="F#" Value="member this.InsertAdjacentElement : System.Windows.Forms.HtmlElementInsertionOrientation * System.Windows.Forms.HtmlElement -&gt; System.Windows.Forms.HtmlElement" Usage="htmlElement.InsertAdjacentElement (orient, newElement)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="orient" Type="System.Windows.Forms.HtmlElementInsertionOrientation" />
        <Parameter Name="newElement" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="orient">Место вставки этого элемента относительно текущего элемента.</param>
        <param name="newElement">Новый элемент, который требуется вставить.</param>
        <summary>Вставляет новый элемент в модель DOM.</summary>
        <returns>Вставленный элемент <see cref="T:System.Windows.Forms.HtmlElement" />. Если не удалось вставить элемент, возвращается значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не вызывайте этот метод до после <xref:System.Windows.Forms.WebBrowser.DocumentCompleted> события <xref:System.Windows.Forms.WebBrowser> элемента управления произошла. Вызов этого метода до этого момента можно приведет к исключению, как документ будет иметь загрузка не завершена.  
  
 Является ли значение <xref:System.Windows.Forms.HtmlElementInsertionOrientation> является допустимым будет зависеть от типа элемента. Например <xref:System.Windows.Forms.HtmlElementInsertionOrientation.AfterBegin> является допустимым, если элемент является `DIV`, но это не `SCRIPT` или `IMG` элемент, ни один из которых может содержать дочерние элементы.  
  
   
  
## Examples  
 В следующем примере кода в примере вставляет `DIV` элемент в верхней части каждой страницы, которую пользователи просматривают вне сервера ADatum.com. В этом примере предполагается, что форма содержит <xref:System.Windows.Forms.WebBrowser> управления с именем `WebBrowser1`. Пример также необходимо импортировать пространство имен <xref:System.Text.RegularExpressions>.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#9](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#9)]
 [!code-vb[System.Windows.Forms.HtmlElement#9](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#9)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет метод, являющийся уникальным для текущего элемента.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string methodName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeMember(string methodName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.InvokeMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeMember (methodName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ methodName);" />
      <MemberSignature Language="F#" Value="member this.InvokeMember : string -&gt; obj" Usage="htmlElement.InvokeMember methodName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="methodName">Имя вызываемого свойства или метода.</param>
        <summary>Выполняет невыявленный метод в базовом элементе DOM данного элемента.</summary>
        <returns>Элемент, возвращаемый данным методом, представленный в виде объекта <see cref="T:System.Object" />. Если этот объект <see cref="T:System.Object" /> является другим элементом HTML и существует ссылка на неуправляемую библиотеку MSHTML, добавленную в проект, элемент можно привести к соответствующему неуправляемому интерфейсу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для вызова методов из документа объектной модели (DOM), не имеют эквивалентов в управляемом коде. Эта версия <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> для выполнения не предоставленным явно методов, которые не принимают аргументов. Пример см. в разделе <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string methodName, params object[] parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object InvokeMember(string methodName, object[] parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.InvokeMember(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function InvokeMember (methodName As String, ParamArray parameter As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ InvokeMember(System::String ^ methodName, ... cli::array &lt;System::Object ^&gt; ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.InvokeMember : string * obj[] -&gt; obj" Usage="htmlElement.InvokeMember (methodName, parameter)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="methodName" Type="System.String" />
        <Parameter Name="parameter" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="methodName">Имя вызываемого свойства или метода.</param>
        <param name="parameter">Список передаваемых параметров.</param>
        <summary>Выполняет функцию, определенную на текущей HTML-странице с помощью языка скриптов.</summary>
        <returns>Элемент, возвращаемый функцией, представленный в виде объекта <see cref="T:System.Object" />. Если этот объект <see cref="T:System.Object" /> является другим элементом HTML и существует ссылка на неуправляемую библиотеку MSHTML, добавленную в проект, элемент можно привести к соответствующему неуправляемому интерфейсу.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для вызова методов из документа объектной модели (DOM), не имеют эквивалентов в управляемом коде. Несколько аргументов все <xref:System.Windows.Forms.HtmlElement.InvokeMember%2A> будут преобразованы в Win32 `VARIANT` типы данных перед их передачей именованную функцию скрипта.  
  
   
  
## Examples  
 В следующем коде примере получается `TABLE` вызывается `dataTable` и использует не предоставленным явно `moveRow` метод, чтобы переместить в начало строки в конец таблицы.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#11](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#11)]
 [!code-vb[System.Windows.Forms.HtmlElement#11](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#11)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ KeyDown;" />
      <MemberSignature Language="F#" Value="member this.KeyDown : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.KeyDown : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь нажимает клавишу на клавиатуре.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.KeyDown> Происходит перед <xref:System.Windows.Forms.HtmlElement.KeyPress>, который в свою очередь, приводит предшествует <xref:System.Windows.Forms.HtmlElement.KeyUp>.  
  
 Вы можете отменить действие по умолчанию для <xref:System.Windows.Forms.HtmlElement.KeyDown> событий для элемента, задав <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класса `true`.  
  
 Объект <xref:System.Windows.Forms.HtmlElement.KeyDown> событий для элемента также может возникнуть в родительские элементы этого элемента а в <xref:System.Windows.Forms.HtmlDocument> класса, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класса `true`.  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.HtmlElement.KeyDown> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.KeyDown> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#442](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#442)]
 [!code-vb[System.Windows.Forms.EventExamples#442](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#442)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyPress">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler KeyPress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler KeyPress" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.KeyPress" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyPress As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ KeyPress;" />
      <MemberSignature Language="F#" Value="member this.KeyPress : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.KeyPress : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь нажимает и отпускает клавишу на клавиатуре.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.KeyPress> Происходит после <xref:System.Windows.Forms.HtmlElement.KeyDown> и перед <xref:System.Windows.Forms.HtmlElement.KeyUp>.  
  
 Вы можете отменить действие по умолчанию для <xref:System.Windows.Forms.HtmlElement.KeyPress> событий для элемента, задав <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класса `true`.  
  
 Объект <xref:System.Windows.Forms.HtmlElement.KeyPress> событий для элемента также может возникнуть в родительские элементы этого элемента а в <xref:System.Windows.Forms.HtmlDocument> класса, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класса `true`.  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.HtmlElement.KeyPress> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.KeyPress> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#443](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#443)]
 [!code-vb[System.Windows.Forms.EventExamples#443](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#443)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ KeyUp;" />
      <MemberSignature Language="F#" Value="member this.KeyUp : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.KeyUp : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь отпускает клавишу на клавиатуре.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.KeyUp> Происходит после <xref:System.Windows.Forms.HtmlElement.KeyPress>, который происходит после <xref:System.Windows.Forms.HtmlElement.KeyDown>.  
  
 Это событие нельзя отменить.  
  
 Объект <xref:System.Windows.Forms.HtmlElement.KeyUp> событий для элемента также может возникнуть в родительские элементы этого элемента а в <xref:System.Windows.Forms.HtmlDocument> класса, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класса `true`.  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.HtmlElement.KeyUp> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.KeyUp> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#444](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#444)]
 [!code-vb[System.Windows.Forms.EventExamples#444](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#444)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LosingFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler LosingFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler LosingFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.LosingFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LosingFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ LosingFocus;" />
      <MemberSignature Language="F#" Value="member this.LosingFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.LosingFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда элемент теряет фокус ввода пользователя.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.HtmlElement.LosingFocus> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.LosingFocus> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#440](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#440)]
 [!code-vb[System.Windows.Forms.EventExamples#440](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#440)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ LostFocus;" />
      <MemberSignature Language="F#" Value="member this.LostFocus : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.LostFocus : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда элемент потерял фокус ввода пользователя.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элемент больше не будет получать события нажатия клавиши после <xref:System.Windows.Forms.HtmlElement.LostFocus> выполняется до его снова, получает фокус пользователем, выбрав его на странице или приложение вызывает <xref:System.Windows.Forms.HtmlElement.Focus%2A> метода для этого элемента.  
  
 Это событие нельзя отменить.  
  
 <xref:System.Windows.Forms.HtmlElement.LostFocus> Событий для элемента также может возникнуть в родительских элементов этого элемента а в <xref:System.Windows.Forms.HtmlDocument> класса, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класса `true`.  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.HtmlElement.LostFocus> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.LostFocus> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#441](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#441)]
 [!code-vb[System.Windows.Forms.EventExamples#441](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#441)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseDown;" />
      <MemberSignature Language="F#" Value="member this.MouseDown : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseDown : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь нажимает кнопку мыши.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вы можете отменить действие по умолчанию для <xref:System.Windows.Forms.HtmlElement.MouseDown> событий для элемента, задав <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класса `true`.  
  
 Объект <xref:System.Windows.Forms.HtmlElement.MouseDown> событий для элемента также может возникнуть в родительские элементы этого элемента а в <xref:System.Windows.Forms.HtmlDocument> класса, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класса `true`.  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.HtmlElement.MouseDown> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.MouseDown> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#446](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#446)]
 [!code-vb[System.Windows.Forms.EventExamples#446](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#446)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseEnter;" />
      <MemberSignature Language="F#" Value="member this.MouseEnter : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseEnter : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь впервые наводит указатель мыши на текущий элемент.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.HtmlElement.MouseEnter> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.MouseEnter> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#449](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#449)]
 [!code-vb[System.Windows.Forms.EventExamples#449](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#449)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseLeave;" />
      <MemberSignature Language="F#" Value="member this.MouseLeave : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseLeave : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь выводит указатель мыши из текущего элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.HtmlElement.MouseLeave> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.MouseLeave> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#450](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#450)]
 [!code-vb[System.Windows.Forms.EventExamples#450](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#450)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseMove;" />
      <MemberSignature Language="F#" Value="member this.MouseMove : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseMove : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь перемещает указатель мыши по элементу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие нельзя отменить.  
  
 Объект <xref:System.Windows.Forms.HtmlElement.MouseMove> событий для элемента также может возникнуть в родительские элементы этого элемента а в <xref:System.Windows.Forms.HtmlDocument> класса, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класса `true`.  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.HtmlElement.MouseMove> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.MouseMove> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#445](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#445)]
 [!code-vb[System.Windows.Forms.EventExamples#445](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#445)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseOver As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseOver;" />
      <MemberSignature Language="F#" Value="member this.MouseOver : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseOver : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда указатель мыши входит в пределы элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вы можете отменить действие по умолчанию для <xref:System.Windows.Forms.HtmlElement.MouseOver> событий для элемента, задав <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класса `true`.  
  
 Объект <xref:System.Windows.Forms.HtmlElement.MouseOver> событий для элемента также может возникнуть в родительские элементы этого элемента а в <xref:System.Windows.Forms.HtmlDocument> класса, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класса `true`.  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.HtmlElement.MouseOver> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.MouseOver> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#447](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#447)]
 [!code-vb[System.Windows.Forms.EventExamples#447](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#447)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.HtmlElementEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.HtmlElementEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.HtmlElement.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As HtmlElementEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::HtmlElementEventHandler ^ MouseUp;" />
      <MemberSignature Language="F#" Value="member this.MouseUp : System.Windows.Forms.HtmlElementEventHandler " Usage="member this.MouseUp : System.Windows.Forms.HtmlElementEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElementEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь отпускает кнопку мыши.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вы можете отменить действие по умолчанию для <xref:System.Windows.Forms.HtmlElement.MouseUp> событий для элемента, задав <xref:System.Windows.Forms.HtmlElementEventArgs.ReturnValue%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класса `true`.  
  
 Объект <xref:System.Windows.Forms.HtmlElement.MouseUp> событий для элемента также может возникнуть в родительские элементы этого элемента а в <xref:System.Windows.Forms.HtmlDocument> класса, если не задать <xref:System.Windows.Forms.HtmlElementEventArgs.BubbleEvent%2A> свойство <xref:System.Windows.Forms.HtmlElementEventArgs> класса `true`.  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.HtmlElement.MouseUp> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.HtmlElement> с именем `HtmlElement1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.HtmlElement.MouseUp> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#448](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#448)]
 [!code-vb[System.Windows.Forms.EventExamples#448](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#448)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Windows.Forms.HtmlElement.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя элемента.</summary>
        <value>Объект <see cref="T:System.String" />, представляющий имя элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Windows.Forms.HtmlElement.Name%2A> свойство для получения элементов из документа с помощью <xref:System.Windows.Forms.HtmlElementCollection.GetElementsByName%2A> метод <xref:System.Windows.Forms.HtmlElement.All%2A> свойство <xref:System.Windows.Forms.HtmlDocument>.  
  
 При применении к `INPUT` элементов, <xref:System.Windows.Forms.HtmlElement.Name%2A> определяет имя переменной для этого элемента данных, при его форма отправляется на сервер.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NextSibling">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement NextSibling { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement NextSibling" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.NextSibling" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property NextSibling As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ NextSibling { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NextSibling : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.NextSibling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает следующий элемент, расположенный в дереве документа на одном уровне с данным элементом.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.HtmlElement" />, представляющий элемент, расположенный справа от текущего элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Windows.Forms.HtmlElement.NextSibling%2A> в сочетании с <xref:System.Windows.Forms.HtmlElement.FirstChild%2A> для прохода по дереву документа для HTML-элемента.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OffsetParent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement OffsetParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement OffsetParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OffsetParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OffsetParent As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ OffsetParent { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OffsetParent : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.OffsetParent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает элемент, из которого вычисляется <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" />.</summary>
        <value>Элемент, по которому вычисляются смещения.  Если родительский элемент или другой элемент в иерархии данного элемента использует относительное или абсолютное расположение, значением <see langword="OffsetParent" /> будет первый элемент с относительным или абсолютным расположением, в который вложен текущий элемент. Если ни один из элементов, расположенных выше текущего элемента, не имеет абсолютного или относительного положения, <see langword="OffsetParent" /> будет <c>текст</c> тег документа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы могут располагаться на HTML-страницы в одном из трех способов: по умолчанию положение потока; относительное расположение, в котором элемент смещается на фиксированное значение, относительно его родительского элемента; и допускает абсолютное позиционирование, в которой элемент получает фиксированные значения координат относительно верхнего левого угла документа.  
  
 Если элементы документа используют относительное или абсолютное расположение, можно использовать `OffsetParent` для вычисления координат положения элемента в клиентской области.  
  
 Дополнительные сведения об элементе в HTML, см. [о позиционирования элемента](http://msdn.microsoft.com/library/ms533005.aspx).  
  
   
  
## Examples  
 В следующем коде показано, как <xref:System.Windows.Forms.HtmlElement.OffsetParent%2A> и <xref:System.Windows.Forms.HtmlElement.OffsetRectangle%2A> различаются для `span1`, `span2` и `span3`:  
  
```  
<HTML>  
    <BODY id="documentBody">  
  
        <DIV id="div1">  
            <SPAN id="span1">Placeholder text 1.</SPAN>  
        </DIV>  
  
        <DIV id="div2" style="position:relative;top:100px;left:100px;">  
            <SPAN id="span2">Placeholder text 2.</SPAN>  
        </DIV>  
  
        <DIV id="div3" style="position:absolute;top:200px;left:200px;">  
            <DIV id="div4" style="position:relative;top:100px;left:100px;">  
                <SPAN id="span3">Placeholder text 3.</SPAN>  
            </DIV>  
        </DIV>  
  
    </BODY>  
</HTML>  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlElement#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OffsetRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle OffsetRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle OffsetRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OffsetRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OffsetRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle OffsetRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.OffsetRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.HtmlElement.OffsetRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает расположение элемента относительно его родительского элемента.</summary>
        <value>Координаты X и Y элемента, а также его ширина и высота относительно родительского элемента.  Если родительский элемент имеет относительное или абсолютное расположение, свойство <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" /> возвращает смещение родительского элемента. Если элемент располагается относительно своего родительского элемента, то свойство <see cref="P:System.Windows.Forms.HtmlElement.OffsetRectangle" /> возвращает смещение относительно родительского элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элементы могут располагаться на HTML-страницы в одном из трех способов:  
  
-   Потоковое расположение по умолчанию.  
  
-   Относительное расположение, в котором элемент смещается на фиксированное значение, относительно его родительского элемента.  
  
-   Абсолютное расположение, в котором элемент получает фиксированные значения координат относительно верхнего левого угла документа.  
  
 Дополнительные сведения об элементе в HTML, см. [о позиционирования элемента](http://msdn.microsoft.com/library/ms533005.aspx).  
  
   
  
## Examples  
 В следующем коде показано, как <xref:System.Windows.Forms.HtmlElement.OffsetParent%2A> и <xref:System.Windows.Forms.HtmlElement.OffsetRectangle%2A> различаются для `span1`, `span2` и `span3`:  
  
```  
<HTML>  
    <BODY id="documentBody">  
  
        <DIV id="div1">  
            <SPAN id="span1">Placeholder text 1.</SPAN>  
        </DIV>  
  
        <DIV id="div2" style="position:relative;top:100px;left:100px;">  
            <SPAN id="span2">Placeholder text 2.</SPAN>  
        </DIV>  
  
        <DIV id="div3" style="position:absolute;top:200px;left:200px;">  
            <DIV id="div4" style="position:relative;top:100px;left:100px;">  
                <SPAN id="span3">Placeholder text 3.</SPAN>  
            </DIV>  
        </DIV>  
  
    </BODY>  
</HTML>  
```  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#6](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#6)]
 [!code-vb[System.Windows.Forms.HtmlElement#6](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#6)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.OffsetParent" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Windows.Forms.HtmlElement left, System.Windows.Forms.HtmlElement right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Windows.Forms.HtmlElement left, class System.Windows.Forms.HtmlElement right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.op_Equality(System.Windows.Forms.HtmlElement,System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As HtmlElement, right As HtmlElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Windows::Forms::HtmlElement ^ left, System::Windows::Forms::HtmlElement ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Windows.Forms.HtmlElement * System.Windows.Forms.HtmlElement -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlElement" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="left">Первая коллекция <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <param name="right">Вторая категория <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <summary>Проверяет равенство двух элементов.</summary>
        <returns>Значение <see langword="true" />, если оба параметра имеют значение <see langword="null" /> или если оба элемента имеют один и тот же базовый интерфейс COM. В противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Оператор равенства тесты `IUnknown` указатели базовых объектов COM в оболочку с помощью предоставленного <xref:System.Windows.Forms.HtmlElement> классы.  
  
 Эквивалентный метод для этого оператора <xref:System.Windows.Forms.HtmlElement.Equals%2A?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Windows.Forms.HtmlElement left, System.Windows.Forms.HtmlElement right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Windows.Forms.HtmlElement left, class System.Windows.Forms.HtmlElement right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.op_Inequality(System.Windows.Forms.HtmlElement,System.Windows.Forms.HtmlElement)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As HtmlElement, right As HtmlElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Windows::Forms::HtmlElement ^ left, System::Windows::Forms::HtmlElement ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Windows.Forms.HtmlElement * System.Windows.Forms.HtmlElement -&gt; bool" Usage="System.Windows.Forms.HtmlElement.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Windows.Forms.HtmlElement" />
        <Parameter Name="right" Type="System.Windows.Forms.HtmlElement" />
      </Parameters>
      <Docs>
        <param name="left">Первая коллекция <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <param name="right">Вторая категория <see cref="T:System.Windows.Forms.HtmlElement" />.</param>
        <summary>Проверяет неравенство двух объектов <see cref="T:System.Windows.Forms.HtmlElement" />.</summary>
        <returns>Значение <see langword="true" />, если только один из элементов имеет значение <see langword="null" /> или эти два объекта не равны. В противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[Эквивалентный метод для этого оператора является отрицательными значениями <xref:System.Windows.Forms.HtmlElement.Equals%2A?displayProperty=nameWithType>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OuterHtml">
      <MemberSignature Language="C#" Value="public string OuterHtml { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OuterHtml" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OuterHtml" />
      <MemberSignature Language="VB.NET" Value="Public Property OuterHtml As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OuterHtml { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OuterHtml : string with get, set" Usage="System.Windows.Forms.HtmlElement.OuterHtml" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает HTML-код текущего элемента.</summary>
        <value>HTML-код текущего элемента и его дочерних элементов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В то время как <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> вернет все документы HTML, содержащиеся в текущий элемент, окружающих тегов текущего элемента, за исключением <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> включает тега текущего элемента, а также код HTML, содержащий тег, например:  
  
 `<HTML>`  
  
 `<BODY>`  
  
 `<DIV id="div1">`  
  
 `Hello`  
  
 `<DIV id="div2">`  
  
 `World`  
  
 `<DIV id="div3">`  
  
 `How are you?`  
  
 `</DIV>`  
  
 `</DIV>`  
  
 `</DIV>`  
  
 `</BODY>`  
  
 `</HTML>`  
  
 В этом примере вызов <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A> на `div2` возвращает:  
  
 `<DIV id="div2">`  
  
 `World`  
  
 `<DIV id="div3">`  
  
 `How are you?`  
  
 `</DIV>`  
  
 `</DIV>`  
  
 Вызов <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> возвращает:  
  
 `World`  
  
 `<DIV id="div3">`  
  
 `How are you?`  
  
 `</DIV>`  
  
 Если присвоить новое значение для <xref:System.Windows.Forms.HtmlElement.OuterHtml%2A>, ссылка на текущий элемент станут недействительными; оно не будет отражать имя, свойства и дочернего содержимого HTML-только назначенные.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerHtml" />
      </Docs>
    </Member>
    <Member MemberName="OuterText">
      <MemberSignature Language="C#" Value="public string OuterText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string OuterText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.OuterText" />
      <MemberSignature Language="VB.NET" Value="Public Property OuterText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ OuterText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.OuterText : string with get, set" Usage="System.Windows.Forms.HtmlElement.OuterText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает текст текущего элемента.</summary>
        <value>Текст внутри текущего элемента и его дочерних элементов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При попытке назначить HTML для элемента с <xref:System.Windows.Forms.HtmlElement.OuterText%2A>, HTML-код будет отображаться как литералы в документе, как если бы Просмотр HTML в текстовый файл. Если назначить HTML для элемента с помощью <xref:System.Windows.Forms.HtmlElement.InnerHtml%2A> свойства <xref:System.Windows.Forms.HtmlElement.OuterText%2A> возвращает весь текст в том, что удален HTML разметкой.  
  
 Присвоения значения <xref:System.Windows.Forms.HtmlElement.OuterText%2A> приведет к удалению всех дочерних элементов, принадлежащих к элементу.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Невозможно задать текст вне этого элемента.</exception>
        <altmember cref="P:System.Windows.Forms.HtmlElement.InnerText" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HtmlElement Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.HtmlElement Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As HtmlElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HtmlElement ^ Parent { System::Windows::Forms::HtmlElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Windows.Forms.HtmlElement" Usage="System.Windows.Forms.HtmlElement.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HtmlElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает родительский элемент текущего элемента.</summary>
        <value>Элемент, расположенный над текущим в иерархии HTML-документа.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.Parent%2A> Свойства включает обнаружение элемента контекста. Это особенно полезно внутри обработчиков событий, таких как <xref:System.Windows.Forms.HtmlElement.Click>, которые вызывают срабатывание для любого элемента в любом месте иерархии объекта документа.  
  
 <xref:System.Windows.Forms.HtmlElement.Parent%2A> HTML-элемента (верхней части HTML-документа) указывает обратно на себя. При вызове метода <xref:System.Windows.Forms.HtmlElement.Parent%2A> в цикле, убедитесь, что условия разрыва цикла сравнивает тип текущего элемента и тип `Parent` свойства, в противном случае код может выполнять бесконечный цикл.  
  
   
  
## Examples  
 В следующем примере кода выполняется поиск всех `IMG` теги в документе, а также использует <xref:System.Windows.Forms.HtmlElement.Parent%2A> свойство для проверки ли `IMG` является ссылкой на другую страницу; Если это так, код присваивает URL-адрес `ALT` атрибут `IMG`тег, чтобы пользователи, наведя указатель мыши изображения, чтобы увидеть, где будет выполняться их.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlElement#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (string eventName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RaiseEvent(string eventName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.RaiseEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RaiseEvent (eventName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RaiseEvent(System::String ^ eventName);" />
      <MemberSignature Language="F#" Value="member this.RaiseEvent : string -&gt; unit" Usage="htmlElement.RaiseEvent eventName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="eventName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="eventName">Имя создаваемого события.</param>
        <summary>Приводит к тому, что именованное событие вызывает все зарегистрированные обработчики событий.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для доступа к событиям объектной модели HTML документа (DOM). Напрямую вызывает [IHTMLElement3::fireEvent](http://go.microsoft.com/fwlink/?LinkId=103189) метод. Дополнительные сведения об использовании DOM через <xref:System.Windows.Forms.HtmlElement> см. в описании [доступ к не предоставленным явно членов управляемых объектной модели документов HTML](~/docs/framework/winforms/controls/accessing-unexposed-members-on-the-managed-html-document-object-model.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveFocus">
      <MemberSignature Language="C#" Value="public void RemoveFocus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveFocus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.RemoveFocus" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveFocus ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveFocus();" />
      <MemberSignature Language="F#" Value="member this.RemoveFocus : unit -&gt; unit" Usage="htmlElement.RemoveFocus " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет фокус из текущего элемента, если этот элемент в фокусе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода вызывает <xref:System.Windows.Forms.HtmlElement.LostFocus> событий для элемента.  
  
 При снятии фокуса с элемента с помощью этого метода назначается документа, содержащего элемент, а не к следующему элементу в последовательности табуляции.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollIntoView">
      <MemberSignature Language="C#" Value="public void ScrollIntoView (bool alignWithTop);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ScrollIntoView(bool alignWithTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.ScrollIntoView(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ScrollIntoView (alignWithTop As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ScrollIntoView(bool alignWithTop);" />
      <MemberSignature Language="F#" Value="member this.ScrollIntoView : bool -&gt; unit" Usage="htmlElement.ScrollIntoView alignWithTop" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="alignWithTop" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="alignWithTop">Если задано значение <see langword="true" />, верхняя часть объекта будет отображаться в верхней части окна. Если задано значение <see langword="false" />, нижняя часть объекта будет отображаться в нижней части окна.</param>
        <summary>Выполняет прокрутку документа, содержащего этот элемент, пока верхний или нижний край элемента не окажется выровненным с окном документа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода выполняет поиск элемента по имени и прокрутку страницы, чтобы верхнего края элемента выравнивается по верхней части страницы отображается.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#12](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#12)]
 [!code-vb[System.Windows.Forms.HtmlElement#12](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#12)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollLeft">
      <MemberSignature Language="C#" Value="public int ScrollLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScrollLeft" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ScrollLeft" />
      <MemberSignature Language="VB.NET" Value="Public Property ScrollLeft As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScrollLeft { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ScrollLeft : int with get, set" Usage="System.Windows.Forms.HtmlElement.ScrollLeft" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает расстояние между краем элемента и левым краем его содержимого.</summary>
        <value>Расстояние в пикселях между левым краем элемента и левым краем его содержимого.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Полный размеры области прокрутки могут использоваться <xref:System.Windows.Forms.HtmlElement.ScrollRectangle%2A>; `ScrollLeft` и <xref:System.Windows.Forms.HtmlElement.ScrollTop%2A> предоставляются независимо друг от друга, так как эти области прокрутки, разработчики могут задавать только два свойства.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollRectangle">
      <MemberSignature Language="C#" Value="public System.Drawing.Rectangle ScrollRectangle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Rectangle ScrollRectangle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ScrollRectangle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ScrollRectangle As Rectangle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Rectangle ScrollRectangle { System::Drawing::Rectangle get(); };" />
      <MemberSignature Language="F#" Value="member this.ScrollRectangle : System.Drawing.Rectangle" Usage="System.Windows.Forms.HtmlElement.ScrollRectangle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Rectangle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает размеры области прокрутки элемента.</summary>
        <value>Размер и координата области прокрутки элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элемент будет иметь область прокрутки, если его содержимое превышает его размеры, если стиль переполнения для элемента запрещает отрисовку полос прокрутки.  
  
 Размер области прокрутки нельзя изменять непосредственно, но можно изменить расстояние от краев области прокрутки до краев элемента. Используйте <xref:System.Windows.Forms.HtmlElement.ScrollLeft%2A> и <xref:System.Windows.Forms.HtmlElement.ScrollTop%2A> свойства, чтобы добиться этого.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ScrollTop">
      <MemberSignature Language="C#" Value="public int ScrollTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ScrollTop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.ScrollTop" />
      <MemberSignature Language="VB.NET" Value="Public Property ScrollTop As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ScrollTop { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ScrollTop : int with get, set" Usage="System.Windows.Forms.HtmlElement.ScrollTop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает расстояние между краем элемента и верхним краем его содержимого.</summary>
        <value>Расстояние в пикселях между верхним краем элемента и верхним краем его содержимого.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Полный размеры области прокрутки могут использоваться <xref:System.Windows.Forms.HtmlElement.ScrollRectangle%2A>; <xref:System.Windows.Forms.HtmlElement.ScrollLeft%2A> и `ScrollTop` предоставляются независимо друг от друга, так как эти области прокрутки, разработчики могут задавать только два свойства.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetAttribute">
      <MemberSignature Language="C#" Value="public void SetAttribute (string attributeName, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAttribute(string attributeName, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.HtmlElement.SetAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttribute (attributeName As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAttribute(System::String ^ attributeName, System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.SetAttribute : string * string -&gt; unit" Usage="htmlElement.SetAttribute (attributeName, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeName" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="attributeName">Имя атрибута, который нужно установить.</param>
        <param name="value">Новое значение этого атрибута.</param>
        <summary>Задает значение атрибута с заданным именем в элементе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Атрибут в формате HTML — любой допустимый пара имя значение для этого элемента. <xref:System.Windows.Forms.HtmlElement> предоставляет только те атрибуты, которые являются общими для всех элементов, а не к тем, которые применяются только к определенным типам элементов; `SRC` предопределенный атрибут для `IMG` тег, например, но не для `DIV` тег. Используйте <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> и <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> для работы с атрибутами, которые не представлены на управляемый объект модели DOM документа.  
  
 Если `attributeName` не является атрибутом, определенным на элементе, <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> будут определены на элемент как новый атрибут.  
  
 <xref:System.Windows.Forms.HtmlElement.GetAttribute%2A> и <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> регистр не учитывается.  
  
 Чтобы задать `class` для атрибута <xref:System.Windows.Forms.HtmlElement> , должны ссылаться на атрибут как `className` при указании первый аргумент <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A>  
  
   
  
## Examples  
 В следующем примере кода добавляется новый `IMG` элемент в текущий документ, используя <xref:System.Windows.Forms.HtmlElement.SetAttribute%2A> для задания `SRC` атрибут для изображения.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#13](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#13)]
 [!code-vb[System.Windows.Forms.HtmlElement#13](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#13)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public string Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Style { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Style : string with get, set" Usage="System.Windows.Forms.HtmlElement.Style" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает список стилей текущего элемента, разделенных точкой с запятой.</summary>
        <value>Строка, состоящая из всех стилей элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объектной модели HTML документа (DOM) используются стили, определенные в спецификации таблиц CSS консорциума World Wide Web для управления отображением элемента. Стили <xref:System.Windows.Forms.HtmlElement.Style%2A> свойства принимают форму разделенных запятой пар имя значение с каждой паре разделенных точкой с запятой, как показано ниже:  
  
 `style-name1:value1;...;[style-nameN:valueN;]`  
  
 Для задания шрифта для `DIV` элемента 14 пунктов Times New Roman полужирным шрифтом, например, можно назначить следующую строку:  
  
 `font-face:Times New Roman;font-size:14px;font-weight:bold;`  
  
 Полный список всех доступных стилей в HTML DOM см. в разделе [атрибут СТИЛЯ](http://msdn.microsoft.com/library/ms534651.aspx).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TabIndex">
      <MemberSignature Language="C#" Value="public short TabIndex { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 TabIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.TabIndex" />
      <MemberSignature Language="VB.NET" Value="Public Property TabIndex As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short TabIndex { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.TabIndex : int16 with get, set" Usage="System.Windows.Forms.HtmlElement.TabIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает расположение этого элемента в последовательности перехода.</summary>
        <value>Числовой индекс элемента в последовательности перехода.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.HtmlElement.TabIndex%2A> Определяет, какой элемент в документе HTML далее получать фокус, при нажатии клавиши TAB. По умолчанию, только элементы, включенные в последовательности табуляции `INPUT` элементов, `SELECT` управления и любой элемент которого `contentEditable` свойству `true`. Можно включить любой HTML-элемент в последовательности табуляции, такие как `DIV`, назначив явно <xref:System.Windows.Forms.HtmlElement.TabIndex%2A>.  
  
 Допустимые значения для <xref:System.Windows.Forms.HtmlElement.TabIndex%2A> в диапазоне от-32767 до 32767.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TagName">
      <MemberSignature Language="C#" Value="public string TagName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string TagName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.HtmlElement.TagName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TagName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ TagName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TagName : string" Usage="System.Windows.Forms.HtmlElement.TagName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает имя HTML-тега.</summary>
        <value>Данное имя используется для создания этого элемента с помощью разметки HTML.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Многие элементы в объектной модели документов HTML, имеют атрибуты, свойства и методы, которые являются уникальными для этих элементов; Например, `HREF` для атрибута `A` элемент, или `Submit` метод `FORM`. Используйте <xref:System.Windows.Forms.HtmlElement.TagName%2A> при имеют элемент потенциально произвольного типа и требуется для выполнения операции определенного типа.  
  
   
  
## Examples  
 В следующем примере кода выполняется поиск всех `IMG` теги в документе, а также использует `TagName` свойство для проверки ли `IMG` является ссылкой на другую страницу; Если это так, код присваивает URL-адрес `ALT` атрибут `IMG`тег, чтобы пользователи, наведя указатель мыши изображения, чтобы увидеть, где будет выполняться их.  
  
 [!code-csharp[System.Windows.Forms.HtmlElement#7](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/CS/Form1.cs#7)]
 [!code-vb[System.Windows.Forms.HtmlElement#7](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.HtmlElement/VB/Form1.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.HtmlDocument.GetElementsByTagName(System.String)" />
      </Docs>
    </Member>
  </Members>
</Type>