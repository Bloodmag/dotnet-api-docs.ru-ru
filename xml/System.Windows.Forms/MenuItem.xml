<Type Name="MenuItem" FullName="System.Windows.Forms.MenuItem">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8a283dcf6b2831ac5f93e9eab903a709ed1e0846" />
    <Meta Name="ms.sourcegitcommit" Value="058bfa0b75b777d3171411d35da8f11617fc06b0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="05/04/2018" />
    <Meta Name="ms.locfileid" Value="33659933" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class MenuItem : System.Windows.Forms.Menu" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MenuItem extends System.Windows.Forms.Menu" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.MenuItem" />
  <TypeSignature Language="VB.NET" Value="Public Class MenuItem&#xA;Inherits Menu" />
  <TypeSignature Language="C++ CLI" Value="public ref class MenuItem : System::Windows::Forms::Menu" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.Menu</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultEvent("Click")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DefaultProperty("Text")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.DesignTimeVisible(false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.ComponentModel.ToolboxItem(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет отдельный элемент, отображаемый в меню <see cref="T:System.Windows.Forms.MainMenu" /> или <see cref="T:System.Windows.Forms.ContextMenu" />. Хотя элемент управления <see cref="T:System.Windows.Forms.ToolStripMenuItem" /> заменяет элемент управления <see cref="T:System.Windows.Forms.MenuItem" /> предыдущих версий и расширяет его функциональные возможности, однако при необходимости элемент управления <see cref="T:System.Windows.Forms.MenuItem" /> можно сохранить для обратной совместимости и использования в будущем.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы <xref:System.Windows.Forms.MenuItem> отображался, необходимо добавить его в <xref:System.Windows.Forms.MainMenu> или <xref:System.Windows.Forms.ContextMenu>. Чтобы создать подменю, можно добавить <xref:System.Windows.Forms.MenuItem> объектов <xref:System.Windows.Forms.Menu.MenuItems%2A> свойство родительского объекта <xref:System.Windows.Forms.MenuItem>.  
  
 <xref:System.Windows.Forms.MenuItem> Класс предоставляет свойства, которые позволяют настраивать внешний вид и функциональные возможности элемента меню. Чтобы отобразить флажок рядом с элементом меню, используйте <xref:System.Windows.Forms.MenuItem.Checked%2A> свойство. Эту функцию можно использовать для идентификации элемента меню, который выбран в списке взаимно исключающих элементов. Например, если у вас есть набор пунктов меню для установки цвета текста в <xref:System.Windows.Forms.TextBox> управления, можно использовать <xref:System.Windows.Forms.MenuItem.Checked%2A> свойство для идентификации цветов, которые в настоящее время выбран. <xref:System.Windows.Forms.MenuItem.Shortcut%2A> Свойство может использоваться для определения сочетания клавиш, которые можно нажать для выбора элемента меню.  
  
 Для <xref:System.Windows.Forms.MenuItem> объектов, отображаемых в приложении многодокументного интерфейса (MDI), можно использовать <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> родительской метод для слияния меню MDI с, ее дочерних форм для создания консолидированной структуры меню. Поскольку <xref:System.Windows.Forms.MenuItem> нельзя использовать повторно в нескольких местах одновременно, например, в <xref:System.Windows.Forms.MainMenu> и <xref:System.Windows.Forms.ContextMenu>, можно использовать <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> метод для создания копии <xref:System.Windows.Forms.MenuItem> для использования в другом месте.  
  
 <xref:System.Windows.Forms.MenuItem.Popup> Событий позволяет выполнять задачи перед отображением меню. Например можно создать обработчик событий для этого события отобразить или скрыть элементы меню, исходя из состояния кода. <xref:System.Windows.Forms.MenuItem.Select> Событий позволяет выполнять задачи, например обеспечении подробную справку для пунктов меню приложения, когда пользователь наводит указатель мыши на элемент меню.  
  
   
  
## Examples  
 В следующем примере кода создается структура меню для формы. В примере кода добавляется <xref:System.Windows.Forms.MenuItem> для представления элемента меню верхнего уровня, к нему добавляется элемент вложенного меню для выбора размера шрифта, а затем добавляет два подменю к этому элементу, предоставляющие возможность выбора шрифта больших и малых в приложении. В примере требуется наличие <xref:System.Windows.Forms.MainMenu> объект с именем `mainMenu1` и четыре <xref:System.Windows.Forms.MenuItem> объектов с именем `menuItem1`, `menuItem2`, `menuItem3`, и `menuItem4`.  
  
 [!code-cpp[Classic Menu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic Menu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Menu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic Menu Example/CS/source.cs#1)]
 [!code-vb[Classic Menu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic Menu Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.MainMenu" />
    <altmember cref="T:System.Windows.Forms.Menu" />
    <altmember cref="T:System.Windows.Forms.MenuMerge" />
    <altmember cref="T:System.Windows.Forms.ContextMenu" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует элемент <see cref="T:System.Windows.Forms.MenuItem" /> без надписи.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После создания пустой <xref:System.Windows.Forms.MenuItem> с использованием этого конструктора, можно использовать свойства и методы <xref:System.Windows.Forms.MenuItem> класса, чтобы задать внешний вид и поведение вашей <xref:System.Windows.Forms.MenuItem>.  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Windows.Forms.MenuItem> использование этой версии конструктора.  
  
 [!code-cpp[Classic MenuItem.MenuItem Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="text">Надпись для элемента меню.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Forms.MenuItem" /> с заданной надписью для элемента меню.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При задании надписи для элемента меню с `text` параметр, можно также указать клавишу доступа, поместив символ «&» перед символом, который используется как клавиша доступа. Например указание «F» в «Файл» в качестве ключа доступа, вы укажите заголовок для элемента меню в виде «& файл». Эту функцию можно использовать для предоставления по меню с помощью клавиатуры.  
  
 Установка `text` параметр «`-`» вызывает элемент меню будет выводиться в качестве разделителя (горизонтальной линии), а не стандартного элемента.  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Windows.Forms.MenuItem> , указывающее подпись данного элемента меню во время его создания.  
  
 [!code-cpp[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, EventHandler onClick);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.EventHandler onClick) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.EventHandler)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, onClick As EventHandler)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, EventHandler ^ onClick);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
      </Parameters>
      <Docs>
        <param name="text">Надпись для элемента меню.</param>
        <param name="onClick">Объект <see cref="T:System.EventHandler" />, обрабатывающий событие <see cref="E:System.Windows.Forms.MenuItem.Click" /> для данного элемента меню.</param>
        <summary>Инициализирует новый экземпляр класса с заданной надписью и обработчиком для события <see cref="E:System.Windows.Forms.MenuItem.Click" /> данного элемента меню.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При задании надписи для элемента меню с `text` параметр, можно также указать клавишу доступа, поместив символ «&» перед символом, который используется как клавиша доступа. Например указание «F» в «Файл» в качестве ключа доступа, вы укажите заголовок для элемента меню в виде «& файл». Эту функцию можно использовать для предоставления по меню с помощью клавиатуры.  
  
 Установка `text` параметр «`-`» вызывает элемент меню будет выводиться в качестве разделителя (горизонтальной линии), а не стандартного элемента.  
  
 Кроме того, этот конструктор можно использовать для указания делегата, который будет обрабатывать <xref:System.Windows.Forms.MenuItem.Click> событий для создаваемого элемента меню. <xref:System.EventHandler> Передать этот конструктор должен быть настроен на вызов обработчика событий, который может обрабатывать <xref:System.Windows.Forms.MenuItem.Click> событий. Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Windows.Forms.MenuItem> объект с указанным заголовком и <xref:System.EventHandler> подключен делегата обработчика событий, который будет обрабатывать <xref:System.Windows.Forms.MenuItem.Click> событий для элемента меню.  
  
 [!code-cpp[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, System.Windows.Forms.MenuItem[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.Windows.Forms.MenuItem[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.Windows.Forms.MenuItem[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (text As String, items As MenuItem())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, cli::array &lt;System::Windows::Forms::MenuItem ^&gt; ^ items);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="items" Type="System.Windows.Forms.MenuItem[]" />
      </Parameters>
      <Docs>
        <param name="text">Надпись для элемента меню.</param>
        <param name="items">Массив объектов <see cref="T:System.Windows.Forms.MenuItem" />, содержащих элементы вложенного меню для данного элемента меню.</param>
        <summary>Инициализирует новый экземпляр класса с заданной подписью и массивом элементов вложенного меню для данного элемента меню.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При задании надписи для элемента меню с `text` параметр, можно также указать клавишу доступа, поместив символ «&» перед символом, который используется как клавиша доступа. Например указание «F» в «Файл» в качестве ключа доступа, вы укажите заголовок для элемента меню в виде «& файл». Эту функцию можно использовать для предоставления по меню с помощью клавиатуры.  
  
 Установка `text` параметр «`-`» вызывает элемент меню будет выводиться в качестве разделителя (горизонтальной линии), а не стандартного элемента.  
  
 `items` Позволяет назначать массив элементов меню для определения вложенного данного элемента меню. Каждый элемент в массиве также может иметь массив элементов меню. Это позволяет создавать законченные структуры меню и их назначение в конструктор для данного элемента меню.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода создает объект с указанным заголовком, обработчик событий, подключенным к методу, который будет обрабатывать событие каждого элемента меню в массиве элементов вложенного меню.  
  
 [!code-cpp[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem4 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem4 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (string text, EventHandler onClick, System.Windows.Forms.Shortcut shortcut);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string text, class System.EventHandler onClick, valuetype System.Windows.Forms.Shortcut shortcut) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.String,System.EventHandler,System.Windows.Forms.Shortcut)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::String ^ text, EventHandler ^ onClick, System::Windows::Forms::Shortcut shortcut);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
        <Parameter Name="shortcut" Type="System.Windows.Forms.Shortcut" />
      </Parameters>
      <Docs>
        <param name="text">Надпись для элемента меню.</param>
        <param name="onClick">Объект <see cref="T:System.EventHandler" />, обрабатывающий событие <see cref="E:System.Windows.Forms.MenuItem.Click" /> для данного элемента меню.</param>
        <param name="shortcut">Одно из значений перечисления <see cref="T:System.Windows.Forms.Shortcut" />.</param>
        <summary>Инициализирует новый экземпляр класса с заданной подписью, обработчиком событий и сочетанием клавиш для данного элемента меню.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При задании надписи для элемента меню с `text` параметр, можно также указать клавишу доступа, поместив символ «&» перед символом, который используется как клавиша доступа. Например указание «F» в «Файл» в качестве ключа доступа, вы укажите заголовок для элемента меню в виде «& файл». Эту функцию можно использовать для предоставления по меню с помощью клавиатуры. Этот конструктор также позволяет задать сочетание клавиш, помимо клавиши доступа для предоставления с помощью клавиатуры. Сочетания клавиш позволяют задать сочетание клавиш, которые можно использовать для активации элементов меню.  
  
 Установка `text` параметр «`-`» вызывает элемент меню будет выводиться в качестве разделителя (горизонтальной линии), а не стандартного элемента.  
  
 Кроме того, этот конструктор можно использовать для указания делегата, который будет обрабатывать <xref:System.Windows.Forms.MenuItem.Click> событий для создаваемого элемента меню. <xref:System.EventHandler> Передать этот конструктор должен быть настроен на вызов обработчика событий, который может обрабатывать <xref:System.Windows.Forms.MenuItem.Click> событий. Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода создается объект с указанным заголовком, сочетания клавиш и обработчика событий, подключенным к методу, который будет обрабатывать событие для элемента меню.  
  
 [!code-cpp[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem3 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem3 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MenuItem (System.Windows.Forms.MenuMerge mergeType, int mergeOrder, System.Windows.Forms.Shortcut shortcut, string text, EventHandler onClick, EventHandler onPopup, EventHandler onSelect, System.Windows.Forms.MenuItem[] items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Windows.Forms.MenuMerge mergeType, int32 mergeOrder, valuetype System.Windows.Forms.Shortcut shortcut, string text, class System.EventHandler onClick, class System.EventHandler onPopup, class System.EventHandler onSelect, class System.Windows.Forms.MenuItem[] items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.#ctor(System.Windows.Forms.MenuMerge,System.Int32,System.Windows.Forms.Shortcut,System.String,System.EventHandler,System.EventHandler,System.EventHandler,System.Windows.Forms.MenuItem[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MenuItem(System::Windows::Forms::MenuMerge mergeType, int mergeOrder, System::Windows::Forms::Shortcut shortcut, System::String ^ text, EventHandler ^ onClick, EventHandler ^ onPopup, EventHandler ^ onSelect, cli::array &lt;System::Windows::Forms::MenuItem ^&gt; ^ items);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mergeType" Type="System.Windows.Forms.MenuMerge" />
        <Parameter Name="mergeOrder" Type="System.Int32" />
        <Parameter Name="shortcut" Type="System.Windows.Forms.Shortcut" />
        <Parameter Name="text" Type="System.String" />
        <Parameter Name="onClick" Type="System.EventHandler" />
        <Parameter Name="onPopup" Type="System.EventHandler" />
        <Parameter Name="onSelect" Type="System.EventHandler" />
        <Parameter Name="items" Type="System.Windows.Forms.MenuItem[]" />
      </Parameters>
      <Docs>
        <param name="mergeType">Одно из значений перечисления <see cref="T:System.Windows.Forms.MenuMerge" />.</param>
        <param name="mergeOrder">Относительное положение, которое будет занимать данный элемент в меню после слияния.</param>
        <param name="shortcut">Одно из значений перечисления <see cref="T:System.Windows.Forms.Shortcut" />.</param>
        <param name="text">Надпись для элемента меню.</param>
        <param name="onClick">Объект <see cref="T:System.EventHandler" />, обрабатывающий событие <see cref="E:System.Windows.Forms.MenuItem.Click" /> для данного элемента меню.</param>
        <param name="onPopup">Объект <see cref="T:System.EventHandler" />, обрабатывающий событие <see cref="E:System.Windows.Forms.MenuItem.Popup" /> для данного элемента меню.</param>
        <param name="onSelect">Объект <see cref="T:System.EventHandler" />, обрабатывающий событие <see cref="E:System.Windows.Forms.MenuItem.Select" /> для данного элемента меню.</param>
        <param name="items">Массив объектов <see cref="T:System.Windows.Forms.MenuItem" />, содержащих элементы вложенного меню для данного элемента меню.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Forms.MenuItem" /> с заданной надписью. Определяет обработчики событий для событий <see cref="E:System.Windows.Forms.MenuItem.Click" />, <see cref="E:System.Windows.Forms.MenuItem.Select" /> и <see cref="E:System.Windows.Forms.MenuItem.Popup" />, сочетание клавиш, тип слияния и порядок, задаваемый для данного элемента меню.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При задании надписи для элемента меню с `text` параметр, можно также указать клавишу доступа, поместив символ «&» перед символом, который используется как клавиша доступа. Например указание «F» в «Файл» в качестве ключа доступа, вы укажите заголовок для элемента меню в виде «& файл». Эту функцию можно использовать для предоставления по меню с помощью клавиатуры.  
  
 Установка `text` параметр «`-`» вызывает элемент меню будет выводиться в качестве разделителя (горизонтальной линии), а не стандартного элемента.  
  
 `items` Позволяет назначать массив элементов меню для определения вложенного данного элемента меню. Каждый элемент в массиве также может иметь массив элементов меню. Это позволяет создавать законченные структуры меню и их назначение в конструктор для данного элемента меню.  
  
 `mergeType` И `mergeOrder` параметры позволяют определить поведение данного элемента меню при слиянии с другим меню пункта меню. В зависимости от значения, указываемые для `mergeType` параметр, вы можно добавить, удалить, заменить или слияние элементов меню и пунктов подменю с меню, которое его слияние с. `mergeOrder` Параметр определяет, где будет располагаться создаваемого элемента меню при слиянии меню.  
  
 Кроме того, можно использовать этот конструктор для создания <xref:System.Windows.Forms.MenuItem> и подключения его к обработчику событий в коде, который будет обрабатывать выбор пункта меню. <xref:System.EventHandler> , Передаваемый в этот конструктор должен быть настроен для вызова обработчика событий, который может обрабатывать <xref:System.Windows.Forms.MenuItem.Click> событий. С помощью этой версии конструктора, можно также подключиться, <xref:System.Windows.Forms.MenuItem.Popup> и <xref:System.Windows.Forms.MenuItem.Select> событий, чтобы определить, при выборе этого пункта меню. Эти события можно использовать для выполнения задач, таких как определение ли флажок рядом с элементами вложенного меню либо включение или отключение элементов меню на основании состояния приложения. <xref:System.Windows.Forms.MenuItem.Select> И <xref:System.Windows.Forms.MenuItem.Click> события вызываются только <xref:System.Windows.Forms.MenuItem> объекты, не родительских элементов меню. Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода создается элемент меню с надписью и сочетанием клавиш. Этот элемент меню также имеет обработчики событий, определенных для <xref:System.Windows.Forms.MenuItem.Popup>, <xref:System.Windows.Forms.MenuItem.Click>, и <xref:System.Windows.Forms.MenuItem.Select> события. При объединении данного элемента меню добавляется пункт меню меню с порядком слияния, равным нулю.  
  
 [!code-cpp[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MenuItem5 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MenuItem5 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.MenuItem.Popup" />
        <altmember cref="E:System.Windows.Forms.MenuItem.Select" />
        <altmember cref="E:System.Windows.Forms.MenuItem.Click" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeType" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeOrder" />
      </Docs>
    </Member>
    <Member MemberName="BarBreak">
      <MemberSignature Language="C#" Value="public bool BarBreak { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BarBreak" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.BarBreak" />
      <MemberSignature Language="VB.NET" Value="Public Property BarBreak As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BarBreak { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, показывающее, размещается ли <see cref="T:System.Windows.Forms.MenuItem" /> в новой строке (для элемента меню, добавленного к объекту <see cref="T:System.Windows.Forms.MainMenu" />) или в новом столбце (для элемента вложенного меню или элемента меню, отображаемого в <see cref="T:System.Windows.Forms.ContextMenu" />).</summary>
        <value>
          Значение <see langword="true" />, если элемент меню размещается в новой строке или в новом столбце, и значение <see langword="false" />, если данный элемент меню остается в положении по умолчанию. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать <xref:System.Windows.Forms.MenuItem.BarBreak%2A> свойством, чтобы создать меню, где каждый элемент меню располагается рядом с друг с другом по горизонтали вместо в вертикальном списке. Это свойство может использоваться для создания строки меню, содержащей несколько строк элементов меню верхнего уровня.  
  
 Это свойство отличается от <xref:System.Windows.Forms.MenuItem.Break%2A> свойства в том, что строка отображается по левому краю каждого элемента меню, содержащее <xref:System.Windows.Forms.MenuItem.Break%2A> свойство `true`. Панель отображается только в том случае, если элемент меню не является элементом меню верхнего уровня.  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Windows.Forms.MenuItem> с двумя элементами вложенного меню. Два элемента вложенного меню отображаются горизонтально, вместо использования по вертикали <xref:System.Windows.Forms.MenuItem.BarBreak%2A> свойство.  
  
 [!code-cpp[Classic MenuItem.BarBreak Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.BarBreak Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.BarBreak Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.BarBreak Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Break" />
      </Docs>
    </Member>
    <Member MemberName="Break">
      <MemberSignature Language="C#" Value="public bool Break { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Break" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Break" />
      <MemberSignature Language="VB.NET" Value="Public Property Break As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Break { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, показывающее, размещается ли элемент на новой строке (для элемента меню, добавленного к объекту <see cref="T:System.Windows.Forms.MainMenu" />) или в новом столбце (для элемента меню или элемента вложенного меню, отображаемого в <see cref="T:System.Windows.Forms.ContextMenu" />).</summary>
        <value>
          Значение <see langword="true" />, если элемент меню размещается в новой строке или в новом столбце, и значение <see langword="false" />, если данный элемент меню остается в положении по умолчанию. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать <xref:System.Windows.Forms.MenuItem.Break%2A> свойством, чтобы создать меню, где каждое меню располагается рядом с друг с другом по горизонтали вместо в вертикальном списке. Это свойство может использоваться для создания строки меню, содержащей несколько строк элементов меню верхнего уровня.  
  
   
  
## Examples  
 В следующем примере кода создается меню с двумя элементами меню верхнего уровня в верхней строке и одним элементом меню в нижней строке.  
  
 [!code-cpp[Classic MenuItem.Break Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Break Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Break Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Break Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Break Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Break Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.BarBreak" />
      </Docs>
    </Member>
    <Member MemberName="Checked">
      <MemberSignature Language="C#" Value="public bool Checked { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Checked" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Checked" />
      <MemberSignature Language="VB.NET" Value="Public Property Checked As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Checked { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, будет ли отображаться флажок рядом с текстом элемента меню.</summary>
        <value>
          Значение <see langword="true" />, если рядом с элементом меню устанавливается флажок, и значение <see langword="false" /> в противном случае. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать <xref:System.Windows.Forms.MenuItem.Checked%2A> свойство в сочетании с другими элементами в меню, чтобы передавать состояние для приложения. Например можно поместить флажок для пункта меню в группу элементов, чтобы определить размер шрифта для текста в приложении. Можно также использовать <xref:System.Windows.Forms.MenuItem.Checked%2A> свойство для идентификации выбранного пункта меню в группу пунктов меню взаимно исключают друг друга.  
  
> [!NOTE]
>  Это свойство не может быть присвоено `true` пункты меню верхнего уровня.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Windows.Forms.MenuItem.Checked%2A> свойства для передачи состояния в приложении. В этом примере группа элементов меню используются для задания цвета для текста в <xref:System.Windows.Forms.TextBox> элемента управления. Указанный обработчик событий используется <xref:System.Windows.Forms.MenuItem.Click> событий из трех элементов меню. Каждый элемент меню указывает цвет текста, `menuItemRed` (красный), `menuItemGreen` (зеленый) или `menuItemBlue` (синий цвет). Обработчик событий определяет, какой элемент меню выбран, устанавливает флажок для выбранного пункта меню и изменяет цвет текста в формате <xref:System.Windows.Forms.TextBox> элемента управления. В этом примере требуется <xref:System.Drawing> пространство имен будет добавлен этот код помещается в форму. В этом примере также требуется <xref:System.Windows.Forms.TextBox> был добавлен в форму, расположенных в этом примере код с именем `textBox1`.  
  
 [!code-cpp[Classic MenuItem.Checked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Checked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Checked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Checked Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Checked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Checked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Элемент <see cref="T:System.Windows.Forms.MenuItem" /> является элементом верхнего меню или содержит дочерние элементы.</exception>
      </Docs>
    </Member>
    <Member MemberName="Click">
      <MemberSignature Language="C#" Value="public event EventHandler Click;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Click" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Click" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Click As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Click;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда элемент меню выбирается щелчком мыши, с помощью сочетания клавиш или клавиши доступа, определенных для данного элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.MenuItem.Click> Событие возникает при этом <xref:System.Windows.Forms.MenuItem> нажатой пользователем. Это событие также возникает, если пользователь выбирает пункт меню с помощью клавиатуры и нажимает клавишу ВВОД. Он также может возникать при нажатии клавиши доступа или сочетание клавиш, связанное с <xref:System.Windows.Forms.MenuItem>. Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
> [!NOTE]
>  Если <xref:System.Windows.Forms.Menu.MenuItems%2A> свойство <xref:System.Windows.Forms.MenuItem> содержит элементы, это событие не происходит. Это событие не вызывается для родительских элементов меню.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.MenuItem.Click> событий для выполнения задач при <xref:System.Windows.Forms.MenuItem> нажатии. В примере создается <xref:System.Windows.Forms.MainMenu> вызывается `mainMenu1` и добавление двух <xref:System.Windows.Forms.MenuItem> объектов, `topMenuItem` (`File`) и `menuItem1` (`Open`). Затем он подключается к `Click` событие `menuItem1_Click` обработчика событий. Когда пользователь щелкает `Open` пункта меню <xref:System.Windows.Forms.OpenFileDialog> инициализируется и отображается. В этом примере предполагается, что вы создали <xref:System.Windows.Forms.Form> с именем `Form1`.  
  
 [!code-cpp[MenuItemClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItemClick/CPP/form1.cpp#1)]
 [!code-csharp[MenuItemClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItemClick/CS/form1.cs#1)]
 [!code-vb[MenuItemClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItemClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CloneMenu">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает копию <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CloneMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.MenuItem CloneMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.MenuItem CloneMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.CloneMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CloneMenu () As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::MenuItem ^ CloneMenu();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает копию текущего поставщика <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
        <returns>Объект <see cref="T:System.Windows.Forms.MenuItem" />, представляющий скопированный элемент меню.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.MenuItem> объекты не может использоваться в нескольких местах, пока не получите копию <xref:System.Windows.Forms.MenuItem>. Можно вызвать этот метод, чтобы создать копию данного элемента меню для использования в <xref:System.Windows.Forms.ContextMenu>, <xref:System.Windows.Forms.MainMenu>, или другие <xref:System.Windows.Forms.MenuItem> в приложении. При клонировании элемента меню все обработчики событий, указанный в исходном элементе меню будет продолжать работать в точной копии версии элемента меню. Например, если вы создали <xref:System.Windows.Forms.MenuItem> и подключенных его <xref:System.Windows.Forms.MenuItem.Click> событий к обработчику событий. При клонировании элемента меню данного элемента меню копия будет вызывать тот же обработчик событий.  
  
   
  
## Examples  
 В следующем примере кода в примере клоны <xref:System.Windows.Forms.MenuItem> и отображает его в <xref:System.Windows.Forms.ContextMenu>. В этом примере требуется <xref:System.Windows.Forms.MenuItem> существует в <xref:System.Windows.Forms.MainMenu> в форме с именем `menuItem1` и что <xref:System.Windows.Forms.ContextMenu> объект с именем `contextMenu1` также существует в этой форме.  
  
 [!code-cpp[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.CloneMenu Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.CloneMenu Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CloneMenu">
      <MemberSignature Language="C#" Value="protected void CloneMenu (System.Windows.Forms.MenuItem itemSrc);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void CloneMenu(class System.Windows.Forms.MenuItem itemSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.CloneMenu(System.Windows.Forms.MenuItem)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub CloneMenu (itemSrc As MenuItem)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void CloneMenu(System::Windows::Forms::MenuItem ^ itemSrc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemSrc" Type="System.Windows.Forms.MenuItem" />
      </Parameters>
      <Docs>
        <param name="itemSrc">Объект <see cref="T:System.Windows.Forms.MenuItem" />, представляющий копируемый элемент меню.</param>
        <summary>Создает копию заданного объекта <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для создания копии элементов меню, уже созданные для использования в контекстном меню или в другой структуре меню в приложении. Эта версия <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> позволяет указать конкретный <xref:System.Windows.Forms.MenuItem> копирование вместо элемента меню, вызывающего метод. Этот метод можно использовать для инициализации нового <xref:System.Windows.Forms.MenuItem> объект с копией другого <xref:System.Windows.Forms.MenuItem>. При клонировании элемента меню все обработчики событий, указанный в исходном элементе меню будет продолжать работать в точной копии версии элемента меню. Например, если вы создали <xref:System.Windows.Forms.MenuItem> и подключенных его <xref:System.Windows.Forms.MenuItem.Click> событий к обработчику событий. При клонировании элемента меню данного элемента меню копия будет вызывать тот же обработчик событий.  
  
   
  
## Examples  
 В следующем примере кода инициализируется новый <xref:System.Windows.Forms.MenuItem> с копией существующего <xref:System.Windows.Forms.MenuItem> , используемый в <xref:System.Windows.Forms.MainMenu> на форме. Затем код добавляет клонированный <xref:System.Windows.Forms.MenuItem> для <xref:System.Windows.Forms.ContextMenu> в форме. В этом примере требуется, <xref:System.Windows.Forms.MenuItem> уже создан и с именем `menuItem1` и что <xref:System.Windows.Forms.ContextMenu> элемент управления создан и с именем `contextMenu1`.  
  
 [!code-cpp[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.CloneMenu1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.CloneMenu1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultItem">
      <MemberSignature Language="C#" Value="public bool DefaultItem { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DefaultItem" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.DefaultItem" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultItem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DefaultItem { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, является ли данный элемент меню элементом по умолчанию.</summary>
        <value>
          Значение <see langword="true" />, если данный элемент меню является элементом меню по умолчанию, в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Элемент меню по умолчанию для меню отображается полужирным шрифтом. При двойном щелчке подменю, содержащее элемент по умолчанию, элемент по умолчанию выбран и вложенное меню закрывается. Можно использовать <xref:System.Windows.Forms.MenuItem.DefaultItem%2A> свойство для указания того, действие по умолчанию, ожидаемое в меню или в контекстном меню.  
  
   
  
## Examples  
 В следующем примере кода создается элемент меню с двумя элементами вложенного меню. В примере устанавливается `menuItem2` как элемент меню по умолчанию с помощью <xref:System.Windows.Forms.MenuItem.DefaultItem%2A> свойство.  
  
 [!code-cpp[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.DefaultItem Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.DefaultItem Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected override void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Dispose(bool disposing);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          Значение <see langword="true" /> позволяет освободить как управляемые, так и неуправляемые ресурсы; значение <see langword="false" /> освобождает только неуправляемые ресурсы.</param>
        <summary>Уничтожает ресурсы (кроме памяти), используемые классом <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите метод <xref:System.Windows.Forms.MenuItem.Dispose%2A> по окончании использования класса <xref:System.Windows.Forms.MenuItem>. Метод <xref:System.Windows.Forms.MenuItem.Dispose%2A> оставляет класс <xref:System.Windows.Forms.MenuItem> в непригодном для использования состоянии. После вызова метода <xref:System.Windows.Forms.MenuItem.Dispose%2A>, необходимо освободить все ссылки на <xref:System.Windows.Forms.MenuItem> , занимаемая ими память можно удалять его сборщику мусора.  
  
> [!NOTE]
>  Всегда вызывайте метод <xref:System.Windows.Forms.MenuItem.Dispose%2A> перед освобождением последней ссылки на класс <xref:System.Windows.Forms.MenuItem>. В противном случае ресурсы <xref:System.Windows.Forms.MenuItem> — не будут освобождены до сборки мусора не будет <xref:System.Windows.Forms.MenuItem> деструктор объекта.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DrawItemEventHandler DrawItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DrawItemEventHandler DrawItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.DrawItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DrawItem As DrawItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DrawItemEventHandler ^ DrawItem;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DrawItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вызывается, когда свойство <see cref="P:System.Windows.Forms.MenuItem.OwnerDraw" /> элемента меню устанавливается в значение <see langword="true" /> и выполняется запрос на отображение данного элемента меню.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.DrawItemEventArgs> Аргумент, передаваемый <xref:System.Windows.Forms.MenuItem.DrawItem> предоставляет обработчик событий <xref:System.Drawing.Graphics> объект, позволяющий выполнять рисования и другие графические операции на поверхности элемента меню. Этот обработчик событий можно использовать для создания пользовательских меню, соответствующих потребностям приложения. Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано, как обрабатывать <xref:System.Windows.Forms.MenuItem.DrawItem> событий. В этом примере рисуется элемент меню с использованием <xref:System.Drawing.Brush> и <xref:System.Drawing.Font>, а затем выводит <xref:System.Drawing.Rectangle> вокруг элемента меню. Рисование осуществляется с помощью <xref:System.Drawing.Graphics> объекта, который передается в обработчик событий <xref:System.Windows.Forms.DrawItemEventArgs> параметра. В этом примере требуется, что при инициализации <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> свойство элемента для `true`. Например, C#, добавьте следующий код в конструктор формы после `InitializeComponent`, чтобы подключить событие:  
  
 `this.menuItem1.DrawItem += new DrawItemEventHandler(menuItem1_DrawItem);`  
  
 [!code-cpp[OwnerDraw example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/OwnerDraw example/CPP/form1.cpp#1)]
 [!code-csharp[OwnerDraw example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/OwnerDraw example/CS/form1.cs#1)]
 [!code-vb[OwnerDraw example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/OwnerDraw example/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.OwnerDraw" />
        <altmember cref="E:System.Windows.Forms.MenuItem.MeasureItem" />
      </Docs>
    </Member>
    <Member MemberName="Enabled">
      <MemberSignature Language="C#" Value="public bool Enabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Enabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Enabled" />
      <MemberSignature Language="VB.NET" Value="Public Property Enabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Enabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, включен ли элемент меню.</summary>
        <value>
          Значение <see langword="true" />, если данный пункт меню включен; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Windows.Forms.MenuItem> , отключено отображается серым цветом для указания состояния. При отключении родительского пункта меню, элементы вложенного меню не отображаются.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.MenuItem.Popup> событие, чтобы определить ли <xref:System.Windows.Forms.MenuItem> объектов, которые обеспечивают поддержку для вырезания, копирования и операции удаления включены перед отображением меню, они отображаются в. В этом примере определяется, если `textBox1`, <xref:System.Windows.Forms.TextBox> управления в форме, включен, фокус ввода и имеет текст, выделенный перед включением <xref:System.Windows.Forms.MenuItem> объектов. Для этого примера требуются три <xref:System.Windows.Forms.MenuItem> создаются именованные объекты `menuCut`, `menuCopy`, и `menuDelete` были созданы.  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Index">
      <MemberSignature Language="C#" Value="public int Index { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Index" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Index" />
      <MemberSignature Language="VB.NET" Value="Public Property Index As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Index { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее положение элемента меню в его родительском меню.</summary>
        <value>Отсчитываемый от нуля индекс, указывающий положение данного элемента в его родительском меню.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предоставляет индексированное положение элемента меню в коллекции элементов меню в его родительском меню. Это свойство можно использовать для изменения положения элемента меню в другое место в пределах меню. Это свойство также можно использовать при создании <xref:System.Windows.Forms.MenuItem> для указания его положение в структуре меню во время создания.  
  
   
  
## Examples  
 В следующем примере меняются местами два элемента меню в меню. В следующем примере кода требуется два <xref:System.Windows.Forms.MenuItem> создаются именованные объекты `menuItem1` и `menuItem2`. `menuItem1` Элемент меню перемещается на одну позицию вниз в меню, а `menuItem2` перемещается на одну позицию вверх.  
  
 [!code-cpp[Classic MenuItem.Index Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Index Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Index Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Index Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Index Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Index Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Заданное значение меньше нуля или больше, чем число элементов.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsParent">
      <MemberSignature Language="C#" Value="public override bool IsParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.IsParent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsParent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsParent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, содержит ли данный элемент меню дочерние элементы меню.</summary>
        <value>
          Значение <see langword="true" />, если данный элемент меню содержит дочерние элементы меню, и значение <see langword="false" />, если данное меню — отдельный элемент меню.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать это свойство с <xref:System.Windows.Forms.MenuItem.Parent%2A> свойство для навигации в коде с помощью структуры всего меню.  
  
   
  
## Examples  
 В следующем примере кода определяет, имеются ли вложенные связанные с <xref:System.Windows.Forms.MenuItem> с именем `menuItem1`. Если существуют вложенные, он отключает их, задав <xref:System.Windows.Forms.MenuItem.Enabled%2A> свойства `false`. В примере требуется наличие <xref:System.Windows.Forms.MenuItem> названный `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.IsParent Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.IsParent Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.IsParent Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.IsParent Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MdiList">
      <MemberSignature Language="C#" Value="public bool MdiList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MdiList" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MdiList" />
      <MemberSignature Language="VB.NET" Value="Public Property MdiList As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MdiList { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, будет ли данный элемент меню заполняться с помощью списка дочерних окон интерфейса MDI, отображаемых в связанной форме.</summary>
        <value>
          Значение <see langword="true" />, если в этом элементе меню отображается список дочерних окон интерфейса MDI, и значение <see langword="false" /> в противном случае. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При выборе пункта меню для отображения списка дочерних окон интерфейса MDI список отображается в качестве вложенного элемента меню. В списке окон отображаются только формы, определенных для дочерних MDI-форм. Одновременно можно отобразить только девять дочерних окон. Если имеется более девяти дочерних окон, пункт меню «Другие окна...» отображается в конце списка. Щелкнуть этот элемент меню отображает диалоговое окно с полный список дочерних окон, которые активны в данный момент.  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Windows.Forms.MenuItem> , используемый для отображения списка открытых дочерних MDI-форм в MDI-формы.  
  
 [!code-cpp[Classic MenuItem.MdiList Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MdiList Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MdiList Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MdiList Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureItem">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.MeasureItemEventHandler MeasureItem;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.MeasureItemEventHandler MeasureItem" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.MeasureItem" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MeasureItem As MeasureItemEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::MeasureItemEventHandler ^ MeasureItem;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MeasureItemEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда меню требуются сведения о размере элемента меню перед его отрисовкой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы это событие, необходимо иметь <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> значение свойства элемента меню `true`. Это событие вызывается до отрисовки меню его владельцем Чтобы получить размер элемента меню для отображения должен быть задан. Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.MenuItem.MeasureItem> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.MenuItem> с именем `MenuItem1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.MenuItem.MeasureItem> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#499](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#499)]
 [!code-vb[System.Windows.Forms.EventExamples#499](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#499)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.OwnerDraw" />
        <altmember cref="E:System.Windows.Forms.MenuItem.DrawItem" />
      </Docs>
    </Member>
    <Member MemberName="MenuID">
      <MemberSignature Language="C#" Value="protected int MenuID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MenuID" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MenuID" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property MenuID As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property int MenuID { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее идентификатор Windows для данного элемента меню.</summary>
        <value>Идентификатор Windows для данного элемента меню.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MergeMenu">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет слияние этого элемента <see cref="T:System.Windows.Forms.MenuItem" /> с другим элементом <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MergeMenu">
      <MemberSignature Language="C#" Value="public virtual System.Windows.Forms.MenuItem MergeMenu ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.Forms.MenuItem MergeMenu() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.MergeMenu" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MergeMenu () As MenuItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::Forms::MenuItem ^ MergeMenu();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuItem</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Выполняет слияние этого элемента <see cref="T:System.Windows.Forms.MenuItem" /> с другим элементом <see cref="T:System.Windows.Forms.MenuItem" /> и возвращает элемент <see cref="T:System.Windows.Forms.MenuItem" />, полученный в результате слияния.</summary>
        <returns>Объект <see cref="T:System.Windows.Forms.MenuItem" />, представляющий объединенный элемент меню.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При вызове этой версии <xref:System.Windows.Forms.MenuItem.MergeMenu%2A>, <xref:System.Windows.Forms.MenuItem> возвращается является копией текущего элемента меню, могут быть объединены с другим элементом меню, не затрагивая функциональность текущего элемента. Эта версия <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> работает как вызов метода <xref:System.Windows.Forms.MenuItem.CloneMenu%2A> метод, который не содержит параметров.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MergeMenu">
      <MemberSignature Language="C#" Value="public void MergeMenu (System.Windows.Forms.MenuItem itemSrc);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void MergeMenu(class System.Windows.Forms.MenuItem itemSrc) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.MergeMenu(System.Windows.Forms.MenuItem)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MergeMenu (itemSrc As MenuItem)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void MergeMenu(System::Windows::Forms::MenuItem ^ itemSrc);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="itemSrc" Type="System.Windows.Forms.MenuItem" />
      </Parameters>
      <Docs>
        <param name="itemSrc">Объект <see cref="T:System.Windows.Forms.MenuItem" />, задающий элемент меню, предназначенный для слияния с данным элементом.</param>
        <summary>Выполняет слияние другого элемента меню с данным элементом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пункты меню объединяются в соответствии со значением элемента меню <xref:System.Windows.Forms.MenuItem.MergeType%2A> и <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> свойства. Эта версия <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> метод позволяет объединять два <xref:System.Windows.Forms.MenuItem> объектов (и их вложенные меню) в единое меню. Слияние меню обрабатывается автоматически, когда родительская форма многодокументного интерфейса (MDI) и дочерняя форма имеют меню. Можно использовать данную версию метода для объединения двух <xref:System.Windows.Forms.MenuItem> объектов (и их подменю) находится в <xref:System.Windows.Forms.MainMenu> элемента управления в единое меню в <xref:System.Windows.Forms.ContextMenu>. Например, можно вызвать этой версии <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> способ слияния пунктов меню File и Edit в единый <xref:System.Windows.Forms.MenuItem> добавлены и отобразить <xref:System.Windows.Forms.ContextMenu>.  
  
   
  
## Examples  
 В следующем примере кода используется эта версия <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> метод для создания копии <xref:System.Windows.Forms.MenuItem> и их слияние с другим. Объединенный <xref:System.Windows.Forms.MenuItem> добавляется <xref:System.Windows.Forms.ContextMenu> элемента управления. В этом примере необходимы два элемента меню `menuItem1` и `menuItem2` , содержащие элементы вложенного меню в них и <xref:System.Windows.Forms.ContextMenu> с именем `contextMenu1` для отображения элементов меню. `menuItem1` и `menuItem2` другое меню элементов, содержащихся в них. После вызова <xref:System.Windows.Forms.MenuItem.MergeMenu%2A> создается объединенное меню создается.  
  
 [!code-cpp[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MergeMenu1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MergeMenu1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MergeOrder">
      <MemberSignature Language="C#" Value="public int MergeOrder { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MergeOrder" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MergeOrder" />
      <MemberSignature Language="VB.NET" Value="Public Property MergeOrder As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int MergeOrder { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее относительное положение данного элемента меню при его слиянии с другим элементом.</summary>
        <value>Начинающийся с нуля индекс, представляющий позицию порядка слияния для данного элемента меню. Значение по умолчанию — 0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Порядок объединения элемента меню указывает относительное положение данного элемента меню будет выполняться, если структура меню, содержащая <xref:System.Windows.Forms.MenuItem> содержится объединяется с другим.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> свойства для управления отображением объединенное меню. Это полный пример, готовый для выполнения после его добавления в проект.  
  
 [!code-cpp[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MenuItemMergeOrder#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MenuItemMergeOrder/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeType" />
        <altmember cref="M:System.Windows.Forms.MenuItem.MergeMenu" />
      </Docs>
    </Member>
    <Member MemberName="MergeType">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.MenuMerge MergeType { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.MenuMerge MergeType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.MergeType" />
      <MemberSignature Language="VB.NET" Value="Public Property MergeType As MenuMerge" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::MenuMerge MergeType { System::Windows::Forms::MenuMerge get(); void set(System::Windows::Forms::MenuMerge value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.MenuMerge</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее поведение данного элемента меню при слиянии его меню с другим меню.</summary>
        <value>Значение <see cref="T:System.Windows.Forms.MenuMerge" />, показывающее тип слияния данного элемента меню.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип объединения элемента меню указывает поведение элемента меню, когда он имеет такой же порядок объединения, как выполняется слияние другого элемента меню. Слияние меню можно использовать для создания объединенного меню на основе двух или более существующих меню.  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Windows.Forms.MenuItem> с <xref:System.Windows.Forms.MenuItem.MergeType%2A> и <xref:System.Windows.Forms.MenuItem.MergeOrder%2A> , чтобы пункт меню добавляется объединенное меню в первой позиции.  
  
 [!code-cpp[Classic MenuItem.MergeType Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.MergeType Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.MergeType Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.MergeType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Присваиваемое значение не относится к значениям <see cref="T:System.Windows.Forms.MenuMerge" />.</exception>
        <altmember cref="T:System.Windows.Forms.MenuMerge" />
        <altmember cref="P:System.Windows.Forms.MenuItem.MergeOrder" />
      </Docs>
    </Member>
    <Member MemberName="Mnemonic">
      <MemberSignature Language="C#" Value="public char Mnemonic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char Mnemonic" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Mnemonic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Mnemonic As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property char Mnemonic { char get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее назначенный символ, связанный с данным элементом меню.</summary>
        <value>Назначенный символ, сопоставленный с данным элементом меню. Возвращает символ NUL (код ASCII 0), если в тексте <see cref="T:System.Windows.Forms.MenuItem" /> не задан назначенный символ.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Назначенный символ является первым символом после символ амперсанда (&) в тексте <xref:System.Windows.Forms.MenuItem>. Это свойство не будет возвращать назначенный, если два символа амперсанда размещаются вместе как амперсанды используются для отображения амперсанда в тексте <xref:System.Windows.Forms.MenuItem> вместо того чтобы определять назначенный символ.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Text" />
      </Docs>
    </Member>
    <Member MemberName="OnClick">
      <MemberSignature Language="C#" Value="protected virtual void OnClick (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClick(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClick (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClick(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.MenuItem.Click" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.MenuItem.Click> событий для выполнения задач при <xref:System.Windows.Forms.MenuItem> нажатии. В примере создается <xref:System.Windows.Forms.MainMenu> вызывается `mainMenu1` и добавление двух <xref:System.Windows.Forms.MenuItem> объектов, `topMenuItem` (`File`) и `menuItem1` (`Open`). Затем он подключается к `Click` событие `menuItem1_Click` обработчика событий. Когда пользователь щелкает `Open` пункта меню <xref:System.Windows.Forms.OpenFileDialog> инициализируется и отображается. В этом примере предполагается, что вы создали <xref:System.Windows.Forms.Form> с именем `Form1`.  
  
 [!code-cpp[MenuItemClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItemClick/CPP/form1.cpp#1)]
 [!code-csharp[MenuItemClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItemClick/CS/form1.cs#1)]
 [!code-vb[MenuItemClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItemClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Windows.Forms.MenuItem.OnClick(System.EventArgs)" /> метод.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDrawItem">
      <MemberSignature Language="C#" Value="protected virtual void OnDrawItem (System.Windows.Forms.DrawItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDrawItem(class System.Windows.Forms.DrawItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDrawItem (e As DrawItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDrawItem(System::Windows::Forms::DrawItemEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.DrawItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Forms.DrawItemEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.MenuItem.DrawItem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Windows.Forms.MenuItem.OnDrawItem(System.Windows.Forms.DrawItemEventArgs)" /> метод.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.DrawItemEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnInitMenuPopup">
      <MemberSignature Language="C#" Value="protected virtual void OnInitMenuPopup (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitMenuPopup(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnInitMenuPopup(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitMenuPopup (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitMenuPopup(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.MenuItem.Popup" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMeasureItem">
      <MemberSignature Language="C#" Value="protected virtual void OnMeasureItem (System.Windows.Forms.MeasureItemEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnMeasureItem(class System.Windows.Forms.MeasureItemEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnMeasureItem (e As MeasureItemEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnMeasureItem(System::Windows::Forms::MeasureItemEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.MeasureItemEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Forms.MeasureItemEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.MenuItem.MeasureItem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Windows.Forms.MenuItem.OnMeasureItem(System.Windows.Forms.MeasureItemEventArgs)" /> метод.</para>
        </block>
        <altmember cref="T:System.Windows.Forms.MeasureItemEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="OnPopup">
      <MemberSignature Language="C#" Value="protected virtual void OnPopup (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPopup(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPopup (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPopup(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.MenuItem.Popup" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.MenuItem.Popup> событие, чтобы определить ли <xref:System.Windows.Forms.MenuItem> объектов, которые обеспечивают поддержку для вырезания, копирования и операции удаления включены перед отображением меню, они отображаются в. В этом примере определяется, если `textBox1`, <xref:System.Windows.Forms.TextBox> управления в форме, включен, фокус ввода и имеет текст, выделенный перед включением <xref:System.Windows.Forms.MenuItem> объектов. Для этого примера требуются три <xref:System.Windows.Forms.MenuItem> создаются именованные объекты `menuCut`, `menuCopy`, и `menuDelete` были созданы.  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Windows.Forms.MenuItem.OnPopup(System.EventArgs)" /> метод.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSelect">
      <MemberSignature Language="C#" Value="protected virtual void OnSelect (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelect(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelect (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelect(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.MenuItem.Select" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.MenuItem.Select> событие <xref:System.Windows.Forms.MenuItem> для назначения текст справки для <xref:System.Windows.Forms.StatusBarPanel> из <xref:System.Windows.Forms.StatusBar> элемента управления. В этом примере требуется, <xref:System.Windows.Forms.MenuItem> объектов с именем `menuOpen`, `menuSave`, и `menuExit` добавляются <xref:System.Windows.Forms.MainMenu> элемента управления в форме. В этом примере также требуется <xref:System.Windows.Forms.StatusBar> управления с именем `statusBar1` был добавлен в форму. <xref:System.Windows.Forms.StatusBar> Элемент управления должен содержать <xref:System.Windows.Forms.StatusBarPanel>.  
  
 [!code-cpp[MenuItem.Select#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Select/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Select#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Select/CS/form1.cs#1)]
 [!code-vb[MenuItem.Select#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Select/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Windows.Forms.MenuItem.OnSelect(System.EventArgs)" /> метод.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OwnerDraw">
      <MemberSignature Language="C#" Value="public bool OwnerDraw { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OwnerDraw" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.OwnerDraw" />
      <MemberSignature Language="VB.NET" Value="Public Property OwnerDraw As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OwnerDraw { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее, будет элемент меню рисоваться с помощью передаваемого кода или средствами Windows.</summary>
        <value>
          Значение <see langword="true" />, если элемент меню рисуется в программном коде, и значение <see langword="false" />, если элемент меню рисуется средствами Windows. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> свойству `true`, необходимо обработать все рисование элемента меню. Эту возможность можно использовать для создания собственных стилей отображения меню.  
  
   
  
## Examples  
 В следующем примере кода показано меню с элементом меню владельцем. Этот пример набора <xref:System.Windows.Forms.MenuItem.OwnerDraw%2A> свойство и использует `AddHandler` инструкции и `AddressOf` оператор, чтобы назначить делегата для обработки <xref:System.Windows.Forms.MenuItem.DrawItem> событий. Чтобы запустить пример, вставьте его в форму, которая импортирует <xref:System>, <xref:System.Windows.Forms>, и <xref:System.Drawing> пространства имен. Вызовите `InitializeMenu` из конструктора формы или `Load` метод.  
  
 [!code-cpp[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.MenuItemOwnerDraw#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.MenuItemOwnerDraw/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Drawing.Graphics" />
        <altmember cref="T:System.Windows.Forms.Menu" />
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Menu Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.Menu Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As Menu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Menu ^ Parent { System::Windows::Forms::Menu ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Menu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее меню, содержащее данный элемент меню.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.Menu" />, представляющий меню, содержащее данный элемент меню.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство можно использовать для получения <xref:System.Windows.Forms.Menu> объекта для подменю. Можно привести <xref:System.Windows.Forms.Menu> объект, возвращаемый этим свойством, чтобы <xref:System.Windows.Forms.MenuItem> для операций.  
  
   
  
## Examples  
 В этом примере создания главного меню и элемент меню верхнего уровня `menuItem1` (`File`). Можно также создать два элемента меню `menuItem2` (`New`) и `menuItem3` (`Open`) и добавить их в список элементов меню из `menuItem1`. Затем проверьте ли `menuItem3` есть родительский элемент меню, который имеет значение true и отображать сведения об этом родительском меню в окне сообщения. В этом примере требуется, что вы создали <xref:System.Windows.Forms.Form> с именем `Form1`.  
  
 [!code-cpp[ParentMenu#1](~/samples/snippets/cpp/VS_Snippets_Winforms/ParentMenu/CPP/form1.cpp#1)]
 [!code-csharp[ParentMenu#1](~/samples/snippets/csharp/VS_Snippets_Winforms/ParentMenu/CS/form1.cs#1)]
 [!code-vb[ParentMenu#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/ParentMenu/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformClick">
      <MemberSignature Language="C#" Value="public void PerformClick ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void PerformClick() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.PerformClick" />
      <MemberSignature Language="VB.NET" Value="Public Sub PerformClick ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PerformClick();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает событие <see cref="E:System.Windows.Forms.Control.Click" />, имитирующее щелчок мышью для элемента <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В этом меню можно использовать для активации элемента меню с помощью кода, не передавая никаких сведений о событии. Например, если нужно активировать элемент меню на основе действия, происходящего в приложении, можно вызвать <xref:System.Windows.Forms.MenuItem.PerformClick%2A> , метод <xref:System.Windows.Forms.MenuItem>.  
  
   
  
## Examples  
 В этом примере программным путем нажатия пункта меню с помощью `PerformClick` метод. Сначала создайте главного меню (`mainMenu1`) и добавьте к нему двух пунктов меню `menuItem1` (`File`) и `menuItem2` (`Edit`). Можно также использовать <xref:System.Windows.Forms.MenuItem.Click> событий для отправки данных в обработчик событий, при выборе пункта меню. Затем с помощью `PerformClick` метод щелкнуть `File` элемента меню. При запуске приложения, `File` активируется элемент меню и окно сообщения с текстом «Файл при выборе меню.» отображается на экране. В этом примере предполагается, что вы создали <xref:System.Windows.Forms.Form> с именем `Form1`.  
  
 [!code-cpp[PerformClick#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PerformClick/CPP/form1.cpp#1)]
 [!code-csharp[PerformClick#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PerformClick/CS/form1.cs#1)]
 [!code-vb[PerformClick#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PerformClick/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PerformSelect">
      <MemberSignature Language="C#" Value="public virtual void PerformSelect ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PerformSelect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.PerformSelect" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub PerformSelect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void PerformSelect();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.MenuItem.Select" /> для данного элемента меню.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод позволяет вызывать <xref:System.Windows.Forms.MenuItem.Select> событий без передачи каких-либо сведений в обработчик событий.  
  
   
  
## Examples  
 В этом примере при выборе пункта меню программными средствами с помощью `PerformSelect` метод. Сначала создайте главного меню (`mainMenu1`) и добавьте к нему двух пунктов меню `menuItem1` (`File`) и `menuItem2` (`Edit`). Можно также использовать <xref:System.Windows.Forms.MenuItem.Select> событий для отправки данных в обработчик событий, при выборе пункта меню. Затем с помощью `PerformSelect` метод для выбора `File` элемента меню. При запуске приложения, `File` выбран элемент меню и окно сообщения с текстом «Меню выбран файл.» отображается на экране. В этом примере предполагается, что вы создали <xref:System.Windows.Forms.Form> с именем `Form1`.  
  
 [!code-cpp[PerformSelect#1](~/samples/snippets/cpp/VS_Snippets_Winforms/PerformSelect/CPP/form1.cpp#1)]
 [!code-csharp[PerformSelect#1](~/samples/snippets/csharp/VS_Snippets_Winforms/PerformSelect/CS/form1.cs#1)]
 [!code-vb[PerformSelect#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/PerformSelect/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.MenuItem.PerformClick" />
      </Docs>
    </Member>
    <Member MemberName="Popup">
      <MemberSignature Language="C#" Value="public event EventHandler Popup;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Popup" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Popup" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Popup As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Popup;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит перед отображением списка элементов меню.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие происходит только после подменю для отображения пункта меню. Этот обработчик событий можно использовать для добавления, удаления, включить, отключить, установите или снимите пунктов меню, исходя из состояния приложения перед их отображением. Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.MenuItem.Popup> событие, чтобы определить ли <xref:System.Windows.Forms.MenuItem> объектов, которые обеспечивают поддержку для вырезания, копирования и операции удаления включены перед отображением меню, они отображаются в. В этом примере определяется, если `textBox1`, <xref:System.Windows.Forms.TextBox> управления в форме, включен, фокус ввода и имеет текст, выделенный перед включением <xref:System.Windows.Forms.MenuItem> объектов. Для этого примера требуются три <xref:System.Windows.Forms.MenuItem> создаются именованные объекты `menuCut`, `menuCopy`, и `menuDelete` были созданы.  
  
 [!code-cpp[MenuItem.Popup#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Popup/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Popup#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Popup/CS/form1.cs#1)]
 [!code-vb[MenuItem.Popup#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Popup/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RadioCheck">
      <MemberSignature Language="C#" Value="public bool RadioCheck { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RadioCheck" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.RadioCheck" />
      <MemberSignature Language="VB.NET" Value="Public Property RadioCheck As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RadioCheck { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, показывающее, будет ли в случае выбора элемента <see cref="T:System.Windows.Forms.MenuItem" /> выводиться переключатель, а не флажок.</summary>
        <value>
          Значение <see langword="true" />, если вместо флажка будет использоваться переключатель, и значение <see langword="false" />, если в случае выбора элемента меню будет отображаться стандартный флажок. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Флажки не обязательно подразумевают взаимно исключают друг друга состояние для группы элементов меню. Это свойство можно использовать, чтобы уведомить пользователя, что флажок для пункта меню являются взаимно исключающими.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Windows.Forms.MenuItem.Checked%2A> свойства для изменения состояния приложения. В примере группу пунктов меню, при условии, что используются для задания цвета для текста в <xref:System.Windows.Forms.TextBox> элемента управления. В примере используется предоставленный обработчик событий <xref:System.Windows.Forms.MenuItem.Click> событие в трех элементах меню. Каждый элемент меню указывает цвет `menuItemRed`, `menuItemGreen`, или `menuItemBlue`. Обработчик событий определяет, какой элемент меню выбран, устанавливает флажок для выбранного пункта меню и изменяет цвет текста в формате <xref:System.Windows.Forms.TextBox> управления с именем `textBox1`. В примере также используется <xref:System.Windows.Forms.MenuItem.RadioCheck%2A> свойство, чтобы продемонстрировать, как проверка переключатель используется для отображения элементов меню, которые являются взаимоисключающими. В этом примере требуется, <xref:System.Drawing?displayProperty=nameWithType> пространство имен будет добавлен в форму, содержащую этот код.  
  
 [!code-cpp[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.RadioCheck Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.RadioCheck Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Checked" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public event EventHandler Select;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Select" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.MenuItem.Select" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Select As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Select;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда пользователь наводит указатель мыши на элемент меню.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие обычно происходит, когда пользователь наводит указатель мыши на элемент меню. Это событие также может возникнуть, когда пользователь выделяет элемент меню с помощью клавиатуры, перейдите к пункту меню с помощью клавиш со стрелками. Это событие можно использовать для отображения строки подробные справочные сведения, относящиеся к данному элементу меню в строке состояния приложения. Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
> [!NOTE]
>  Если <xref:System.Windows.Forms.Menu.MenuItems%2A> свойство <xref:System.Windows.Forms.MenuItem> содержит элементы, это событие не происходит. Это событие не вызывается для родительских элементов меню.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.MenuItem.Select> событие <xref:System.Windows.Forms.MenuItem> для назначения текст справки для <xref:System.Windows.Forms.StatusBarPanel> из <xref:System.Windows.Forms.StatusBar> элемента управления. В этом примере требуется, <xref:System.Windows.Forms.MenuItem> объектов с именем `menuOpen`, `menuSave`, и `menuExit` добавляются <xref:System.Windows.Forms.MainMenu> элемента управления в форме. В этом примере также требуется <xref:System.Windows.Forms.StatusBar> управления с именем `statusBar1` был добавлен в форму. <xref:System.Windows.Forms.StatusBar> Элемент управления должен содержать <xref:System.Windows.Forms.StatusBarPanel>.  
  
 [!code-cpp[MenuItem.Select#1](~/samples/snippets/cpp/VS_Snippets_Winforms/MenuItem.Select/CPP/form1.cpp#1)]
 [!code-csharp[MenuItem.Select#1](~/samples/snippets/csharp/VS_Snippets_Winforms/MenuItem.Select/CS/form1.cs#1)]
 [!code-vb[MenuItem.Select#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/MenuItem.Select/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.MenuItem.Click" />
      </Docs>
    </Member>
    <Member MemberName="Shortcut">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.Shortcut Shortcut { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.Shortcut Shortcut" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Shortcut" />
      <MemberSignature Language="VB.NET" Value="Public Property Shortcut As Shortcut" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::Shortcut Shortcut { System::Windows::Forms::Shortcut get(); void set(System::Windows::Forms::Shortcut value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.Shortcut</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее сочетание клавиш для данного элемента меню.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Windows.Forms.Shortcut" />. Значение по умолчанию: <see langword="Shortcut.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сочетания клавиш позволяют пользователям вызывать часто используемые элементы меню в системе меню и на доступ с клавиатуры в приложение для пользователей, которые имеют доступ к мыши или другого устройства указатель.  
  
   
  
## Examples  
 В следующем примере кода создается элемент меню, задает заголовок, назначается сочетание клавиш, делает элемент меню видимым и отображается сочетание клавиш для элемента меню. В этом примере требуется <xref:System.Windows.Forms.MenuItem> будет создана, с именем `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Присваиваемое значение не относится к значениям <see cref="T:System.Windows.Forms.Shortcut" />.</exception>
        <altmember cref="T:System.Windows.Forms.Shortcut" />
      </Docs>
    </Member>
    <Member MemberName="ShowShortcut">
      <MemberSignature Language="C#" Value="public bool ShowShortcut { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowShortcut" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.ShowShortcut" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowShortcut As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowShortcut { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, будет ли сочетание клавиш для данного элемента меню, отображаться рядом с текстом подписи для этого элемента.</summary>
        <value>
          Значение <see langword="true" />, если сочетание клавиш отображается рядом с надписью элемента меню, и значение <see langword="false" />, если сочетание клавиш не отображается. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство можно использовать для предоставления пользователям возможность скрывать сочетания клавиш меню для экономии места или скрыть сочетания клавиш будут отображаться.  
  
   
  
## Examples  
 В следующем примере кода создается элемент меню, задает заголовок, назначается сочетание клавиш, делает элемент меню видимым и отображается сочетание клавиш для элемента меню. В этом примере требуется <xref:System.Windows.Forms.MenuItem> будет создана, с именем `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Shortcut" />
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Text" />
      <MemberSignature Language="VB.NET" Value="Public Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее подпись данного элемента меню.</summary>
        <value>Текст подписи данного элемента меню.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При указании заголовка для элемента меню можно также указать клавишу доступа, поместив символ «&» перед символом, который используется как ключ доступа. Например указание «F» в «Файл» в качестве ключа доступа, вы укажите заголовок для элемента меню в виде «& файл». Эту функцию можно использовать для предоставления по меню с помощью клавиатуры.  
  
 Присвоение этому свойству «`-`» вызывает элемент меню будет выводиться в качестве разделителя (горизонтальной линии), а не стандартного элемента.  
  
   
  
## Examples  
 В следующем примере кода создается элемент меню, задает заголовок, назначается сочетание клавиш, делает элемент меню видимым и отображается сочетание клавиш для элемента меню. В этом примере требуется <xref:System.Windows.Forms.MenuItem> будет создана, с именем `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.MenuItem.Mnemonic" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.MenuItem.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает строку, представляющую объект <see cref="T:System.Windows.Forms.MenuItem" />.</summary>
        <returns>Строка, представляющая текущий объект <see cref="T:System.Windows.Forms.MenuItem" />. Строка содержит тип и свойство <see cref="P:System.Windows.Forms.MenuItem.Text" /> элемента управления.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Visible">
      <MemberSignature Language="C#" Value="public bool Visible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Visible" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.MenuItem.Visible" />
      <MemberSignature Language="VB.NET" Value="Public Property Visible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Visible { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, будет ли видимым данный элемент меню.</summary>
        <value>
          Значение <see langword="true" />, если данный элемент меню будет виден в меню. В противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство можно использовать для изменения структуры меню без объединения или отключения меню. Например, если вы хотите скрыть часть функциональности из меню в приложении, можно скрыть их от пользователя, присвоив этому свойству значение `false`.  
  
   
  
## Examples  
 В следующем примере кода создается элемент меню, задает заголовок, назначается сочетание клавиш, делает элемент меню видимым и отображается сочетание клавиш для элемента меню. В этом примере требуется <xref:System.Windows.Forms.MenuItem> будет создана, с именем `menuItem1`.  
  
 [!code-cpp[Classic MenuItem.Text Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MenuItem.Text Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic MenuItem.Text Example/CS/source.cs#1)]
 [!code-vb[Classic MenuItem.Text Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic MenuItem.Text Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>