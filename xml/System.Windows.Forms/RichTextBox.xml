<Type Name="RichTextBox" FullName="System.Windows.Forms.RichTextBox">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f6bc4582e825296fa306e1a8f5b9ad0a64930707" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36516168" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RichTextBox : System.Windows.Forms.TextBoxBase" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RichTextBox extends System.Windows.Forms.TextBoxBase" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Forms.RichTextBox" />
  <TypeSignature Language="VB.NET" Value="Public Class RichTextBox&#xA;Inherits TextBoxBase" />
  <TypeSignature Language="C++ CLI" Value="public ref class RichTextBox : System::Windows::Forms::TextBoxBase" />
  <TypeSignature Language="F#" Value="type RichTextBox = class&#xA;    inherit TextBoxBase" />
  <AssemblyInfo>
    <AssemblyName>System.Windows.Forms</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Forms.TextBoxBase</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.Designer("System.Windows.Forms.Design.RichTextBoxDesigner, System.Design, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Forms.Docking(System.Windows.Forms.DockingBehavior.Ask)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет элемент управления полем форматированного текста Windows.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 С <xref:System.Windows.Forms.RichTextBox> элемента управления, пользователь может вводить и редактировать текст. Элемент управления также предоставляет расширенные возможности форматирования, чем стандартные <xref:System.Windows.Forms.TextBox> элемента управления. Текст можно назначить непосредственно в элемент управления, или можно загрузить в формате RTF (RTF) или текстового файла. Текст в элементе управления можно назначить форматирование знаков и абзацев.  
  
 <xref:System.Windows.Forms.RichTextBox> Элемент управления предоставляет ряд свойств, которые можно использовать при применении форматирования к любой части текста в элементе управления. Чтобы изменить форматирование текста, его необходимо сначала выбрать. Форматирование знаков и абзацев, могут назначаться только выделенный текст. После параметра была предпринята выбранный фрагмент текста, выбран текст, введенный после выбора также отформатирован с теми же параметрами до изменения параметра или в другой раздел документа элемента управления. <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A> Позволяет сделать текст полужирным шрифтом или курсивом. Это свойство также можно изменить размер и шрифт текста. <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> Свойства можно изменить цвет текста. Чтобы создать маркированные списки, можно использовать <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> свойства. Можно также настроить форматирование, задав абзацев <xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A>, <xref:System.Windows.Forms.RichTextBox.SelectionRightIndent%2A>, и <xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A> свойства.  
  
 <xref:System.Windows.Forms.RichTextBox> Элемент управления предоставляет методы, которые предоставляют функциональные возможности для открытия и сохранения файлов. <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> Метод позволяет загрузить существующий текстовый файл ASCII или RTF в элемент управления. Можно также загрузить данные из уже открытого потока данных. <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> Позволяет сохранить файл в формате RTF или ASCII текст. Аналогично <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> метод, можно также использовать <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> метод для сохранения в открытый поток данных. <xref:System.Windows.Forms.RichTextBox> Управления также предоставляет возможности для поиска строк текста. <xref:System.Windows.Forms.RichTextBox.Find%2A> Метод перегружен, чтобы найти обеих строк текста и отдельных символов в тексте элемента управления.  
  
 Можно также инициализировать <xref:System.Windows.Forms.RichTextBox> элемента управления к данным, хранящимся в памяти. Например, можно инициализировать <xref:System.Windows.Forms.RichTextBox.Rtf%2A> строковое значение, содержащее текст для отображения, включая коды RTF, которые определяют, как следует форматировать текст.  
  
 Если текст в элементе управления содержит ссылки, например ссылку на веб-сайт можно использовать <xref:System.Windows.Forms.RichTextBox.DetectUrls%2A> свойство для отображения ссылки соответствующим образом в тексте элемента управления. Затем можно обработать <xref:System.Windows.Forms.RichTextBox.LinkClicked> событий для выполнения задач, связанных со ссылкой. <xref:System.Windows.Forms.RichTextBox.SelectionProtected%2A> Позволяет защитить от обработки пользователем текста в элементе управления. Текст в элементе управления, можно обработать <xref:System.Windows.Forms.RichTextBox.Protected> событие, чтобы определить, когда пользователь предпримет попытку изменить защищенный текст и либо оповестить пользователя о том, что текст защищена, или предоставить пользователю стандартный способ работы с защищенным текстом.  
  
 Приложения, которые уже используют <xref:System.Windows.Forms.TextBox> элементов управления не составит особого труда вносить использование <xref:System.Windows.Forms.RichTextBox> элементов управления. Тем не менее <xref:System.Windows.Forms.RichTextBox> управления не имеет такое же ограничение емкости 64K символов из <xref:System.Windows.Forms.TextBox> элемента управления. <xref:System.Windows.Forms.RichTextBox> Обычно используется для работы с текстом и отображения функций, как для текстовых редакторов, таких как Microsoft Word.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.TextBoxBase.Undo%2A?displayProperty=nameWithType> Метод не работает с <xref:System.Windows.Forms.Control.KeyPress> или <xref:System.Windows.Forms.Control.TextChanged> события.  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Windows.Forms.RichTextBox> элемент управления, который загружает файл формата RTF в элемент управления и выполняет поиск первого экземпляра слова «Text». Затем код изменяет стиль шрифта, размер шрифта и цвет шрифта выделенного текста и сохраняет изменения в исходный файл. В примере кода завершения путем добавления элемента управления в его <xref:System.Windows.Forms.Form>. В этом примере требуется, что метод, созданный в примере кода добавляется <xref:System.Windows.Forms.Form> класса и вызывается из конструктора формы. В примере также требуется что RTF-файл создается в корне диска C, содержащего и слово «Текст».  
  
 [!code-cpp[Classic RichTextBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.Forms.TextBoxBase" />
    <altmember cref="T:System.Windows.Forms.TextBox" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RichTextBox ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RichTextBox();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> свойство элемента управления имеет значение `true`.  
  
   
  
## Examples  
 В следующем примере кода создается <xref:System.Windows.Forms.RichTextBox> элемент управления, который загружает файл формата RTF в элемент управления и выполняет поиск первого экземпляра слова «Text». Затем код изменяет стиль шрифта, размер шрифта и цвет шрифта выделенного текста и сохраняет изменения в исходный файл. В примере кода завершения путем добавления элемента управления в его <xref:System.Windows.Forms.Form>. В этом примере требуется, что метод, созданный в примере кода добавляется <xref:System.Windows.Forms.Form> класса и вызывается из конструктора формы. В примере также требуется что RTF-файл создается в корне диска C, содержащего и слово «Текст».  
  
 [!code-cpp[Classic RichTextBox Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Multiline" />
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public override bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AllowDrop : bool with get, set" Usage="System.Windows.Forms.RichTextBox.AllowDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, будет ли элемент управления поддерживать операции перетаскивания.</summary>
        <value>Значение <see langword="true" />, если перетаскивание в элементе управления разрешено; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода показано, как выполнять операции перетаскивания и вставки с помощью <xref:System.Windows.Forms.ListBox> управления, который содержит элементы для удаления в <xref:System.Windows.Forms.RichTextBox> элемента управления. Конструктор наборов данных формы <xref:System.Windows.Forms.RichTextBox.AllowDrop%2A> свойства `true` Включение операций перетаскивания и вставки в <xref:System.Windows.Forms.RichTextBox>. В этом примере <xref:System.Windows.Forms.Control.MouseDown> событие <xref:System.Windows.Forms.ListBox> для начала операции перетаскивания путем вызова <xref:System.Windows.Forms.Control.DoDragDrop%2A> метод. В этом примере <xref:System.Windows.Forms.Control.DragEnter> событий для определения элемента, перетаскиваемого в <xref:System.Windows.Forms.RichTextBox> имеет допустимый тип данных. <xref:System.Windows.Forms.Control.DragDrop> События выполняет фактическое удаление перетаскиваемый элемент в <xref:System.Windows.Forms.RichTextBox> управления в текущем положении курсора в пределах <xref:System.Windows.Forms.RichTextBox>. В этом примере требуется, <xref:System.Windows.Forms.Control.DragDrop> и <xref:System.Windows.Forms.Control.DragEnter> события были подключены к обработчики событий, определенный в примере.  
  
 [!code-cpp[RichTextBox.AllowDrop#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.AllowDrop/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.AllowDrop#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.AllowDrop/CS/form1.cs#1)]
 [!code-vb[RichTextBox.AllowDrop#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.AllowDrop/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoSize">
      <MemberSignature Language="C#" Value="public override bool AutoSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.AutoSize" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property AutoSize As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool AutoSize { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoSize : bool with get, set" Usage="System.Windows.Forms.RichTextBox.AutoSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Данное свойство не применимо к этому классу.</summary>
        <value>Значение <see langword="true" />, если включен, в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
-   Данное свойство не применимо к этому классу.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AutoWordSelection">
      <MemberSignature Language="C#" Value="public bool AutoWordSelection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AutoWordSelection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.AutoWordSelection" />
      <MemberSignature Language="VB.NET" Value="Public Property AutoWordSelection As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AutoWordSelection { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.AutoWordSelection : bool with get, set" Usage="System.Windows.Forms.RichTextBox.AutoWordSelection" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, определяющее, включен ли автоматический выбор слов.</summary>
        <value>
          <see langword="true" />, если автоматическое выделение слов включено; в противном случае <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если это свойство имеет значение `true`, выбрав любую часть текста в элементе управления выбирает слово целиком.  
  
   
  
## Examples  
 В следующем примере кода показано, как создать <xref:System.Windows.Forms.RichTextBox> , увеличивает масштаб текста, автоматически выделять слова в тексте элемента управления, при двойном щелчке слова, а также имеет поле в правой части клиентской области элемента управления. Если <xref:System.Windows.Forms.RichTextBox> управления имеет небольшой ширину, с помощью следующего кода будет создан <xref:System.Windows.Forms.RichTextBox> где каждый символ текст отображается на отдельной строке. В этой позиции вертикальное отображение щелчка по любой части слова будут выделены все символы слова, несмотря на то, что текст отображается вертикально. В этом примере требуется наличие формы, содержащей <xref:System.Windows.Forms.RichTextBox> управления с именем `richTextBox1`.  
  
 [!code-cpp[RichTextBox.ZoomFactor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.ZoomFactor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CS/form1.cs#1)]
 [!code-vb[RichTextBox.ZoomFactor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.ZoomFactor/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImage">
      <MemberSignature Language="C#" Value="public override System.Drawing.Image BackgroundImage { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Image BackgroundImage" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.BackgroundImage" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImage As Image" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Image ^ BackgroundImage { System::Drawing::Image ^ get(); void set(System::Drawing::Image ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImage : System.Drawing.Image with get, set" Usage="System.Windows.Forms.RichTextBox.BackgroundImage" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Image</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Данное свойство не применимо к этому классу.</summary>
        <value>Фоновое изображение, отображаемое на элементе управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данное свойство не применимо к этому классу.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.BackgroundImageChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageChanged : EventHandler " Usage="member this.BackgroundImageChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении значения свойства <see cref="P:System.Windows.Forms.RichTextBox.BackgroundImage" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке событий см. в разделе [NIB: Потребление событий](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayout">
      <MemberSignature Language="C#" Value="public override System.Windows.Forms.ImageLayout BackgroundImageLayout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.ImageLayout BackgroundImageLayout" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.BackgroundImageLayout" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property BackgroundImageLayout As ImageLayout" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Windows::Forms::ImageLayout BackgroundImageLayout { System::Windows::Forms::ImageLayout get(); void set(System::Windows::Forms::ImageLayout value); };" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayout : System.Windows.Forms.ImageLayout with get, set" Usage="System.Windows.Forms.RichTextBox.BackgroundImageLayout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ImageLayout</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Данное свойство не применимо к этому классу.</summary>
        <value>Структура фонового изображения, отображаемого в элементе управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данное свойство не применимо к этому классу.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BackgroundImageLayoutChanged">
      <MemberSignature Language="C#" Value="public event EventHandler BackgroundImageLayoutChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler BackgroundImageLayoutChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.BackgroundImageLayoutChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event BackgroundImageLayoutChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ BackgroundImageLayoutChanged;" />
      <MemberSignature Language="F#" Value="member this.BackgroundImageLayoutChanged : EventHandler " Usage="member this.BackgroundImageLayoutChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении значения свойства <see cref="P:System.Windows.Forms.RichTextBox.BackgroundImageLayout" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данное событие не применимо к этому классу.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BulletIndent">
      <MemberSignature Language="C#" Value="public int BulletIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BulletIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.BulletIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property BulletIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BulletIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BulletIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.BulletIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает отступ, который используется в элементе управления <see cref="T:System.Windows.Forms.RichTextBox" />, когда к тексту применяется стиль маркированного списка.</summary>
        <value>Число пикселей, которые вставляются в качестве отступа после токена. По умолчанию используется значение ноль.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы применить стиль маркера абзац текста, установите <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> свойства `true` и задайте <xref:System.Windows.Forms.RichTextBox.BulletIndent%2A> количество пикселей, что текст должен иметь отступ. Абзац будет применен с заданным объемом отступа после маркера стиль маркера. Это свойство относится только к текущему абзацу текста элемента управления и выбранного маркеру списка маркированных объектов. Чтобы применить другую длину отступа всему списку маркированных объектов, необходимо выбрать весь текст этих объектов перед установкой <xref:System.Windows.Forms.RichTextBox.BulletIndent%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> свойство с <xref:System.Windows.Forms.RichTextBox.BulletIndent%2A>, <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>, <xref:System.Windows.Forms.RichTextBox.SelectedText%2A>, и <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> свойства для создания маркированного списка в <xref:System.Windows.Forms.RichTextBox> элемента управления. В этом примере требуется, <xref:System.Windows.Forms.RichTextBox> управления с именем `richTextBox1` создается в форме.  
  
 [!code-cpp[RichTextBox.BulletIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.BulletIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.BulletIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.BulletIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.BulletIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.BulletIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Была задана длина отступа меньше нуля.</exception>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionBullet" />
      </Docs>
    </Member>
    <Member MemberName="CanPaste">
      <MemberSignature Language="C#" Value="public bool CanPaste (System.Windows.Forms.DataFormats.Format clipFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CanPaste(class System.Windows.Forms.DataFormats/Format clipFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.CanPaste(System.Windows.Forms.DataFormats.Format)" />
      <MemberSignature Language="VB.NET" Value="Public Function CanPaste (clipFormat As DataFormats.Format) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CanPaste(System::Windows::Forms::DataFormats::Format ^ clipFormat);" />
      <MemberSignature Language="F#" Value="member this.CanPaste : System.Windows.Forms.DataFormats.Format -&gt; bool" Usage="richTextBox.CanPaste clipFormat" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipFormat" Type="System.Windows.Forms.DataFormats+Format" />
      </Parameters>
      <Docs>
        <param name="clipFormat">Одно из значений перечисления <see cref="T:System.Windows.Forms.DataFormats.Format" />.</param>
        <summary>Определяет, можно ли вставить сведения из буфера обмена в указанном формате данных.</summary>
        <returns>Значение <see langword="true" />, если данные из буфера обмена в указанном формате вставить можно; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для определения, ли текущее содержимое буфера обмена в указанном формате данных буфера обмена перед включением пользователю вставлять данные в <xref:System.Windows.Forms.RichTextBox> элемента управления. Например, можно создать обработчик событий для <xref:System.Windows.Forms.MenuItem.Popup> событие команды вставки <xref:System.Windows.Forms.MenuItem> и использовать этот метод для определения ли вставка <xref:System.Windows.Forms.MenuItem> должна быть включена на основе типа данных в буфер обмена.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.RichTextBox.Paste%2A> метод для точечного рисунка в <xref:System.Windows.Forms.RichTextBox> элемента управления. После открытия точечный рисунок из файла, в примере используется <xref:System.Windows.Forms.Clipboard.SetDataObject%2A> метод скопируйте растровое изображение в буфер обмена Windows. Наконец, в примере извлекается формат для <xref:System.Drawing.Bitmap> объект использует <xref:System.Windows.Forms.RichTextBox.CanPaste%2A> метод, чтобы убедиться, что формат может быть вставлено в <xref:System.Windows.Forms.RichTextBox> управления, а затем используется <xref:System.Windows.Forms.RichTextBox.Paste%2A> метод вставки данных.  
  
 [!code-cpp[RichText_Paste#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichText_Paste/CPP/form1.cpp#1)]
 [!code-csharp[RichText_Paste#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichText_Paste/CS/form1.cs#1)]
 [!code-vb[RichText_Paste#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichText_Paste/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.Paste(System.Windows.Forms.DataFormats.Format)" />
        <altmember cref="T:System.Windows.Forms.DataFormats.Format" />
      </Docs>
    </Member>
    <Member MemberName="CanRedo">
      <MemberSignature Language="C#" Value="public bool CanRedo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanRedo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.CanRedo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanRedo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanRedo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanRedo : bool" Usage="System.Windows.Forms.RichTextBox.CanRedo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, определяющее, были ли в элементе управления <see cref="T:System.Windows.Forms.RichTextBox" /> произведены такие действия, которые можно было применить заново.</summary>
        <value>Значение <see langword="true" />, если отменные операции, которые можно было бы применить к элементу управления заново, существуют; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство можно использовать, чтобы определить, является ли операцию в <xref:System.Windows.Forms.RichTextBox> можно снова с помощью <xref:System.Windows.Forms.RichTextBox.Redo%2A> метод.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> и <xref:System.Windows.Forms.RichTextBox.RedoActionName%2A> свойства и <xref:System.Windows.Forms.RichTextBox.Redo%2A> метод, чтобы ограничить проведения операции отмены для любого действия, за исключением удаления текста. В этом примере требуется наличие формы, содержащей <xref:System.Windows.Forms.RichTextBox> управления и что на операцию в <xref:System.Windows.Forms.RichTextBox> была проведена и отменены до вызова кода в этом примере.  
  
 [!code-cpp[RichTextBox.RedoAction#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.RedoAction/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.RedoAction#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.RedoAction/CS/form1.cs#1)]
 [!code-vb[RichTextBox.RedoAction#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.RedoAction/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.Redo" />
      </Docs>
    </Member>
    <Member MemberName="ContentsResized">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.ContentsResizedEventHandler ContentsResized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.ContentsResizedEventHandler ContentsResized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.ContentsResized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContentsResized As ContentsResizedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::ContentsResizedEventHandler ^ ContentsResized;" />
      <MemberSignature Language="F#" Value="member this.ContentsResized : System.Windows.Forms.ContentsResizedEventHandler " Usage="member this.ContentsResized : System.Windows.Forms.ContentsResizedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.ContentsResizedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении размера содержимого элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке событий см. в разделе [NIB: Потребление событий](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.RichTextBox.ContentsResized> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.RichTextBox> с именем `RichTextBox1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.RichTextBox.ContentsResized> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#537](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#537)]
 [!code-vb[System.Windows.Forms.EventExamples#537](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#537)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.ContentsResizedEventHandler" />
      </Docs>
    </Member>
    <Member MemberName="CreateParams">
      <MemberSignature Language="C#" Value="protected override System.Windows.Forms.CreateParams CreateParams { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Forms.CreateParams CreateParams" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.CreateParams" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property CreateParams As CreateParams" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Windows::Forms::CreateParams ^ CreateParams { System::Windows::Forms::CreateParams ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CreateParams : System.Windows.Forms.CreateParams" Usage="System.Windows.Forms.RichTextBox.CreateParams" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.CreateParams</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает параметры, необходимые для создания дескриптора элемента управления.</summary>
        <value>Объект <see cref="T:System.Windows.Forms.CreateParams" />, содержащий необходимые параметры процедуры создания дескриптора элемента управления.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateRichEditOleCallback">
      <MemberSignature Language="C#" Value="protected virtual object CreateRichEditOleCallback ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object CreateRichEditOleCallback() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.CreateRichEditOleCallback" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CreateRichEditOleCallback () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ CreateRichEditOleCallback();" />
      <MemberSignature Language="F#" Value="abstract member CreateRichEditOleCallback : unit -&gt; obj&#xA;override this.CreateRichEditOleCallback : unit -&gt; obj" Usage="richTextBox.CreateRichEditOleCallback " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает объект, совместимый с <see langword="IRichEditOleCallback" />, для обработки операций обратного вызова "RichEdit".</summary>
        <returns>Объект, реализующий интерфейс <see langword="IRichEditOleCallback" />.</returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для непосредственно вызывающего метода вызова неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <block subset="none" type="overrides">
          <para>Этот метод можно переопределить в производном классе позволяет разрешить доступ к функциональным возможностям rich edit. При переопределении этого метода все события перетаскивания и вставки не вызываются. В результате необходимо предоставить собственную поддержку для операций перетаскивания и вставки. Дополнительные сведения о <see langword="IRichEditOleCallback" /> интерфейсом, см. в документации Platform SDK в http://msdn.microsoft.com.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="DefaultSize">
      <MemberSignature Language="C#" Value="protected override System.Drawing.Size DefaultSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Size DefaultSize" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.DefaultSize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property DefaultSize As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property System::Drawing::Size DefaultSize { System::Drawing::Size get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultSize : System.Drawing.Size" Usage="System.Windows.Forms.RichTextBox.DefaultSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Size</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает размер элемента управления по умолчанию.</summary>
        <value>Значение <see cref="T:System.Drawing.Size" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.DefaultSize" />
      </Docs>
    </Member>
    <Member MemberName="DetectUrls">
      <MemberSignature Language="C#" Value="public bool DetectUrls { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DetectUrls" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.DetectUrls" />
      <MemberSignature Language="VB.NET" Value="Public Property DetectUrls As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DetectUrls { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DetectUrls : bool with get, set" Usage="System.Windows.Forms.RichTextBox.DetectUrls" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, определяющее, будет ли элемент управления <see cref="T:System.Windows.Forms.RichTextBox" /> автоматически форматировать адрес URL при вводе его в элемент управления.</summary>
        <value>Значение <see langword="true" />, если элемент управления <see cref="T:System.Windows.Forms.RichTextBox" /> будет автоматически форматировать как ссылки адреса URL, вводимые в элемент управления; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если это свойство имеет значение `true`, любой текст, введенный в элемент управления, который определяется <xref:System.Windows.Forms.RichTextBox> быть URL-адрес автоматически форматируется в виде ссылки. Можно создать обработчик событий для <xref:System.Windows.Forms.RichTextBox.LinkClicked> нажатии событий, чтобы обрабатывать все ссылки в элементе управления. <xref:System.Windows.Forms.LinkClickedEventArgs> , Предоставляемой в обработчик событий для <xref:System.Windows.Forms.RichTextBox.LinkClicked> событие предоставляет данные, позволяющий определить, какая ссылка была выбрана в элементе управления для обработки по ссылке.  
  
   
  
## Examples  
 В следующем примере кода содержится обработчик событий для <xref:System.Windows.Forms.RichTextBox.LinkClicked> события. Обработчик событий обрабатывает нажатия ссылок из документа элемента <xref:System.Windows.Forms.RichTextBox> управления и запускает экземпляр браузера по умолчанию (с помощью <xref:System.Diagnostics.Process.Start%2A?displayProperty=nameWithType> метод), отображается страница ссылку, которая была нажата. В этом примере требуется, что обработчик событий был связан с <xref:System.Windows.Forms.RichTextBox.LinkClicked> событий для <xref:System.Windows.Forms.RichTextBox>.  
  
 [!code-cpp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.RichTextBox.LinkClicked" />
        <altmember cref="T:System.Windows.Forms.LinkClickedEventArgs" />
      </Docs>
    </Member>
    <Member MemberName="DragDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragDrop;" />
      <MemberSignature Language="F#" Value="member this.DragDrop : System.Windows.Forms.DragEventHandler " Usage="member this.DragDrop : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после перетаскивания пользователем</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragEnter;" />
      <MemberSignature Language="F#" Value="member this.DragEnter : System.Windows.Forms.DragEventHandler " Usage="member this.DragEnter : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда объект перетаскивается в границы элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке событий см. в разделе [NIB: Потребление событий](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.RichTextBox.DragEnter> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.RichTextBox> с именем `RichTextBox1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.RichTextBox.DragEnter> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#539](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#539)]
 [!code-vb[System.Windows.Forms.EventExamples#539](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#539)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event EventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ DragLeave;" />
      <MemberSignature Language="F#" Value="member this.DragLeave : EventHandler " Usage="member this.DragLeave : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вызывается, когда объект перетаскивается за пределы элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данное событие не применимо к этому классу. Дополнительные сведения об обработке событий см. в разделе [NIB: Потребление событий](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::DragEventHandler ^ DragOver;" />
      <MemberSignature Language="F#" Value="member this.DragOver : System.Windows.Forms.DragEventHandler " Usage="member this.DragOver : System.Windows.Forms.DragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда объект перетаскивается через границу элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данное событие не применимо к этому классу. Дополнительные сведения об обработке событий см. в разделе [NIB: Потребление событий](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DrawToBitmap">
      <MemberSignature Language="C#" Value="public void DrawToBitmap (System.Drawing.Bitmap bitmap, System.Drawing.Rectangle targetBounds);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DrawToBitmap(class System.Drawing.Bitmap bitmap, valuetype System.Drawing.Rectangle targetBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.DrawToBitmap(System.Drawing.Bitmap,System.Drawing.Rectangle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DrawToBitmap(System::Drawing::Bitmap ^ bitmap, System::Drawing::Rectangle targetBounds);" />
      <MemberSignature Language="F#" Value="override this.DrawToBitmap : System.Drawing.Bitmap * System.Drawing.Rectangle -&gt; unit" Usage="richTextBox.DrawToBitmap (bitmap, targetBounds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bitmap" Type="System.Drawing.Bitmap" />
        <Parameter Name="targetBounds" Type="System.Drawing.Rectangle" />
      </Parameters>
      <Docs>
        <param name="bitmap">Объект <see cref="T:System.Drawing.Bitmap" />.</param>
        <param name="targetBounds">Объект <see cref="T:System.Drawing.Rectangle" />.</param>
        <summary>Данный метод не применим к этому классу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный метод не применим к этому классу.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnableAutoDragDrop">
      <MemberSignature Language="C#" Value="public bool EnableAutoDragDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableAutoDragDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.EnableAutoDragDrop" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableAutoDragDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableAutoDragDrop { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableAutoDragDrop : bool with get, set" Usage="System.Windows.Forms.RichTextBox.EnableAutoDragDrop" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, с помощью которого разрешается перетаскивание текста, изображений и других данных.</summary>
        <value>Значение <see langword="true" /> для включения перетаскивания; в противном случае — <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Find">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Осуществляет поиск текста в содержимом <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (char[] characterSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(char[] characterSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (characterSet As Char()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(cli::array &lt;char&gt; ^ characterSet);" />
      <MemberSignature Language="F#" Value="member this.Find : char[] -&gt; int" Usage="richTextBox.Find characterSet" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="characterSet" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="characterSet">Массив символов для поиска.</param>
        <summary>Осуществляет поиск первого экземпляра символа из списка символов по тексту элемента управления <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <returns>Расположение в элементе управления, если искомые символы были найдены, или -1, если искомые символы не были найдены, или в качестве параметра <paramref name="char" /> был указан пустой набор символов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта версия <xref:System.Windows.Forms.RichTextBox.Find%2A> метод выполняет поиск первого вхождения символа из списка символов, указанных в `characterSet` параметр и возвращает расположение символа. Например можно передать массив символов, содержащий символ «Q». Если элемент управления содержит текст «коричневый выпей», <xref:System.Windows.Forms.RichTextBox.Find%2A> метод вернет значение из четырех. Строчные и прописные символы считаются различными значениями в поиск.  
  
 Если свойство возвращает отрицательное значение, символы, поиск не были найдены в содержимом элемента управления. Этот метод можно использовать для поиска группы символов в элементе управления. Эта версия <xref:System.Windows.Forms.RichTextBox.Find%2A> метод требует, что весь документ, содержащийся в элементе управления ищется символы. Если символ из списка, заданного в методе `characterSet` найден параметр, то значение, этот метод возвращает отсчитываемый от нуля индекс позиции в элементе управления. Пробел считается символ с помощью метода при определении положения символа.  
  
   
  
## Examples  
 В следующем примере кода выполняет поиск содержимого <xref:System.Windows.Forms.RichTextBox> для символов, которые передаются в метод `text` параметра. Если содержимое `text` массива можно найти на <xref:System.Windows.Forms.RichTextBox>, метод возвращает индекс, найден; в противном случае — значение, возвращается значение -1. В этом примере предполагается, что этот метод размещается в классе <xref:System.Windows.Forms.Form> , содержащий <xref:System.Windows.Forms.RichTextBox> управления с именем `richTextBox1` и <xref:System.Windows.Forms.Button> управления с именем `button1`, который подключен к `Click` обработчик событий, определенных в Пример.  
  
 [!code-cpp[RichTextBox.FindChar1#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.FindChar1/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.FindChar1#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.FindChar1/CS/form1.cs#1)]
 [!code-vb[RichTextBox.FindChar1#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.FindChar1/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str);" />
      <MemberSignature Language="F#" Value="member this.Find : string -&gt; int" Usage="richTextBox.Find str" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="str">Текст, который необходимо найти в элементе управления.</param>
        <summary>Осуществляет поиск текста в элементе управления <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <returns>Расположение в элементе управления, если искомый текст был найден, или -1, если искомая строка не были найдены, или в качестве параметра <paramref name="str" /> была указана пустая строка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.Find%2A> Метод осуществляет поиск текста, указанного в `str` параметр и возвращает расположение первого символа в элементе управления. Если свойство возвращает отрицательное значение, текстовая строка, поиск не была найдена в содержимом элемента управления. Этот метод можно использовать для создания функции поиска, которые могут быть предоставлены пользователю элемента управления. Этот метод также можно использовать для поиска текста замены определенный формат. Например, если пользователь ввел дат в элементе управления, можно использовать <xref:System.Windows.Forms.RichTextBox.Find%2A> метод для поиска всех дат в документе и заменить их формат перед использованием <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> метод элемента управления.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.Find%2A> Методов, которые принимают `string` как параметр не удается найти текст, находящийся на более одной строки текста в <xref:System.Windows.Forms.RichTextBox>. Выполнение такого поиска вернет значение минус единица (-1).  
  
   
  
## Examples  
 Следующий пример кода выполняет все содержимое <xref:System.Windows.Forms.RichTextBox> для первого экземпляра строки поиска, переданный в качестве текстового параметра метода. Если строка поиска, которая находится в <xref:System.Windows.Forms.RichTextBox>, метод возвращает значение `true` и выделяет искомый текст. в противном случае возвращается `false`. В этом примере предполагается, что этот метод размещается в классе <xref:System.Windows.Forms.Form> , содержащий <xref:System.Windows.Forms.RichTextBox> с именем `richTextBox1`.  
  
 [!code-cpp[Classic RichTextBox.Find Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.Find Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.Find Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.Find Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.Find Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.Find Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (char[] characterSet, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(char[] characterSet, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.Char[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (characterSet As Char(), start As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(cli::array &lt;char&gt; ^ characterSet, int start);" />
      <MemberSignature Language="F#" Value="member this.Find : char[] * int -&gt; int" Usage="richTextBox.Find (characterSet, start)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="characterSet" Type="System.Char[]" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="characterSet">Массив символов для поиска.</param>
        <param name="start">Положение в тексте элемента управления, в котором будет начат поиск.</param>
        <summary>С заданной начальной позиции осуществляет поиск первого экземпляра символа из списка символов по тексту элемента управления <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <returns>Положение в элементе управления, в котором были найдены искомые символы.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта версия <xref:System.Windows.Forms.RichTextBox.Find%2A> метод выполняет поиск первого вхождения символа из списка символов, указанных в `characterSet` параметр и возвращает расположение символа. Например можно передать массив символов, содержащий символ «Q». Если элемент управления содержит текст «коричневый выпей», <xref:System.Windows.Forms.RichTextBox.Find%2A> метод вернет значение из четырех. Строчные и прописные символы считаются различными значениями в поиск.  
  
 Если свойство возвращает отрицательное значение, символы, поиск не были найдены в содержимом элемента управления. Этот метод можно использовать для поиска группы символов в элементе управления. Если символ из списка, заданного в методе `characterSet` найден параметр, то значение, этот метод возвращает отсчитываемый от нуля индекс позиции в элементе управления. Пробел считается символ с помощью метода при определении положения символа.  
  
 Эта версия <xref:System.Windows.Forms.RichTextBox.Find%2A> метод позволяет искать набор знаков из указанной начальной позиции, в тексте элемента управления, указав значение для `start` параметра. Нулевое значение указывает, что поиск необходимо начать с самого начала документа элемента управления. Данную версию можно использовать <xref:System.Windows.Forms.RichTextBox.Find%2A> метод, чтобы сузить поиск во избежание текст, который вы уже знаете не содержит указанные символы для поиска, или они не важны для поиска.  
  
   
  
## Examples  
 В следующем примере кода выполняет поиск содержимого <xref:System.Windows.Forms.RichTextBox> для символов, которые передаются в метод `text` параметра. Поиск начинается с положения элемента <xref:System.Windows.Forms.RichTextBox> заданные `start` параметр `FindMyText` метода. Если содержимое текста массива найдены в <xref:System.Windows.Forms.RichTextBox>, метод возвращает индекс, найден; в противном случае — значение, возвращается значение -1. В этом примере предполагается, что этот метод размещается в классе <xref:System.Windows.Forms.Form> , содержащий <xref:System.Windows.Forms.RichTextBox> управления с именем `richTextBox1` и <xref:System.Windows.Forms.Button> управления с именем `button1` , подключенном к <xref:System.Windows.Forms.Control.Click> обработчик событий, определенных в Пример.  
  
 [!code-cpp[RichTextBox.FindChar2#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.FindChar2/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.FindChar2#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.FindChar2/CS/form1.cs#1)]
 [!code-vb[RichTextBox.FindChar2#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.FindChar2/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str, System.Windows.Forms.RichTextBoxFinds options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str, valuetype System.Windows.Forms.RichTextBoxFinds options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String,System.Windows.Forms.RichTextBoxFinds)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String, options As RichTextBoxFinds) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str, System::Windows::Forms::RichTextBoxFinds options);" />
      <MemberSignature Language="F#" Value="member this.Find : string * System.Windows.Forms.RichTextBoxFinds -&gt; int" Usage="richTextBox.Find (str, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="options" Type="System.Windows.Forms.RichTextBoxFinds" />
      </Parameters>
      <Docs>
        <param name="str">Текст, который необходимо найти в элементе управления.</param>
        <param name="options">Поразрядное сочетание значений <see cref="T:System.Windows.Forms.RichTextBoxFinds" />.</param>
        <summary>Осуществляет поиск в элементе управления <see cref="T:System.Windows.Forms.RichTextBox" /> текстовой строки с определенными параметрами, примененными к поиску.</summary>
        <returns>Положение в элементе управления, в котором был найден искомый текст.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.Find%2A> Метод осуществляет поиск текста, указанного в `str` параметр и возвращает расположение первого символа в элементе управления. Если свойство возвращает отрицательное значение, текстовая строка, поиск не была найдена в содержимом элемента управления. Этот метод можно использовать для создания функции поиска, которые могут быть предоставлены пользователю элемента управления. Этот метод также можно использовать для поиска текста замены определенный формат. Например, если пользователь ввел дат в элементе управления, можно использовать <xref:System.Windows.Forms.RichTextBox.Find%2A> метод для поиска всех дат в документе и заменить их формат перед использованием <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> метод элемента управления.  
  
 С этой версией <xref:System.Windows.Forms.RichTextBox.Find%2A> метод, можно указать параметры, которые позволяют расширить или сузить область поиска. Можно указать параметры, которые позволяют совпадает с регистром слова поиска или поиска целыми словами вместо слов. Указав `RichTextBoxFinds.Reverse` перечисления в `options` параметр, можно выполнить поиск текста с конца документа к началу вместо top по умолчанию для метода поиска нижней.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.Find%2A> Методов, которые принимают `string` как параметр не удается найти текст, находящийся на более одной строки текста в <xref:System.Windows.Forms.RichTextBox>. Выполнение такого поиска вернет значение минус единица (-1).  
  
   
  
## Examples  
 Следующий пример кода выполняет все содержимое <xref:System.Windows.Forms.RichTextBox> для первого экземпляра строки поиска, переданный в качестве текстового параметра метода. Если строка поиска, которая находится в <xref:System.Windows.Forms.RichTextBox>, метод возвращает значение `true` и выделяет текст; в противном случае он возвращает `false`. В примере также указывается параметры при поиске с учетом регистра для указанной строки поиска. В этом примере предполагается, что этот метод размещается в классе <xref:System.Windows.Forms.Form> , содержащий <xref:System.Windows.Forms.RichTextBox> с именем `richTextBox1`.  
  
 [!code-cpp[Classic RichTextBox.Find1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.Find1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.Find1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.Find1 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.Find1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.Find1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (char[] characterSet, int start, int end);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(char[] characterSet, int32 start, int32 end) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (characterSet As Char(), start As Integer, end As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(cli::array &lt;char&gt; ^ characterSet, int start, int end);" />
      <MemberSignature Language="F#" Value="member this.Find : char[] * int * int -&gt; int" Usage="richTextBox.Find (characterSet, start, end)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="characterSet" Type="System.Char[]" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="end" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="characterSet">Массив символов для поиска.</param>
        <param name="start">Положение в тексте элемента управления, в котором будет начат поиск.</param>
        <param name="end">Положение в тексте элемента управления, на котором поиск будет завершен.</param>
        <summary>Осуществляет поиск первого экземпляра символа из списка символов по отрезку текста элемента управления <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <returns>Положение в элементе управления, в котором были найдены искомые символы.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта версия <xref:System.Windows.Forms.RichTextBox.Find%2A> метод выполняет поиск первого вхождения символа из списка символов, указанных в `characterSet` параметр и возвращает расположение символа. Например можно передать массив символов, содержащий символ «Q». Если элемент управления содержит текст «коричневый выпей», <xref:System.Windows.Forms.RichTextBox.Find%2A> метод вернет значение из четырех. Строчные и прописные символы считаются различными значениями в поиск.  
  
 Если свойство возвращает отрицательное значение, символы, поиск не были найдены в содержимом элемента управления. Этот метод можно использовать для поиска группы символов в элементе управления. Если символ из списка, заданного в методе `characterSet` найден параметр, то значение, этот метод возвращает отсчитываемый от нуля индекс позиции в элементе управления. Пробел считается символ с помощью метода при определении положения символа.  
  
 Эта версия <xref:System.Windows.Forms.RichTextBox.Find%2A> метод позволяет искать набор знаков из фрагмента текста в элементе управления, указав значение для `start` и `end` параметров. Нулевое значение для `start` параметр указывает, что поиск необходимо начать с самого начала документа элемента управления. Значение-1 для `end` параметр указывает, что поиск должен быть завершен в конце текста в элементе управления. Данную версию можно использовать <xref:System.Windows.Forms.RichTextBox.Find%2A> метод, чтобы сузить область поиска до определенного отрезка текста в элементе управления во избежание поиск области документа, которые не представляют интереса для потребностей вашего приложения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="characterSet" /> имеет значение null.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="start" /> меньше 0 или больше длины текста в элементе управления.</exception>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str, int start, System.Windows.Forms.RichTextBoxFinds options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str, int32 start, valuetype System.Windows.Forms.RichTextBoxFinds options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String,System.Int32,System.Windows.Forms.RichTextBoxFinds)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String, start As Integer, options As RichTextBoxFinds) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str, int start, System::Windows::Forms::RichTextBoxFinds options);" />
      <MemberSignature Language="F#" Value="member this.Find : string * int * System.Windows.Forms.RichTextBoxFinds -&gt; int" Usage="richTextBox.Find (str, start, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="options" Type="System.Windows.Forms.RichTextBoxFinds" />
      </Parameters>
      <Docs>
        <param name="str">Текст, который необходимо найти в элементе управления.</param>
        <param name="start">Положение в тексте элемента управления, в котором будет начат поиск.</param>
        <param name="options">Поразрядное сочетание значений <see cref="T:System.Windows.Forms.RichTextBoxFinds" />.</param>
        <summary>Осуществляет поиск текстовой строки в определенном месте текста элемента управления <see cref="T:System.Windows.Forms.RichTextBox" /> с примененными к поиску параметрами.</summary>
        <returns>Положение в элементе управления, в котором был найден искомый текст.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.Find%2A> Метод осуществляет поиск текста, указанного в `str` параметр и возвращает положение первого знака поиска строки в элементе управления. Если свойство возвращает отрицательное значение, текстовая строка, поиск не была найдена в содержимом элемента управления. Этот метод можно использовать для создания функции поиска, которые могут быть предоставлены пользователю элемента управления. Этот метод также можно использовать для поиска текста замены определенный формат. Например, если пользователь ввел дат в элементе управления, можно использовать <xref:System.Windows.Forms.RichTextBox.Find%2A> метод для поиска всех дат в документе и заменить их формат перед использованием <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> метод элемента управления.  
  
 С этой версией <xref:System.Windows.Forms.RichTextBox.Find%2A> метод, можно указать параметры, которые позволяют расширить или сузить область поиска. Можно указать параметры, которые позволяют совпадает с регистром слова поиска или поиска целыми словами вместо слов. Указав `RichTextBoxFinds.Reverse` перечисления в `options` параметр, можно выполнить поиск текста с конца документа к началу вместо top по умолчанию для метода поиска нижней. Эта версия <xref:System.Windows.Forms.RichTextBox.Find%2A> метод также позволяет сузить область поиска текста посредством выбора начального положения в тексте элемента управления. Эта функция может позволить избежать текста, может уже завершен поиск или где искомого текста для поиска известно, не существует. Когда `RichTextBoxFinds.Reverse` значение указывается в `options` параметра, значение `start` указывает позицию, где обратный поиск прекратится, поскольку при использовании этой версии в нижней части документа будет начинаться поиск <xref:System.Windows.Forms.RichTextBox.Find%2A> метод.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.Find%2A> Методов, которые принимают `string` как параметр не удается найти текст, находящийся на более одной строки текста в <xref:System.Windows.Forms.RichTextBox>. Выполнение такого поиска вернет значение минус единица (-1).  
  
   
  
## Examples  
 Следующий пример кода выполняет все содержимое <xref:System.Windows.Forms.RichTextBox> для первого экземпляра строки поиска, переданный в качестве текстового параметра метода. Место начала поиска задается в параметре запуска метода. Если строка поиска, которая находится в <xref:System.Windows.Forms.RichTextBox>, метод возвращает индекс первого символа найденный текст и выделяет искомый текст; в противном случае возвращается значение-1. В примере также указывается параметры при поиске с учетом регистра для указанной строки поиска. В этом примере предполагается, что этот метод размещается в классе <xref:System.Windows.Forms.Form> , содержащий <xref:System.Windows.Forms.RichTextBox> с именем `richTextBox1`. В этом примере можно использовать для выполнения «Найти далее», тип операции. После обнаружения экземпляра искомого текста можно найти другие экземпляры текста, изменив значение `start` параметр для поиска в местоположение за позицией текущее совпадение.  
  
 [!code-cpp[Classic RichTextBox.Find2 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.Find2 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.Find2 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.Find2 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.Find2 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.Find2 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Find">
      <MemberSignature Language="C#" Value="public int Find (string str, int start, int end, System.Windows.Forms.RichTextBoxFinds options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Find(string str, int32 start, int32 end, valuetype System.Windows.Forms.RichTextBoxFinds options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Find(System.String,System.Int32,System.Int32,System.Windows.Forms.RichTextBoxFinds)" />
      <MemberSignature Language="VB.NET" Value="Public Function Find (str As String, start As Integer, end As Integer, options As RichTextBoxFinds) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Find(System::String ^ str, int start, int end, System::Windows::Forms::RichTextBoxFinds options);" />
      <MemberSignature Language="F#" Value="member this.Find : string * int * int * System.Windows.Forms.RichTextBoxFinds -&gt; int" Usage="richTextBox.Find (str, start, end, options)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="str" Type="System.String" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="end" Type="System.Int32" />
        <Parameter Name="options" Type="System.Windows.Forms.RichTextBoxFinds" />
      </Parameters>
      <Docs>
        <param name="str">Текст, который необходимо найти в элементе управления.</param>
        <param name="start">Положение в тексте элемента управления, в котором будет начат поиск.</param>
        <param name="end">Положение в тексте элемента управления, на котором поиск будет завершен. Это значение должно быть равно минус единице (–1) либо больше или равно значению параметра <c>start</c>.</param>
        <param name="options">Поразрядное сочетание значений <see cref="T:System.Windows.Forms.RichTextBoxFinds" />.</param>
        <summary>Осуществляет поиск текстовой строки в определенном отрезке текста элемента управления <see cref="T:System.Windows.Forms.RichTextBox" /> с примененными к поиску параметрами.</summary>
        <returns>Положение в элементе управления, в котором был найден искомый текст.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.Find%2A> Метод осуществляет поиск текста, указанного в `str` параметр и возвращает положение первого знака поиска строки в элементе управления. Если свойство возвращает отрицательное значение, текстовая строка, поиск не была найдена в содержимом элемента управления. Этот метод можно использовать для создания функции поиска, которые могут быть предоставлены пользователю элемента управления. Этот метод также можно использовать для поиска текста замены определенный формат. Например, если пользователь ввел дат в элементе управления, можно использовать <xref:System.Windows.Forms.RichTextBox.Find%2A> метод для поиска всех дат в документе и заменить их формат перед использованием <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> метод элемента управления.  
  
 С этой версией <xref:System.Windows.Forms.RichTextBox.Find%2A> метод, можно указать параметры, которые позволяют расширить или сузить область поиска. Можно указать параметры, которые позволяют совпадает с регистром слова поиска или поиска целыми словами вместо слов. Указав `RichTextBoxFinds.Reverse` перечисления в `options` параметр, можно выполнить поиск текста с конца документа к началу вместо top по умолчанию для метода поиска нижней. Эта версия <xref:System.Windows.Forms.RichTextBox.Find%2A> метод также позволяет сузить поиск текста, выбора начального и конечного положения в тексте элемента управления. Эта функция позволяет ограничить диапазон поиска к конкретному разделу текста элемента управления. Если значение минус единица (-1) присваивается `end` параметр, метод выполняет поиск до конца текста в <xref:System.Windows.Forms.RichTextBox> условиях поиска. Для поиска в обратном направлении значение минус единица (-1) назначены `end` параметр указывает, что текст будет осуществляться в конце текста до положения, определяемого по `start` параметр. Когда `start` и `end` приведены параметры, то же значение всего элемента управления осуществляется в условиях поиска. Для обратного поиска поиск всего элемента управления, но поиск начинается в нижней части документа и выполняет поиск в верхней части документа.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.Find%2A> Методов, которые принимают `string` как параметр не удается найти текст, находящийся на более одной строки текста в <xref:System.Windows.Forms.RichTextBox>. Выполнение такого поиска вернет значение минус единица (-1).  
  
   
  
## Examples  
 В следующем примере кода выполняет поиск текста в раздел <xref:System.Windows.Forms.RichTextBox> для первого экземпляра строки поиска, передаваемых в `searchText` параметра метода. Диапазон для поиска текста в элементе управления определяется `searchStart` и `searchEnd` параметров метода. Если строка поиска, которая находится в <xref:System.Windows.Forms.RichTextBox>, метод возвращает индекс первого символа найденный текст и выделяет искомый текст; в противном случае возвращается значение-1. В примере также используется `options` параметр <xref:System.Windows.Forms.RichTextBox.Find%2A> метод, чтобы указать, что этот текст должен соответствовать регистру строки поиска. В этом примере предполагается, что этот метод размещается в классе <xref:System.Windows.Forms.Form> , содержащий <xref:System.Windows.Forms.RichTextBox> управления с именем `richTextBox1`. После первого экземпляра строки поиска найдены, этот пример можно использовать для поиска других экземпляров в текст.  
  
 [!code-cpp[RichTextBox.FindStringStartEnd#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.FindStringStartEnd/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.FindStringStartEnd#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.FindStringStartEnd/CS/form1.cs#1)]
 [!code-vb[RichTextBox.FindStringStartEnd#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.FindStringStartEnd/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Параметр <paramref name="str" /> имел значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Параметр <paramref name="end" /> был меньше параметра <paramref name="start" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Font">
      <MemberSignature Language="C#" Value="public override System.Drawing.Font Font { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font Font" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Font" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Font As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Font ^ Font { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Font : System.Drawing.Font with get, set" Usage="System.Windows.Forms.RichTextBox.Font" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает шрифт текста, отображаемого элементом управления.</summary>
        <value>Шрифт <see cref="T:System.Drawing.Font" />, применяемый к тексту, отображаемому элементом управления. Значением по умолчанию является значение свойства <see cref="P:System.Windows.Forms.Control.DefaultFont" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.Control.Font" />
      </Docs>
    </Member>
    <Member MemberName="ForeColor">
      <MemberSignature Language="C#" Value="public override System.Drawing.Color ForeColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color ForeColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ForeColor" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property ForeColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Drawing::Color ForeColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.ForeColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.RichTextBox.ForeColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает цвет элемента управления.</summary>
        <value>Класс <see cref="T:System.Drawing.Color" />, предоставляющий основной цвет элемента управления.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.ForeColor" />
      </Docs>
    </Member>
    <Member MemberName="GetCharIndexFromPosition">
      <MemberSignature Language="C#" Value="public override int GetCharIndexFromPosition (System.Drawing.Point pt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetCharIndexFromPosition(valuetype System.Drawing.Point pt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition(System.Drawing.Point)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCharIndexFromPosition (pt As Point) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetCharIndexFromPosition(System::Drawing::Point pt);" />
      <MemberSignature Language="F#" Value="override this.GetCharIndexFromPosition : System.Drawing.Point -&gt; int" Usage="richTextBox.GetCharIndexFromPosition pt" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pt" Type="System.Drawing.Point" />
      </Parameters>
      <Docs>
        <param name="pt">Местоположение для поиска.</param>
        <summary>Возвращает индекс ближайшего к указанному местоположению символа.</summary>
        <returns>Отсчитываемый от нуля индекс символа в указанном местоположении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает индекс символа, ближайший к позиции, указанной в `pt` параметра. Индекс знака является отсчитываемый от нуля индекс текста в элементе управления, включая пробелы. Этот метод можно использовать для определения, где в тексте имеет пользователь мыши посредством передачи координат мыши этот метод. Это может быть полезно использовать для выполнения задач, когда пользователь наводит указатель мыши на слово в тексте элемента управления.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition%2A> метод с <xref:System.Windows.Forms.RichTextBox.Find%2A> метод для поиска конкретной строки в <xref:System.Windows.Forms.RichTextBox> управления и отображения индекс символа, где находится в пределах найденной строки <xref:System.Windows.Forms.RichTextBox> элемент управления. В примере выполняется поиск слова «brown» в содержимом элемента управления и возвращается индекс положения которых находится строка поиска. В этом примере требуется наличие формы, содержащей <xref:System.Windows.Forms.RichTextBox> управления с именем `richTextBox1` , содержащий текст. Также требует, что код в примере подключен к <xref:System.Windows.Forms.Control.MouseDown> событие <xref:System.Windows.Forms.RichTextBox>.  
  
 [!code-cpp[RichTextBox.GetCharIndexFromPosition#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.GetCharIndexFromPosition/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.GetCharIndexFromPosition#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.GetCharIndexFromPosition/CS/form1.cs#1)]
 [!code-vb[RichTextBox.GetCharIndexFromPosition#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.GetCharIndexFromPosition/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetLineFromCharIndex(System.Int32)" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetPositionFromCharIndex(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetLineFromCharIndex">
      <MemberSignature Language="C#" Value="public override int GetLineFromCharIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetLineFromCharIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.GetLineFromCharIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetLineFromCharIndex (index As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetLineFromCharIndex(int index);" />
      <MemberSignature Language="F#" Value="override this.GetLineFromCharIndex : int -&gt; int" Usage="richTextBox.GetLineFromCharIndex index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Местоположение индекса символа для поиска.</param>
        <summary>Извлекает номер строки по указанному местоположению символа в тексте элемента управления <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <returns>Отсчитываемый от нуля номер строки, на которую указывает индекс символа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод позволяет определить номер строки на основе индекса символа, указанного в `index` параметра метода. Первая строка текста в элементе управления, возвращается нулевое значение. <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> Метод возвращает номер физической, где индексированных символ находится в элементе управления. Например, если часть первой логической строки текста в автоматически переносятся на следующую строку <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> метод возвращает 1, если символ в символ с указанным индексом перешел второй строки. Если <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> равно `false`, нет часть строки переходит на следующую и метод возвращает значение 0 для символ с указанным индексом. Этот метод позволяет определить строку, в котором определенный индекс находится в пределах. Например, после вызова метода <xref:System.Windows.Forms.RichTextBox.Find%2A> метод для поиска текста, можно получить индекс знака, в котором находятся результаты поиска. Этот метод можно вызывать с индекс символа, возвращенных <xref:System.Windows.Forms.RichTextBox.Find%2A> найден метод, чтобы определить строку слово.  
  
 В некоторых случаях <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> не вызывает исключение при `index` параметр не является допустимым значением. Пример:  
  
-   Если `index` параметр <xref:System.Int32.MinValue> или -1, <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> возвращает 0.  
  
-   Если `index` параметр является длина текста или <xref:System.Int32.MaxValue>, <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> возвращает номер последней строки текста, которые не обязательно совпадает как `Lines.Length-1`, в зависимости от значения <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> свойство.  
  
 В этих случаях проверки входных перед вызовом <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A>.  
  
> [!NOTE]
>  Если указанный индекс символа в `index` параметра превышает допустимое число строк, содержащихся в элементе управления, возвращается номер последней строки.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Windows.Forms.RichTextBox.GetLineFromCharIndex%2A> метода. Чтобы запустить пример, вставьте следующий код в форму, содержащую <xref:System.Windows.Forms.RichTextBox> управления с именем `RichTextBox1`, кнопку с именем `Button1` и два текстовых поля с именем `TextBox1` и `TextBox2`. Если пример выполняется, введите строку поиска в `TextBox2` и нажмите кнопку, чтобы получить результаты поиска.  
  
 [!code-cpp[System.Windows.Forms.RichTextBoxGetLine#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxGetLine/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.RichTextBoxGetLine#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxGetLine/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.RichTextBoxGetLine#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxGetLine/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetPositionFromCharIndex(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetPositionFromCharIndex">
      <MemberSignature Language="C#" Value="public override System.Drawing.Point GetPositionFromCharIndex (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance valuetype System.Drawing.Point GetPositionFromCharIndex(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.GetPositionFromCharIndex(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetPositionFromCharIndex (index As Integer) As Point" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Drawing::Point GetPositionFromCharIndex(int index);" />
      <MemberSignature Language="F#" Value="override this.GetPositionFromCharIndex : int -&gt; System.Drawing.Point" Usage="richTextBox.GetPositionFromCharIndex index" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Drawing.Point</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Индекс символа, расположение которого требуется определить.</param>
        <summary>Вычисляет положение в элементе управления по указанному индексу символа.</summary>
        <returns>Местоположение указанного символа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод позволяет определить, где находится определенный индекс символа в элементе управления. Этот метод можно использовать для таких задач, как отображение контекстное меню элементов или справочных сведений для слова элемента управления. Например, если требуется отображать меню параметров для пользователя, когда пользователь щелкает правой кнопкой мыши слово в элементе управления, можно использовать этот метод для определения позиции word для правильного отображения <xref:System.Windows.Forms.ContextMenu> элемента управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetCharIndexFromPosition(System.Drawing.Point)" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.GetLineFromCharIndex(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberSignature Language="F#" Value="member this.GiveFeedback : System.Windows.Forms.GiveFeedbackEventHandler " Usage="member this.GiveFeedback : System.Windows.Forms.GiveFeedbackEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Вызывается при выполнении операции перетаскивания.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данное событие не применимо к этому классу.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HScroll">
      <MemberSignature Language="C#" Value="public event EventHandler HScroll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler HScroll" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.HScroll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event HScroll As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ HScroll;" />
      <MemberSignature Language="F#" Value="member this.HScroll : EventHandler " Usage="member this.HScroll : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при щелчке пользователем горизонтальной полосы прокрутки элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке событий см. в разделе [NIB: Потребление событий](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.RichTextBox.HScroll> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.RichTextBox> с именем `RichTextBox1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.RichTextBox.HScroll> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#540](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#540)]
 [!code-vb[System.Windows.Forms.EventExamples#540](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#540)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ImeChange">
      <MemberSignature Language="C#" Value="public event EventHandler ImeChange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ImeChange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.ImeChange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ImeChange As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ ImeChange;" />
      <MemberSignature Language="F#" Value="member this.ImeChange : EventHandler " Usage="member this.ImeChange : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при переключении пользователем способов ввода в азиатской версии операционной системы Windows.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке событий см. в разделе [NIB: Потребление событий](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.RichTextBox.ImeChange> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.RichTextBox> с именем `RichTextBox1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.RichTextBox.ImeChange> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#542](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#542)]
 [!code-vb[System.Windows.Forms.EventExamples#542](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#542)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageOption">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.RichTextBoxLanguageOptions LanguageOption { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RichTextBoxLanguageOptions LanguageOption" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.LanguageOption" />
      <MemberSignature Language="VB.NET" Value="Public Property LanguageOption As RichTextBoxLanguageOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::RichTextBoxLanguageOptions LanguageOption { System::Windows::Forms::RichTextBoxLanguageOptions get(); void set(System::Windows::Forms::RichTextBoxLanguageOptions value); };" />
      <MemberSignature Language="F#" Value="member this.LanguageOption : System.Windows.Forms.RichTextBoxLanguageOptions with get, set" Usage="System.Windows.Forms.RichTextBox.LanguageOption" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RichTextBoxLanguageOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, которое указывает параметры <see cref="T:System.Windows.Forms.RichTextBox" /> для редактора метода ввода и поддержки азиатских языков.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Windows.Forms.RichTextBoxLanguageOptions" />. Значение по умолчанию: <see cref="F:System.Windows.Forms.RichTextBoxLanguageOptions.AutoFontSizeAdjust" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LinkClicked">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.LinkClickedEventHandler LinkClicked;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.LinkClickedEventHandler LinkClicked" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.LinkClicked" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LinkClicked As LinkClickedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::LinkClickedEventHandler ^ LinkClicked;" />
      <MemberSignature Language="F#" Value="member this.LinkClicked : System.Windows.Forms.LinkClickedEventHandler " Usage="member this.LinkClicked : System.Windows.Forms.LinkClickedEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.LinkClickedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при щелчке пользователем ссылки, расположенной в тексте элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно создать обработчик событий для этого события для обработки ссылку, которая была нажата в элементе управления. Используя эту информацию для обработчика событий, можно определить, какая ссылка была нажата в документе.  
  
> [!IMPORTANT]
>  По умолчанию связи отображаются в виде текста и не являются интерактивными. Чтобы сделать их интерактивными набор <xref:System.Windows.Forms.RichTextBox.DetectUrls%2A> свойства `true`.  
  
 Дополнительные сведения об обработке событий см. в разделе [NIB: Потребление событий](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 В следующем примере кода содержится обработчик событий для <xref:System.Windows.Forms.RichTextBox.LinkClicked> события. Обработчик событий обрабатывает нажатия ссылок из документа элемента <xref:System.Windows.Forms.RichTextBox> управления и запускает экземпляр браузера по умолчанию (с помощью <xref:System.Diagnostics.Process.Start%2A?displayProperty=nameWithType> метод), отображается страница ссылку, которая была нажата. В этом примере требуется, что обработчик событий был связан с <xref:System.Windows.Forms.RichTextBox.LinkClicked> событий для <xref:System.Windows.Forms.RichTextBox>.  
  
 [!code-cpp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LinkClicked Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LinkClicked Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.DetectUrls" />
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Загружает в элемент управления <see cref="T:System.Windows.Forms.RichTextBox" /> содержимое файла.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public void LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadFile (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.LoadFile : string -&gt; unit" Usage="richTextBox.LoadFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Имя и расположение файла, который будет загружен в элемент управления.</param>
        <summary>Загружает файл в формате RTF или стандартный текстовый файл в кодировке ASCII в элемент управления <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При загрузке файла с <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> метод, содержимое файла, загружаемого замените все содержимое <xref:System.Windows.Forms.RichTextBox> элемента управления. Это приведет к значения <xref:System.Windows.Forms.TextBoxBase.Text%2A> и <xref:System.Windows.Forms.RichTextBox.Rtf%2A> свойства для изменения. Этот метод можно использовать для загрузки предварительно созданный текст или RTF-документ в элемент управления для обработки. Если вы хотите сохранить файл, можно использовать <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> метода.  
  
> [!NOTE]
>  С этой версией <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> метод, если загружаемый файл не является документом RTF, возникает исключение. Чтобы загрузить другой тип файла, например текстовый файл в кодировке ASCII, используйте другие версии этого метода, которые принимают значение из <xref:System.Windows.Forms.RichTextBoxStreamType> перечисление как параметр.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> Метод не открывайте файл, пока не будет создан дескриптор для <xref:System.Windows.Forms.RichTextBox>. Убедитесь, что перед вызовом метода создается дескриптор элемента управления <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> метод.  
  
   
  
## Examples  
 В следующем примере кода открывается файл формата RTF в <xref:System.Windows.Forms.RichTextBox> элемента управления. В этом примере <xref:System.Windows.Forms.OpenFileDialog> класс, чтобы отобразить диалоговое окно с запросом файла от пользователя. Затем код загружает этот файл подразумевается, что RTF, документ в формате. Если файл не является, в примере кода возникает исключение. В этом примере требуется, что код размещается в <xref:System.Windows.Forms.Form> классом, имеющим <xref:System.Windows.Forms.RichTextBox> управления с именем `richTextBox1`.  
  
 [!code-cpp[Classic RichTextBox.LoadFile Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LoadFile Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LoadFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LoadFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">При загрузке файла в элемент управления произошла ошибка.</exception>
        <exception cref="T:System.ArgumentException">Загружаемый файл является документом RTF.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для открытия файла. Соответствующее перечисление: <see langword="Read" /> значение <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />.</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public void LoadFile (System.IO.Stream data, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadFile(class System.IO.Stream data, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.LoadFile(System.IO.Stream,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadFile (data As Stream, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadFile(System::IO::Stream ^ data, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.LoadFile : System.IO.Stream * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.LoadFile (data, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="data">Поток данных, который будет загружен в элемент управления <see cref="T:System.Windows.Forms.RichTextBox" />.</param>
        <param name="fileType">Одно из значений перечисления <see cref="T:System.Windows.Forms.RichTextBoxStreamType" />.</param>
        <summary>Загружает в элемент управления <see cref="T:System.Windows.Forms.RichTextBox" /> содержимое существующего потока данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данную версию можно использовать <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> метод, чтобы загрузить <xref:System.Windows.Forms.RichTextBox> данными из существующего потока данных. Данные, загружаемые в элемент управления заменяет все содержимое <xref:System.Windows.Forms.RichTextBox> элемента управления. Это приведет к значения <xref:System.Windows.Forms.TextBoxBase.Text%2A> и <xref:System.Windows.Forms.RichTextBox.Rtf%2A> свойства для изменения. Этот метод можно использовать для загрузки файла, который ранее был открыт в поток данных в элемент управления для обработки. Если вы хотите сохранить содержимое элемента управления обратно в поток, можно использовать <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> метод, который принимает <xref:System.IO.Stream> объект в качестве параметра.  
  
 Эта версия <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> метод также позволяет указать тип данных, который загружается в элемент управления. Эта функция позволяет использовать потоки данных, которые содержат данные, отличные от документы формате RTF форматированного текста в элементе управления.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> Метод не открывайте файл, пока не будет создан дескриптор для <xref:System.Windows.Forms.RichTextBox>. Убедитесь, что перед вызовом метода создается дескриптор элемента управления <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> метод.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> и <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> методов с потоками. Также демонстрируется использование <xref:System.Windows.Forms.FileDialog.FileName%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.FileDialog.DefaultExt%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.SaveFileDialog.CreatePrompt%2A?displayProperty=nameWithType>, и <xref:System.Windows.Forms.SaveFileDialog.OverwritePrompt%2A?displayProperty=nameWithType> члены.  
  
 Это полный пример, готов к выполнению при копировании проекта.  
  
 [!code-cpp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">При загрузке файла в элемент управления произошла ошибка.</exception>
        <exception cref="T:System.ArgumentException">Загружаемый файл является документом RTF.</exception>
        <altmember cref="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public void LoadFile (string path, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void LoadFile(string path, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.LoadFile(System.String,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub LoadFile (path As String, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void LoadFile(System::String ^ path, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.LoadFile : string * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.LoadFile (path, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="path">Имя и расположение файла, который будет загружен в элемент управления.</param>
        <param name="fileType">Одно из значений перечисления <see cref="T:System.Windows.Forms.RichTextBoxStreamType" />.</param>
        <summary>Загружает в элемент управления <see cref="T:System.Windows.Forms.RichTextBox" /> определенный тип файла.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При загрузке файла с <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> метод, содержимое файла, загружаемого замените все содержимое <xref:System.Windows.Forms.RichTextBox> элемента управления. Это приведет к значения <xref:System.Windows.Forms.TextBoxBase.Text%2A> и <xref:System.Windows.Forms.RichTextBox.Rtf%2A> свойства для изменения. Этот метод можно использовать для загрузки предварительно созданный текст или документ в формате (RTF) в элементе управления для обработки. Если вы хотите сохранить файл, можно использовать <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> метода.  
  
 Данную версию можно использовать <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> метод, чтобы указать тип файла, загружаемого файла. Эта функция позволяет загружать файлы, не являющиеся документы формата RTF в элемент управления.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> Метод не открывайте файл, пока не будет создан дескриптор для <xref:System.Windows.Forms.RichTextBox>. Убедитесь, что перед вызовом метода создается дескриптор элемента управления <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> метод.  
  
   
  
## Examples  
 В следующем примере кода открывается текстовый файл в <xref:System.Windows.Forms.RichTextBox> элемента управления. В этом примере <xref:System.Windows.Forms.OpenFileDialog> класс, чтобы отобразить диалоговое окно с запросом файла от пользователя. Затем код загружает этот файл в <xref:System.Windows.Forms.RichTextBox> элемента управления. В примере используется эта версия <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> метод, чтобы указать, что открыть файл как текстовый файл ASCII, а не стандартный текст в формате RTF. В этом примере требуется, что код размещается в <xref:System.Windows.Forms.Form> классом, имеющим <xref:System.Windows.Forms.RichTextBox> управления с именем `richTextBox1`.  
  
 [!code-cpp[Classic RichTextBox.LoadFile1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.LoadFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.LoadFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.LoadFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.LoadFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">При загрузке файла в элемент управления произошла ошибка.</exception>
        <exception cref="T:System.ArgumentException">Загружаемый файл является документом RTF.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для открытия файла. Соответствующее перечисление: <see langword="Read" /> значение <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />.</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="MaxLength">
      <MemberSignature Language="C#" Value="public override int MaxLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaxLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.MaxLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property MaxLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaxLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.MaxLength : int with get, set" Usage="System.Windows.Forms.RichTextBox.MaxLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(2147483647)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает наибольшее число символов, которое можно ввести или вставить в поле форматированного текста элемента управления.</summary>
        <value>Число символов, которое можно ввести в элемент управления. Значение по умолчанию: <see cref="F:System.Int32.MaxValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если это свойство имеет значение 0, максимальная длина текста, введенного в элементе управления составляет 64 КБ символов. Это свойство является обычно используется, когда <xref:System.Windows.Forms.RichTextBox> используется для отображения одной строки текста формате RTF форматированного текста. Это свойство можно использовать для ограничения длины текста, введенного в элементе управления для значений, как почтовые индексы и номера телефона, или для ограничения длины текста, введенного в случаях, когда должна вводиться в базе данных. Можно ограничить текста, введенного в элемент управления в максимальную длину в соответствующее поле в базе данных.  
  
> [!NOTE]
>  В коде, можно задать значение <xref:System.Windows.Forms.TextBoxBase.Text%2A> свойство в значение, которое имеет длину больше значения, указанного в <xref:System.Windows.Forms.TextBoxBase.MaxLength%2A> свойство. Это свойство влияет только на текст, введенный в элемент управления во время выполнения.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.RichTextBox.MaxLength%2A> свойство для определения текста, назначаемый <xref:System.Windows.Forms.RichTextBox> управления больше, чем значение, присваиваемое <xref:System.Windows.Forms.RichTextBox.MaxLength%2A> свойство. Если текст не большего размера, в примере используется <xref:System.Windows.Forms.RichTextBox.SelectedText%2A> свойство текст элемента управления. В этом примере требуется, <xref:System.Windows.Forms.RichTextBox> управления с именем `richTextBox1`, добавляемых на форму и вызываемого метода в примере текст предоставляется параметру, который будет вставлен в элемент управления. В этом примере также требуется <xref:System.Windows.Forms.TextBoxBase.MaxLength%2A> свойство было задано значение для ограничения ввод текста в <xref:System.Windows.Forms.RichTextBox>.  
  
 [!code-cpp[RichTextBox.MaxLength#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.MaxLength/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.MaxLength#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.MaxLength/CS/form1.cs#1)]
 [!code-vb[RichTextBox.MaxLength#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.MaxLength/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Значение, назначенное свойству, меньше 0.</exception>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.MaxLength" />
      </Docs>
    </Member>
    <Member MemberName="Multiline">
      <MemberSignature Language="C#" Value="public override bool Multiline { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Multiline" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Multiline" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Multiline As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool Multiline { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Multiline : bool with get, set" Usage="System.Windows.Forms.RichTextBox.Multiline" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, показывающее, является ли данный элемент управления многострочным <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <value>Значение <see langword="true" />, если элемент управления <see cref="T:System.Windows.Forms.RichTextBox" /> является многострочным; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBackColorChanged">
      <MemberSignature Language="C#" Value="protected override void OnBackColorChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBackColorChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnBackColorChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnBackColorChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnBackColorChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnBackColorChanged : EventArgs -&gt; unit" Usage="richTextBox.OnBackColorChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.BackColorChanged" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentsResized">
      <MemberSignature Language="C#" Value="protected virtual void OnContentsResized (System.Windows.Forms.ContentsResizedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentsResized(class System.Windows.Forms.ContentsResizedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnContentsResized(System.Windows.Forms.ContentsResizedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentsResized (e As ContentsResizedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentsResized(System::Windows::Forms::ContentsResizedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnContentsResized : System.Windows.Forms.ContentsResizedEventArgs -&gt; unit&#xA;override this.OnContentsResized : System.Windows.Forms.ContentsResizedEventArgs -&gt; unit" Usage="richTextBox.OnContentsResized e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.ContentsResizedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Forms.ContentsResizedEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.RichTextBox.ContentsResized" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.RichTextBox.OnContentsResized%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.RichTextBox.OnContentsResized(System.Windows.Forms.ContentsResizedEventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Windows.Forms.RichTextBox.OnContentsResized(System.Windows.Forms.ContentsResizedEventArgs)" /> метод, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.ContentsResized" />
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuChanged">
      <MemberSignature Language="C#" Value="protected override void OnContextMenuChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContextMenuChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnContextMenuChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContextMenuChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContextMenuChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnContextMenuChanged : EventArgs -&gt; unit" Usage="richTextBox.OnContextMenuChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.ContextMenuChanged" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleCreated">
      <MemberSignature Language="C#" Value="protected override void OnHandleCreated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleCreated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnHandleCreated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleCreated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleCreated(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleCreated : EventArgs -&gt; unit" Usage="richTextBox.OnHandleCreated e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.HandleCreated" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHandleDestroyed">
      <MemberSignature Language="C#" Value="protected override void OnHandleDestroyed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnHandleDestroyed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnHandleDestroyed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnHandleDestroyed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnHandleDestroyed(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnHandleDestroyed : EventArgs -&gt; unit" Usage="richTextBox.OnHandleDestroyed e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.HandleDestroyed" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnHScroll">
      <MemberSignature Language="C#" Value="protected virtual void OnHScroll (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnHScroll(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnHScroll(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnHScroll (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnHScroll(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnHScroll : EventArgs -&gt; unit&#xA;override this.OnHScroll : EventArgs -&gt; unit" Usage="richTextBox.OnHScroll e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.RichTextBox.HScroll" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.RichTextBox.OnHScroll%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.RichTextBox.OnHScroll(System.EventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Windows.Forms.RichTextBox.OnHScroll(System.EventArgs)" /> метод, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.HScroll" />
      </Docs>
    </Member>
    <Member MemberName="OnImeChange">
      <MemberSignature Language="C#" Value="protected virtual void OnImeChange (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnImeChange(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnImeChange(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnImeChange (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnImeChange(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnImeChange : EventArgs -&gt; unit&#xA;override this.OnImeChange : EventArgs -&gt; unit" Usage="richTextBox.OnImeChange e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.RichTextBox.ImeChange" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.RichTextBox.OnImeChange%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.RichTextBox.OnImeChange(System.EventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Windows.Forms.RichTextBox.OnImeChange(System.EventArgs)" /> метод, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.ImeChange" />
      </Docs>
    </Member>
    <Member MemberName="OnLinkClicked">
      <MemberSignature Language="C#" Value="protected virtual void OnLinkClicked (System.Windows.Forms.LinkClickedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLinkClicked(class System.Windows.Forms.LinkClickedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnLinkClicked(System.Windows.Forms.LinkClickedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLinkClicked (e As LinkClickedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLinkClicked(System::Windows::Forms::LinkClickedEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLinkClicked : System.Windows.Forms.LinkClickedEventArgs -&gt; unit&#xA;override this.OnLinkClicked : System.Windows.Forms.LinkClickedEventArgs -&gt; unit" Usage="richTextBox.OnLinkClicked e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Forms.LinkClickedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.Windows.Forms.LinkClickedEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.RichTextBox.LinkClicked" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.RichTextBox.OnLinkClicked%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.RichTextBox.OnLinkClicked(System.Windows.Forms.LinkClickedEventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Windows.Forms.RichTextBox.OnLinkClicked(System.Windows.Forms.LinkClickedEventArgs)" /> метод, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.LinkClicked" />
      </Docs>
    </Member>
    <Member MemberName="OnProtected">
      <MemberSignature Language="C#" Value="protected virtual void OnProtected (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnProtected(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnProtected(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnProtected (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnProtected(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnProtected : EventArgs -&gt; unit&#xA;override this.OnProtected : EventArgs -&gt; unit" Usage="richTextBox.OnProtected e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.RichTextBox.Protected" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.RichTextBox.OnProtected%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.RichTextBox.OnProtected(System.EventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Windows.Forms.RichTextBox.OnProtected(System.EventArgs)" /> метод, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.Protected" />
      </Docs>
    </Member>
    <Member MemberName="OnRightToLeftChanged">
      <MemberSignature Language="C#" Value="protected override void OnRightToLeftChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnRightToLeftChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnRightToLeftChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnRightToLeftChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnRightToLeftChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="override this.OnRightToLeftChanged : EventArgs -&gt; unit" Usage="richTextBox.OnRightToLeftChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.Control.RightToLeftChanged" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.Control.OnRightToLeftChanged(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnSelectionChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnSelectionChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSelectionChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnSelectionChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSelectionChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSelectionChanged(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnSelectionChanged : EventArgs -&gt; unit&#xA;override this.OnSelectionChanged : EventArgs -&gt; unit" Usage="richTextBox.OnSelectionChanged e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.RichTextBox.SelectionChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.RichTextBox.OnSelectionChanged%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.RichTextBox.OnSelectionChanged(System.EventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Windows.Forms.RichTextBox.OnSelectionChanged(System.EventArgs)" /> метод, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.SelectionChanged" />
      </Docs>
    </Member>
    <Member MemberName="OnVScroll">
      <MemberSignature Language="C#" Value="protected virtual void OnVScroll (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnVScroll(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.OnVScroll(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnVScroll (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnVScroll(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnVScroll : EventArgs -&gt; unit&#xA;override this.OnVScroll : EventArgs -&gt; unit" Usage="richTextBox.OnVScroll e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Forms.RichTextBox.VScroll" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При возникновении события через делегат вызывается обработчик события. Дополнительные сведения см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Метод <xref:System.Windows.Forms.RichTextBox.OnVScroll%2A> также позволяет производным классам обрабатывать событие, не присоединяя делегат. Это предпочтительная методика обработки событий в производном классе.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении метода <see cref="M:System.Windows.Forms.RichTextBox.OnVScroll(System.EventArgs)" /> в производном классе нужно убедиться, что вызов базового класса <see cref="M:System.Windows.Forms.RichTextBox.OnVScroll(System.EventArgs)" /> метод, чтобы зарегистрированные делегаты получили событие.</para>
        </block>
        <altmember cref="E:System.Windows.Forms.RichTextBox.VScroll" />
      </Docs>
    </Member>
    <Member MemberName="Paste">
      <MemberSignature Language="C#" Value="public void Paste (System.Windows.Forms.DataFormats.Format clipFormat);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Paste(class System.Windows.Forms.DataFormats/Format clipFormat) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Paste(System.Windows.Forms.DataFormats.Format)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Paste (clipFormat As DataFormats.Format)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Paste(System::Windows::Forms::DataFormats::Format ^ clipFormat);" />
      <MemberSignature Language="F#" Value="override this.Paste : System.Windows.Forms.DataFormats.Format -&gt; unit" Usage="richTextBox.Paste clipFormat" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clipFormat" Type="System.Windows.Forms.DataFormats+Format" />
      </Parameters>
      <Docs>
        <param name="clipFormat">Формат буфера обмена, в котором данные должны быть получены из буфера обмена.</param>
        <summary>Вставляет в элемент управления содержимое буфера обмена в указанном формате буфера обмена.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для вставки данных из буфера обмена в элементе управления. Эта версия <xref:System.Windows.Forms.RichTextBox.Paste%2A> метод отличается от <xref:System.Windows.Forms.TextBoxBase.Paste%2A?displayProperty=nameWithType> метода как его можно вставить только текст в указанном формате буфера обмена. Можно использовать <xref:System.Windows.Forms.RichTextBox.CanPaste%2A> метод, чтобы определить, является ли данные в буфер обмена в указанном формате буфера обмена. Затем можно вызвать эту версию <xref:System.Windows.Forms.RichTextBox.Paste%2A> метод, чтобы гарантировать, что операция вставки выполняется с подходящий формат данных.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.RichTextBox.Paste%2A> метод для точечного рисунка в <xref:System.Windows.Forms.RichTextBox> элемента управления. После открытия точечный рисунок из файла, в примере используется <xref:System.Windows.Forms.Clipboard.SetDataObject%2A> метод скопируйте растровое изображение в буфер обмена Windows. Наконец, в примере извлекается формат для <xref:System.Drawing.Bitmap> объекта, проверяет, что формат может быть вставлено в <xref:System.Windows.Forms.RichTextBox> управления и использует <xref:System.Windows.Forms.RichTextBox.Paste%2A> метод вставки данных.  
  
 [!code-cpp[RichText_Paste#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichText_Paste/CPP/form1.cpp#1)]
 [!code-csharp[RichText_Paste#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichText_Paste/CS/form1.cs#1)]
 [!code-vb[RichText_Paste#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichText_Paste/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для чтения из буфера обмена. Соответствующее перечисление: <see langword="AllClipboard" /> значение <see cref="T:System.Security.Permissions.UIPermissionClipboard" />.</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.CanPaste(System.Windows.Forms.DataFormats.Format)" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Paste" />
        <altmember cref="T:System.Windows.Forms.DataFormats.Format" />
      </Docs>
    </Member>
    <Member MemberName="ProcessCmdKey">
      <MemberSignature Language="C#" Value="protected override bool ProcessCmdKey (ref System.Windows.Forms.Message m, System.Windows.Forms.Keys keyData);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool ProcessCmdKey(valuetype System.Windows.Forms.Message&amp; m, valuetype System.Windows.Forms.Keys keyData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ProcessCmdKey (ByRef m As Message, keyData As Keys) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool ProcessCmdKey(System::Windows::Forms::Message % m, System::Windows::Forms::Keys keyData);" />
      <MemberSignature Language="F#" Value="override this.ProcessCmdKey :  * System.Windows.Forms.Keys -&gt; bool" Usage="richTextBox.ProcessCmdKey (m, keyData)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
        <Parameter Name="keyData" Type="System.Windows.Forms.Keys" />
      </Parameters>
      <Docs>
        <param name="m">Передаваемый по ссылке объект <see cref="T:System.Windows.Forms.Message" />, который представляет сообщение окна для обработки.</param>
        <param name="keyData">Одно из значений <see cref="T:System.Windows.Forms.Keys" />, представляющее обрабатываемую клавишу.</param>
        <summary>Обрабатывает клавишу для команд.</summary>
        <returns>Значение <see langword="true" />, если знак был обработан элементом управления; в противном случае — значение <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.ProcessCmdKey(System.Windows.Forms.Message@,System.Windows.Forms.Keys)" />
      </Docs>
    </Member>
    <Member MemberName="Protected">
      <MemberSignature Language="C#" Value="public event EventHandler Protected;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Protected" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.Protected" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Protected As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Protected;" />
      <MemberSignature Language="F#" Value="member this.Protected : EventHandler " Usage="member this.Protected : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при попытке пользователя изменить защищенный текст элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно создать обработчик событий для этого события в приложениях, чтобы определить, когда пользователь пытался изменить текст, который был помечен как защищенный в элементе управления. Обработчик событий может использоваться для уведомления о том, что пользователь, который пытается изменить текст, который он защищен или отобразить диалоговое окно, которое дает пользователю возможность внести соответствующие изменения в текст. Например если защищенной областью является дата, можно отобразить диалоговым окном, которое позволяет пользователю выбрать дату, которую затем можно применить к тексту элемента управления.  
  
 Дополнительные сведения об обработке событий см. в разделе [NIB: Потребление событий](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.RichTextBox.Protected> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.RichTextBox> с именем `RichTextBox1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.RichTextBox.Protected> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#543](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#543)]
 [!code-vb[System.Windows.Forms.EventExamples#543](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#543)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Forms.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Forms::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberSignature Language="F#" Value="member this.QueryContinueDrag : System.Windows.Forms.QueryContinueDragEventHandler " Usage="member this.QueryContinueDrag : System.Windows.Forms.QueryContinueDragEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Данное событие не применимо к этому классу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данное событие не применимо к этому классу.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Redo">
      <MemberSignature Language="C#" Value="public void Redo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Redo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.Redo" />
      <MemberSignature Language="VB.NET" Value="Public Sub Redo ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Redo();" />
      <MemberSignature Language="F#" Value="member this.Redo : unit -&gt; unit" Usage="richTextBox.Redo " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Заново применяет выполненное последним действие, результаты которого были отменены в элементе управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Затем можно использовать <xref:System.Windows.Forms.RichTextBox.Redo%2A> метода для повторного применения последней операции отмены в элемент управления. <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> Метод позволяет определить ли последняя операция пользователем повторно применить к элементу управления.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> и <xref:System.Windows.Forms.RichTextBox.RedoActionName%2A> свойства и <xref:System.Windows.Forms.RichTextBox.Redo%2A> метод, чтобы ограничить проведения операции отмены для любого действия, за исключением удаления текста. В этом примере требуется наличие формы, содержащей <xref:System.Windows.Forms.RichTextBox> управления и что на операцию в <xref:System.Windows.Forms.RichTextBox> была проведена и отменены до вызова кода в этом примере.  
  
 [!code-cpp[RichTextBox.RedoAction#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.RedoAction/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.RedoAction#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.RedoAction/CS/form1.cs#1)]
 [!code-vb[RichTextBox.RedoAction#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.RedoAction/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.CanRedo" />
      </Docs>
    </Member>
    <Member MemberName="RedoActionName">
      <MemberSignature Language="C#" Value="public string RedoActionName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RedoActionName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.RedoActionName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RedoActionName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RedoActionName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RedoActionName : string" Usage="System.Windows.Forms.RichTextBox.RedoActionName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает имя действия, которое можно повторно применить к элементу управления при вызове метода <see cref="M:System.Windows.Forms.RichTextBox.Redo" />.</summary>
        <value>Строка, которая предоставляет имя действия, которое будет выполнено при вызове метода <see cref="M:System.Windows.Forms.RichTextBox.Redo" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если это свойство возвращает пустую строку ("»), нет операций, доступных для повторного применения к элементу управления. Этот метод можно использовать для определения последнего действия отменить в <xref:System.Windows.Forms.RichTextBox> управления, можно заново применить к элементу управления, когда вызов <xref:System.Windows.Forms.RichTextBox.Redo%2A> метода. Чтобы выяснить, существуют ли все операции к повторному к элементу управления с помощью <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.RichTextBox.CanRedo%2A> и <xref:System.Windows.Forms.RichTextBox.RedoActionName%2A> свойства и <xref:System.Windows.Forms.RichTextBox.Redo%2A> метод, чтобы ограничить проведения операции отмены для любого действия, за исключением удаления текста. В этом примере требуется наличие формы, содержащей <xref:System.Windows.Forms.RichTextBox> управления и что на операцию в <xref:System.Windows.Forms.RichTextBox> была проведена и отменены до вызова кода в этом примере.  
  
 [!code-cpp[RichTextBox.RedoAction#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.RedoAction/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.RedoAction#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.RedoAction/CS/form1.cs#1)]
 [!code-vb[RichTextBox.RedoAction#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.RedoAction/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.CanRedo" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.Redo" />
      </Docs>
    </Member>
    <Member MemberName="RichTextShortcutsEnabled">
      <MemberSignature Language="C#" Value="public bool RichTextShortcutsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool RichTextShortcutsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.RichTextShortcutsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property RichTextShortcutsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool RichTextShortcutsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.RichTextShortcutsEnabled : bool with get, set" Usage="System.Windows.Forms.RichTextBox.RichTextShortcutsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Данное свойство не применимо к этому классу.</summary>
        <value>Значение <see langword="true" />, если задействуются сочетания клавиш; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данное свойство не применимо к этому классу.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RightMargin">
      <MemberSignature Language="C#" Value="public int RightMargin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 RightMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.RightMargin" />
      <MemberSignature Language="VB.NET" Value="Public Property RightMargin As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int RightMargin { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.RightMargin : int with get, set" Usage="System.Windows.Forms.RichTextBox.RightMargin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает размер одной строки текста элемента управления <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <value>Размер одной строки текста элемента управления в пикселях. По умолчанию используется значение ноль.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение больше нуля, введенное в элемент управления, выделяется невидимое в элементе управления на указанное число пикселей от левого края элемента управления. Любой текст, который вводится, выходит за пределы этого поля будет располагаться на следующей строке текста в элементе управления. Это свойство влияет на текст, введенный в данный момент в элементе управления, а также любой дополнительный текст, вводимый в элемент управления после изменения свойства. Это свойство можно использовать, чтобы указать максимальную ширину строки для всего текста, введенного в <xref:System.Windows.Forms.RichTextBox> элемента управления.  
  
   
  
## Examples  
 В следующем примере кода показано, как создать <xref:System.Windows.Forms.RichTextBox> , увеличивает масштаб текста, автоматически выделять слова в тексте элемента управления, при двойном щелчке слова, а также имеет поле в правой части клиентской области элемента управления. Если <xref:System.Windows.Forms.RichTextBox> управления имеет небольшой ширину, с помощью следующего кода будет создан <xref:System.Windows.Forms.RichTextBox> где каждый символ текст отображается на отдельной строке. В этой позиции вертикальное отображение щелчка по любой части слова будут выделены все символы слова, несмотря на то, что текст отображается вертикально. В этом примере требуется наличие формы, содержащей <xref:System.Windows.Forms.RichTextBox> управления с именем `richTextBox1`.  
  
 [!code-cpp[RichTextBox.ZoomFactor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.ZoomFactor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CS/form1.cs#1)]
 [!code-vb[RichTextBox.ZoomFactor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.ZoomFactor/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Было задано значение меньше нуля.</exception>
      </Docs>
    </Member>
    <Member MemberName="Rtf">
      <MemberSignature Language="C#" Value="public string Rtf { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Rtf" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Rtf" />
      <MemberSignature Language="VB.NET" Value="Public Property Rtf As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Rtf { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Rtf : string with get, set" Usage="System.Windows.Forms.RichTextBox.Rtf" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает текст элемента управления <see cref="T:System.Windows.Forms.RichTextBox" />, в том числе все коды RTF.</summary>
        <value>Текст элемента управления в формате RTF.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать это свойство, чтобы поместить текст в формате RTF в элемент управления для отображения или извлечь текст элемента управления с заданным форматированием RTF, определенным в тексте элемента управления. Это свойство обычно используется при назначении RTF-текст из другого источника формата RTF, такие как Microsoft Word или Windows WordPad для элемента управления.  
  
 При изменении <xref:System.Windows.Forms.Control.RightToLeft%2A> свойство во время выполнения, только необработанный текст без форматирования сохраняется.  
  
 Коды RTF см. в разделе «форматированного текста (RTF) спецификация формата, версии 1.6» в библиотеке MSDN по http://msdn.microsoft.com/library.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Text" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SaveFile">
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сохраняет содержимое элемента управления <see cref="T:System.Windows.Forms.RichTextBox" /> в файл.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SaveFile">
      <MemberSignature Language="C#" Value="public void SaveFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.SaveFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveFile (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SaveFile : string -&gt; unit" Usage="richTextBox.SaveFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Имя и расположение сохраняемого файла.</param>
        <summary>Сохраняет содержимое элемента управления <see cref="T:System.Windows.Forms.RichTextBox" /> в RTF-файл.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> Метод позволяет сохранять все содержимое элемента управления RTF-файл, который может использоваться другими программами, такими как Microsoft Word и Windows WordPad. Если имя файла, который передается `path` уже существует в указанном каталоге, файл будет перезаписан без предварительного уведомления. Можно использовать <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> метод, чтобы загрузить содержимое файла в <xref:System.Windows.Forms.RichTextBox>.  
  
> [!NOTE]
>  Чтобы сохранить содержимое элемента управления на другой тип формата файла, такие как текст ASCII, используйте другие версии этого метода, которые принимают значение из <xref:System.Windows.Forms.RichTextBoxStreamType> перечисление как параметр.  
  
   
  
## Examples  
 В следующем примере кода сохраняет содержимое <xref:System.Windows.Forms.RichTextBox> управления RTF-файл. В этом примере <xref:System.Windows.Forms.SaveFileDialog> класса, чтобы отобразить диалоговое окно, чтобы запрашивать пользователя, путь и имя файла для сохранения. Затем код сохраняет файл, при условии, что содержимое находится в формате RTF. Если файл уже существует, он будет автоматически перезаписан. В этом примере требуется, что код размещается в <xref:System.Windows.Forms.Form> классом, имеющим <xref:System.Windows.Forms.RichTextBox> управления с именем `richTextBox1`.  
  
 [!code-cpp[Classic RichTextBox.SaveFile Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SaveFile Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SaveFile Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SaveFile Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Во время сохранения содержимого элемента управления в файл произошла ошибка.</exception>
        <altmember cref="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SaveFile">
      <MemberSignature Language="C#" Value="public void SaveFile (System.IO.Stream data, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveFile(class System.IO.Stream data, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.SaveFile(System.IO.Stream,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveFile (data As Stream, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveFile(System::IO::Stream ^ data, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.SaveFile : System.IO.Stream * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.SaveFile (data, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="data" Type="System.IO.Stream" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="data">Поток данных, который содержит файл, в который будут сохранены данные.</param>
        <param name="fileType">Одно из значений перечисления <see cref="T:System.Windows.Forms.RichTextBoxStreamType" />.</param>
        <summary>Сохраняет содержимое элемента управления <see cref="T:System.Windows.Forms.RichTextBox" /> в открытый поток данных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта версия <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> метод позволяет сохранять все содержимое элемента управления в поток данных, который уже открыт. Затем поток данных можно сохранить данные в файл. Можно использовать <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> метод, чтобы загрузить содержимое файла в <xref:System.Windows.Forms.RichTextBox>.  
  
 Эта версия <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> метод также позволяет указать формат данных, данных, которые будут отправляться на <xref:System.IO.Stream> объекта.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> и <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> методов с потоками. Также демонстрируется использование <xref:System.Windows.Forms.FileDialog.FileName%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.FileDialog.DefaultExt%2A?displayProperty=nameWithType>, <xref:System.Windows.Forms.SaveFileDialog.CreatePrompt%2A?displayProperty=nameWithType>, и <xref:System.Windows.Forms.SaveFileDialog.OverwritePrompt%2A?displayProperty=nameWithType> члены.  
  
 Это полный пример, готов к выполнению при копировании проекта.  
  
 [!code-cpp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/cpp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CPP/form1.cpp#1)]
 [!code-csharp[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/CS/form1.cs#1)]
 [!code-vb[System.Windows.Forms.RichTextBoxSaveFile#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.RichTextBoxSaveFile/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">В качестве параметра <paramref name="fileType" /> указан недопустимый тип файла.</exception>
        <exception cref="T:System.IO.IOException">Во время сохранения содержимого элемента управления в файл произошла ошибка.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для создания или изменения файла. Соответствующее перечисление: <see langword="Write" /> значение <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />.</permission>
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="SaveFile">
      <MemberSignature Language="C#" Value="public void SaveFile (string path, System.Windows.Forms.RichTextBoxStreamType fileType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SaveFile(string path, valuetype System.Windows.Forms.RichTextBoxStreamType fileType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.SaveFile(System.String,System.Windows.Forms.RichTextBoxStreamType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SaveFile (path As String, fileType As RichTextBoxStreamType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SaveFile(System::String ^ path, System::Windows::Forms::RichTextBoxStreamType fileType);" />
      <MemberSignature Language="F#" Value="member this.SaveFile : string * System.Windows.Forms.RichTextBoxStreamType -&gt; unit" Usage="richTextBox.SaveFile (path, fileType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="fileType" Type="System.Windows.Forms.RichTextBoxStreamType" />
      </Parameters>
      <Docs>
        <param name="path">Имя и расположение сохраняемого файла.</param>
        <param name="fileType">Одно из значений перечисления <see cref="T:System.Windows.Forms.RichTextBoxStreamType" />.</param>
        <summary>Сохраняет содержимое элемента управления <see cref="T:System.Windows.Forms.RichTextBox" /> в файл определенного типа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> Метод позволяет сохранять все содержимое элемента управления RTF-файл, который может использоваться другими программами, такими как Microsoft Word и Windows WordPad. Если имя файла, который передается `path` уже существует в указанном каталоге, файл будет перезаписан без предварительного уведомления. Можно использовать <xref:System.Windows.Forms.RichTextBox.LoadFile%2A> метод, чтобы загрузить содержимое файла в <xref:System.Windows.Forms.RichTextBox>.  
  
 Эта версия <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> метод позволяет определить тип файла для сохранения содержимого элемента управления. Чтобы убедиться, что файл сохранен в правильном формате, в соответствии с содержимым элемента управления можно использовать эту функцию. Например, если в документе имеются различия в стиль шрифта или цвета, можно сохранить файл как текстовый файл ASCII, задав `fileType` параметр `RichTextBoxStreamType.PlainText`.  
  
   
  
## Examples  
 В следующем примере кода сохраняет содержимое <xref:System.Windows.Forms.RichTextBox> в текстовый файл ASCII. В этом примере <xref:System.Windows.Forms.SaveFileDialog> класса, чтобы отобразить диалоговое окно, чтобы запросить у пользователя имя и путь к файлу. Затем код сохраняет содержимое элемента управления к этому файлу. В примере используется эта версия <xref:System.Windows.Forms.RichTextBox.SaveFile%2A> метод, чтобы указать, что файл сохранен как текстовый файл ASCII, а не стандартный текст в формате RTF. В этом примере требуется, что код размещается в <xref:System.Windows.Forms.Form> классом, имеющим <xref:System.Windows.Forms.RichTextBox> управления с именем `richTextBox1`.  
  
 [!code-cpp[Classic RichTextBox.SaveFile1 Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SaveFile1 Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SaveFile1 Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SaveFile1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SaveFile1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">В качестве параметра <paramref name="fileType" /> указан недопустимый тип файла.</exception>
        <exception cref="T:System.IO.IOException">Во время сохранения содержимого элемента управления в файл произошла ошибка.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для создания или изменения файла. Соответствующее перечисление: <see langword="Write" /> значение <see cref="T:System.Security.Permissions.FileIOPermissionAccess" />.</permission>
        <altmember cref="M:System.Windows.Forms.RichTextBox.LoadFile(System.String)" />
        <altmember cref="T:System.Windows.Forms.RichTextBoxStreamType" />
      </Docs>
    </Member>
    <Member MemberName="ScrollBars">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.RichTextBoxScrollBars ScrollBars { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RichTextBoxScrollBars ScrollBars" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ScrollBars" />
      <MemberSignature Language="VB.NET" Value="Public Property ScrollBars As RichTextBoxScrollBars" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::RichTextBoxScrollBars ScrollBars { System::Windows::Forms::RichTextBoxScrollBars get(); void set(System::Windows::Forms::RichTextBoxScrollBars value); };" />
      <MemberSignature Language="F#" Value="member this.ScrollBars : System.Windows.Forms.RichTextBoxScrollBars with get, set" Usage="System.Windows.Forms.RichTextBox.ScrollBars" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RichTextBoxScrollBars</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает тип полос прокрутки, отображающихся в элементе управления <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Windows.Forms.RichTextBoxScrollBars" />. Значение по умолчанию: <see langword="RichTextBoxScrollBars.Both" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство позволяет предоставить пользователю горизонтальные и вертикальные полосы прокрутки <xref:System.Windows.Forms.RichTextBox> элемент управления прокруткой текста в элементе управления, которое находится за пределами размеры элемента управления. Это свойство может использоваться для удаления из управления, чтобы ограничить, выполняя прокрутку содержимого элемента управления полосы прокрутки.  
  
> [!NOTE]
>  Горизонтальные полосы прокрутки не будут отображаться при <xref:System.Windows.Forms.TextBoxBase.WordWrap%2A> — `true`, независимо от значения <xref:System.Windows.Forms.RichTextBox.ScrollBars%2A> свойство.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Указанное значение не задано в перечислении <see cref="T:System.Windows.Forms.RichTextBoxScrollBars" />.</exception>
        <altmember cref="T:System.Windows.Forms.RichTextBoxScrollBars" />
      </Docs>
    </Member>
    <Member MemberName="SelectedRtf">
      <MemberSignature Language="C#" Value="public string SelectedRtf { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SelectedRtf" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectedRtf" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectedRtf As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ SelectedRtf { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectedRtf : string with get, set" Usage="System.Windows.Forms.RichTextBox.SelectedRtf" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает в элементе управления выделенный в настоящий момент текст в формате RTF.</summary>
        <value>Выделенный в элементе управления текст в формате RTF.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство позволяет получить выделенный текст в элементе управления, включая коды формата RTF. Это свойство можно использовать, чтобы скопировать текст из элемента управления, дополненный форматирование и вставлять текст в другие приложения, принимающие RTF в формате текста, например Microsoft Word и Windows WordPad. Чтобы получить выделенный текст без кодов форматирования RTF, используйте <xref:System.Windows.Forms.TextBoxBase.SelectedText%2A> свойство.  
  
 Если текст не выбран, текст, указанный в этом свойстве вставляется в позицию курсора. Если текст выбран, любой текст, назначенный этому свойству заменяет выделенный текст.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.Rtf" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectedText" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Text" />
      </Docs>
    </Member>
    <Member MemberName="SelectedText">
      <MemberSignature Language="C#" Value="public override string SelectedText { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SelectedText" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectedText" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SelectedText As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SelectedText { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectedText : string with get, set" Usage="System.Windows.Forms.RichTextBox.SelectedText" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue("")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает выделенный в элементе управления <see cref="T:System.Windows.Forms.RichTextBox" /> текст.</summary>
        <value>Строка, предоставляющая выделенный текст в элементе управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> свойство с <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>, <xref:System.Windows.Forms.RichTextBox.SelectedText%2A>, и <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> свойства для создания маркированного списка в <xref:System.Windows.Forms.RichTextBox> элемента управления. В этом примере требуется, <xref:System.Windows.Forms.RichTextBox> управления с именем `richTextBox1` создается в форме.  
  
 [!code-cpp[RichTextBox.SelectionBullet#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionBullet#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionBullet#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionBullet/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.HorizontalAlignment SelectionAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.HorizontalAlignment SelectionAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionAlignment As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::HorizontalAlignment SelectionAlignment { System::Windows::Forms::HorizontalAlignment get(); void set(System::Windows::Forms::HorizontalAlignment value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionAlignment : System.Windows.Forms.HorizontalAlignment with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionAlignment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает выравнивание, которое будет применено к текущему выделению или положению курсора.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Windows.Forms.HorizontalAlignment" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если ни один абзац выбран в элементе управления, установка этого свойства применяется параметр выравнивания абзац, в котором содержится положение курсора также относительно абзацы, созданным после абзаца, имеющий свойство выравнивания. Например, если имеются два абзаца в <xref:System.Windows.Forms.RichTextBox> управления и точка вставки расположена в второго абзаца. Если задать <xref:System.Windows.Forms.RichTextBox.SelectionAlignment%2A> свойства `HorizontalAlignment.Center`, будет выравниваться по центру абзаца в позиции курсора в элементе управления. После второго абзаца, созданный третий абзац, он также выравнивается по центру элемента управления.  
  
 Если в элементе управления делается выбор, если свойство задано, все выделенные абзацы выравниваются в зависимости от значения этого параметра. Это свойство можно использовать для выравнивания абзаца в документе, в <xref:System.Windows.Forms.RichTextBox>. Например, если требуется всех абзацев документа по центру, можно выделить все абзацы в элементе управления и задать <xref:System.Windows.Forms.RichTextBox.SelectionAlignment%2A> свойства `HorizontalAlignment.Center`.  
  
> [!NOTE]
>  <xref:System.Windows.Forms.RichTextBox.SelectionAlignment%2A> Возвращает `SelectionAlignment.Left` Если выделенный текст содержит несколько абзацев со смешанным выравниванием.  
  
   
  
## Examples  
 В следующем примере кода показано, как выравнивание текста внутри <xref:System.Windows.Forms.RichTextBox>. В этом примере требуется, <xref:System.Windows.Forms.RichTextBox> управления с именем `richTextBox1`, будет добавлен в форму.  
  
 [!code-cpp[RichTextBox.SelectionAlignment#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionAlignment/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionAlignment#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionAlignment/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionAlignment#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionAlignment/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Данное значение не является значением, определенным в классе <see cref="T:System.Windows.Forms.HorizontalAlignment" />.</exception>
        <altmember cref="T:System.Windows.Forms.HorizontalAlignment" />
      </Docs>
    </Member>
    <Member MemberName="SelectionBackColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color SelectionBackColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color SelectionBackColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionBackColor" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionBackColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color SelectionBackColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionBackColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionBackColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает цвет текста, когда текст выбран в элементе управления <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <value>
          <see cref="T:System.Drawing.Color" />, представляющий цвет текста, если текст выбран. Значением по умолчанию является значение свойства <see cref="P:System.Windows.Forms.Control.DefaultBackColor" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Windows.Forms.RichTextBox.SelectionBackColor%2A> требуется получить или задать цвет выделенного текста в <xref:System.Windows.Forms.RichTextBox>. Если текст не выбран, <xref:System.Windows.Forms.RichTextBox.SelectionBackColor%2A> свойство применяется к текущей позиции курсора. Символы, введенные в этой позиции имеют заданное <xref:System.Windows.Forms.RichTextBox.SelectionBackColor%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionBullet">
      <MemberSignature Language="C#" Value="public bool SelectionBullet { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SelectionBullet" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionBullet" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionBullet As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SelectionBullet { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionBullet : bool with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionBullet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, определяющее, будет ли применен к текущему выделению или положению курсора стиль маркированного списка.</summary>
        <value>Значение <see langword="true" />, если к текущему выделению или положению курсора был применен стиль маркированного списка; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текст не выделен, стиль маркера применяется к текущей позиции курсора и для всех абзацев, которые пользователь вводит после курсора. Стиль маркера применяется в тексте элемента управления, пока курсор не будет перемещен или при нажатии клавиши ВВОД на пустом объекте маркированного списка.  
  
 Если текст выбран в элементе управления, если это свойство задано, все абзацы в выделенный текст преобразуются в объекты маркированного списка. Это свойство можно использовать для создания маркированные списки в документах, создаваемых в <xref:System.Windows.Forms.RichTextBox> элемента управления.  
  
 <xref:System.Windows.Forms.RichTextBox.BulletIndent%2A> Свойство дает возможность указать величину отступа для применения между маркером и текста маркированного элемента.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.RichTextBox.SelectionBullet%2A> свойство с <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A>, <xref:System.Windows.Forms.RichTextBox.SelectedText%2A>, и <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> свойства для создания маркированного списка в <xref:System.Windows.Forms.RichTextBox> элемента управления. В этом примере требуется, <xref:System.Windows.Forms.RichTextBox> управления с именем `richTextBox1` создается в форме.  
  
 [!code-cpp[RichTextBox.SelectionBullet#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionBullet#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionBullet/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionBullet#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionBullet/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.BulletIndent" />
      </Docs>
    </Member>
    <Member MemberName="SelectionChanged">
      <MemberSignature Language="C#" Value="public event EventHandler SelectionChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SelectionChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.SelectionChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SelectionChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SelectionChanged;" />
      <MemberSignature Language="F#" Value="member this.SelectionChanged : EventHandler " Usage="member this.SelectionChanged : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении выделения текста в элементе управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно создать обработчик событий для этого события определить, когда пользователь изменил выделение текста в элементе управления. Обработчик событий для этого события можно использовать для сохранения текста выделение, пока пользователь завершит задачу в приложении.  
  
 Дополнительные сведения об обработке событий см. в разделе [NIB: Потребление событий](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.RichTextBox.SelectionChanged> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.RichTextBox> с именем `RichTextBox1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.RichTextBox.SelectionChanged> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#544](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#544)]
 [!code-vb[System.Windows.Forms.EventExamples#544](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#544)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionCharOffset">
      <MemberSignature Language="C#" Value="public int SelectionCharOffset { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionCharOffset" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionCharOffset" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionCharOffset As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionCharOffset { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionCharOffset : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionCharOffset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает, будет ли текст в элементе управления отображаться на обычном уровне, или как верхний или нижний индекс.</summary>
        <value>Число, которое определяет величину смещения символов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этого свойства должно быть от -2000 до 2000.  
  
 Если это свойство равно нулю, текст отображается на направляющей. Если это положительное число, число указывает количество точек, на которую возводится выбранный текст над направляющей. Если это отрицательное число, это число указывает количество пикселей, на который индекс выделенного текста. Это свойство можно использовать для задания текста в верхний или нижний индекс.  
  
 Если текст не выделен, отступ применяется к текущей позиции курсора и ко всему тексту, что пользователь вводит после курсора. Смещение символов применяется до изменения свойства с другим значением или пока курсор будет перемещен в другой раздел элемента управления.  
  
 Если текст выбран в элементе управления, выделенный текст и любой текст, введенный после выделенный текст будут иметь значение этого свойства, применяемый к нему. Это свойство можно использовать для создания верхнего и нижнего индексов для приложений, таких как математические выражения.  
  
   
  
## Examples  
 В следующем примере кода показано, как для указания верхнего и нижнего индексов в <xref:System.Windows.Forms.RichTextBox> с помощью <xref:System.Windows.Forms.RichTextBox.SelectionCharOffset%2A> свойство. В этом примере требуется, <xref:System.Windows.Forms.RichTextBox> управления с именем `richTextBox1`, будет добавлен в форму.  
  
 [!code-cpp[RichTextBox.SelectionCharOffset#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionCharOffset/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionCharOffset#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionCharOffset/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionCharOffset#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionCharOffset/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Указанное значение меньше -2000 или больше 2000.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectionColor">
      <MemberSignature Language="C#" Value="public System.Drawing.Color SelectionColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Drawing.Color SelectionColor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionColor" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionColor As Color" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Color SelectionColor { System::Drawing::Color get(); void set(System::Drawing::Color value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionColor : System.Drawing.Color with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionColor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Color</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает цвет текста, который будет применен к текущему выделению или положению курсора.</summary>
        <value>Объект <see cref="T:System.Drawing.Color" />, который предоставляет цвет, который будет применен к текущему выделению текста или к тексту, введенному после места вставки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текущее выделение текста не указано более одного цвета, это свойство возвращает `Color.Empty`. Если текст не выбран, цвет текста, указанный в этом свойстве применяется к текущей позиции курсора и ко всему тексту, введенных в элемент управления после точки вставки. Цвет текста применяется до изменения свойства разные цвета или пока курсор перемещается в другой раздел элемента управления.  
  
 Если текст выбран в элементе управления, выделенный текст и любой текст, введенный после выделенный текст будут иметь значение этого свойства, применяемый к нему. Это свойство можно использовать для изменения цвета текста в <xref:System.Windows.Forms.RichTextBox>.  
  
 Чтобы сделать текст полужирным шрифтом в элементе управления, используйте <xref:System.Windows.Forms.RichTextBox.SelectionFont%2A> свойства, которому назначается новый шрифт, имеющий указанный стиль полужирным шрифтом.  
  
   
  
## Examples  
 В следующем примере кода отображается <xref:System.Windows.Forms.ColorDialog> для пользователей, чтобы указать цвет для выделенного текста или текста, введенного после вставки текущей на момент <xref:System.Windows.Forms.RichTextBox> элемента управления. В этом примере требуется, что метод, определенный в примере добавляется <xref:System.Windows.Forms.Form> класс, содержащий <xref:System.Windows.Forms.RichTextBox> управления с именем `richTextBox1`.  
  
 [!code-cpp[Classic RichTextBox.SelectionColor Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SelectionColor Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SelectionColor Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SelectionColor Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SelectionColor Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SelectionColor Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionFont" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Select(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SelectionFont">
      <MemberSignature Language="C#" Value="public System.Drawing.Font SelectionFont { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Drawing.Font SelectionFont" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionFont" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionFont As Font" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Drawing::Font ^ SelectionFont { System::Drawing::Font ^ get(); void set(System::Drawing::Font ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionFont : System.Drawing.Font with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionFont" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Drawing.Font</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает цвет текущего текстового выделения или места вставки.</summary>
        <value>Объект <see cref="T:System.Drawing.Font" />, который предоставляет шрифт, который будет применен к текущему выделению текста или к тексту, введенному после места вставки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если указано более одного шрифта выделенного текста, это свойство является `null`. Если текст не выбран, шрифт, указанный в этом свойстве применяется к текущей позиции курсора и ко всему тексту, введенных в элемент управления после точки вставки. Шрифт применяется до изменения свойства другой шрифт или пока курсор перемещается в другой раздел элемента управления.  
  
 Если текст выбран в элементе управления, выделенный текст и любой текст, введенный после выделенный текст будут иметь значение этого свойства, применяемый к нему. Это свойство можно использовать, чтобы изменить начертание шрифта для текста в <xref:System.Windows.Forms.RichTextBox>. Можно сделать текст в элементе управления, полужирный, курсив и подчеркнутый. Можно также изменить размер текста, а также шрифт, применяемый к тексту.  
  
 Чтобы изменить цвет текста в элементе управления, используйте <xref:System.Windows.Forms.RichTextBox.SelectionColor%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода изменяется текущего стиля полужирного шрифта выделенного текста или текста, введенного после точки вставки в <xref:System.Windows.Forms.RichTextBox> элемента управления. В этом примере требуется, что код содержится в методе в <xref:System.Windows.Forms.Form>. В этом примере также требуется <xref:System.Windows.Forms.RichTextBox>с именем `richTextBox1`, будет добавлен <xref:System.Windows.Forms.Form>.  
  
 [!code-cpp[Classic RichTextBox.SelectionFont Example#1](~/samples/snippets/cpp/VS_Snippets_Winforms/Classic RichTextBox.SelectionFont Example/CPP/source.cpp#1)]
 [!code-csharp[Classic RichTextBox.SelectionFont Example#1](~/samples/snippets/csharp/VS_Snippets_Winforms/Classic RichTextBox.SelectionFont Example/CS/source.cs#1)]
 [!code-vb[Classic RichTextBox.SelectionFont Example#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/Classic RichTextBox.SelectionFont Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionColor" />
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Select(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SelectionHangingIndent">
      <MemberSignature Language="C#" Value="public int SelectionHangingIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionHangingIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionHangingIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionHangingIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionHangingIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionHangingIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionHangingIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает расстояние между левым краем первой строки текста выделенного абзаца и левым краем последующих строк того же абзаца.</summary>
        <value>Длина выступа, применяемая к текущему текстовому выделению или положению курсора, в пикселях.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текст не выбран, выступ применяется абзац, в котором содержится положение курсора и ко всему тексту, введенных в элемент управления после точки вставки. Выступ применяется до изменения свойства с другим значением или пока курсор не будет перемещено в другой абзац в элементе управления.  
  
 Если текст выбран в элементе управления, выделенный текст и любой текст, введенный после выделенный текст будут иметь значение этого свойства, применяемый к нему. Это свойство позволяет применить выступ для абзацами.  
  
 Чтобы задать отступ первой строки выделенного абзаца, используйте <xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода показано, как указать красной строки в <xref:System.Windows.Forms.RichTextBox> с помощью <xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A> свойство. В этом примере требуется, <xref:System.Windows.Forms.RichTextBox> управления с именем `richTextBox1`, будет добавлен в форму.  
  
 [!code-cpp[RichTextBox.SelectionHangingIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionHangingIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionHangingIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionHangingIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionHangingIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionHangingIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionIndent" />
      </Docs>
    </Member>
    <Member MemberName="SelectionIndent">
      <MemberSignature Language="C#" Value="public int SelectionIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает длину отступа первой строки выделенного в пикселях.</summary>
        <value>Текущая длина отступа, применяемая к левому краю текущего текстового выделения или положению курсора, в пикселях.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текст не выбран, отступ применяется абзац, в котором содержится положение курсора и ко всему тексту, введенных в элемент управления после точки вставки. Отступ применяется до изменения свойства с другим значением или пока курсор не будет перемещено в другой абзац в элементе управления.  
  
 Если текст выбран в элементе управления, выделенный текст и любой текст, введенный после выделенный текст будут иметь значение этого свойства, применяемый к нему. Это свойство можно использовать для отступа абзацев, содержащихся в документе из <xref:System.Windows.Forms.RichTextBox>. Это свойство можно использовать в сочетании с <xref:System.Windows.Forms.RichTextBox.SelectionRightIndent%2A> для создания абзацев, отображающихся в абзацах.  
  
 Чтобы создать выступ для абзацев в элементе управления, используйте <xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода показано, как для указания текста с отступом в <xref:System.Windows.Forms.RichTextBox> с помощью <xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A> свойство. В этом примере требуется, <xref:System.Windows.Forms.RichTextBox> управления с именем `richTextBox1`, будет добавлен в форму.  
  
 [!code-cpp[RichTextBox.SelectionIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionRightIndent" />
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectionHangingIndent" />
      </Docs>
    </Member>
    <Member MemberName="SelectionLength">
      <MemberSignature Language="C#" Value="public override int SelectionLength { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property SelectionLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int SelectionLength { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionLength : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает число символов, выделенных в элементе управления.</summary>
        <value>Число символов, выделенных в текстовом поле.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство можно использовать для определения, если все символы выбранных в данный момент в элементе текстового поля перед выполнением операций над выделенным текстом. Также можно использовать это свойство, чтобы определить общее число символов (включая пробелы), которые выбираются при выполнении одного символа задач в `for` цикла.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.Windows.Forms.RichTextBox.SelectionLength%2A> свойства, чтобы определить, если текст будет выделен в <xref:System.Windows.Forms.RichTextBox>. В этом примере требуется, <xref:System.Windows.Forms.RichTextBox> управления с именем `richTextBox1`, будет добавлен в форму. В этом примере также требуется `richTextBox1` содержит текст, который выбран в элементе управления.  
  
 [!code-cpp[RichTextBox.SelectionLength#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionLength/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionLength#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionLength/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionLength#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionLength/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectionStart" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.SelectedText" />
      </Docs>
    </Member>
    <Member MemberName="SelectionProtected">
      <MemberSignature Language="C#" Value="public bool SelectionProtected { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SelectionProtected" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionProtected" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionProtected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SelectionProtected { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionProtected : bool with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionProtected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, определяющее, защищено ли текущее текстовое выделение.</summary>
        <value>Значение <see langword="true" />, если в текущее выделение нельзя внести изменение; в противном случае — <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текст не выбран, параметр защиты применяется абзац, в котором содержится положение курсора и ко всему тексту, введенных в элемент управления после точки вставки. Параметр защиты применяется до изменения свойства с другим значением или пока курсор не будет перемещено в другой абзац в элементе управления.  
  
 Если текст выбран в элементе управления, выделенный текст и любой текст, введенный после выделенный текст будут иметь значение этого свойства, применяемый к нему. Это свойство можно использовать для предотвращения изменения разделов текста в элементе управления пользователя.  
  
 Если это свойство имеет значение `true`, <xref:System.Windows.Forms.RichTextBox.Protected> событие возникает, когда пользователь пытается изменить выделенного текста.  
  
> [!NOTE]
>  Это свойство будет возвращать `true` только в том случае, если все выделение элемента управления содержит защищенные элементы.  
  
   
  
## Examples  
 В следующем примере кода показано, как указать защиты текста в <xref:System.Windows.Forms.RichTextBox> с помощью <xref:System.Windows.Forms.RichTextBox.SelectionProtected%2A> свойство. В этом примере требуется, <xref:System.Windows.Forms.RichTextBox> управления с именем `richTextBox1`, будет добавлен к форме, а <xref:System.Windows.Forms.RichTextBox> управления был добавлен текст, содержащий слово «RichTextBox».  
  
 [!code-cpp[RichTextBox.SelectionProtected#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionProtected/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionProtected#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionProtected/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionProtected#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionProtected/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Forms.RichTextBox.Protected" />
      </Docs>
    </Member>
    <Member MemberName="SelectionRightIndent">
      <MemberSignature Language="C#" Value="public int SelectionRightIndent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SelectionRightIndent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionRightIndent" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionRightIndent As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SelectionRightIndent { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionRightIndent : int with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionRightIndent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(0)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Расстояние в пикселях между правым краем элемента управления <see cref="T:System.Windows.Forms.RichTextBox" /> и правым краем текущего текстового выделения или текста, добавленного после места вставки.</summary>
        <value>Длина отступа с правого края текущего выделения или места вставки, в пикселях.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если текст не выбран, отступ применяется абзац, в котором содержится положение курсора и ко всему тексту, введенных в элемент управления после точки вставки. Отступ применяется до изменения свойства с другим значением или пока курсор не будет перемещено в другой абзац в элементе управления.  
  
 Если текст выбран в элементе управления, выделенный текст и любой текст, введенный после выделенный текст будут иметь значение этого свойства, применяемый к нему. Это свойство можно использовать для отступа абзацев, содержащихся в документе из <xref:System.Windows.Forms.RichTextBox>. Это свойство можно использовать в сочетании с <xref:System.Windows.Forms.RichTextBox.SelectionIndent%2A> для создания абзацев, отображающихся в абзацах.  
  
 Чтобы создать выступ для абзацев в элементе управления, используйте <xref:System.Windows.Forms.RichTextBox.SelectionHangingIndent%2A> свойство.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется создание правого поля в <xref:System.Windows.Forms.RichTextBox> с помощью <xref:System.Windows.Forms.RichTextBox.SelectionRightIndent%2A> свойство. В примере требуется наличие формы, содержащей <xref:System.Windows.Forms.RichTextBox> управления с именем `richTextBox1`, и, в примере кода вызывается из события в класс формы.  
  
 [!code-cpp[RichTextBox.SelectionRightIndent#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.SelectionRightIndent/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.SelectionRightIndent#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.SelectionRightIndent/CS/form1.cs#1)]
 [!code-vb[RichTextBox.SelectionRightIndent#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.SelectionRightIndent/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectionTabs">
      <MemberSignature Language="C#" Value="public int[] SelectionTabs { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32[] SelectionTabs" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionTabs" />
      <MemberSignature Language="VB.NET" Value="Public Property SelectionTabs As Integer()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;int&gt; ^ SelectionTabs { cli::array &lt;int&gt; ^ get(); void set(cli::array &lt;int&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SelectionTabs : int[] with get, set" Usage="System.Windows.Forms.RichTextBox.SelectionTabs" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает абсолютные положения точек перехода по клавише табуляции в элементе управления <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <value>Массив, каждый элемент которого задает смещение по клавише табуляции, в пикселях.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство позволяет получить массив, содержащий размер отступа для каждой вкладки в текущем выделении текста в <xref:System.Windows.Forms.RichTextBox> элемента управления. Затем можно использовать это свойство для настройки размера каждой из вкладок в выделенный текст. Например, если вы хотите настроить табуляции в документе, можно выделить весь документ и получить список с помощью шага табуляции <xref:System.Windows.Forms.RichTextBox.SelectionTabs%2A> свойство. Затем можно изменить их новых значений и перевести их на это свойство.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Массив содержит более максимально возможного количества, равного 32 элементам.</exception>
      </Docs>
    </Member>
    <Member MemberName="SelectionType">
      <MemberSignature Language="C#" Value="public System.Windows.Forms.RichTextBoxSelectionTypes SelectionType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Forms.RichTextBoxSelectionTypes SelectionType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.SelectionType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SelectionType As RichTextBoxSelectionTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Forms::RichTextBoxSelectionTypes SelectionType { System::Windows::Forms::RichTextBoxSelectionTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.SelectionType : System.Windows.Forms.RichTextBoxSelectionTypes" Usage="System.Windows.Forms.RichTextBox.SelectionType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Forms.RichTextBoxSelectionTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает тип выделения в элементе управления.</summary>
        <value>Поразрядное сочетание значений <see cref="T:System.Windows.Forms.RichTextBoxSelectionTypes" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство можно использовать для определения типа данных, которые в данный момент выбраны в элементе управления Чтобы выделение должным образом при выполнении задач в элементе управления для текущего выбора. Свойство может представлять любое сочетание значений из <xref:System.Windows.Forms.RichTextBoxSelectionTypes> перечисление, представляющее многих типов объектов в текущем выделенном фрагменте.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.RichTextBox.SelectedRtf" />
      </Docs>
    </Member>
    <Member MemberName="ShowSelectionMargin">
      <MemberSignature Language="C#" Value="public bool ShowSelectionMargin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowSelectionMargin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ShowSelectionMargin" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowSelectionMargin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowSelectionMargin { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ShowSelectionMargin : bool with get, set" Usage="System.Windows.Forms.RichTextBox.ShowSelectionMargin" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, отображается ли поле выделения в элементе управления <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <value>Значение <see langword="true" />, если поле выделения в элементе управления включено; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство можно использовать, чтобы пользователь мог легко выделение текста в <xref:System.Windows.Forms.RichTextBox>. В левой части добавляется поле выделения <xref:System.Windows.Forms.RichTextBox>. Это поле помогает пользователю выбрать текст, начиная с левой стороны элемента управления. Пользователю можно щелкнуть поле выделения, чтобы выбрать одну строку текста или дважды щелкните, чтобы выделить весь абзац, содержащийся в эту строку.  
  
> [!NOTE]
>  Если <xref:System.Windows.Forms.RichTextBox.ShowSelectionMargin%2A> свойству `true`, параметр <xref:System.Windows.Forms.RichTextBox.ScrollBars%2A> свойства `RichTextBoxScrollBars.Horizontal`, `RichTextBoxScrollBars.Vertical`, или `RichTextBoxScrollBars.Both` не приведет к отображению полос прокрутки. Для отображения полос прокрутки при <xref:System.Windows.Forms.RichTextBox.ShowSelectionMargin%2A> свойству `true`, задайте <xref:System.Windows.Forms.RichTextBox.ScrollBars%2A> свойства `RichTextBoxScrollBars.ForcedHorizontal`, `RichTextBoxScrollBars.ForcedVertical`, или `RichTextBoxScrollBars.ForcedBoth`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Text">
      <MemberSignature Language="C#" Value="public override string Text { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Text" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.Text" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Property Text As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Text { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Text : string with get, set" Usage="System.Windows.Forms.RichTextBox.Text" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.RefreshProperties</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает текущий текст в поле форматированного текста.</summary>
        <value>Текст, который отображается в элементе управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы просмотреть несколько строк текста в <xref:System.Windows.Forms.RichTextBox>, задайте <xref:System.Windows.Forms.TextBoxBase.Multiline%2A> свойства `true`. Для чтения или текст элемента многострочное текстовое поле, используйте <xref:System.Windows.Forms.TextBoxBase.Lines%2A> свойство. <xref:System.Windows.Forms.RichTextBox.Text%2A> Свойство не возвращает никаких сведений о форматирование, применяемое к содержимому <xref:System.Windows.Forms.RichTextBox>. Чтобы получить форматированный текст (RTF) кодов, используйте <xref:System.Windows.Forms.RichTextBox.Rtf%2A> свойство. Объем текста, введенного в <xref:System.Windows.Forms.RichTextBox> управления ограничивается только объемом доступной системной памяти.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Lines" />
        <altmember cref="P:System.Windows.Forms.TextBoxBase.Multiline" />
      </Docs>
    </Member>
    <Member MemberName="TextLength">
      <MemberSignature Language="C#" Value="public override int TextLength { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 TextLength" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.TextLength" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property TextLength As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int TextLength { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TextLength : int" Usage="System.Windows.Forms.RichTextBox.TextLength" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает длину текста в элементе управления.</summary>
        <value>Количество символов, содержащихся в тексте элемента управления.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Forms.TextBoxBase.TextLength" />
      </Docs>
    </Member>
    <Member MemberName="UndoActionName">
      <MemberSignature Language="C#" Value="public string UndoActionName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UndoActionName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.UndoActionName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property UndoActionName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ UndoActionName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UndoActionName : string" Usage="System.Windows.Forms.RichTextBox.UndoActionName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает имя действия, результаты которого в элементе управления можно отменить при вызове метода <see cref="M:System.Windows.Forms.TextBoxBase.Undo" />.</summary>
        <value>Текстовое имя действия, которое можно отменить.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство позволяет определить последнее действие, которое было выполнено в элементе управления, которое может быть отменено. Это свойство можно использовать для ограничения операций может отменить пользователем элемента управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Forms.TextBoxBase.Undo" />
      </Docs>
    </Member>
    <Member MemberName="VScroll">
      <MemberSignature Language="C#" Value="public event EventHandler VScroll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler VScroll" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Forms.RichTextBox.VScroll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event VScroll As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ VScroll;" />
      <MemberSignature Language="F#" Value="member this.VScroll : EventHandler " Usage="member this.VScroll : System.EventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при щелчке пользователем вертикальных полос прокрутки элемента управления.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об обработке событий см. в разделе [NIB: Потребление событий](http://msdn.microsoft.com/library/01e4f1bc-e55e-413f-98c7-6588493e5f67).  
  
   
  
## Examples  
 В следующем примере кода показано применение этого элемента. В примере обработчик событий сообщает при наступлении <xref:System.Windows.Forms.RichTextBox.VScroll> событий. Этот отчет позволяет выяснить, когда произошло событие и может оказаться полезным при отладке. Отчет по несколько событий или события, которые происходят часто, рассмотрите возможность замены <xref:System.Windows.Forms.MessageBox.Show%2A?displayProperty=nameWithType> с <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> или добавление сообщения в многострочном <xref:System.Windows.Forms.TextBox>.  
  
 Чтобы запустить пример кода, вставьте его в проект, который содержит экземпляр типа <xref:System.Windows.Forms.RichTextBox> с именем `RichTextBox1`. Убедитесь, что обработчик событий связан с <xref:System.Windows.Forms.RichTextBox.VScroll> событий.  
  
 [!code-csharp[System.Windows.Forms.EventExamples#545](~/samples/snippets/csharp/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/CS/EventExamples.cs#545)]
 [!code-vb[System.Windows.Forms.EventExamples#545](~/samples/snippets/visualbasic/VS_Snippets_Winforms/System.Windows.Forms.EventExamples/VB/EventExamples.vb#545)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WndProc">
      <MemberSignature Language="C#" Value="protected override void WndProc (ref System.Windows.Forms.Message m);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void WndProc(valuetype System.Windows.Forms.Message&amp; m) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Forms.RichTextBox.WndProc(System.Windows.Forms.Message@)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub WndProc (ByRef m As Message)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void WndProc(System::Windows::Forms::Message % m);" />
      <MemberSignature Language="F#" Value="override this.WndProc :  -&gt; unit" Usage="richTextBox.WndProc m" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="m" Type="System.Windows.Forms.Message&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="m">Объект сообщения Windows.</param>
        <summary>Обрабатывает сообщения Windows.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ZoomFactor">
      <MemberSignature Language="C#" Value="public float ZoomFactor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float32 ZoomFactor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Forms.RichTextBox.ZoomFactor" />
      <MemberSignature Language="VB.NET" Value="Public Property ZoomFactor As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property float ZoomFactor { float get(); void set(float value); };" />
      <MemberSignature Language="F#" Value="member this.ZoomFactor : single with get, set" Usage="System.Windows.Forms.RichTextBox.ZoomFactor" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Windows.Forms</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(1)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Localizable(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает текущий уровень увеличения элемента управления <see cref="T:System.Windows.Forms.RichTextBox" />.</summary>
        <value>Коэффициент увеличения содержимого элемента управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этого свойства может составлять от 1/64 (0.015625) до 64,0, не включительно. Значение 1,0 указывает, что без увеличения применяется к элементу управления. Функция масштабирования работает наилучшим образом, если документ содержит шрифты TrueType. Если в документе элемент управления используется шрифт, который не является шрифтом TrueType <xref:System.Windows.Forms.RichTextBox.ZoomFactor%2A> свойство будет использоваться ближайшего целого значения. Это свойство можно использовать, чтобы пользователь из <xref:System.Windows.Forms.RichTextBox> управления для увеличения изображения на разделы документации, которые слишком малы, чтобы просмотреть или уменьшать включить больше текста для отображения на экране.  
  
   
  
## Examples  
 В следующем примере кода показано, как создать <xref:System.Windows.Forms.RichTextBox> , увеличивает масштаб текста, автоматически выделять слова в тексте элемента управления, при двойном щелчке слова, а также имеет поле в правой части клиентской области элемента управления. Если <xref:System.Windows.Forms.RichTextBox> управления имеет небольшой ширину, с помощью следующего кода будет создан <xref:System.Windows.Forms.RichTextBox> где каждый символ текст отображается на отдельной строке. В этой позиции вертикальное отображение щелчка по любой части слова будут выделены все символы слова, несмотря на то, что текст отображается вертикально. В этом примере требуется наличие формы, содержащей <xref:System.Windows.Forms.RichTextBox> управления с именем `richTextBox1`.  
  
 [!code-cpp[RichTextBox.ZoomFactor#1](~/samples/snippets/cpp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CPP/form1.cpp#1)]
 [!code-csharp[RichTextBox.ZoomFactor#1](~/samples/snippets/csharp/VS_Snippets_Winforms/RichTextBox.ZoomFactor/CS/form1.cs#1)]
 [!code-vb[RichTextBox.ZoomFactor#1](~/samples/snippets/visualbasic/VS_Snippets_Winforms/RichTextBox.ZoomFactor/VB/form1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Заданный коэффициент увеличения находится за пределами допустимого интервала.</exception>
      </Docs>
    </Member>
  </Members>
</Type>