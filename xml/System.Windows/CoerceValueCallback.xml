<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="CoerceValueCallback.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5edddfb39d197bb5c7d9ebb6e4c366a99eae21935.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">edddfb39d197bb5c7d9ebb6e4c366a99eae21935</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.CoerceValueCallback">
          <source>The object that the property exists on.</source>
          
        </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Windows.CoerceValueCallback">
          <source>When the callback is invoked, the property system will pass this value.</source>
          
        </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" uid="T:System.Windows.CoerceValueCallback">
          <source>The new value of the property, prior to any coercion attempt.</source>
          
        </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" uid="T:System.Windows.CoerceValueCallback">
          <source>Provides a template for a method that is called whenever a dependency property value is being re-evaluated, or coercion is specifically requested.</source>
          
        </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" uid="T:System.Windows.CoerceValueCallback">
          <source>The coerced value (with appropriate type).</source>
          
        </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Callbacks based on <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> can be assigned to a dependency property through several different techniques.</source>
          <target state="translated">На основе обратных вызовов <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> можно назначить свойству зависимостей через несколькими способами.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Each of these techniques requires that you first create a new property metadata object (<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>, or a derived class such as <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>).</source>
          <target state="translated">Каждый из этих способов необходимо сначала создать объект метаданных свойств (<ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph>, или производного класса, такие как <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Create the metadata object using a constructor signature that takes the <ph id="ph1">`coerceValueCallback`</ph> parameter, and assign that parameter to your callback handler.</source>
          <target state="translated">Создать объект метаданных, с помощью подписи конструктор, принимающий <ph id="ph1">`coerceValueCallback`</ph> параметра и присвоить этому параметру обработчика ответа.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Or construct the metadata by any signature and set the <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> property prior to putting the metadata in use.</source>
          <target state="translated">Или создать метаданные любого подписями и набор <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> свойство до помещения метаданных используется.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>When you have this metadata, you can:</source>
          <target state="translated">Если у вас есть эти метаданные, можно:</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Define a new dependency property on a new class, using either signature of  <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, giving the metadata as the <ph id="ph2">`typeMetadata`</ph> value.</source>
          <target state="translated">Определить новые свойства зависимостей для нового класса с помощью либо подпись <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph>, предоставляя метаданные как <ph id="ph2">`typeMetadata`</ph> значение.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Override the metadata (call <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>) for an existing dependency property, when you derive from the class that owns the dependency property.</source>
          <target state="translated">Переопределить метаданные (вызов <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>) для существующего свойства зависимости, при наследовании от класса, которому принадлежит свойство зависимостей.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Add an existing dependency property to a new <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> class, using new metadata, by calling <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>.</source>
          <target state="translated">Добавление существующего свойства зависимостей в новую <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> класс с помощью новых метаданных путем вызова <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Implementations of this callback should check the value in <ph id="ph1">`baseValue`</ph> and determine based on either the value or the type whether this is a value that needs to be further coerced.</source>
          <target state="translated">Реализации данного ответа следует проверить значение <ph id="ph1">`baseValue`</ph> и определить на основе значения или тип ли это значение, которое необходимо дополнительно привести.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>The <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> for a dependency property is invoked any time that the property system or any other caller calls <ph id="ph2">&lt;xref:System.Windows.DependencyObject.CoerceValue%2A&gt;</ph> on a <ph id="ph3">&lt;xref:System.Windows.DependencyObject&gt;</ph> instance, specifying that property's identifier as the <ph id="ph4">`dp`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> Зависимость свойство вызывается каждый раз, когда в системе свойств или любой вызывающий объект вызывает <ph id="ph2">&lt;xref:System.Windows.DependencyObject.CoerceValue%2A&gt;</ph> на <ph id="ph3">&lt;xref:System.Windows.DependencyObject&gt;</ph> экземпляра с указанием идентификатора этого свойства как <ph id="ph4">`dp`</ph>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Changes to the property value may have come from any possible participant in the property system.</source>
          <target state="translated">Изменения значения свойства может поступать любого из членов в системе свойств.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>This includes styles, generic invalidation, triggers, property value inheritance, and local value setting.</source>
          <target state="translated">Это включает стили, изначальную, триггеры, наследование значения свойства и локальное значение параметра.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Generally you should avoid specifying more than one <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> for any given dependency property (overriding or adding with new metadata for a dependency property that already had a <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph>).</source>
          <target state="translated">Обычно следует избегать, указание более одного <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph> для любого заданного свойства зависимостей (переопределения или добавления с новыми метаданными для свойства зависимостей, уже <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Only one of the callbacks will be able to act. The acting callback will be the one that was applied to the most derived class in the inheritance as compared to the <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> caller.</source>
          <target state="translated">Только одна из обратных вызовов будет действовать. Действующим ответом будет тем, которое было применено к наиболее производного класса в наследовании по сравнению с <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> вызывающего объекта.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>Other callbacks as assigned to metadata for the dependency property as it existed higher in the owner hierarchy are replaced when the metadata is overridden.</source>
          <target state="translated">При переопределении метаданных, заменяются других обратных вызовах, связанные с метаданными для свойства зависимостей, существовавшего выше в иерархии владельцев.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>The following example includes an implementation of this callback to coerce the stored value of a dependency property based on other inputs, such as another property's value.</source>
          <target state="translated">Следующий пример содержит реализацию данного ответа для запрета хранимого значения свойства зависимостей, в зависимости от других входных данных, таких как значение другого свойства.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.CoerceValueCallback">
          <source>In this case, the callback checks to see whether the <ph id="ph1">`ShirtType`</ph> property corresponds to a type of shirt that has buttons; if so it establishes a starting default color for the <ph id="ph2">`ButtonColor`</ph>, if the shirt type has no buttons, it coerces the <ph id="ph3">`ButtonColor`</ph> value back to a starting value, which causes the <ph id="ph4">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph> (not shown) to remove that dropdown from the effective choices.</source>
          <target state="translated">В этом случае проверяет обратный вызов ли <ph id="ph1">`ShirtType`</ph> свойства соответствует типу элемента, содержащего кнопки; в этом случае он устанавливает начальный цвет по умолчанию для <ph id="ph2">`ButtonColor`</ph>, если тип рубашка нет кнопок, приводит <ph id="ph3">`ButtonColor`</ph> значение обратно в начальное значение, которое вызывает <ph id="ph4">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph> (не показано) для удаления из эффективных выборов выпадающего меню.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>