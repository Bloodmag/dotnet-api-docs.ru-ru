<Type Name="ContentElement" FullName="System.Windows.ContentElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3cec39524c57162a57591073e35fafea313c0d5d" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ContentElement : System.Windows.DependencyObject, System.Windows.IInputElement, System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi ContentElement extends System.Windows.DependencyObject implements class System.Windows.IInputElement, class System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.ContentElement" />
  <TypeSignature Language="VB.NET" Value="Public Class ContentElement&#xA;Inherits DependencyObject&#xA;Implements IAnimatable, IInputElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class ContentElement : System::Windows::DependencyObject, System::Windows::IInputElement, System::Windows::Media::Animation::IAnimatable" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.IInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Media.Animation.IAnimatable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>
      <span data-ttu-id="332d7-101">Предоставляет базовый класс уровня ядра WPF для элементов содержимого.</span>
      <span class="sxs-lookup">
        <span data-stu-id="332d7-101">Provides a WPF core-level base class for content elements.</span>
      </span>
      <span data-ttu-id="332d7-102">Элементы содержимого разработаны для представления в стиле потока с использованием интуитивно понятной модели макета разметки и намеренно простой объектной модели.</span>
      <span class="sxs-lookup">
        <span data-stu-id="332d7-102">Content elements are designed for flow-style presentation, using an intuitive markup-oriented layout model and a deliberately simple object model.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-103"><xref:System.Windows.ContentElement> определяет следующие общие характеристики содержимого:</span><span class="sxs-lookup"><span data-stu-id="332d7-103"><xref:System.Windows.ContentElement> defines the following common content characteristics:</span></span>  
  
-   <span data-ttu-id="332d7-104">Входные данные: Все <xref:System.Windows.ContentElement> производные классы обеспечивают поддержку базовый ввод с клавиатуры, мыши, операции перетаскивания и вставки, сенсорного экрана и сочетания клавиш.</span><span class="sxs-lookup"><span data-stu-id="332d7-104">Input: All <xref:System.Windows.ContentElement> derived classes provide support for basic input capture from keyboard, mouse, drag-and-drop operations, stylus controls, and accelerators.</span></span>  
  
-   <span data-ttu-id="332d7-105">Фокус: Все <xref:System.Windows.ContentElement> производные классы потенциально может получить фокус.</span><span class="sxs-lookup"><span data-stu-id="332d7-105">Focus: All <xref:System.Windows.ContentElement> derived classes are potentially focusable.</span></span> <span data-ttu-id="332d7-106">(Тем не менее, может иметь фокус состояние по умолчанию для <xref:System.Windows.ContentElement> базовым классом является `false`.</span><span class="sxs-lookup"><span data-stu-id="332d7-106">(However, the default focusable state for the <xref:System.Windows.ContentElement> base class is `false`.</span></span> <span data-ttu-id="332d7-107">Дополнительные сведения о том, как сделать <xref:System.Windows.ContentElement> может иметь фокус, см. в разделе <xref:System.Windows.ContentElement.Focusable%2A>.) Кроме того, этот класс содержит [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] , можно использовать для перемещения фокуса между связанных элементов.</span><span class="sxs-lookup"><span data-stu-id="332d7-107">For details on how to make a <xref:System.Windows.ContentElement> focusable, see <xref:System.Windows.ContentElement.Focusable%2A>.) In addition, this class contains [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] that you can use for traversing the focus across related elements.</span></span>  
  
-   <span data-ttu-id="332d7-108">События: <xref:System.Windows.ContentElement> включает в себя события, связанные с входными и фокус; также включает события для изменений в состоянии.</span><span class="sxs-lookup"><span data-stu-id="332d7-108">Events: <xref:System.Windows.ContentElement> includes events that are related to input and focus; it also includes events for changes in state.</span></span> <span data-ttu-id="332d7-109">Во многих случаях <xref:System.Windows.ContentElement> события, перенаправленные события.</span><span class="sxs-lookup"><span data-stu-id="332d7-109">In many cases, the <xref:System.Windows.ContentElement> events are routed events.</span></span> <span data-ttu-id="332d7-110">В некоторых случаях перенаправленные события имеют нисходящей и восходящей маршрутизации стратегии возникновения как отдельные события в ответ на том же состоянии или условие.</span><span class="sxs-lookup"><span data-stu-id="332d7-110">In some cases, routed events have both tunneling and bubbling routing strategies, raised as separate events in response to the same state or condition.</span></span> <span data-ttu-id="332d7-111">Кроме того <xref:System.Windows.ContentElement> определяет [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] , можно вызвать направлено события, которые можно добавлять и удалять обработчики событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-111">Also, <xref:System.Windows.ContentElement> defines [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] that can raise routed events and that can add or remove handlers to events.</span></span>  
  
 <span data-ttu-id="332d7-112"><xref:System.Windows.ContentElement> использует многие распространенные [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] с <xref:System.Windows.UIElement>.</span><span class="sxs-lookup"><span data-stu-id="332d7-112"><xref:System.Windows.ContentElement> shares many common [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] with <xref:System.Windows.UIElement>.</span></span> <span data-ttu-id="332d7-113">Эти Общие [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] поставляются наследования из общего класса.</span><span class="sxs-lookup"><span data-stu-id="332d7-113">These common [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] do not come from a shared class inheritance.</span></span> <span data-ttu-id="332d7-114">Но они совместно используют общие названия, аналогичное поведение и внутреннее применение [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] в каждом классе.</span><span class="sxs-lookup"><span data-stu-id="332d7-114">But they do share common naming, similar behavior, and similar internal implementation of [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] in each class.</span></span> <span data-ttu-id="332d7-115">Сходство вызвано <xref:System.Windows.ContentElement> и <xref:System.Windows.UIElement> являются каждого классы, которые являются основе элемента, несмотря на то, что использует другой подход к модели поведения объекта разметки.</span><span class="sxs-lookup"><span data-stu-id="332d7-115">The similarity is because <xref:System.Windows.ContentElement> and <xref:System.Windows.UIElement> are each classes that are an element base, although each has different intentions for its markup object model behavior.</span></span>  
  
 <span data-ttu-id="332d7-116">В частности <xref:System.Windows.UIElement> потомком <xref:System.Windows.Media.Visual>, предоставляющее графики более низкого уровня поддержки для подготовки к просмотру <xref:System.Windows.ContentElement> в прямоугольной области, в пределах составных периода, в то время как <xref:System.Windows.ContentElement> откладывает отрисовки, чтобы дополнительные основные понятия Общие для документа сценариев, таких как поток перенос, более легко поддерживаются.</span><span class="sxs-lookup"><span data-stu-id="332d7-116">In particular, <xref:System.Windows.UIElement> descends from <xref:System.Windows.Media.Visual>, which provides the lower-level graphics support for rendering a <xref:System.Windows.ContentElement> to a rectangular region within a composited window, whereas <xref:System.Windows.ContentElement> defers rendering so that concepts more common to document scenarios, such as flow and wrapping, are more easily supported.</span></span> <span data-ttu-id="332d7-117">Эти два связанные классы также реализовывать общих интерфейсов <xref:System.Windows.IInputElement> и <xref:System.Windows.Media.Animation.IAnimatable>.</span><span class="sxs-lookup"><span data-stu-id="332d7-117">These two related classes also implement the common interfaces <xref:System.Windows.IInputElement> and <xref:System.Windows.Media.Animation.IAnimatable>.</span></span>  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>
        <span data-ttu-id="332d7-118">
          <see cref="T:System.Windows.ContentElement" /> Класс еще не определяет все аспекты полный элемент содержимого для представления в стиле потока.</span>
        <span class="sxs-lookup">
          <span data-stu-id="332d7-118">The <see cref="T:System.Windows.ContentElement" /> class does not yet define all aspects of a complete content element for flow-style presentation.</span>
        </span>
        <span data-ttu-id="332d7-119">
          <see cref="T:System.Windows.FrameworkContentElement" /> является непосредственно производным классом <see cref="T:System.Windows.ContentElement" />.</span>
        <span class="sxs-lookup">
          <span data-stu-id="332d7-119">
            <see cref="T:System.Windows.FrameworkContentElement" /> is an immediately derived class of <see cref="T:System.Windows.ContentElement" />.</span>
        </span>
        <span data-ttu-id="332d7-120">
          <see cref="T:System.Windows.FrameworkContentElement" /> включает более полный набор дополнительных членов, которые поддерживают отрисовку <see cref="T:System.Windows.FrameworkContentElement" /> внутри узла содержимого и с помощью системы макета уровня платформы WPF.</span>
        <span class="sxs-lookup">
          <span data-stu-id="332d7-120">
            <see cref="T:System.Windows.FrameworkContentElement" /> includes a more complete set of additional members that support rendering a <see cref="T:System.Windows.FrameworkContentElement" /> within a content host and using the WPF framework-level layout system.</span>
        </span>
      </para>
    </block>
    <altmember cref="T:System.Windows.UIElement" />
    <altmember cref="T:System.Windows.FrameworkContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ContentElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ContentElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="332d7-121">Инициализирует новый экземпляр класса <see cref="T:System.Windows.ContentElement" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-121">Initializes a new instance of the <see cref="T:System.Windows.ContentElement" /> class.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddHandler">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-122">Добавляет обработчик перенаправленного события для указанного маршрутизируемого события, помещая этот обработчик в коллекцию обработчиков текущего элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-122">Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">
          <span data-ttu-id="332d7-123">Идентификатор для обрабатываемого маршрутизируемого события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-123">An identifier for the routed event to be handled.</span>
          </span>
        </param>
        <param name="handler">
          <span data-ttu-id="332d7-124">Ссылка на реализацию обработчика.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-124">A reference to the handler implementation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-125">Добавляет обработчик перенаправленного события для указанного маршрутизируемого события, помещая этот обработчик в коллекцию обработчиков текущего элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-125">Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-126">Можно добавить один и тот же обработчик для того же события несколько раз, не вызывая исключение.</span><span class="sxs-lookup"><span data-stu-id="332d7-126">You can add the same handler for the same event multiple times without raising an exception.</span></span> <span data-ttu-id="332d7-127">Тем не менее обработчик вызывается несколько раз, когда событие обрабатывается.</span><span class="sxs-lookup"><span data-stu-id="332d7-127">However, the handler is actually invoked multiple times when the event is handled.</span></span> <span data-ttu-id="332d7-128">Таким образом рассмотрим, как это поведение может иметь побочные эффекты, которые должны быть учтены в вашу реализацию обработчика.</span><span class="sxs-lookup"><span data-stu-id="332d7-128">Therefore, consider how this behavior might have side effects that should be accounted for in your handler implementation.</span></span>  
  
 <span data-ttu-id="332d7-129">Этот метод обычно используется для реализации метода доступа «добавить» для [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] шаблона доступа события пользовательского маршрутизируемого события.</span><span class="sxs-lookup"><span data-stu-id="332d7-129">You typically use this method to provide the implementation of the "add" accessor for the [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] event access pattern of a custom routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddHandler">
      <MemberSignature Language="C#" Value="public void AddHandler (System.Windows.RoutedEvent routedEvent, Delegate handler, bool handledEventsToo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler, bool handledEventsToo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler, bool handledEventsToo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
        <Parameter Name="handledEventsToo" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="routedEvent">
          <span data-ttu-id="332d7-130">Идентификатор для обрабатываемого перенаправленного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-130">An identifier for the.routed event to be handled.</span>
          </span>
        </param>
        <param name="handler">
          <span data-ttu-id="332d7-131">Ссылка на реализацию обработчика.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-131">A reference to the handler implementation.</span>
          </span>
        </param>
        <param name="handledEventsToo">
          <span data-ttu-id="332d7-132">
            <see langword="true" /> для регистрации обработчика, чтобы он вызывался даже в том случае, если перенаправленное событие помечено как обработанное в его данных события. <see langword="false" /> для регистрации обработчика с условием по умолчанию, что он не будет вызываться, если перенаправленное событие уже помечено как обработанное.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-132">
              <see langword="true" /> to register the handler such that it is invoked even when the routed event is marked handled in its event data; <see langword="false" /> to register the handler with the default condition that it will not be invoked if the routed event is already marked handled.</span>
          </span>
          <span data-ttu-id="332d7-133">Значение по умолчанию: <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-133">The default is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="332d7-134">Не следует постоянно прибегать к повторной обработке перенаправленного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-134">Do not routinely ask to rehandle a routed event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-135">Добавляет обработчик перенаправленного события для указанного маршрутизируемого события, помещая этот обработчик в коллекцию обработчиков текущего элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-135">Adds a routed event handler for a specified routed event, adding the handler to the handler collection on the current element.</span>
          </span>
          <span data-ttu-id="332d7-136">Укажите <paramref name="handledEventsToo" /> как <see langword="true" />, чтобы предоставленный обработчик вызывался для перенаправленного события, которое уже было отмечено как обработанное другим элементом на маршруте события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-136">Specify <paramref name="handledEventsToo" /> as <see langword="true" /> to have the provided handler be invoked for routed event that had already been marked as handled by another element along the event route.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-137">Обработка событий низкоуровневого ввода практическая является сложной задачей.</span><span class="sxs-lookup"><span data-stu-id="332d7-137">Processing low-level input events in a practical way is a complex task.</span></span> <span data-ttu-id="332d7-138">Многие элементы управления реализуют поведение, определенное событие помечено как обработанное куда заменяется более интуитивным событием.</span><span class="sxs-lookup"><span data-stu-id="332d7-138">Many controls implement behavior where a certain event is marked as handled, and is replaced by another more intuitive event.</span></span> <span data-ttu-id="332d7-139">Как правило элемент управления только отметит событие ввода платформы как обработанное при наличии намеренной таким образом.</span><span class="sxs-lookup"><span data-stu-id="332d7-139">Generally, a control will only mark a platform input event as handled if there is some design intention for doing so.</span></span> <span data-ttu-id="332d7-140">В некоторых сценариях желаемого возможно способа обработки входных событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-140">In certain scenarios, those design intentions might not be what your particular handling of the input event requires.</span></span> <span data-ttu-id="332d7-141">Он предназначен для этих сценариев, Регистрация обработчиков с `handledEventsToo` как `true` подходит.</span><span class="sxs-lookup"><span data-stu-id="332d7-141">It is for these scenarios that registering handlers with `handledEventsToo` as `true` is appropriate.</span></span> <span data-ttu-id="332d7-142">Однако не следует это регулярно.</span><span class="sxs-lookup"><span data-stu-id="332d7-142">But you should not do this routinely.</span></span> <span data-ttu-id="332d7-143">Вызов обработчиков в ответ на все события, даже в случае обработки усложнит собственную логику обработки событий в приложении.</span><span class="sxs-lookup"><span data-stu-id="332d7-143">Invoking handlers in response to all events even if handled will complicate your own application event processing logic.</span></span> <span data-ttu-id="332d7-144">Снижение производительности могут появиться, если логику обработки является существенным.</span><span class="sxs-lookup"><span data-stu-id="332d7-144">You may see a decrease in performance if the handler logic is substantial.</span></span> <span data-ttu-id="332d7-145">Необходимо зарезервировать использование присоединения обработчиков для уже обработанных событий для ситуаций, где были обнаружены в процессе разработки, некоторые элементы управления обработки событий, которые по-прежнему необходимо обработать с логикой приложения.</span><span class="sxs-lookup"><span data-stu-id="332d7-145">You should reserve the use of attaching handlers for already-handled events for situations where you have already discovered during the development process that certain controls are handling events that you still want to handle with application logic.</span></span>  
  
 <span data-ttu-id="332d7-146">Предотвращение классов определенные сочетания элементов управления другим способом является использование события предварительного просмотра.</span><span class="sxs-lookup"><span data-stu-id="332d7-146">Another technique for avoiding the class handling behavior of certain event-control combinations is to use that event's preview alternative.</span></span> <span data-ttu-id="332d7-147">Например если <xref:System.Windows.ContentElement.MouseLeftButtonDown> помечено как обработанное обработкой классов, можно добавить обработчики для <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> вместо него.</span><span class="sxs-lookup"><span data-stu-id="332d7-147">For example, if <xref:System.Windows.ContentElement.MouseLeftButtonDown> is marked handled by class handling, you might be able to add handlers for <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> instead.</span></span>  
  
 <span data-ttu-id="332d7-148">Можно добавить один и тот же обработчик для того же события несколько раз, не вызывая исключение.</span><span class="sxs-lookup"><span data-stu-id="332d7-148">You can add the same handler for the same event multiple times without raising an exception.</span></span> <span data-ttu-id="332d7-149">Тем не менее обработчик вызывается несколько раз, когда событие обрабатывается.</span><span class="sxs-lookup"><span data-stu-id="332d7-149">However, the handler is actually invoked multiple times when the event is handled.</span></span> <span data-ttu-id="332d7-150">Таким образом рассмотрим, как это поведение может иметь побочные эффекты, которые должны быть учтены в вашу реализацию обработчика.</span><span class="sxs-lookup"><span data-stu-id="332d7-150">Therefore, consider how this behavior might have side effects that should be accounted for in your handler implementation.</span></span>  
  
 <span data-ttu-id="332d7-151">Этот метод обычно используется для реализации метода доступа «добавить» для [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] шаблона доступа события пользовательского маршрутизируемого события.</span><span class="sxs-lookup"><span data-stu-id="332d7-151">You typically use this method to provide the implementation of the "add" accessor for the [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] event access pattern of a custom routed event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="332d7-152">В следующем примере реализуется обработчик, вызванную <xref:System.Windows.FrameworkElement.Initialized> событий на странице, определенный обработчик присоединяется к один из именованных элементов на странице с помощью `handledEventsToo` `true`.</span><span class="sxs-lookup"><span data-stu-id="332d7-152">The following example implements a handler invoked on the <xref:System.Windows.FrameworkElement.Initialized> event on a page that attaches a defined handler to one of the named elements on the page using `handledEventsToo` `true`.</span></span> <span data-ttu-id="332d7-153">Этот обработчик будет вызываться, даже если другим элементом на маршруте общие данные события как обработанные до достижения обрабатывающего элемента в маршруте.</span><span class="sxs-lookup"><span data-stu-id="332d7-153">This handler would be invoked even if another element along the route marked the shared event data as handled before reaching the handling element in the route.</span></span>  
  
 [!code-csharp[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/csharp/VS_Snippets_Wpf/EventOvwSupport/CSharp/page2.xaml.cs#addhandlerhandledtoo)]
 [!code-vb[EventOvwSupport#AddHandlerHandledToo](~/samples/snippets/visualbasic/VS_Snippets_Wpf/EventOvwSupport/visualbasic/page2.xaml.vb#addhandlerhandledtoo)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddToEventRoute">
      <MemberSignature Language="C#" Value="public void AddToEventRoute (System.Windows.EventRoute route, System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddToEventRoute(class System.Windows.EventRoute route, class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.AddToEventRoute(System.Windows.EventRoute,System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddToEventRoute (route As EventRoute, e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddToEventRoute(System::Windows::EventRoute ^ route, System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="route" Type="System.Windows.EventRoute" />
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="route">
          <span data-ttu-id="332d7-154">Маршрут события, к которому добавляются обработчики.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-154">The event route that handlers are added to.</span>
          </span>
        </param>
        <param name="e">
          <span data-ttu-id="332d7-155">Информация о событии, используемая для добавления обработчиков.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-155">The event data that is used to add the handlers.</span>
          </span>
          <span data-ttu-id="332d7-156">Данный метод использует свойство <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> аргументов для создания обработчиков.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-156">This method uses the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> property of the arguments to create the handlers.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-157">Добавляет обработчики в указанный <see cref="T:System.Windows.EventRoute" /> для настоящего коллекции обработчиков событий <see cref="T:System.Windows.ContentElement" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-157">Adds handlers to the specified <see cref="T:System.Windows.EventRoute" /> for the current <see cref="T:System.Windows.ContentElement" /> event handler collection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-158">Используйте этот метод для элементов (независимо от того, является ли они реализуют <xref:System.Windows.IContentHost>) чтобы добавить обработчики для дочерних элементов в узле <xref:System.Windows.EventRoute>.</span><span class="sxs-lookup"><span data-stu-id="332d7-158">Use this method for content host elements (regardless whether they implement <xref:System.Windows.IContentHost>) in order to add handlers for the content host child elements to the host <xref:System.Windows.EventRoute>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDrop">
      <MemberSignature Language="C#" Value="public bool AllowDrop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowDrop" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AllowDrop" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowDrop As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowDrop { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-159">Возвращает или задает значение, указывающее, можно ли использовать этот элемент как целевой объект операции перетаскивания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-159">Gets or sets a value that indicates whether this element can be used as the target of a drag-and-drop operation.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="332d7-160">Значение <see langword="true" />, если этот элемент можно использовать в качестве целевого объекта для операции перетаскивания; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-160">
              <see langword="true" /> if this element can be used as the target of a drag-and-drop operation; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="332d7-161">Значение по умолчанию — <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-161">The default value is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-162">Операции перетаскивания и вставки не включены по умолчанию и необходимо включить, установив намеренно <xref:System.Windows.ContentElement.AllowDrop%2A> для `true`.</span><span class="sxs-lookup"><span data-stu-id="332d7-162">Drag-and-drop operations are not enabled by default, and must be enabled deliberately by setting <xref:System.Windows.ContentElement.AllowDrop%2A> to  `true`.</span></span> <span data-ttu-id="332d7-163">Кроме данной базовой настройки, и перетащите поведение зависит от способа реализации и не определяется <xref:System.Windows.ContentElement> или любым другим классом базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-163">Beyond this basic setting, drag-and-drop behavior is entirely implementation specific and is not defined by <xref:System.Windows.ContentElement> or any other base element class.</span></span> <span data-ttu-id="332d7-164">Некоторые элементы управления, например, <xref:System.Windows.Controls.RichTextBox>, есть ли у поведение по умолчанию, но это не <xref:System.Windows.ContentElement> производные классы имеют такие расширения функциональности.</span><span class="sxs-lookup"><span data-stu-id="332d7-164">Certain controls, for example, <xref:System.Windows.Controls.RichTextBox>, do have a default behavior, but no <xref:System.Windows.ContentElement> derived classes have such a behavior.</span></span> <span data-ttu-id="332d7-165">Дополнительные сведения об операции перетаскивания см. в разделе [Drop Обзор и перетащите](~/docs/framework/wpf/advanced/drag-and-drop-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-165">For more information on drag and drop, see [Drag and Drop Overview](~/docs/framework/wpf/advanced/drag-and-drop-overview.md).</span></span>  
  
 <span data-ttu-id="332d7-166"><xref:System.Windows.FrameworkContentElement> переопределяет метаданные для этого свойства зависимостей в своей реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-166"><xref:System.Windows.FrameworkContentElement> overrides the metadata for this dependency property in its implementation.</span></span> <span data-ttu-id="332d7-167">В частности <xref:System.Windows.FrameworkContentElement> обозначает, что это свойство позволяет наследование значения свойства (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> — `true` в метаданных).</span><span class="sxs-lookup"><span data-stu-id="332d7-167">Specifically, <xref:System.Windows.FrameworkContentElement> designates that this property allows property value inheritance (<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> is `true` in metadata).</span></span> <span data-ttu-id="332d7-168">Наследование значения свойства в данном контексте означает, что если существуют дочерние элементы и не имеет значения для <xref:System.Windows.ContentElement.AllowDrop%2A> назначенного с помощью локальных значений или стилей, значение ближайшего родительского элемента с назначенным данным значением (опять же, либо в стилях, по умолчанию значения, или локальное значение), а затем присваивается значение из этого родительского элемента Все неназначенные дочерним элементам системой свойств.</span><span class="sxs-lookup"><span data-stu-id="332d7-168">Property value inheritance in this context means that if there are child elements with no other value for <xref:System.Windows.ContentElement.AllowDrop%2A> assigned through local values or styles, the value of the nearest parent element with this value assigned (again, either in styles, by default values, or a local value), then the value from that parent element is assigned to all unassigned child elements by the property system.</span></span> <span data-ttu-id="332d7-169">Это означает, что можно указать, следует ли разрешить операции удаления в корневом элементе и затем передавать значение для всех <xref:System.Windows.FrameworkContentElement> дочерние элементы, не назначенные специально его значение `false`.</span><span class="sxs-lookup"><span data-stu-id="332d7-169">This means that you can specify whether to allow drop operations at the root element and then propagate the value to all <xref:System.Windows.FrameworkContentElement> child elements that have not specifically assigned it a value of `false`.</span></span>  
  
<a name="dependencyPropertyInfo_AllowDrop"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="332d7-170">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="332d7-170">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-171">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-171">Identifier field</span></span>|<xref:System.Windows.ContentElement.AllowDropProperty>|  
|<span data-ttu-id="332d7-172">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="332d7-172">Metadata properties set to `true`</span></span>|<span data-ttu-id="332d7-173">Нет</span><span class="sxs-lookup"><span data-stu-id="332d7-173">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="332d7-174">В следующем примере задается <xref:System.Windows.ContentElement.AllowDrop%2A> в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span><span class="sxs-lookup"><span data-stu-id="332d7-174">The following example sets <xref:System.Windows.ContentElement.AllowDrop%2A> in [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#AllowDrop](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#allowdrop)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AllowDropProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowDropProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowDropProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AllowDropProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowDropProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowDropProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-175">Идентифицирует свойство зависимостей <see cref="P:System.Windows.ContentElement.AllowDrop" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-175">Identifies the <see cref="P:System.Windows.ContentElement.AllowDrop" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ApplyAnimationClock">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-176">Применяет анимацию к указанному свойству зависимостей в этом элементе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-176">Applies an animation to a specified dependency property on this element.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyAnimationClock (dp As DependencyProperty, clock As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="332d7-177">Идентификатор анимируемого свойства.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-177">The identifier for the property to animate.</span>
          </span>
        </param>
        <param name="clock">
          <span data-ttu-id="332d7-178">Таймер анимации, контролирующий и объявляющий анимацию.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-178">The animation clock that controls and declares the animation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-179">Применяет анимацию к указанному свойству зависимостей в этом элементе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-179">Applies an animation to a specified dependency property on this element.</span>
          </span>
          <span data-ttu-id="332d7-180">Все существующие анимации останавливаются и заменяются новой анимацией.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-180">Any existing animations are stopped and replaced with the new animation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-181">Чтобы удалить анимацию из свойства, укажите идентификатор для свойства в качестве `dp` и укажите `clock` как `null`.</span><span class="sxs-lookup"><span data-stu-id="332d7-181">To remove an animation from a property, specify the identifier for that property as `dp` and specify `clock` as `null`.</span></span> <span data-ttu-id="332d7-182">Это действие удаляет анимацию и анимированное свойство имеет значение к базовому значению.</span><span class="sxs-lookup"><span data-stu-id="332d7-182">This removes the animation and the animated property is set to its base value.</span></span> <span data-ttu-id="332d7-183">Тем не менее счетчик анимации не останавливается.</span><span class="sxs-lookup"><span data-stu-id="332d7-183">However, the originally associated animation clock is not stopped.</span></span> <span data-ttu-id="332d7-184">Любая другая назначенная этим часам анимация будет продолжать запуска.</span><span class="sxs-lookup"><span data-stu-id="332d7-184">Any other animations assigned to that clock will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="332d7-185">Анимируемое свойство.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-185">The property to animate.</span>
          </span>
        </param>
        <param name="clock">
          <span data-ttu-id="332d7-186">Таймер анимации, контролирующий и объявляющий анимацию.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-186">The animation clock that controls and declares the animation.</span>
          </span>
        </param>
        <param name="handoffBehavior">
          <span data-ttu-id="332d7-187">Значение перечисления.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-187">A value of the enumeration.</span>
          </span>
          <span data-ttu-id="332d7-188">Значение по умолчанию — <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" />, означающее остановку любой существующей анимации и ее замену новой.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-188">The default is <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" />, which will stop any existing animation and replace with the new one.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-189">Применяет анимацию к заданному свойству зависимостей этого элемента с возможностью указать, что должно происходить, если у свойства уже имеется запущенная анимация.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-189">Applies an animation to a specified dependency property on this element, with the ability to specify what happens if the property already has a running animation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-190">Чтобы удалить анимацию из свойства, укажите идентификатор для свойства в качестве `dp` и укажите `clock` как `null`.</span><span class="sxs-lookup"><span data-stu-id="332d7-190">To remove an animation from a property, specify the identifier for that property as `dp` and specify `clock` as `null`.</span></span> <span data-ttu-id="332d7-191">Это действие удаляет анимацию и анимированное свойство имеет значение к базовому значению.</span><span class="sxs-lookup"><span data-stu-id="332d7-191">This removes the animation and the animated property is set to its base value.</span></span> <span data-ttu-id="332d7-192">Тем не менее счетчик анимации не останавливается.</span><span class="sxs-lookup"><span data-stu-id="332d7-192">However, the originally associated animation clock is not stopped.</span></span> <span data-ttu-id="332d7-193">Любая другая назначенная этим часам анимация будет продолжать запуска.</span><span class="sxs-lookup"><span data-stu-id="332d7-193">Any other animations assigned to that clock will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCaptured">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCaptured { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-194">Получает значение, которое указывает, была ли хотя бы одна операция сенсорного ввода передана в данный элемент.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-194">Gets a value that indicates whether at least one touch is captured to this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="332d7-195">Значение <see langword="true" />, если хотя бы одна операция сенсорного ввода получена данным элементом; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-195">
              <see langword="true" /> if at least one touch is captured to this element; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-196">Идентифицирует свойство зависимостей <see cref="P:System.Windows.ContentElement.AreAnyTouchesCaptured" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-196">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesCaptured" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesCapturedWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesCapturedWithin { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-197">Получает значение, указывающее, была ли хотя бы одна операция сенсорного ввода передана в данный элемент или в какой-либо из его дочерних элементов в визуальном дереве.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-197">Gets a value that indicates whether at least one touch is captured to this element or to any child elements in its visual tree.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="332d7-198">Значение <see langword="true" />, если хотя бы одна операция сенсорного ввода получена данным элементом или каким-либо из его дочерних элементов в визуальном дереве; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-198">
              <see langword="true" /> if at least one touch is captured to this element or any child elements in its visual tree; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesCapturedWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesCapturedWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesCapturedWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesCapturedWithinProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-199">Идентифицирует свойство зависимостей <see cref="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-199">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesCapturedWithin" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesDirectlyOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-200">Получает значение, которое указывает, произошло ли хотя бы одно сенсорное нажатие данного элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-200">Gets a value that indicates whether at least one touch is pressed over this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="332d7-201">Значение <see langword="true" />, если произошло хотя бы одно сенсорное нажатие данного элемента; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-201">
              <see langword="true" /> if at least one touch is pressed over this element; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesDirectlyOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-202">Идентифицирует свойство зависимостей <see cref="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-202">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesDirectlyOver" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOver">
      <MemberSignature Language="C#" Value="public bool AreAnyTouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AreAnyTouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.AreAnyTouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AreAnyTouchesOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AreAnyTouchesOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-203">Получает значение, указывающее, произошло ли хотя бы одно сенсорное нажатие данного элемента или какого-либо из его дочерних элементов в визуальном дереве.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-203">Gets a value that indicates whether at least one touch is pressed over this element or any child elements in its visual tree.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="332d7-204">Значение <see langword="true" />, если произошло хотя бы одно сенсорное нажатие данного элемента или какого-либо из его дочерних элементов в визуальном дереве; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-204">
              <see langword="true" /> if at least one touch is pressed over this element or any child elements in its visual tree; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AreAnyTouchesOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AreAnyTouchesOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AreAnyTouchesOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.AreAnyTouchesOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AreAnyTouchesOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AreAnyTouchesOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-205">Идентифицирует свойство зависимостей <see cref="P:System.Windows.ContentElement.AreAnyTouchesOver" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-205">Identifies the <see cref="P:System.Windows.ContentElement.AreAnyTouchesOver" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAnimation">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-206">Запускает анимацию для указанного свойства данного элемента, имеющего анимацию.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-206">Starts an animation for a specified animated property on this element.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginAnimation (dp As DependencyProperty, animation As AnimationTimeline)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="332d7-207">Свойство для анимации, указанное как идентификатор свойства зависимостей.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-207">The property to animate, which is specified as a dependency property identifier.</span>
          </span>
        </param>
        <param name="animation">
          <span data-ttu-id="332d7-208">График для анимации.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-208">The timeline of the animation to start.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-209">Запускает анимацию для указанного свойства данного элемента, имеющего анимацию.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-209">Starts an animation for a specified animated property on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-210">При возвращении анимировано ли свойство, обратите внимание, что анимация начнется считаться анимации при отображении первый кадр отправной точкой, без анимации.</span><span class="sxs-lookup"><span data-stu-id="332d7-210">When you check whether a property is animated, note that the animation will begin and be considered animated when the first frame beyond the non-animated starting point is rendered.</span></span>  
  
 <span data-ttu-id="332d7-211">Если <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> для `animation` — `null`, любые текущие анимации будут удалены и удерживается текущее значение свойства.</span><span class="sxs-lookup"><span data-stu-id="332d7-211">If the <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> for `animation` is `null`, then any current animations are removed and the current value of the property is held.</span></span>  
  
 <span data-ttu-id="332d7-212">Если вся `animation` значение `null`, все анимации будут удалены из свойства, и свойство возвращается к базовому значению.</span><span class="sxs-lookup"><span data-stu-id="332d7-212">If the entire `animation` value is `null`, all animations are removed from the property and the property value reverts to its base value.</span></span> <span data-ttu-id="332d7-213">Однако график анимации не останавливается.</span><span class="sxs-lookup"><span data-stu-id="332d7-213">However, the originally associated animation timeline is not stopped.</span></span> <span data-ttu-id="332d7-214">Любая другая назначенная этой шкале анимация будет продолжать запуска.</span><span class="sxs-lookup"><span data-stu-id="332d7-214">Any other animations assigned to that timeline will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="332d7-215">Свойство для анимации, указанное как идентификатор свойства зависимостей.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-215">The property to animate, which is specified as the dependency property identifier.</span>
          </span>
        </param>
        <param name="animation">
          <span data-ttu-id="332d7-216">График для анимации, которую следует применить.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-216">The timeline of the animation to be applied.</span>
          </span>
        </param>
        <param name="handoffBehavior">
          <span data-ttu-id="332d7-217">Значение перечисления, которое указывает, как новая анимация должна взаимодействовать с любыми текущими анимациями, уже влияющими на значение свойства.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-217">A value of the enumeration that specifies how the new animation interacts with any current (running) animations that are already affecting the property value.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-218">Запускает указанную анимацию для указанного анимированного свойства зависимостей этого элемента, с возможностью указания действий, которые следует предпринять при уже существующей анимации для данного свойства.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-218">Starts a specific animation for a specified animated property on this element, with the option of specifying what happens if the property already has a running animation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-219">При возвращении анимировано ли свойство, обратите внимание, что анимация начнется считаться анимации при отображении первый кадр отправной точкой, без анимации.</span><span class="sxs-lookup"><span data-stu-id="332d7-219">When you check whether a property is animated, note that the animation will begin and be considered animated when the first frame beyond the non-animated starting point is rendered.</span></span>  
  
 <span data-ttu-id="332d7-220">Если <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> для `animation` — `null`, любые текущие анимации будут удалены и удерживается текущее значение свойства.</span><span class="sxs-lookup"><span data-stu-id="332d7-220">If the <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> for `animation` is `null`, then any current animations are removed and the current value of the property is held.</span></span>  
  
 <span data-ttu-id="332d7-221">Если вся `animation` значение `null`, все анимации будут удалены из свойства, и свойство возвращается к базовому значению.</span><span class="sxs-lookup"><span data-stu-id="332d7-221">If the entire `animation` value is `null`, all animations are removed from the property and the property value reverts to its base value.</span></span> <span data-ttu-id="332d7-222">Однако график анимации не останавливается.</span><span class="sxs-lookup"><span data-stu-id="332d7-222">However, the originally associated animation timeline is not stopped.</span></span> <span data-ttu-id="332d7-223">Любая другая назначенная этой шкале анимация будет продолжать запуска.</span><span class="sxs-lookup"><span data-stu-id="332d7-223">Any other animations assigned to that timeline will continue to run.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureMouse">
      <MemberSignature Language="C#" Value="public bool CaptureMouse ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureMouse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureMouse" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureMouse () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureMouse();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureMouse</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="332d7-224">Пытается принудительно захватить мышь данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-224">Attempts to force capture of the mouse to this element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="332d7-225">Значение <see langword="true" />, если мышь успешно захвачена, в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-225">
              <see langword="true" /> if the mouse is successfully captured; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-226">Для отслеживания, необходимо включить элемент.</span><span class="sxs-lookup"><span data-stu-id="332d7-226">To be captured, an element must be enabled.</span></span> <span data-ttu-id="332d7-227">Проверьте ли <xref:System.Windows.ContentElement.IsEnabled%2A> — `true` перед вызовом метода <xref:System.Windows.ContentElement.CaptureMouse%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-227">Check whether <xref:System.Windows.ContentElement.IsEnabled%2A> is `true` before you call <xref:System.Windows.ContentElement.CaptureMouse%2A>.</span></span>  
  
 <span data-ttu-id="332d7-228">Если вызов <xref:System.Windows.ContentElement.CaptureMouse%2A> возвращает `true`, затем <xref:System.Windows.ContentElement.IsMouseCaptured%2A> также `true`.</span><span class="sxs-lookup"><span data-stu-id="332d7-228">If calling <xref:System.Windows.ContentElement.CaptureMouse%2A> returns `true`, then <xref:System.Windows.ContentElement.IsMouseCaptured%2A> is also `true`.</span></span>  
  
 <span data-ttu-id="332d7-229">Если вызов <xref:System.Windows.ContentElement.CaptureMouse%2A> возвращает `true`, то <xref:System.Windows.ContentElement.GotMouseCapture> и <xref:System.Windows.ContentElement.IsMouseCapturedChanged> событий, с <xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType> событий данные выводятся как элемент где <xref:System.Windows.ContentElement.CaptureMouse%2A> вызывается метод.</span><span class="sxs-lookup"><span data-stu-id="332d7-229">If calling <xref:System.Windows.ContentElement.CaptureMouse%2A> returns `true`, then the <xref:System.Windows.ContentElement.GotMouseCapture> and <xref:System.Windows.ContentElement.IsMouseCapturedChanged> events are raised, with <xref:System.Windows.RoutedEventArgs.Source%2A?displayProperty=nameWithType> in the event data reported as the element where the <xref:System.Windows.ContentElement.CaptureMouse%2A> method is called.</span></span> <span data-ttu-id="332d7-230">При попытке захвата, возможен конфликт с уже существующим захватом, особенно с относящимися к перетаскивания и вставки с помощью мыши.</span><span class="sxs-lookup"><span data-stu-id="332d7-230">If you force capture, you might interfere with existing captures—especially with captures that relate to drag-and-drop with the mouse.</span></span>  
  
 <span data-ttu-id="332d7-231">Чтобы очистить захват мыши из всех элементов, вызовите <xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType> с `element` указанный параметр как `null`.</span><span class="sxs-lookup"><span data-stu-id="332d7-231">To clear mouse capture from all elements, call <xref:System.Windows.Input.Mouse.Capture%2A?displayProperty=nameWithType> with the `element` parameter provided as `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="332d7-232">В следующем примере захватывает мышь или освобождает, основании уже записали мыши элементом.</span><span class="sxs-lookup"><span data-stu-id="332d7-232">The following example captures the mouse or releases capture, based on whether the mouse is already captured by the element.</span></span> <span data-ttu-id="332d7-233">Обратите внимание, что в данном примере приводится потенциального отслеживания целевого элемента <xref:System.Windows.IInputElement> интерфейс и таким образом, изначально вызов <xref:System.Windows.IInputElement.CaptureMouse%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="332d7-233">Note that this example casts the prospective capture target element to the <xref:System.Windows.IInputElement> interface, and is thus initially calling the <xref:System.Windows.IInputElement.CaptureMouse%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="332d7-234">Явное приведение к <xref:System.Windows.IInputElement> методика полезна, если вы не уверены, является ли элемент должны быть захвата мыши <xref:System.Windows.UIElement> или <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="332d7-234">Casting to <xref:System.Windows.IInputElement> is a technique that is useful if you are unsure whether the element you want to have capture the mouse is a <xref:System.Windows.UIElement> or a <xref:System.Windows.ContentElement>.</span></span> <span data-ttu-id="332d7-235">Приведение интерфейса и метода интерфейса вызвать затем вызывает соответствующую конкретного типа CaptureMouse реализацию внутренне без необходимости получения пробной версии приведение либо <xref:System.Windows.UIElement> или <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="332d7-235">The interface cast and the interface method call then calls the appropriate type-specific CaptureMouse implementation internally without requiring a trial cast to either <xref:System.Windows.UIElement> or <xref:System.Windows.ContentElement>.</span></span> <span data-ttu-id="332d7-236">Данная техника работает для других участников, <xref:System.Windows.IInputElement> определяет, например большое число событий и другие методы ввода.</span><span class="sxs-lookup"><span data-stu-id="332d7-236">This same casting technique works for other members that <xref:System.Windows.IInputElement> defines, for instance many of the input-related events, and other input-related methods.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#ismousecaptured)]
 [!code-vb[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="CaptureStylus">
      <MemberSignature Language="C#" Value="public bool CaptureStylus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CaptureStylus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureStylus" />
      <MemberSignature Language="VB.NET" Value="Public Function CaptureStylus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CaptureStylus();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.CaptureStylus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="332d7-237">Пытается принудительно захватить перо данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-237">Attempts to force capture of the stylus to this element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="332d7-238">Значение <see langword="true" />, если перо успешно захвачена, в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-238">
              <see langword="true" /> if the stylus is successfully captured; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-239">Реализация по умолчанию, на основании основным устройством пера всегда возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="332d7-239">The default implementation based on the underlying default stylus device always returns `true`.</span></span> <span data-ttu-id="332d7-240">Тем не менее при расширении устройств ввода, которые обеспечивают реализацию устройств для системы ввода, имеется возможность создать систему с альтернативной реализацией перьевого устройства, могут возвращать разные результаты.</span><span class="sxs-lookup"><span data-stu-id="332d7-240">However, if you are extending the input devices that provide the device implementation for the input system, it is possible to create a system with an alternative stylus device implementation that might return different results.</span></span>  
  
 <span data-ttu-id="332d7-241">При захвате пера элементом, он получает ввод от пера, даже если перо находится вне границ элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-241">When an element captures the stylus, it receives stylus input even if the stylus is outside its bounds.</span></span> <span data-ttu-id="332d7-242">Перо обычно захватывается только во время операции перетаскивания и вставки.</span><span class="sxs-lookup"><span data-stu-id="332d7-242">The stylus is typically captured only during drag-and-drop operations.</span></span>  
  
 <span data-ttu-id="332d7-243">Вызов этого метода вызывает статический базовая <xref:System.Windows.Input.Stylus> метод <xref:System.Windows.Input.Stylus.Capture%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-243">Calling this method calls an underlying static <xref:System.Windows.Input.Stylus> method <xref:System.Windows.Input.Stylus.Capture%2A>.</span></span> <span data-ttu-id="332d7-244">Поведение самого захвата реализуется с помощью реализации устройства пера active.</span><span class="sxs-lookup"><span data-stu-id="332d7-244">The actual capture behavior is implemented by the active stylus device implementation.</span></span>  
  
 <span data-ttu-id="332d7-245">Для отслеживания, необходимо включить элемент.</span><span class="sxs-lookup"><span data-stu-id="332d7-245">To be captured, an element must be enabled.</span></span> <span data-ttu-id="332d7-246">Проверьте ли <xref:System.Windows.ContentElement.IsEnabled%2A> — `true` возвращают перед вызовом метода <xref:System.Windows.ContentElement.CaptureStylus%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-246">Check whether <xref:System.Windows.ContentElement.IsEnabled%2A> is `true` return before you call <xref:System.Windows.ContentElement.CaptureStylus%2A>.</span></span>  
  
 <span data-ttu-id="332d7-247">Если вызов <xref:System.Windows.ContentElement.CaptureStylus%2A> возвращает `true`, <xref:System.Windows.ContentElement.IsStylusCaptured%2A> также `true`.</span><span class="sxs-lookup"><span data-stu-id="332d7-247">If calling <xref:System.Windows.ContentElement.CaptureStylus%2A> returns `true`, <xref:System.Windows.ContentElement.IsStylusCaptured%2A> is also `true`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CaptureTouch">
      <MemberSignature Language="C#" Value="public bool CaptureTouch (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool CaptureTouch(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.CaptureTouch(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool CaptureTouch(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice">
          <span data-ttu-id="332d7-248">Захватываемое устройство.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-248">The device to capture.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-249">Предпринимает попытку принудительного получения операции сенсорного ввода данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-249">Attempts to force capture of a touch to this element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="332d7-250">Значение <see langword="true" />, если указанная операция сенсорного ввода была получена данным элементом; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-250">
              <see langword="true" /> if the specified touch is captured to this element; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-251"><xref:System.Windows.ContentElement.CaptureTouch%2A> Возвращает `false` Если <xref:System.Windows.Input.TouchDevice> записывается в настоящее время в другой элемент.</span><span class="sxs-lookup"><span data-stu-id="332d7-251"><xref:System.Windows.ContentElement.CaptureTouch%2A> will return `false` if the <xref:System.Windows.Input.TouchDevice> is currently captured to another element.</span></span>  
  
 <span data-ttu-id="332d7-252">Если <xref:System.Windows.ContentElement.CaptureTouch%2A> возвращает `true`, то <xref:System.Windows.ContentElement.GotTouchCapture> события.</span><span class="sxs-lookup"><span data-stu-id="332d7-252">If <xref:System.Windows.ContentElement.CaptureTouch%2A> returns `true`, then the <xref:System.Windows.ContentElement.GotTouchCapture> event is raised.</span></span>  
  
 <span data-ttu-id="332d7-253">Чтобы освободить записи одним нажатием из этого элемента, используйте <xref:System.Windows.ContentElement.ReleaseTouchCapture%2A> метод и указать устройство сенсорного ввода для освобождения.</span><span class="sxs-lookup"><span data-stu-id="332d7-253">To release capture of a single touch from this element, use the <xref:System.Windows.ContentElement.ReleaseTouchCapture%2A> method and specify the touch device to release.</span></span> <span data-ttu-id="332d7-254">Чтобы освободить все изменения из этого элемента, используйте <xref:System.Windows.ContentElement.ReleaseAllTouchCaptures%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="332d7-254">To release all touches from this element, use the <xref:System.Windows.ContentElement.ReleaseAllTouchCaptures%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="332d7-255">Свойство <paramref name="touchDevice" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-255">
              <paramref name="touchDevice" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.Windows.Input.TouchDevice.Capture(System.Windows.IInputElement)" />
      </Docs>
    </Member>
    <Member MemberName="CommandBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.CommandBindingCollection CommandBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.CommandBindingCollection CommandBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.CommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CommandBindings As CommandBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::CommandBindingCollection ^ CommandBindings { System::Windows::Input::CommandBindingCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.CommandBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-256">Возвращает коллекцию объектов <see cref="T:System.Windows.Input.CommandBinding" />, сопоставленных этому элементу.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-256">Gets a collection of <see cref="T:System.Windows.Input.CommandBinding" /> objects that are associated with this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="332d7-257">Коллекция всех объектов <see cref="T:System.Windows.Input.CommandBinding" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-257">The collection of all <see cref="T:System.Windows.Input.CommandBinding" /> objects.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-258">Объект <xref:System.Windows.Input.CommandBinding> включает обработку команд для определенной команды для данного элемента и объявляет компоновку между командой, ее событиями и обработчики, подключенные с помощью данного элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-258">A <xref:System.Windows.Input.CommandBinding> enables command handling of a specific command for this element and declares the linkage between a command, its events, and the handlers that are attached by this element.</span></span>  
  
 <span data-ttu-id="332d7-259">Другой способ заполнения <xref:System.Windows.ContentElement.CommandBindings%2A> коллекции заключается в использовании <xref:System.Windows.Input.CommandManager> методы программными средствами.</span><span class="sxs-lookup"><span data-stu-id="332d7-259">Another typical way to populate the <xref:System.Windows.ContentElement.CommandBindings%2A> collection is to use <xref:System.Windows.Input.CommandManager> methods programmatically.</span></span>  
  
<a name="xamlPropertyElementUsage_CommandBindings"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="332d7-260">Использование элемента свойства XAML</span><span class="sxs-lookup"><span data-stu-id="332d7-260">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.CommandBindings>  
    oneOrMoreCommandBindings  </object.CommandBindings>  
</object>  
```  
  
<a name="xamlValues_CommandBindings"></a>   
## <a name="xaml-values"></a><span data-ttu-id="332d7-261">Значения XAML</span><span class="sxs-lookup"><span data-stu-id="332d7-261">XAML Values</span></span>  
 <span data-ttu-id="332d7-262">*oneOrMoreCommandBindings*</span><span class="sxs-lookup"><span data-stu-id="332d7-262">*oneOrMoreCommandBindings*</span></span>  
 <span data-ttu-id="332d7-263">Один или несколько <xref:System.Windows.Input.CommandBinding> элементов.</span><span class="sxs-lookup"><span data-stu-id="332d7-263">One or more <xref:System.Windows.Input.CommandBinding> elements.</span></span> <span data-ttu-id="332d7-264">Каждый из них должен иметь <xref:System.Windows.Input.CommandBinding.Command%2A> атрибуту присвоено известной командой, и набор атрибутов для <xref:System.Windows.Input.CommandBinding.CanExecute> и <xref:System.Windows.Input.CommandBinding.Executed> реализации обработчика.</span><span class="sxs-lookup"><span data-stu-id="332d7-264">Each of these should have a <xref:System.Windows.Input.CommandBinding.Command%2A> attribute set to a known command, and attributes set for the <xref:System.Windows.Input.CommandBinding.CanExecute> and <xref:System.Windows.Input.CommandBinding.Executed> handler implementations.</span></span> <span data-ttu-id="332d7-265">Дополнительные сведения см. в разделе <xref:System.Windows.Input.CommandBinding>.</span><span class="sxs-lookup"><span data-stu-id="332d7-265">For more information see <xref:System.Windows.Input.CommandBinding>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.CommandManager" />
      </Docs>
    </Member>
    <Member MemberName="DragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragEnter;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-266">Возникает, когда система ввода сообщает о соответствующем событии перетаскивания, имеющем в качестве источника перетаскивания этот элемент.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-266">Occurs when the input system reports an underlying drag event with this element as the drag target.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-267">Это событие создается псевдоним для <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.DragEnter?displayProperty=nameWithType> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-267">This event creates an alias for the <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.DragEnter?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-268">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.DragEnter> событий присоединяются к базовому объекту <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-268">Event handlers that are attached to the <xref:System.Windows.ContentElement.DragEnter> event are attached to the underlying <xref:System.Windows.DragDrop.DragEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_DragEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-269">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-269">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-270">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-270">Identifier field</span></span>|<xref:System.Windows.ContentElement.DragEnterEvent>|  
|<span data-ttu-id="332d7-271">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-271">Routing strategy</span></span>|<span data-ttu-id="332d7-272">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-272">Bubbling</span></span>|  
|<span data-ttu-id="332d7-273">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-273">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="332d7-274">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewDragEnter>.</span><span class="sxs-lookup"><span data-stu-id="332d7-274">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewDragEnter>.</span></span>  
  
-   <span data-ttu-id="332d7-275">Переопределить <xref:System.Windows.ContentElement.OnDragEnter%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-275">Override <xref:System.Windows.ContentElement.OnDragEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="DragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragEnterEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-276">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.DragEnter" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-276">Identifies the <see cref="E:System.Windows.ContentElement.DragEnter" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-277">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-277">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-278">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-278">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-279">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-279">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-280">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-280">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-281">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-281">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragLeave;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-282">Возникает, когда система ввода сообщает о соответствующем событии перетаскивания, имеющем в качестве источника перетаскивания этот элемент.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-282">Occurs when the input system reports an underlying drag event with this element as the drag origin.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-283">Это событие создается псевдоним для <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.DragLeave?displayProperty=nameWithType> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-283">This event creates an alias for the <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.DragLeave?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-284">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.DragLeave> событий присоединяются к базовому объекту <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-284">Event handlers that are attached to the <xref:System.Windows.ContentElement.DragLeave> event are attached to the underlying <xref:System.Windows.DragDrop.DragLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_DragLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-285">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-285">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-286">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-286">Identifier field</span></span>|<xref:System.Windows.ContentElement.DragLeaveEvent>|  
|<span data-ttu-id="332d7-287">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-287">Routing strategy</span></span>|<span data-ttu-id="332d7-288">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-288">Bubbling</span></span>|  
|<span data-ttu-id="332d7-289">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-289">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="332d7-290">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.DragDrop.PreviewDragLeave>.</span><span class="sxs-lookup"><span data-stu-id="332d7-290">The corresponding tunneling event is <xref:System.Windows.DragDrop.PreviewDragLeave>.</span></span>  
  
-   <span data-ttu-id="332d7-291">Переопределить <xref:System.Windows.ContentElement.OnDragLeave%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-291">Override <xref:System.Windows.ContentElement.OnDragLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
        <altmember cref="E:System.Windows.ContentElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="DragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragLeaveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-292">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.DragLeave" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-292">Identifies the <see cref="E:System.Windows.ContentElement.DragLeave" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-293">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-293">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-294">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-294">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-295">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-295">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-296">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-296">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-297">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-297">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler DragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler DragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.DragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ DragOver;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-298">Происходит, когда подсистема ввода сообщает о соответствующем событии перетаскивания, имеющем в качестве потенциальной цели данный элемент.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-298">Occurs when the input system reports an underlying drag event with this element as the potential drop target.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-299">Это событие возникает, даже если источник перетаскивания находится в границах элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-299">This event occurs even if the drag originates in the element bounds.</span></span> <span data-ttu-id="332d7-300">Если перетаскивание начинается за пределами границ, а затем перемещается, это событие также возникает, а также <xref:System.Windows.ContentElement.DragEnter> и связанные события предварительного просмотра.</span><span class="sxs-lookup"><span data-stu-id="332d7-300">If the drag starts outside the bounds and then moves inside, this event is also raised, as well as <xref:System.Windows.ContentElement.DragEnter> and related preview events.</span></span>  
  
 <span data-ttu-id="332d7-301">Это событие создается псевдоним для <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.DragOver?displayProperty=nameWithType> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-301">This event creates an alias for the <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.DragOver?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-302">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.DragOver> событий присоединяются к базовому объекту <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-302">Event handlers that are attached to the <xref:System.Windows.ContentElement.DragOver> event are attached to the underlying <xref:System.Windows.DragDrop.DragOver?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_DragOver"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-303">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-303">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-304">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-304">Identifier field</span></span>|<xref:System.Windows.ContentElement.DragOverEvent>|  
|<span data-ttu-id="332d7-305">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-305">Routing strategy</span></span>|<span data-ttu-id="332d7-306">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-306">Bubbling</span></span>|  
|<span data-ttu-id="332d7-307">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-307">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="332d7-308">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.DragDrop.PreviewDragOver>.</span><span class="sxs-lookup"><span data-stu-id="332d7-308">The corresponding tunneling event is <xref:System.Windows.DragDrop.PreviewDragOver>.</span></span>  
  
-   <span data-ttu-id="332d7-309">Переопределить <xref:System.Windows.ContentElement.OnDragOver%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-309">Override <xref:System.Windows.ContentElement.OnDragOver%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
        <altmember cref="E:System.Windows.ContentElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="DragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DragOverEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-310">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.DragOver" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-310">Identifies the <see cref="E:System.Windows.ContentElement.DragOver" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-311">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-311">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-312">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-312">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-313">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-313">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-314">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-314">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-315">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-315">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Drop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler Drop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler Drop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.Drop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Drop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ Drop;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-316">Происходит, когда система ввода сообщает о базовом событии удаления с этим элементом в качестве цели удаления.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-316">Occurs when the input system reports an underlying drop event with this element as the drop target.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-317">Это событие создается псевдоним для <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.Drop?displayProperty=nameWithType> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-317">This event creates an alias for the <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.Drop?displayProperty=nameWithType> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-318">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.Drop> событий присоединяются к базовому объекту <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-318">Event handlers that are attached to the <xref:System.Windows.ContentElement.Drop> event are attached to the underlying <xref:System.Windows.DragDrop.Drop?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_Drop"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-319">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-319">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-320">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-320">Identifier field</span></span>|<xref:System.Windows.ContentElement.DropEvent>|  
|<span data-ttu-id="332d7-321">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-321">Routing strategy</span></span>|<span data-ttu-id="332d7-322">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-322">Bubbling</span></span>|  
|<span data-ttu-id="332d7-323">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-323">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="332d7-324">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewDrop>.</span><span class="sxs-lookup"><span data-stu-id="332d7-324">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewDrop>.</span></span>  
  
-   <span data-ttu-id="332d7-325">Переопределить <xref:System.Windows.ContentElement.OnDrop%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-325">Override <xref:System.Windows.ContentElement.OnDrop%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="DropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.DropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DropEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-326">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.Drop" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-326">Identifies the <see cref="E:System.Windows.ContentElement.Drop" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-327">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-327">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-328">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-328">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-329">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-329">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-330">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-330">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-331">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-331">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Focus">
      <MemberSignature Language="C#" Value="public bool Focus ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Focus() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.Focus" />
      <MemberSignature Language="VB.NET" Value="Public Function Focus () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Focus();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.Focus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="332d7-332">Попытка задать фокус для данного элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-332">Attempts to set focus to this element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="332d7-333">
            <see langword="true" /> если элемент может получить клавиатурный фокус; <see langword="false" /> если в результате вызова данного метода элемент фокус не получил.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-333">
              <see langword="true" /> if keyboard focus could be set to this element; <see langword="false" /> if this method call did not force focus.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-334">Необходимо получить фокус, <xref:System.Windows.ContentElement.Focusable%2A> и <xref:System.Windows.ContentElement.IsEnabled%2A> должны быть `true`.</span><span class="sxs-lookup"><span data-stu-id="332d7-334">To be focusable, <xref:System.Windows.ContentElement.Focusable%2A> and <xref:System.Windows.ContentElement.IsEnabled%2A> must both be `true`.</span></span> <span data-ttu-id="332d7-335">Обратите внимание, что почти все <xref:System.Windows.ContentElement> производные классы не являются <xref:System.Windows.ContentElement.Focusable%2A> по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-335">Note that nearly all <xref:System.Windows.ContentElement> derived classes are not <xref:System.Windows.ContentElement.Focusable%2A> by default.</span></span>  
  
 <span data-ttu-id="332d7-336">Даже если элемент является обработка событий может иметь фокус и включена, в составе определенного дерева, (например, для составного элемента управления) может реагировать на события предварительного просмотра фокуса, не позволяя фокус, таким образом этот метод вернет `false`.</span><span class="sxs-lookup"><span data-stu-id="332d7-336">Even if an element is focusable and enabled, event handling within a specific tree, (such as for a composite control) might respond to the preview focus events by not allowing focus there, thus this method would return `false`.</span></span>  
  
 <span data-ttu-id="332d7-337">Фокус в общем случае характеризуется два разных понятия: фокус клавиатуры и логический фокус, которые не всегда совпадают.</span><span class="sxs-lookup"><span data-stu-id="332d7-337">Focus in general is governed by two separate concepts: keyboard focus and logical focus, which are not always identical.</span></span> <span data-ttu-id="332d7-338">Этот метод устанавливает логический фокус.</span><span class="sxs-lookup"><span data-stu-id="332d7-338">This method sets the logical focus.</span></span> <span data-ttu-id="332d7-339">Имеется программный способ задать фокус клавиатуры; фокус клавиатуры, определяется пользователем.</span><span class="sxs-lookup"><span data-stu-id="332d7-339">There is no programmatic means to set keyboard focus specifically; keyboard focus is determined by user input.</span></span> <span data-ttu-id="332d7-340">Дополнительные сведения см. в разделе [фокус Обзор](~/docs/framework/wpf/advanced/focus-overview.md) и [фокусе](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-340">For more information, see [Focus Overview](~/docs/framework/wpf/advanced/focus-overview.md) and [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
 <span data-ttu-id="332d7-341">Если вызов <xref:System.Windows.ContentElement.Focus%2A> возвращает `true`, <xref:System.Windows.ContentElement.IsKeyboardFocused%2A> и <xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> также `true`.</span><span class="sxs-lookup"><span data-stu-id="332d7-341">If calling <xref:System.Windows.ContentElement.Focus%2A> returns `true`, <xref:System.Windows.ContentElement.IsKeyboardFocused%2A> and <xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> are also `true`.</span></span>  
  
 <span data-ttu-id="332d7-342">Если связанные свойства еще не `true`, при вызове <xref:System.Windows.ContentElement.Focus%2A>, один или несколько из следующих событий вызываются в следующем порядке: <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>, <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> (источник — новый целевой фокус), <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>, <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>, <xref:System.Windows.ContentElement.LostKeyboardFocus>, <xref:System.Windows.ContentElement.GotKeyboardFocus> (источник — новый целевой фокус).</span><span class="sxs-lookup"><span data-stu-id="332d7-342">If the related properties are not already `true`, when you call <xref:System.Windows.ContentElement.Focus%2A>, one or more of the following events are raised in the following order: <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>, <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> (source is the new focus target), <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged>, <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged>, <xref:System.Windows.ContentElement.LostKeyboardFocus>, <xref:System.Windows.ContentElement.GotKeyboardFocus> (source is the new focus target).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="332d7-343">В следующем примере обработчик событий загрузки страницы, выполняет поиск указанного абзаца в документе с именем и передает ему фокус.</span><span class="sxs-lookup"><span data-stu-id="332d7-343">The following example is a page-loaded event handler that finds a specified named paragraph in the document and sets focus to it.</span></span> <span data-ttu-id="332d7-344">Абзацы не получают фокус по умолчанию. Это конкретного абзаца был применен стиль (не показано), в котором использовался стиль <xref:System.Windows.Setter> вносить может иметь фокус.</span><span class="sxs-lookup"><span data-stu-id="332d7-344">Paragraphs are not focusable by default; this particular paragraph had a style applied (not shown) that used a style <xref:System.Windows.Setter> to make it focusable.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#Focus](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#focus)]
 [!code-vb[ContentElementsSmorgasbord#Focus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#focus)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="Focusable">
      <MemberSignature Language="C#" Value="public bool Focusable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Focusable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.Focusable" />
      <MemberSignature Language="VB.NET" Value="Public Property Focusable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Focusable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.Focusable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-345">Получение или установка значения, определяющего возможность получения фокуса элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-345">Gets or sets a value that indicates whether the element can receive focus.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="332d7-346">
            <see langword="true" />, если элемент может получать фокус; в противном случае — <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-346">
              <see langword="true" /> if the element is focusable; otherwise <see langword="false" />.</span>
          </span>
          <span data-ttu-id="332d7-347">Значение по умолчанию: <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-347">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-348">Получать только элемент фокус ввода с клавиатуры.</span><span class="sxs-lookup"><span data-stu-id="332d7-348">Only the focused element receives keyboard input.</span></span>  
  
 <span data-ttu-id="332d7-349">Определенные производные классы могут переопределять метаданные этого свойства зависимостей, таким образом, чтобы производный класс может иметь фокус по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-349">Certain derived classes might override metadata for this dependency property such that the derived class is focusable by default.</span></span>  
  
 <span data-ttu-id="332d7-350">Если наследуемые <xref:System.Windows.Documents.Hyperlink> или его производных классов <xref:System.Windows.Documents.Hyperlink> переопределяет метаданные для этого свойства зависимостей и переопределяет значение по умолчанию этого свойства было `true`.</span><span class="sxs-lookup"><span data-stu-id="332d7-350">When inherited by <xref:System.Windows.Documents.Hyperlink> or its derived classes, <xref:System.Windows.Documents.Hyperlink> overrides the metadata for this dependency property and redefines the default value of this property to be `true`.</span></span>  
  
<a name="dependencyPropertyInfo_Focusable"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="332d7-351">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="332d7-351">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-352">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-352">Identifier field</span></span>|<xref:System.Windows.ContentElement.FocusableProperty>|  
|<span data-ttu-id="332d7-353">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="332d7-353">Metadata properties set to `true`</span></span>|<span data-ttu-id="332d7-354">Нет</span><span class="sxs-lookup"><span data-stu-id="332d7-354">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="332d7-355">В следующем примере создается стиль, который делает <xref:System.Windows.Documents.Paragraph> может иметь фокус по умолчанию и предоставляет визуальное поведение при получении фокуса.</span><span class="sxs-lookup"><span data-stu-id="332d7-355">The following example creates a style that makes a <xref:System.Windows.Documents.Paragraph> focusable by default and gives it a visual behavior when it receives focus.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#Focusable](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#focusable)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="332d7-356">При наследовании от <see cref="T:System.Windows.ContentElement" />, рассмотрите, следует ли элемент должен иметь фокус, так как по умолчанию он не будет получать фокус ввода.</span>
            <span class="sxs-lookup">
              <span data-stu-id="332d7-356">When you derive from <see cref="T:System.Windows.ContentElement" />, consider whether you want your element to be focusable, because by default it will not be focusable.</span>
            </span>
            <span data-ttu-id="332d7-357">Если элемент должен иметь фокус, переопределите метаданные для этого свойства в производном классе статический конструктора следующим образом:</span>
            <span class="sxs-lookup">
              <span data-stu-id="332d7-357">If you want your element to be focusable, override the metadata for this property in your derived class static constructor as follows:</span>
            </span>  
  
 [!code-csharp[CorePseudocode#UIElementShortOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#uielementshortoverride)]
 [!code-vb[CorePseudocode#UIElementShortOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#uielementshortoverride)]  
  
 <span data-ttu-id="332d7-358">где <paramref name="myElement" /> — это имя класса типа, который переопределяется значение метаданных.</span><span class="sxs-lookup"><span data-stu-id="332d7-358">where <paramref name="myElement" /> is the class name of the type that you are overriding the metadata value on.</span></span></para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="E:System.Windows.UIElement.GotKeyboardFocus" />
        <altmember cref="E:System.Windows.UIElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="FocusableChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler FocusableChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler FocusableChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.FocusableChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FocusableChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ FocusableChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-359">Происходит при изменении значения свойства <see cref="P:System.Windows.ContentElement.Focusable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-359">Occurs when the value of the <see cref="P:System.Windows.ContentElement.Focusable" /> property changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-360">Этот член представляет [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] событий, не является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-360">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="FocusableProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusableProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusableProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.FocusableProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusableProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusableProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-361">Идентифицирует свойство зависимостей <see cref="P:System.Windows.ContentElement.Focusable" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-361">Identifies the <see cref="P:System.Windows.ContentElement.Focusable" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAnimationBaseValue">
      <MemberSignature Language="C#" Value="public object GetAnimationBaseValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetAnimationBaseValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.GetAnimationBaseValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnimationBaseValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetAnimationBaseValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.GetAnimationBaseValue(System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">
          <span data-ttu-id="332d7-362">Свойство зависимостей для проверки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-362">The.dependency property to check.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-363">Возвращает значение базового свойства для указанного свойства данного элемента без учета возможного анимированного значения из запущенной или остановленной анимации.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-363">Returns the base property value for the specified property on this element, disregarding any possible animated value from a running or stopped animation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="332d7-364">Значение свойства, как если бы анимации не присоединялись к указанному свойству зависимостей.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-364">The property value as if no animations are attached to the specified dependency property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-365">Если бы анимации не присоединялись к свойству, а затем <xref:System.Windows.ContentElement.GetAnimationBaseValue%2A> возвращаемое значение всегда равно идентичен <xref:System.Windows.DependencyObject.GetValue%2A> возвращаемое значение.</span><span class="sxs-lookup"><span data-stu-id="332d7-365">If no animations are attached to the property, then the <xref:System.Windows.ContentElement.GetAnimationBaseValue%2A> return value is always identical to the <xref:System.Windows.DependencyObject.GetValue%2A> return value.</span></span> <span data-ttu-id="332d7-366">При наличии анимированные, затем все возможные производные значения, включая начальные и остановки, игнорируются, и значение свойства определяется в зависимости от всех других возможных входных значений.</span><span class="sxs-lookup"><span data-stu-id="332d7-366">If there are animations attached, then all possible animation derived values including the start and stop values are ignored, and the property value is determined based on all other possible inputs.</span></span> <span data-ttu-id="332d7-367">Дополнительные сведения см. в разделе [Приоритет значений свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-367">For more information, see [Dependency Property Value Precedence](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal virtual System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="332d7-368">При переопределении в производном классе возвращает альтернативный родительский элемент [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] при условии отсутствия видимого родительского элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-368">When overridden in a derived class, returns an alternative [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] parent for this element if no visual parent exists.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="332d7-369">Объект, если реализация производного класса сообщает об альтернативном родительском подключении.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-369">An object, if implementation of a derived class has an alternate parent connection to report.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-370">Виртуальная реализация по умолчанию этот метод возвращает `null`.</span><span class="sxs-lookup"><span data-stu-id="332d7-370">The default virtual implementation of this method returns `null`.</span></span> <span data-ttu-id="332d7-371"><xref:System.Windows.FrameworkContentElement> предоставляет практической реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-371"><xref:System.Windows.FrameworkContentElement> provides a practical implementation.</span></span>  
  
 <span data-ttu-id="332d7-372">Альтернативные родительские используется для маршрутизации событий, в случаях, когда элемент создает альтернативную родительскую структуру, чтобы его события маршрутизируются в, изменяя стандартный шаблон маршрутизации вверх по визуальному дереву родительскому элементу, или вниз Предварительный просмотр стратегию маршрутизации.</span><span class="sxs-lookup"><span data-stu-id="332d7-372">Alternative parents are used for event routing, in cases where an element creates an alternative parent structure so that its events are routed in a way that diverges from the standard pattern of routing up the visual tree to the standard parent, or downward in the preview routing strategy.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler GiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler GiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ GiveFeedback;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-373">Происходит, когда подсистема ввода сообщает о соответствующем событии перетаскивания, в котором участвует данный элемент.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-373">Occurs when the input system reports an underlying drag-and-drop event that involves this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-374"><xref:System.Windows.ContentElement.GiveFeedback> Событие позволяет источнику события перетаскивания изменять внешний вид указателя мыши, чтобы дать пользователю визуальную обратную связь во время операции перетаскивания и вставки.</span><span class="sxs-lookup"><span data-stu-id="332d7-374">The <xref:System.Windows.ContentElement.GiveFeedback> event allows the source of a drag event to modify the appearance of the mouse pointer in order to give the user visual feedback during a drag-and-drop operation.</span></span> <span data-ttu-id="332d7-375">Визуальную обратную связь для более глубокого, операции перетаскивания и вставки находится в процессе.</span><span class="sxs-lookup"><span data-stu-id="332d7-375">The visual feedback reinforces that a drag-and-drop operation is in process.</span></span>  
  
 <span data-ttu-id="332d7-376">Это событие создается псевдоним для <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.GiveFeedback> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-376">This event creates an alias for the <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.GiveFeedback> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-377">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.GiveFeedback> событий присоединяются к базовому объекту <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-377">Event handlers that are attached to the <xref:System.Windows.ContentElement.GiveFeedback> event are attached to the underlying <xref:System.Windows.DragDrop.GiveFeedback?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GiveFeedback"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-378">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-378">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-379">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-379">Identifier field</span></span>|<xref:System.Windows.ContentElement.GiveFeedbackEvent>|  
|<span data-ttu-id="332d7-380">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-380">Routing strategy</span></span>|<span data-ttu-id="332d7-381">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-381">Bubbling</span></span>|  
|<span data-ttu-id="332d7-382">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-382">Delegate</span></span>|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   <span data-ttu-id="332d7-383">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewGiveFeedback>.</span><span class="sxs-lookup"><span data-stu-id="332d7-383">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewGiveFeedback>.</span></span>  
  
-   <span data-ttu-id="332d7-384">Переопределить <xref:System.Windows.ContentElement.OnGiveFeedback%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-384">Override <xref:System.Windows.ContentElement.OnGiveFeedback%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="GiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GiveFeedbackEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-385">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.GiveFeedback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-385">Identifies the <see cref="E:System.Windows.ContentElement.GiveFeedback" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-386">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-386">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-387">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-387">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-388">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-388">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-389">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-389">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-390">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-390">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler GotFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler GotFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ GotFocus;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-391">Происходит при получении данным элементом логического фокуса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-391">Occurs when this element gets logical focus.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-392">Логический фокус отличается от фокуса, если он является результатом вызова метода, в на другом уровне существует предыдущий фокус клавиатуры.</span><span class="sxs-lookup"><span data-stu-id="332d7-392">Logical focus differs from keyboard focus if focus is deliberately forced by using a method call but the previous keyboard focus exists in a different scope.</span></span> <span data-ttu-id="332d7-393">В этом случае фокус остается там, где это и элемент где <xref:System.Windows.ContentElement.Focus%2A> вызывается метод по-прежнему возвращает логический фокус.</span><span class="sxs-lookup"><span data-stu-id="332d7-393">In this scenario, keyboard focus remains where it is and the element where a <xref:System.Windows.ContentElement.Focus%2A> method is called still gets logical focus.</span></span>  
  
 <span data-ttu-id="332d7-394">Точнее интерпретацию этого события является что он вызывается, когда значение <xref:System.Windows.ContentElement.IsFocused%2A> свойства элемента в маршруте изменяется с `false` для `true`.</span><span class="sxs-lookup"><span data-stu-id="332d7-394">A more precise interpretation of this event is that it is raised when the value of the <xref:System.Windows.ContentElement.IsFocused%2A> property of an element in the route is changed from `false` to `true`.</span></span>  
  
 <span data-ttu-id="332d7-395">Вследствие этого события восходящей маршрутизации, элемент, который получает фокус, может быть дочерний элемент, а не элемента, которому фактически присоединен обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-395">Because this event uses bubbling routing, the element that receives focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="332d7-396">Проверьте <xref:System.Windows.RoutedEventArgs.Source%2A> в данных события, чтобы определить фактический элемент, полученные фокус.</span><span class="sxs-lookup"><span data-stu-id="332d7-396">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that gained focus.</span></span>  
  
<a name="routedEventInfo_GotFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-397">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-397">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-398">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-398">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotFocusEvent>|  
|<span data-ttu-id="332d7-399">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-399">Routing strategy</span></span>|<span data-ttu-id="332d7-400">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-400">Bubbling</span></span>|  
|<span data-ttu-id="332d7-401">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-401">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
-   <span data-ttu-id="332d7-402">Нет соответствующего туннелирования события.</span><span class="sxs-lookup"><span data-stu-id="332d7-402">There is no corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="332d7-403">Переопределить <xref:System.Windows.ContentElement.OnGotFocus%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-403">Override <xref:System.Windows.ContentElement.OnGotFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotKeyboardFocus" />
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="GotFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-404">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.GotFocus" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-404">Identifies the <see cref="E:System.Windows.ContentElement.GotFocus" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-405">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-405">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-406">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-406">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-407">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-407">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-408">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-408">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-409">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-409">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler GotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ GotKeyboardFocus;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-410">Происходит при получении данным элементом фокуса ввода с клавиатуры.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-410">Occurs when the keyboard is focused on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-411"><xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> аналогичные событие, которое отслеживает изменения состояния в свойство, которое поддерживает состояния фокуса для элемента; <xref:System.Windows.ContentElement.GotKeyboardFocus> событие возникает в тех же условиях.</span><span class="sxs-lookup"><span data-stu-id="332d7-411"><xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> is a similar event that tracks status changes in a property that maintains the focus state for an element; the <xref:System.Windows.ContentElement.GotKeyboardFocus> event is raised in many of the same circumstances.</span></span>  
  
 <span data-ttu-id="332d7-412">Вследствие этого события восходящей маршрутизации, элемент, имеющий фокус ввода может быть дочерний элемент, а не элемента, которому фактически присоединен обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-412">Because this event uses bubbling routing, the element that has focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="332d7-413">Проверьте <xref:System.Windows.RoutedEventArgs.Source%2A> в данных события, чтобы определить фактический элемент, имеющий фокус.</span><span class="sxs-lookup"><span data-stu-id="332d7-413">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has focus.</span></span>  
  
 <span data-ttu-id="332d7-414">Это событие создается псевдоним для <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.GotKeyboardFocus> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-414">This event creates an alias for the <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.GotKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-415">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.GotKeyboardFocus> событий присоединяются к базовому объекту <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-415">Event handlers that are attached to the <xref:System.Windows.ContentElement.GotKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.GotKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GotKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-416">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-416">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-417">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-417">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotKeyboardFocusEvent>|  
|<span data-ttu-id="332d7-418">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-418">Routing strategy</span></span>|<span data-ttu-id="332d7-419">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-419">Bubbling</span></span>|  
|<span data-ttu-id="332d7-420">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-420">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="332d7-421">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>.</span><span class="sxs-lookup"><span data-stu-id="332d7-421">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="332d7-422">Переопределить <xref:System.Windows.ContentElement.OnGotKeyboardFocus%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-422">Override <xref:System.Windows.ContentElement.OnGotKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="GotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotKeyboardFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-423">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.GotKeyboardFocus" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-423">Identifies the <see cref="E:System.Windows.ContentElement.GotKeyboardFocus" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-424">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-424">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-425">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-425">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-426">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-426">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-427">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-427">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-428">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-428">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler GotMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler GotMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ GotMouseCapture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-429">Происходит при захвате мыши данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-429">Occurs when this element captures the mouse.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-430">При захвате мыши элементом, он получает ввод от мыши, даже если указатель мыши находится вне границ элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-430">When an element captures the mouse, it receives mouse input even if the mouse pointer is outside its bounds.</span></span> <span data-ttu-id="332d7-431">Мышь обычно захватывается только во время операции перетаскивания и вставки и остается захваченной, пока не произойдет действие операции перетаскивания и вставки.</span><span class="sxs-lookup"><span data-stu-id="332d7-431">The mouse is typically captured only during drag-and-drop operations and remains captured until the drop action of the drag-and-drop operation occurs.</span></span>  
  
 <span data-ttu-id="332d7-432">Вследствие этого события восходящей маршрутизации, элемент, захвативший может быть дочерний элемент, а не элемента, которому фактически присоединен обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-432">Because this event uses bubbling routing, the element that has capture might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="332d7-433">Проверьте <xref:System.Windows.RoutedEventArgs.Source%2A> событий системы отслеживания измененных данных, чтобы определить фактический элемент, имеющий мыши.</span><span class="sxs-lookup"><span data-stu-id="332d7-433">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has mouse capture.</span></span>  
  
 <span data-ttu-id="332d7-434">Это событие создается псевдоним для <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.GotMouseCapture> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-434">This event creates an alias for the <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> attached event for  this class so that <xref:System.Windows.ContentElement.GotMouseCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-435">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.GotMouseCapture> событий присоединяются к базовому объекту <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-435">Event handlers that are attached to the <xref:System.Windows.ContentElement.GotMouseCapture> event are attached to the underlying <xref:System.Windows.Input.Mouse.GotMouseCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GotMouseCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-436">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-436">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-437">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-437">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotMouseCaptureEvent>|  
|<span data-ttu-id="332d7-438">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-438">Routing strategy</span></span>|<span data-ttu-id="332d7-439">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-439">Bubbling</span></span>|  
|<span data-ttu-id="332d7-440">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-440">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="332d7-441">Нет определенного события, соответствующие туннелирования.</span><span class="sxs-lookup"><span data-stu-id="332d7-441">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="332d7-442">Переопределить <xref:System.Windows.ContentElement.OnGotMouseCapture%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-442">Override <xref:System.Windows.ContentElement.OnGotMouseCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="GotMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotMouseCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-443">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.GotMouseCapture" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-443">Identifies the <see cref="E:System.Windows.ContentElement.GotMouseCapture" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-444">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-444">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-445">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-445">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-446">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-446">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-447">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-447">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-448">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-448">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler GotStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler GotStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ GotStylusCapture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.GotStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-449">Происходит при захвате пера данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-449">Occurs when this element captures the stylus.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-450">При захвате пера элементом, он получает ввод от пера, даже если указатель находится вне границ элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-450">When an element captures the stylus, it receives stylus input even if the pointer is outside its bounds.</span></span> <span data-ttu-id="332d7-451">Перо обычно захватывается только во время операции перетаскивания и вставки и сохраняет захват, пока не произойдет действие операции перетаскивания и вставки.</span><span class="sxs-lookup"><span data-stu-id="332d7-451">The stylus is typically captured only during drag-and-drop operations and retains capture until the drop action of the drag-and-drop operation occurs.</span></span>  
  
 <span data-ttu-id="332d7-452">Вследствие этого события восходящей маршрутизации, элемент, захвативший может быть дочерний элемент, а не элемента, которому фактически присоединен обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-452">Because this event uses bubbling routing, the element that has capture might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="332d7-453">Проверьте <xref:System.Windows.RoutedEventArgs.Source%2A> в данных события, чтобы определить фактический элемент, захвативший.</span><span class="sxs-lookup"><span data-stu-id="332d7-453">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has capture.</span></span>  
  
 <span data-ttu-id="332d7-454">Это событие создается псевдоним для вложенного события для этого класса, чтобы <xref:System.Windows.ContentElement.GotStylusCapture> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-454">This event creates an alias for the  attached event for this class so that <xref:System.Windows.ContentElement.GotStylusCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-455">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.GotStylusCapture> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-455">Event handlers that are attached to the <xref:System.Windows.ContentElement.GotStylusCapture> event are attached to the underlying <xref:System.Windows.Input.Stylus.GotStylusCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_GotStylusCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-456">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-456">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-457">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-457">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotStylusCaptureEvent>|  
|<span data-ttu-id="332d7-458">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-458">Routing strategy</span></span>|<span data-ttu-id="332d7-459">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-459">Bubbling</span></span>|  
|<span data-ttu-id="332d7-460">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-460">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="332d7-461">Нет определенного события, соответствующие туннелирования.</span><span class="sxs-lookup"><span data-stu-id="332d7-461">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="332d7-462">Переопределить <xref:System.Windows.ContentElement.OnGotStylusCapture%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-462">Override <xref:System.Windows.ContentElement.OnGotStylusCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotStylusCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-463">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.GotStylusCapture" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-463">Identifies the <see cref="E:System.Windows.ContentElement.GotStylusCapture" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-464">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-464">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-465">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-465">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-466">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-466">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-467">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-467">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-468">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-468">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; GotTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; GotTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.GotTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event GotTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ GotTouchCapture;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-469">Происходит при получении данным элементом операции сенсорного ввода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-469">Occurs when a touch is captured to this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_GotTouchCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-470">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-470">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-471">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-471">Identifier field</span></span>|<xref:System.Windows.ContentElement.GotTouchCaptureEvent>|  
|<span data-ttu-id="332d7-472">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-472">Routing strategy</span></span>|<span data-ttu-id="332d7-473">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-473">Bubbling</span></span>|  
|<span data-ttu-id="332d7-474">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-474">Delegate</span></span>|<span data-ttu-id="332d7-475"><xref:System.EventHandler%601> имеет тип данных <xref:System.Windows.Input.TouchEventArgs>.</span><span class="sxs-lookup"><span data-stu-id="332d7-475"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="332d7-476">Переопределить <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-476">Override <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GotTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent GotTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent GotTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.GotTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly GotTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ GotTouchCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-477">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.GotTouchCapture" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-477">Identifies the <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnimatedProperties">
      <MemberSignature Language="C#" Value="public bool HasAnimatedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAnimatedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.HasAnimatedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasAnimatedProperties As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasAnimatedProperties { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Media.Animation.IAnimatable.HasAnimatedProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-478">Возвращает значение, указывающее, имеет ли экземпляр анимированные свойства.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-478">Gets a value that indicates whether this element has any animated properties.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="332d7-479">
            <see langword="true" />, если элемент имеет анимированные свойства; иначе, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-479">
              <see langword="true" /> if this element has animations attached to any of its properties; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-480">Это свойство возвращает `true` для постоянных анимаций (без часов, всегда запущенной) или для анимаций, имеющих определенный график.</span><span class="sxs-lookup"><span data-stu-id="332d7-480">This property returns `true` either for persistent (unclocked, always-running) animations or for animations that have a specific timeline.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InputBindings">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputBindingCollection InputBindings { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputBindingCollection InputBindings" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.InputBindings" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property InputBindings As InputBindingCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputBindingCollection ^ InputBindings { System::Windows::Input::InputBindingCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputBindingCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-481">Возвращает коллекцию привязок ввода, используемых этим элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-481">Gets the collection of input bindings that are associated with this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="332d7-482">Коллекция привязок ввода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-482">The collection of input bindings.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-483">Привязки ввода поддерживают привязку команд к устройствам ввода.</span><span class="sxs-lookup"><span data-stu-id="332d7-483">Input bindings support the binding of commands to input devices.</span></span> <span data-ttu-id="332d7-484">Например <xref:System.Windows.Input.MouseBinding> реализует входных привязок, которые включают свойства, которые относятся к устройствам мыши.</span><span class="sxs-lookup"><span data-stu-id="332d7-484">For example, <xref:System.Windows.Input.MouseBinding> implements input bindings that include properties that are specific to mouse devices.</span></span>  
  
 <span data-ttu-id="332d7-485">Коллекция привязок ввода включает как привязки ввода, относящиеся к типу, а также привязки ввода, объявленные в экземпляре.</span><span class="sxs-lookup"><span data-stu-id="332d7-485">The collection of input bindings includes both input bindings that pertain to the type and also input bindings that are declared on the instance.</span></span>  
  
 <span data-ttu-id="332d7-486">Связанное свойство <xref:System.Windows.ContentElement.CommandBindings%2A>, поддерживает коллекцию привязок команд.</span><span class="sxs-lookup"><span data-stu-id="332d7-486">A related property, <xref:System.Windows.ContentElement.CommandBindings%2A>, maintains a collection of command bindings.</span></span> <span data-ttu-id="332d7-487">Эти привязки отличаются от привязок ввода, в том, что они представляют следующего уровня вниз обработки команд - действий, которые связаны с известным командами и обработчиками данного класса для них.</span><span class="sxs-lookup"><span data-stu-id="332d7-487">These bindings differ from input bindings in that they represent the next level down of command processing - actions that are tied to known commands and class-specific handlers for them.</span></span>  
  
<a name="xamlPropertyElementUsage_InputBindings"></a>   
## <a name="xaml-property-element-usage"></a><span data-ttu-id="332d7-488">Использование элемента свойства XAML</span><span class="sxs-lookup"><span data-stu-id="332d7-488">XAML Property Element Usage</span></span>  
  
```  
<object>  
  <object.InputBindings>  
    oneOrMoreInputBindings  </object.InputBindings>  
</object>  
```  
  
<a name="xamlValues_InputBindings"></a>   
## <a name="xaml-values"></a><span data-ttu-id="332d7-489">Значения XAML</span><span class="sxs-lookup"><span data-stu-id="332d7-489">XAML Values</span></span>  
 <span data-ttu-id="332d7-490">*oneOrMoreInputBindings*</span><span class="sxs-lookup"><span data-stu-id="332d7-490">*oneOrMoreInputBindings*</span></span>  
 <span data-ttu-id="332d7-491">Один или несколько <xref:System.Windows.Input.InputBinding> элементов (обычно <xref:System.Windows.Input.KeyBinding> или <xref:System.Windows.Input.MouseBinding> производных классах).</span><span class="sxs-lookup"><span data-stu-id="332d7-491">One or more <xref:System.Windows.Input.InputBinding> elements (typically the <xref:System.Windows.Input.KeyBinding> or <xref:System.Windows.Input.MouseBinding> derived classes).</span></span> <span data-ttu-id="332d7-492">Каждый из них должен иметь <xref:System.Windows.Input.InputBinding.Command%2A> и <xref:System.Windows.Input.InputBinding.Gesture%2A> набором атрибутов.</span><span class="sxs-lookup"><span data-stu-id="332d7-492">Each of these is expected to have a <xref:System.Windows.Input.InputBinding.Command%2A> and <xref:System.Windows.Input.InputBinding.Gesture%2A> attribute set.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabled">
      <MemberSignature Language="C#" Value="public bool IsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Property IsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-493">Получает или задает значение, определяющее, активен ли этот элемент в [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-493">Gets or sets a value that indicates whether this element is enabled in the [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="332d7-494">Значение <see langword="true" />, если элемент включен; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-494">
              <see langword="true" /> if the element is enabled; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="332d7-495">Значение по умолчанию — <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-495">The default value is <see langword="true" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsEnabled"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="332d7-496">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="332d7-496">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-497">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-497">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsEnabledProperty>|  
|<span data-ttu-id="332d7-498">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="332d7-498">Metadata properties set to `true`</span></span>|<span data-ttu-id="332d7-499">Нет</span><span class="sxs-lookup"><span data-stu-id="332d7-499">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="332d7-500">В следующем примере создается стиль, который содержит метод задания свойства, которое дает другое поведение visual при <xref:System.Windows.Documents.Hyperlink> равно <xref:System.Windows.ContentElement.IsEnabled%2A> `false`.</span><span class="sxs-lookup"><span data-stu-id="332d7-500">The following example creates a style that includes a property setter that gives an alternate visual behavior when a <xref:System.Windows.Documents.Hyperlink> is set to <xref:System.Windows.ContentElement.IsEnabled%2A> `false`.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#IsEnabledIsMouseOver](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#isenabledismouseover)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsEnabledChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsEnabledChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsEnabledChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsEnabledChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-501">Происходит при изменении значения свойства <see cref="P:System.Windows.ContentElement.IsEnabled" /> данного элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-501">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsEnabled" /> property on this element changes.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-502">Этот член представляет [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] событий, не является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-502">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledCore">
      <MemberSignature Language="C#" Value="protected virtual bool IsEnabledCore { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnabledCore" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsEnabledCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable ReadOnly Property IsEnabledCore As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property bool IsEnabledCore { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-503">Возвращает значение, которое становится возвращаемым значением свойства <see cref="P:System.Windows.ContentElement.IsEnabled" /> в производных классах.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-503">Gets a value that becomes the return value of <see cref="P:System.Windows.ContentElement.IsEnabled" /> in derived classes.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="332d7-504">Значение <see langword="true" />, если элемент включен; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-504">
              <see langword="true" /> if the element is enabled; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="332d7-505">Реализация по умолчанию этого свойства кэширует значение, а также определяет, включен ли родительский элемент этого элемента.</span>
            <span class="sxs-lookup">
              <span data-stu-id="332d7-505">The default implementation of this property caches the value and also calculates whether the parent element of this element is enabled.</span>
            </span>
            <span data-ttu-id="332d7-506">(Если родительский не включен, дочерний элемент не может быть успешно активирован в Практическое применение [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].) Если вы решите переопределить эту реализацию, убедитесь, что можно вызвать базовую реализацию для сохранения этого поведения.</span>
            <span class="sxs-lookup">
              <span data-stu-id="332d7-506">(If the parent is not enabled, the child element cannot be effectively enabled in practical [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].) If you choose to override this implementation, make certain that you call the base implementation to preserve this behavior.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsEnabledProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsEnabledProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsEnabledProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsEnabledProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsEnabledProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsEnabledProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-507">Идентифицирует свойство зависимостей <see cref="P:System.Windows.ContentElement.IsEnabled" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-507">Identifies the <see cref="P:System.Windows.ContentElement.IsEnabled" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFocused">
      <MemberSignature Language="C#" Value="public bool IsFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFocused { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-508">Получает значение, определяющее, имеет ли элемент логический фокус.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-508">Gets a value that determines whether this element has logical focus.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="332d7-509">Значение <see langword="true" />, если этот элемент имеет логический фокус; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-509">
              <see langword="true" /> if this element has logical focus; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-510">Логический фокус могут отличаться от фокус клавиатуры, если приложение имеет несколько фокусных секций, например между содержанием меню и остальной частью приложения.</span><span class="sxs-lookup"><span data-stu-id="332d7-510">Logical focus might differ from keyboard focus if an application has multiple focus divisions, such as between menu contents and the remainder of the application.</span></span> <span data-ttu-id="332d7-511">В этом случае фокус клавиатуры можно только на одном элементе пользовательского интерфейса приложения, но некоторые элементы в других разделах фокуса могут сохранять логический фокус.</span><span class="sxs-lookup"><span data-stu-id="332d7-511">In this scenario, keyboard focus can only be on one element of the application  UI, however, certain elements in other focus divisions might still retain logical focus.</span></span> <span data-ttu-id="332d7-512">Дополнительные сведения о логическом фокусе см [фокусе](~/docs/framework/wpf/advanced/input-overview.md) и [фокус Обзор](~/docs/framework/wpf/advanced/focus-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-512">For more information on logical focus, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md) and [Focus Overview](~/docs/framework/wpf/advanced/focus-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsFocused"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="332d7-513">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="332d7-513">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-514">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-514">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsFocusedProperty>|  
|<span data-ttu-id="332d7-515">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="332d7-515">Metadata properties set to `true`</span></span>|<span data-ttu-id="332d7-516">Нет</span><span class="sxs-lookup"><span data-stu-id="332d7-516">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="332d7-517">В следующем примере создается стиль, который делает <xref:System.Windows.Documents.Paragraph> может иметь фокус по умолчанию и предоставляет визуальное поведение при получении фокуса.</span><span class="sxs-lookup"><span data-stu-id="332d7-517">The following example creates a style that makes a <xref:System.Windows.Documents.Paragraph> focusable by default and gives it a visual behavior when it receives focus.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#Focusable](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#focusable)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="IsFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsFocusedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-518">Идентифицирует свойство зависимостей <see cref="P:System.Windows.ContentElement.IsFocused" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-518">Identifies the <see cref="P:System.Windows.ContentElement.IsFocused" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInputMethodEnabled">
      <MemberSignature Language="C#" Value="public bool IsInputMethodEnabled { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInputMethodEnabled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsInputMethodEnabled" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInputMethodEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInputMethodEnabled { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-519">Возвращает значение, определяющее, активирована ли система метода ввода, как [!INCLUDE[TLA#tla_ime](~/includes/tlasharptla-ime-md.md)], для обработки ввода для данного элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-519">Gets a value that indicates whether an input method system, such as an [!INCLUDE[TLA#tla_ime](~/includes/tlasharptla-ime-md.md)], is enabled for processing the input to this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="332d7-520">Значение <see langword="true" />, если метод ввода активен; в обратном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-520">
              <see langword="true" /> if an input method is active; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="332d7-521">Значение по умолчанию базового прикрепленного свойства — <see langword="true" />, однако это значение влияет состояние методов ввода во время выполнения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-521">The default value of the underlying attached property is <see langword="true" />; however, this value is influenced by the state of input methods at runtime.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-522">Это свойство возвращает значение, которое возвращается вложенное свойство <xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType> для в настоящий момент разрешенные методы ввода (клавиатуры, речи и других устройств ввода).</span><span class="sxs-lookup"><span data-stu-id="332d7-522">This property returns the value that is returned by the attached property <xref:System.Windows.Input.InputMethod.IsInputMethodEnabled%2A?displayProperty=nameWithType> for the currently enabled input methods (keyboard, speech, and other input devices).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocused">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocused { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocused" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsKeyboardFocused" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocused As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocused { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocused</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-523">Получает значение, указывающее, имеет ли данный элемент фокус клавиатуры.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-523">Gets a value that indicates whether this element has keyboard focus.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="332d7-524">
            <see langword="true" />, если на данном элементе установлен клавиатурный фокус; в противном случае — <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-524">
              <see langword="true" /> if this element has keyboard focus; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="332d7-525">Значение по умолчанию: <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-525">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsKeyboardFocused"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="332d7-526">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="332d7-526">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-527">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-527">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsKeyboardFocusedProperty>|  
|<span data-ttu-id="332d7-528">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="332d7-528">Metadata properties set to `true`</span></span>|<span data-ttu-id="332d7-529">Нет</span><span class="sxs-lookup"><span data-stu-id="332d7-529">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotFocus" />
        <altmember cref="E:System.Windows.ContentElement.LostFocus" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusedChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-530">Происходит при изменении значения свойства <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> данного элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-530">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-531">Этот член представляет [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] событий, не является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-531">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsKeyboardFocusedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-532">Идентифицирует свойство зависимостей <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-532">Identifies the <see cref="P:System.Windows.ContentElement.IsKeyboardFocused" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithin">
      <MemberSignature Language="C#" Value="public bool IsKeyboardFocusWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsKeyboardFocusWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsKeyboardFocusWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsKeyboardFocusWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsKeyboardFocusWithin { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsKeyboardFocusWithin</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-533">Возвращает значение, определяющее, находится ли клавиатурный фокус на элементе, или его дочерних элементах.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-533">Gets a value that indicates whether keyboard focus is anywhere within the element or child elements.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="332d7-534">
            <see langword="true" />, если клавиатурный фокус установлен на элементе или его дочерних элементах; в противном случае — <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-534">
              <see langword="true" /> if keyboard focus is on the element or its child elements; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="332d7-535">Значение по умолчанию: <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-535">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-536">Изменения значения этого свойства обычно вызывают <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> событие, если производный класс не переопределяет <xref:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged%2A> отключение события.</span><span class="sxs-lookup"><span data-stu-id="332d7-536">Changes to the value of this property typically raise the <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> event, unless a derived class has overridden <xref:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged%2A> to suppress the event.</span></span>  
  
 <span data-ttu-id="332d7-537">Это свойство не задано непосредственно, но можно перевести фокус на элемент, вызвав <xref:System.Windows.ContentElement.Focus%2A>, или путем создания <xref:System.Windows.ContentElement.MoveFocus%2A> запроса.</span><span class="sxs-lookup"><span data-stu-id="332d7-537">You do not set this property directly, but you can set the focus to the element by calling <xref:System.Windows.ContentElement.Focus%2A>, or by making a <xref:System.Windows.ContentElement.MoveFocus%2A> request.</span></span> <span data-ttu-id="332d7-538">Одно из этих вызовов метода может изменить значение этого свойства.</span><span class="sxs-lookup"><span data-stu-id="332d7-538">Either of these method calls might change this property value.</span></span>  
  
<a name="dependencyPropertyInfo_IsKeyboardFocusWithin"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="332d7-539">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="332d7-539">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-540">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-540">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsKeyboardFocusWithinProperty>|  
|<span data-ttu-id="332d7-541">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="332d7-541">Metadata properties set to `true`</span></span>|<span data-ttu-id="332d7-542">Нет</span><span class="sxs-lookup"><span data-stu-id="332d7-542">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsKeyboardFocusWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsKeyboardFocusWithinChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-543">Происходит при изменении значения свойства <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> данного элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-543">Occurs when the value of the <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-544">Этот член представляет [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] событий, не является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-544">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" />
      </Docs>
    </Member>
    <Member MemberName="IsKeyboardFocusWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsKeyboardFocusWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsKeyboardFocusWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsKeyboardFocusWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsKeyboardFocusWithinProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-545">Идентифицирует свойство зависимостей <see cref="P:System.Windows.ContentElement.IsKeyboardFocusWithin" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-545">Identifies the <see cref="P:System.Windows.ContentElement.IsKeyboardFocusWithin" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptured">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptured { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-546">Возвращает значение, определяющее, захвачена ли мышь данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-546">Gets a value that indicates whether the mouse is captured by this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="332d7-547">
            <see langword="true" />, если на элементе установлен захват мыши; в противном случае — <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-547">
              <see langword="true" /> if the element has mouse capture; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="332d7-548">Значение по умолчанию: <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-548">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-549">Состояние захвата мыши соотносится с операции перетаскивания и вставки в процессе.</span><span class="sxs-lookup"><span data-stu-id="332d7-549">Mouse capture state is related to in-process drag-and-drop operations.</span></span>  
  
<a name="dependencyPropertyInfo_IsMouseCaptured"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="332d7-550">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="332d7-550">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-551">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-551">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseCapturedProperty>|  
|<span data-ttu-id="332d7-552">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="332d7-552">Metadata properties set to `true`</span></span>|<span data-ttu-id="332d7-553">Нет</span><span class="sxs-lookup"><span data-stu-id="332d7-553">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="332d7-554">В следующем примере производится состояние захвата мыши или отключение основании уже записали мыши элементом.</span><span class="sxs-lookup"><span data-stu-id="332d7-554">The following example turns the mouse capture state on or off based on whether the mouse is already captured by the element.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#ismousecaptured)]
 [!code-vb[ContentElementsSmorgasbord#IsMouseCaptured](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#ismousecaptured)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
        <altmember cref="E:System.Windows.ContentElement.GotMouseCapture" />
        <altmember cref="E:System.Windows.ContentElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCapturedChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-555">Происходит при изменении значения свойства <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> данного элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-555">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-556">Этот член представляет [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] событий, не является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-556">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCapturedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-557">Идентифицирует свойство зависимостей <see cref="P:System.Windows.ContentElement.IsMouseCaptured" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-557">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseCaptured" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsMouseCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseCaptureWithin { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-558">Получает значение, определяющее, удерживается ли захват мыши данным элементом или дочерними элементами в его дереве элементов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-558">Gets a value that determines whether mouse capture is held by this element or by child elements in its element tree.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="332d7-559">Значение <see langword="true" />, если этот элемент или содержащийся в нем элемент удерживают захват мыши; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-559">
              <see langword="true" /> if this element or a contained element has mouse capture; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="332d7-560">Значение по умолчанию: <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-560">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="dependencyPropertyInfo_IsMouseCaptureWithin"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="332d7-561">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="332d7-561">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-562">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-562">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseCaptureWithinProperty>|  
|<span data-ttu-id="332d7-563">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="332d7-563">Metadata properties set to `true`</span></span>|<span data-ttu-id="332d7-564">Нет</span><span class="sxs-lookup"><span data-stu-id="332d7-564">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
        <altmember cref="M:System.Windows.ContentElement.CaptureMouse" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseCaptureWithinChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-565">Происходит при изменении значения поля <see cref="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" /> данного элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-565">Occurs when the value of the <see cref="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" /> changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-566">Этот член представляет [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] событий, не является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-566">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseCaptureWithinProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-567">Идентифицирует свойство зависимостей <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-567">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsMouseDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseDirectlyOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-568">Возвращает значение, указывающее, соответствует ли позиция указателя мыши результатам проверки нажатия, при которой учитывается компоновка элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-568">Gets a value that indicates whether the position of the mouse pointer corresponds to hit test results, which take element compositing into account.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="332d7-569">
            <see langword="true" /> Если указатель мыши находится над тем же элементом проверки нажатия; в противном случае <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-569">
              <see langword="true" /> if the mouse pointer is over the same element result as a hit test; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="332d7-570">Значение по умолчанию: <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-570">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-571">В отличие от <xref:System.Windows.ContentElement.IsMouseOver%2A>, это свойство доступно только `true` если указатель мыши находится над элементом литерал, как и для проверки нажатия.</span><span class="sxs-lookup"><span data-stu-id="332d7-571">Unlike <xref:System.Windows.ContentElement.IsMouseOver%2A>, this property is only `true` if the mouse pointer is over the literal element—as it is for a hit test.</span></span> <span data-ttu-id="332d7-572">Если указатель мыши находится над дочерним элементом, в частности по элементам, которые являются частью глубокого шаблона элемента и его композиции, это свойство будет `false`.</span><span class="sxs-lookup"><span data-stu-id="332d7-572">If the mouse pointer is instead over a child element, in particular over elements that are part of an element's deeper template and compositing, this property will be `false`.</span></span> <span data-ttu-id="332d7-573">Если вы не знаете как составного элемента управления (например, используется это свойство в пользовательский шаблон элемента управления для элемента управления, можно определить), это свойство может возвращать непредвиденные результаты.</span><span class="sxs-lookup"><span data-stu-id="332d7-573">Unless you know how a control is composited (for example, you use this property in a custom control template for a control that you define), this property might return unexpected results.</span></span> <span data-ttu-id="332d7-574">В большинстве сценариев, где вы не создаете элементы управления, использовать <xref:System.Windows.ContentElement.IsMouseOver%2A> вместо него.</span><span class="sxs-lookup"><span data-stu-id="332d7-574">For most scenarios where you are not authoring controls, use <xref:System.Windows.ContentElement.IsMouseOver%2A> instead.</span></span>  
  
 <span data-ttu-id="332d7-575">Если мышь захвачена элементом, и это свойство является `true` во время записи, это свойство будет продолжать возвращать `true` пока захват мыши не будет потерян и указатель не выйдет за границы элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-575">If the mouse is captured by this element, and this property is `true` at time of capture, this property will continue to return `true` until mouse capture is lost and the pointer is not over its bounds.</span></span>  
  
<a name="dependencyPropertyInfo_IsMouseDirectlyOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="332d7-576">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="332d7-576">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-577">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-577">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseDirectlyOverProperty>|  
|<span data-ttu-id="332d7-578">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="332d7-578">Metadata properties set to `true`</span></span>|<span data-ttu-id="332d7-579">Нет</span><span class="sxs-lookup"><span data-stu-id="332d7-579">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsMouseDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsMouseDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsMouseDirectlyOverChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-580">Происходит при изменении значения свойства <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> данного элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-580">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-581">Этот член представляет [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] событий, не является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-581">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseDirectlyOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-582">Идентифицирует свойство зависимостей <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-582">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOver">
      <MemberSignature Language="C#" Value="public bool IsMouseOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMouseOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsMouseOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMouseOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMouseOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsMouseOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-583">Возвращает значение, определяющее, находится ли указатель мыши на элементе (включая видимые дочерние элементы и композицию элемента управления).</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-583">Gets a value that indicates whether the mouse pointer is located over this element (including visual child elements, or its control compositing).</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="332d7-584">Значение <see langword="true" />, если указатель мыши находится на элементе или его дочерних элементах; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-584">
              <see langword="true" /> if mouse pointer is over the element or its child elements; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="332d7-585">Значение по умолчанию: <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-585">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-586">Несмотря на то, что аналогичные события «IsMouseOverChanged» не существует, выполните несколько схожих событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-586">Although an analogous "IsMouseOverChanged" event does not exist, several similar events do.</span></span> <span data-ttu-id="332d7-587">Например, можно использовать <xref:System.Windows.ContentElement.MouseEnter>, <xref:System.Windows.ContentElement.MouseMove>, и <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>.</span><span class="sxs-lookup"><span data-stu-id="332d7-587">For example, you can use <xref:System.Windows.ContentElement.MouseEnter>, <xref:System.Windows.ContentElement.MouseMove>, and <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged>.</span></span>  
  
 <span data-ttu-id="332d7-588">При захвате мыши данным элементом, это свойство остается `true` пока захват мыши не будет потерян и указатель мыши покидает границы элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-588">If this element captures the mouse, this property remains `true` until mouse capture is lost and the mouse pointer leaves the element bounds.</span></span>  
  
<a name="dependencyPropertyInfo_IsMouseOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="332d7-589">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="332d7-589">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-590">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-590">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsMouseOverProperty>|  
|<span data-ttu-id="332d7-591">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="332d7-591">Metadata properties set to `true`</span></span>|<span data-ttu-id="332d7-592">Нет</span><span class="sxs-lookup"><span data-stu-id="332d7-592">None</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="332d7-593">В следующем примере создается стиль, который содержит метод задания свойства, которое дает другое поведение visual при <xref:System.Windows.Documents.Hyperlink> отчеты <xref:System.Windows.ContentElement.IsMouseOver%2A> `true`.</span><span class="sxs-lookup"><span data-stu-id="332d7-593">The following example creates a style that includes a property setter that gives an alternate visual behavior when a <xref:System.Windows.Documents.Hyperlink> reports <xref:System.Windows.ContentElement.IsMouseOver%2A> `true`.</span></span>  
  
 [!code-xaml[ContentElementsSmorgasbord#IsEnabledIsMouseOver](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml#isenabledismouseover)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsMouseOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsMouseOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsMouseOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsMouseOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsMouseOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsMouseOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-594">Идентифицирует свойство зависимостей <see cref="P:System.Windows.ContentElement.IsMouseOver" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-594">Identifies the <see cref="P:System.Windows.ContentElement.IsMouseOver" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptured">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptured As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptured { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusCaptured</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-595">Получает значение, указывающее, захвачено ли перо в этом элементе управления.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-595">Gets a value that indicates whether the stylus is captured to this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="332d7-596">
            <see langword="true" />, если элемент получил захват пера; в противном случае — <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-596">
              <see langword="true" /> if the element has stylus capture; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="332d7-597">Значение по умолчанию: <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-597">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-598">Сенсорный ввод, мышь и ввод от пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="332d7-598">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="332d7-599">Дополнительные сведения см. в разделе [фокусе](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-599">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusCaptured"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="332d7-600">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="332d7-600">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-601">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-601">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusCapturedProperty>|  
|<span data-ttu-id="332d7-602">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="332d7-602">Metadata properties set to `true`</span></span>|<span data-ttu-id="332d7-603">Нет</span><span class="sxs-lookup"><span data-stu-id="332d7-603">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.CaptureStylus" />
        <altmember cref="E:System.Windows.ContentElement.GotStylusCapture" />
        <altmember cref="E:System.Windows.ContentElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCapturedChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusCapturedChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCapturedChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCapturedChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-604">Происходит при изменении значения свойства <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> данного элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-604">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-605">Этот член представляет [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] событий, не является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-605">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCapturedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCapturedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCapturedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusCapturedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCapturedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCapturedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-606">Идентифицирует свойство зависимостей <see cref="P:System.Windows.ContentElement.IsStylusCaptured" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-606">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusCaptured" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithin">
      <MemberSignature Language="C#" Value="public bool IsStylusCaptureWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusCaptureWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusCaptureWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusCaptureWithin As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusCaptureWithin { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-607">Возвращает значение, определяющее, захвачено ли перо этим элементом, включая его дочерние элементы и композицию элемента управления.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-607">Gets a value that determines whether stylus capture is held by this element, including child elements and control compositing.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="332d7-608">
            <see langword="true" /> если перо захвачено данным элементом; иначе, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-608">
              <see langword="true" /> if stylus capture is held within this element; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-609">Сенсорный ввод, мышь и ввод от пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="332d7-609">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="332d7-610">Дополнительные сведения см. в разделе [фокусе](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-610">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusCaptureWithin"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="332d7-611">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="332d7-611">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-612">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-612">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusCaptureWithinProperty>|  
|<span data-ttu-id="332d7-613">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="332d7-613">Metadata properties set to `true`</span></span>|<span data-ttu-id="332d7-614">Нет</span><span class="sxs-lookup"><span data-stu-id="332d7-614">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusCaptureWithinChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusCaptureWithinChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusCaptureWithinChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-615">Происходит при изменении значения свойства <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> данного элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-615">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-616">Этот член представляет [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] событий, не является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-616">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusCaptureWithinProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusCaptureWithinProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusCaptureWithinProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusCaptureWithinProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusCaptureWithinProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusCaptureWithinProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-617">Идентифицирует свойство зависимостей <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-617">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusCaptureWithin" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOver">
      <MemberSignature Language="C#" Value="public bool IsStylusDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusDirectlyOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusDirectlyOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusDirectlyOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-618">Возвращает значение, указывающее, соответствует ли позиция пера результатам проверки нажатия, при которой учитывается компоновка элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-618">Gets a value that indicates whether the stylus position corresponds to hit test results, which take element compositing into account.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="332d7-619">
            <see langword="true" /> если проверка подтверждает результаты проверки нажатия; иначе, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-619">
              <see langword="true" /> if the stylus is over the same element as a hit test; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="332d7-620">Значение по умолчанию: <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-620">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-621">В отличие от <xref:System.Windows.ContentElement.IsStylusOver%2A>, это свойство доступно только `true` если перо находится над элементом.</span><span class="sxs-lookup"><span data-stu-id="332d7-621">Unlike <xref:System.Windows.ContentElement.IsStylusOver%2A>, this property is only `true` if the stylus is over the element.</span></span> <span data-ttu-id="332d7-622">Если перо находится над дочерним элементом или над элементами, которые являются частью глубокой композиции элемента, это свойство будет `false`.</span><span class="sxs-lookup"><span data-stu-id="332d7-622">If the stylus is instead over a child element or over elements that are part of an element's deeper compositing, this property will be `false`.</span></span>  
  
 <span data-ttu-id="332d7-623">Если вы не знаете как составного элемента управления (например, используется это свойство в пользовательский шаблон элемента управления для элемента управления, можно определить), это свойство может возвращать непредвиденные результаты.</span><span class="sxs-lookup"><span data-stu-id="332d7-623">Unless you know how a control is composited (for example, you use this property in a custom control template for a control that you define), this property might return unexpected results.</span></span> <span data-ttu-id="332d7-624">В большинстве сценариев, где вы не создаете элементы управления, использовать <xref:System.Windows.ContentElement.IsStylusOver%2A> вместо него.</span><span class="sxs-lookup"><span data-stu-id="332d7-624">For most scenarios where you are not authoring controls, use <xref:System.Windows.ContentElement.IsStylusOver%2A> instead.</span></span>  
  
 <span data-ttu-id="332d7-625">Если этот элемент имеет захват пера, и это свойство является `true` во время записи, это свойство остается `true` пока не будет освобождено и перо не выйдет за границы элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-625">If this element has stylus capture and this property is `true` at the time of capture, this property remains `true` until stylus capture is lost and the stylus is not over its bounds.</span></span>  
  
 <span data-ttu-id="332d7-626">Сенсорный ввод, мышь и ввод от пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="332d7-626">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="332d7-627">Дополнительные сведения см. в разделе [фокусе](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-627">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusDirectlyOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="332d7-628">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="332d7-628">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-629">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-629">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusDirectlyOverProperty>|  
|<span data-ttu-id="332d7-630">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="332d7-630">Metadata properties set to `true`</span></span>|<span data-ttu-id="332d7-631">Нет</span><span class="sxs-lookup"><span data-stu-id="332d7-631">None</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseDirectlyOver" />
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler IsStylusDirectlyOverChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event IsStylusDirectlyOverChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ IsStylusDirectlyOverChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-632">Происходит при изменении значения свойства <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> данного элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-632">Occurs when the value of the <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> property changes on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-633">Этот член представляет [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] событий, не является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-633">This member is a [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] event, not a routed event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusDirectlyOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusDirectlyOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusDirectlyOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusDirectlyOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusDirectlyOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusDirectlyOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-634">Идентифицирует свойство зависимостей <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-634">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusDirectlyOver" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOver">
      <MemberSignature Language="C#" Value="public bool IsStylusOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsStylusOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.IsStylusOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsStylusOver As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsStylusOver { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IInputElement.IsStylusOver</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-635">Возвращает значение, определяющее, находится ли перо на элементе (включая видимые дочерние элементы).</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-635">Gets a value that indicates whether the stylus is located over this element (including visual child elements).</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="332d7-636">
            <see langword="true" />, если перо находится на элементе, или его дочерних элементах; иначе, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-636">
              <see langword="true" /> if the stylus is over the element or its child elements; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="332d7-637">Значение по умолчанию: <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-637">The default is <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-638">Если этот элемент имеет захват пера, это свойство остается `true` пока не будет освобождено и указатель мыши выходит за его границы.</span><span class="sxs-lookup"><span data-stu-id="332d7-638">If this element has stylus capture, this property remains `true` until stylus capture is lost and the pointer is out of its bounds.</span></span>  
  
 <span data-ttu-id="332d7-639">Сенсорный ввод, мышь и ввод от пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="332d7-639">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="332d7-640">Дополнительные сведения см. в разделе [фокусе](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-640">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="dependencyPropertyInfo_IsStylusOver"></a>   
## <a name="dependency-property-information"></a><span data-ttu-id="332d7-641">Сведения о свойстве зависимостей</span><span class="sxs-lookup"><span data-stu-id="332d7-641">Dependency Property Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-642">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-642">Identifier field</span></span>|<xref:System.Windows.ContentElement.IsStylusOverProperty>|  
|<span data-ttu-id="332d7-643">Значение свойства метаданных `true`</span><span class="sxs-lookup"><span data-stu-id="332d7-643">Metadata properties set to `true`</span></span>|<span data-ttu-id="332d7-644">Нет</span><span class="sxs-lookup"><span data-stu-id="332d7-644">None</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsStylusOverProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsStylusOverProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsStylusOverProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.IsStylusOverProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsStylusOverProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsStylusOverProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-645">Идентифицирует свойство зависимостей <see cref="P:System.Windows.ContentElement.IsStylusOver" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-645">Identifies the <see cref="P:System.Windows.ContentElement.IsStylusOver" /> dependency property.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.KeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-646">Возникает при нажатии клавиши, если фокус установлен на данном элементе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-646">Occurs when a key is pressed while focus is on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-647">Обработка клавиш взаимодействует с другими функциями платформы, такие как выполнение команд и композиция текста.</span><span class="sxs-lookup"><span data-stu-id="332d7-647">Key handling interacts with other platform features such as commanding and text composition.</span></span> <span data-ttu-id="332d7-648"><xref:System.Windows.ContentElement.KeyDown> Событие является событием входной текст нижнего уровня, могут работать некорректно, в некоторых элементах управления.</span><span class="sxs-lookup"><span data-stu-id="332d7-648">The <xref:System.Windows.ContentElement.KeyDown> event is a lower-level text input event that might not behave as expected on certain controls.</span></span> <span data-ttu-id="332d7-649">Это так, как некоторые элементы управления имеют композиции элементов управления или обработку ввода обработку класса, который предоставляет более высокого уровня версия текста, а также связанные события.</span><span class="sxs-lookup"><span data-stu-id="332d7-649">This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</span></span>  
  
 <span data-ttu-id="332d7-650">Это событие создается псевдоним для <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.KeyDown> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-650">This event creates an alias for the <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> attached event for this class so that <xref:System.Windows.ContentElement.KeyDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-651">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.KeyDown> событий присоединяются к базовому объекту <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-651">Event handlers that are attached to the <xref:System.Windows.ContentElement.KeyDown> event are attached to the underlying <xref:System.Windows.Input.Keyboard.KeyDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_KeyDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-652">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-652">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-653">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-653">Identifier field</span></span>|<xref:System.Windows.ContentElement.KeyDownEvent>|  
|<span data-ttu-id="332d7-654">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-654">Routing strategy</span></span>|<span data-ttu-id="332d7-655">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-655">Bubbling</span></span>|  
|<span data-ttu-id="332d7-656">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-656">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="332d7-657">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewKeyDown>.</span><span class="sxs-lookup"><span data-stu-id="332d7-657">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewKeyDown>.</span></span>  
  
-   <span data-ttu-id="332d7-658">Переопределить <xref:System.Windows.ContentElement.OnKeyDown%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-658">Override <xref:System.Windows.ContentElement.OnKeyDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="KeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.KeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-659">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.KeyDown" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-659">Identifies the <see cref="E:System.Windows.ContentElement.KeyDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-660">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-660">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-661">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-661">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-662">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-662">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-663">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-663">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-664">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-664">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler KeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler KeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.KeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event KeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ KeyUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.KeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-665">Происходит при отпускании клавиши, если фокус находится на этом элементе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-665">Occurs when a key is released while focus is on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-666">Это событие создается псевдоним для <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.KeyUp> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-666">This event creates an alias for the <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> attached event for this class so that  <xref:System.Windows.ContentElement.KeyUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-667">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.KeyUp> событий присоединяются к базовому объекту <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-667">Event handlers that are attached to the <xref:System.Windows.ContentElement.KeyUp> event are attached to the underlying <xref:System.Windows.Input.Keyboard.KeyUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_KeyUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-668">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-668">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-669">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-669">Identifier field</span></span>|<xref:System.Windows.ContentElement.KeyUpEvent>|  
|<span data-ttu-id="332d7-670">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-670">Routing strategy</span></span>|<span data-ttu-id="332d7-671">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-671">Bubbling</span></span>|  
|<span data-ttu-id="332d7-672">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-672">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="332d7-673">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewKeyUp>.</span><span class="sxs-lookup"><span data-stu-id="332d7-673">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewKeyUp>.</span></span>  
  
-   <span data-ttu-id="332d7-674">Переопределить <xref:System.Windows.ContentElement.OnKeyUp%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-674">Override <xref:System.Windows.ContentElement.OnKeyUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="KeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent KeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent KeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.KeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly KeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ KeyUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-675">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.KeyUp" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-675">Identifies the <see cref="E:System.Windows.ContentElement.KeyUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-676">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-676">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-677">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-677">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-678">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-678">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-679">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-679">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-680">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-680">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler LostFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler LostFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostFocus As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ LostFocus;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-681">Происходит при потере данным элементом логического фокуса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-681">Occurs when this element loses logical focus.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-682">Логический фокус отличается от фокуса ввода, если фокус был намеренно вытеснен посредством вызова метода, но на другом уровне существует предыдущий фокус ввода.</span><span class="sxs-lookup"><span data-stu-id="332d7-682">Logical focus differs from keyboard focus if focus is deliberately forced away by using a method call but the previous keyboard focus exists in a different scope.</span></span> <span data-ttu-id="332d7-683">В этом сценарии, остается фокус клавиатуры, там, где это и элемент где <xref:System.Windows.ContentElement.Focus%2A> вызывается метод по-прежнему возвращает логический фокус.</span><span class="sxs-lookup"><span data-stu-id="332d7-683">In this scenario, keyboard focus remains where it is, and the element where a <xref:System.Windows.ContentElement.Focus%2A> method is called still gets logical focus.</span></span>  
  
 <span data-ttu-id="332d7-684">Точнее интерпретацию этого события является что он вызывается, когда значение <xref:System.Windows.ContentElement.IsFocused%2A> изменяет свойства элемента в маршруте с `true` для `false`.</span><span class="sxs-lookup"><span data-stu-id="332d7-684">A more precise interpretation of this event is that it is raised when the value of the <xref:System.Windows.ContentElement.IsFocused%2A> property of an element in the route changes from `true` to `false`.</span></span>  
  
 <span data-ttu-id="332d7-685">Вследствие этого события восходящей маршрутизации, элемент, который теряет фокус может быть дочерний элемент, а не элемента, которому фактически присоединен обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-685">Because this event uses bubbling routing, the element that loses focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="332d7-686">Проверьте <xref:System.Windows.RoutedEventArgs.Source%2A> в данных события, чтобы определить фактический элемент, полученные фокус.</span><span class="sxs-lookup"><span data-stu-id="332d7-686">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that gained focus.</span></span>  
  
<a name="routedEventInfo_LostFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-687">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-687">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-688">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-688">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostFocusEvent>|  
|<span data-ttu-id="332d7-689">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-689">Routing strategy</span></span>|<span data-ttu-id="332d7-690">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-690">Bubbling</span></span>|  
|<span data-ttu-id="332d7-691">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-691">Delegate</span></span>|<xref:System.Windows.RoutedEventHandler>|  
  
-   <span data-ttu-id="332d7-692">Нет соответствующего туннелирования события.</span><span class="sxs-lookup"><span data-stu-id="332d7-692">There is no corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="332d7-693">Переопределить <xref:System.Windows.ContentElement.OnLostFocus%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-693">Override <xref:System.Windows.ContentElement.OnLostFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="LostFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-694">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.LostFocus" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-694">Identifies the <see cref="E:System.Windows.ContentElement.LostFocus" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-695">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-695">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-696">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-696">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-697">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-697">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-698">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-698">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-699">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-699">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler LostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ LostKeyboardFocus;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-700">Происходит при потере данным элементом фокуса ввода с клавиатуры.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-700">Occurs when the keyboard is no longer focused on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-701">Вследствие этого события восходящей маршрутизации, элемент, который потерял фокус ввода может быть дочерний элемент, а не элемента, которому фактически присоединен обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-701">Because this event uses bubbling routing, the element that lost focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="332d7-702">Проверьте <xref:System.Windows.RoutedEventArgs.Source%2A> в данных события, чтобы определить фактический элемент, который теряет фокус.</span><span class="sxs-lookup"><span data-stu-id="332d7-702">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost focus.</span></span>  
  
 <span data-ttu-id="332d7-703">Это событие создается псевдоним для <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.LostKeyboardFocus> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-703">This event creates an alias for the <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.LostKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-704">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.LostKeyboardFocus> событий присоединяются к базовому объекту <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-704">Event handlers that are attached to the <xref:System.Windows.ContentElement.LostKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.LostKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_LostKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-705">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-705">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-706">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-706">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostKeyboardFocusEvent>|  
|<span data-ttu-id="332d7-707">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-707">Routing strategy</span></span>|<span data-ttu-id="332d7-708">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-708">Bubbling</span></span>|  
|<span data-ttu-id="332d7-709">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-709">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="332d7-710">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>.</span><span class="sxs-lookup"><span data-stu-id="332d7-710">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="332d7-711">Переопределить <xref:System.Windows.ContentElement.OnLostKeyboardFocus%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-711">Override <xref:System.Windows.ContentElement.OnLostKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostKeyboardFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-712">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.LostKeyboardFocus" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-712">Identifies the <see cref="E:System.Windows.ContentElement.LostKeyboardFocus" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-713">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-713">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-714">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-714">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-715">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-715">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-716">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-716">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-717">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-717">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler LostMouseCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler LostMouseCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostMouseCapture As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ LostMouseCapture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-718">Происходит при потере элементом захвата мыши.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-718">Occurs when this element loses mouse capture.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-719">При захвате мыши элементом, он получает ввод от мыши, даже если указатель находится вне границ элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-719">When an element captures the mouse, it receives mouse input even if the pointer is outside its bounds.</span></span> <span data-ttu-id="332d7-720">Мышь обычно захватывается только во время операции перетаскивания и вставки.</span><span class="sxs-lookup"><span data-stu-id="332d7-720">The mouse is typically captured only during drag-and-drop operations.</span></span>  
  
 <span data-ttu-id="332d7-721">Вследствие этого события восходящей маршрутизации, элемент, который теряет захват может быть дочерний элемент, а не элемента, которому фактически присоединен обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-721">Because this event uses bubbling routing, the element that loses capture might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="332d7-722">Проверьте <xref:System.Windows.RoutedEventArgs.Source%2A> в данных события, чтобы определить фактический элемент, который потерял отслеживания.</span><span class="sxs-lookup"><span data-stu-id="332d7-722">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost capture.</span></span>  
  
 <span data-ttu-id="332d7-723">Это событие создается псевдоним для <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.LostMouseCapture> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-723">This event creates an alias for the <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.LostMouseCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-724">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.LostMouseCapture> событий присоединяются к базовому объекту <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-724">Event handlers that are attached to the <xref:System.Windows.ContentElement.LostMouseCapture> event are attached to the underlying <xref:System.Windows.Input.Mouse.LostMouseCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_LostMouseCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-725">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-725">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-726">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-726">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostMouseCaptureEvent>|  
|<span data-ttu-id="332d7-727">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-727">Routing strategy</span></span>|<span data-ttu-id="332d7-728">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-728">Bubbling</span></span>|  
|<span data-ttu-id="332d7-729">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-729">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="332d7-730">Нет определенного события, соответствующие туннелирования.</span><span class="sxs-lookup"><span data-stu-id="332d7-730">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="332d7-731">Переопределить <xref:System.Windows.ContentElement.OnLostMouseCapture%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-731">Override <xref:System.Windows.ContentElement.OnLostMouseCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostMouseCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostMouseCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostMouseCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostMouseCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostMouseCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostMouseCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-732">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.LostMouseCapture" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-732">Identifies the <see cref="E:System.Windows.ContentElement.LostMouseCapture" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-733">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-733">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-734">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-734">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-735">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-735">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-736">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-736">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-737">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-737">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCapture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler LostStylusCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler LostStylusCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostStylusCapture As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ LostStylusCapture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.LostStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-738">Происходит при потере элементом захвата пера.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-738">Occurs when this element loses stylus capture.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-739">При захвате пера элементом, он получает ввод от пера, даже если указатель находится вне границ элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-739">When an element captures the stylus, it receives stylus input even if the pointer is outside its bounds.</span></span> <span data-ttu-id="332d7-740">Перо обычно захватывается только во время операции перетаскивания и вставки.</span><span class="sxs-lookup"><span data-stu-id="332d7-740">The stylus is typically captured only during drag-and-drop operations.</span></span>  
  
 <span data-ttu-id="332d7-741">Вследствие этого события восходящей маршрутизации, элемент, который теряет фокус может быть дочерний элемент, а не элемента, которому фактически присоединен обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-741">Because this event uses bubbling routing, the element that loses focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="332d7-742">Проверьте <xref:System.Windows.RoutedEventArgs.Source%2A> в данных события, чтобы определить фактический элемент, который теряет фокус.</span><span class="sxs-lookup"><span data-stu-id="332d7-742">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost focus.</span></span>  
  
 <span data-ttu-id="332d7-743">Это событие создается псевдоним для <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.LostStylusCapture> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-743">This event creates an alias for the <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.LostStylusCapture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-744">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.LostStylusCapture> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-744">Event handlers that are attached to the <xref:System.Windows.ContentElement.LostStylusCapture> event are attached to the underlying <xref:System.Windows.Input.Stylus.LostStylusCapture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_LostStylusCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-745">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-745">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-746">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-746">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostStylusCaptureEvent>|  
|<span data-ttu-id="332d7-747">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-747">Routing strategy</span></span>|<span data-ttu-id="332d7-748">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-748">Bubbling</span></span>|  
|<span data-ttu-id="332d7-749">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-749">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="332d7-750">Нет определенного события, соответствующие туннелирования.</span><span class="sxs-lookup"><span data-stu-id="332d7-750">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="332d7-751">Переопределить <xref:System.Windows.ContentElement.OnLostStylusCapture%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-751">Override <xref:System.Windows.ContentElement.OnLostStylusCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostStylusCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostStylusCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostStylusCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostStylusCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostStylusCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostStylusCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-752">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.LostStylusCapture" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-752">Identifies the <see cref="E:System.Windows.ContentElement.LostStylusCapture" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-753">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-753">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-754">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-754">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-755">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-755">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-756">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-756">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-757">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-757">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCapture">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; LostTouchCapture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; LostTouchCapture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.LostTouchCapture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LostTouchCapture As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ LostTouchCapture;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-758">Происходит, когда элемент теряет касание.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-758">Occurs when this element loses a touch capture.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_LostTouchCapture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-759">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-759">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-760">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-760">Identifier field</span></span>|<xref:System.Windows.ContentElement.LostTouchCaptureEvent>|  
|<span data-ttu-id="332d7-761">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-761">Routing strategy</span></span>|<span data-ttu-id="332d7-762">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-762">Bubbling</span></span>|  
|<span data-ttu-id="332d7-763">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-763">Delegate</span></span>|<span data-ttu-id="332d7-764"><xref:System.EventHandler%601> имеет тип данных <xref:System.Windows.Input.TouchEventArgs>.</span><span class="sxs-lookup"><span data-stu-id="332d7-764"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="332d7-765">Переопределить <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-765">Override <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LostTouchCaptureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LostTouchCaptureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LostTouchCaptureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.LostTouchCaptureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LostTouchCaptureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LostTouchCaptureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-766">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.LostTouchCapture" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-766">Identifies the <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-767">Происходит при нажатии любой кнопки мыши в тот момент, когда указатель мыши находится над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-767">Occurs when any mouse button is pressed while the pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-768">Это событие создается псевдоним для <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.MouseDown> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-768">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-769">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.MouseDown> событий присоединяются к базовому объекту <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-769">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseDown> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="332d7-770"><xref:System.Windows.ContentElement.MouseDown> Событие часто возникает вместе с либо <xref:System.Windows.ContentElement.MouseLeftButtonDown> или <xref:System.Windows.ContentElement.MouseRightButtonDown>, которые соответствуют нажмите одну из двух кнопок мыши стандартные.</span><span class="sxs-lookup"><span data-stu-id="332d7-770">The <xref:System.Windows.ContentElement.MouseDown> event is often raised together with either <xref:System.Windows.ContentElement.MouseLeftButtonDown> or <xref:System.Windows.ContentElement.MouseRightButtonDown>, which correspond to a press of one of the two standard mouse buttons.</span></span> <span data-ttu-id="332d7-771"><xref:System.Windows.ContentElement.MouseLeftButtonDown> и <xref:System.Windows.ContentElement.MouseRightButtonDown> также перенаправленные события, но они являются прямой перенаправленные события, и возникает соответствующее событие кнопками при <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> событий достигает этого элемента на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-771"><xref:System.Windows.ContentElement.MouseLeftButtonDown> and <xref:System.Windows.ContentElement.MouseRightButtonDown> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="332d7-772">См. заметки для <xref:System.Windows.ContentElement.MouseLeftButtonDown> или <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span><span class="sxs-lookup"><span data-stu-id="332d7-772">See Remarks for <xref:System.Windows.ContentElement.MouseLeftButtonDown> or <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="332d7-773">Несколько <xref:System.Windows.ContentElement> производным классам, характеризующимся наличием поведение элемента управления, например, <xref:System.Windows.Documents.Hyperlink>, может быть реализована собственная обработка событий кнопки мыши.</span><span class="sxs-lookup"><span data-stu-id="332d7-773">A few <xref:System.Windows.ContentElement> derived classes that have control-like behavior, for example, <xref:System.Windows.Documents.Hyperlink>, might have inherent class handling for mouse button events.</span></span> <span data-ttu-id="332d7-774">Событие нажатия кнопки мыши является наиболее вероятным событием с обработкой классов в элементе управления.</span><span class="sxs-lookup"><span data-stu-id="332d7-774">The left mouse button down event is the most likely event to have class handling in a control.</span></span> <span data-ttu-id="332d7-775">Обработчик часто класса помечает базовый <xref:System.Windows.Input.Mouse> класс событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-775">The class handling often marks the underlying <xref:System.Windows.Input.Mouse> class event as handled.</span></span> <span data-ttu-id="332d7-776">Когда событие помечено как обработанное, другие обработчики экземпляра, присоединенные к данному элементу, не инициируются.</span><span class="sxs-lookup"><span data-stu-id="332d7-776">Once the event is marked handled, other instance handlers that are attached to that element are not ordinarily raised.</span></span> <span data-ttu-id="332d7-777">Любые другие обработчики класса или экземпляра, присоединенные к элементам в восходящем направлении к корню дерева пользовательского интерфейса, также обычно не инициируются.</span><span class="sxs-lookup"><span data-stu-id="332d7-777">Any other class or instance handlers that are attached to elements in the bubbling direction towards the root in the UI tree are also not ordinarily raised.</span></span>  
  
 <span data-ttu-id="332d7-778">Можно устранить проблему, описанную в Важном и по-прежнему получать <xref:System.Windows.ContentElement.MouseDown> событий для кнопки мыши в производном классе с обработкой класса с помощью любого из следующих решений:</span><span class="sxs-lookup"><span data-stu-id="332d7-778">You can resolve the issue that is outlined in the preceding Important and still receive <xref:System.Windows.ContentElement.MouseDown> events for left mouse button down events on a derived class that has class handling by using either of these solutions:</span></span>  
  
-   <span data-ttu-id="332d7-779">Присоединение обработчиков для <xref:System.Windows.ContentElement.PreviewMouseDown> события, который не помечен как обработанное в элементах управления.</span><span class="sxs-lookup"><span data-stu-id="332d7-779">Attach handlers for the <xref:System.Windows.ContentElement.PreviewMouseDown> event, which is not marked as handled by the controls.</span></span> <span data-ttu-id="332d7-780">Обратите внимание, что это события предварительного просмотра, маршрут начинается с корневого элемента следует к элементу управления.</span><span class="sxs-lookup"><span data-stu-id="332d7-780">Notice that because this is a preview event, the route starts at the root and tunnels down to the control.</span></span>  
  
-   <span data-ttu-id="332d7-781">Зарегистрируйте обработчик в элементе управления с помощью процедур, вызвав <xref:System.Windows.ContentElement.AddHandler%2A> и выбрав параметр подписи, который позволяет обработчикам прослушивать события, даже если они помечены как обработанное в данные о событии.</span><span class="sxs-lookup"><span data-stu-id="332d7-781">Register a handler on the control procedurally by calling <xref:System.Windows.ContentElement.AddHandler%2A> and choosing the signature option that enables handlers to listen for events even if they are already marked as handled in the routed event data.</span></span>  
  
<a name="routedEventInfo_MouseDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-782">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-782">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-783">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-783">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseDownEvent>|  
|<span data-ttu-id="332d7-784">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-784">Routing strategy</span></span>|<span data-ttu-id="332d7-785">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-785">Bubbling</span></span>|  
|<span data-ttu-id="332d7-786">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-786">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="332d7-787">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewMouseDown>.</span><span class="sxs-lookup"><span data-stu-id="332d7-787">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseDown>.</span></span>  
  
-   <span data-ttu-id="332d7-788">Переопределить <xref:System.Windows.ContentElement.OnMouseDown%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-788">Override <xref:System.Windows.ContentElement.OnMouseDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-789">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.MouseDown" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-789">Identifies the <see cref="E:System.Windows.ContentElement.MouseDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-790">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-790">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-791">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-791">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-792">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-792">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-793">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-793">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-794">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-794">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseEnter As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseEnter;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-795">Происходит, когда указатель мыши попадает внутрь границ данного элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-795">Occurs when the mouse pointer enters the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-796"><xref:System.Windows.ContentElement.MouseEnter> — [направлено Общие сведения о событиях](~/docs/framework/wpf/advanced/routed-events-overview.md) , использующий прямой обработки стратегия маршрутизации события.</span><span class="sxs-lookup"><span data-stu-id="332d7-796"><xref:System.Windows.ContentElement.MouseEnter> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="332d7-797">Прямые перенаправленные события не вызываются по маршруту; Вместо этого они обрабатываются в том же элементе где они возникли.</span><span class="sxs-lookup"><span data-stu-id="332d7-797">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="332d7-798">Тем не менее они включают другие аспекты поведения маршрутизируемых событий, например триггеры событий в стилях.</span><span class="sxs-lookup"><span data-stu-id="332d7-798">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="332d7-799">Несмотря на то что <xref:System.Windows.ContentElement.MouseEnter> отслеживает момент, когда указатель мыши попадает внутрь границ элемента, это событие больше о том, что буквально <xref:System.Windows.ContentElement.IsMouseOver%2A> значение свойства было изменено с `false` для `true` для этого элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-799">Although <xref:System.Windows.ContentElement.MouseEnter> tracks when the mouse pointer enters the bounds of an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsMouseOver%2A> property value has changed from `false` to `true` on this element.</span></span>  
  
 <span data-ttu-id="332d7-800">Это событие создается псевдоним для <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.MouseEnter> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-800">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseEnter> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-801">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.MouseEnter> событий присоединяются к базовому объекту <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-801">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseEnter> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-802">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-802">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-803">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-803">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseEnterEvent>|  
|<span data-ttu-id="332d7-804">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-804">Routing strategy</span></span>|<span data-ttu-id="332d7-805">Direct</span><span class="sxs-lookup"><span data-stu-id="332d7-805">Direct</span></span>|  
|<span data-ttu-id="332d7-806">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-806">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="332d7-807">Переопределить <xref:System.Windows.ContentElement.OnMouseEnter%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-807">Override <xref:System.Windows.ContentElement.OnMouseEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseEnterEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-808">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.MouseEnter" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-808">Identifies the <see cref="E:System.Windows.ContentElement.MouseEnter" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-809">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-809">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-810">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-810">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-811">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-811">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-812">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-812">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-813">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-813">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeave As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseLeave;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-814">Происходит, когда указатель мыши покидает границы данного элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-814">Occurs when the mouse pointer leaves the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-815"><xref:System.Windows.ContentElement.MouseLeave> — [направлено Общие сведения о событиях](~/docs/framework/wpf/advanced/routed-events-overview.md) , использующий прямой обработки стратегия маршрутизации события.</span><span class="sxs-lookup"><span data-stu-id="332d7-815"><xref:System.Windows.ContentElement.MouseLeave> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="332d7-816">Прямые перенаправленные события не вызываются по маршруту; Вместо этого они обрабатываются в том же элементе где они возникли.</span><span class="sxs-lookup"><span data-stu-id="332d7-816">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="332d7-817">Тем не менее они включают другие аспекты поведения маршрутизируемых событий, например триггеры событий в стилях.</span><span class="sxs-lookup"><span data-stu-id="332d7-817">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="332d7-818">Несмотря на то что <xref:System.Windows.ContentElement.MouseLeave> отслеживает момент, когда указатель мыши покидает элемент, это событие больше о том, что буквально <xref:System.Windows.ContentElement.IsMouseOver%2A> значение свойства было изменено с `true` для `false` для этого элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-818">Although <xref:System.Windows.ContentElement.MouseLeave> tracks when the mouse leaves an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsMouseOver%2A> property value has changed from `true` to `false` on this element.</span></span>  
  
 <span data-ttu-id="332d7-819">Это событие создается псевдоним для <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.MouseLeave> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-819">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseLeave> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-820">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.MouseLeave> событий присоединяются к базовому объекту <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-820">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseLeave> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-821">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-821">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-822">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-822">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseLeaveEvent>|  
|<span data-ttu-id="332d7-823">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-823">Routing strategy</span></span>|<span data-ttu-id="332d7-824">Direct</span><span class="sxs-lookup"><span data-stu-id="332d7-824">Direct</span></span>|  
|<span data-ttu-id="332d7-825">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-825">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="332d7-826">Переопределить <xref:System.Windows.ContentElement.OnMouseLeave%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-826">Override <xref:System.Windows.ContentElement.OnMouseLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeaveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-827">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.MouseLeave" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-827">Identifies the <see cref="E:System.Windows.ContentElement.MouseLeave" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-828">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-828">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-829">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-829">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-830">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-830">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-831">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-831">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-832">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-832">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-833">Происходит при нажатии левой кнопки мыши в тот момент, когда указатель мыши находится над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-833">Occurs when the left mouse button is pressed while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-834">Несмотря на то что это [направлено Общие сведения о событиях](~/docs/framework/wpf/advanced/routed-events-overview.md) кажется маршруту через дерево элементов, фактически является прямой перенаправленного события, которое возникает и восходящему на дереве элементов каждым <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="332d7-834">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="332d7-835">Это событие является одним из нескольких связанных событий, сообщающих кнопки мыши базовая <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> события, который является вложенным событием, которое обрабатывается каждым элементом на маршруте событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-835">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="332d7-836">Аргументы события предоставляют аргументов базового <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-836">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="332d7-837">Если это событие помечено как обработанное на маршруте события, по-прежнему возникают определенные события кнопки мыши; Тем не менее, необходимо добавить обработчики событий кнопки мыши путем явного вызова <xref:System.Windows.ContentElement.AddHandler%2A>, с помощью параметра для обработки событий, которые уже помечено как обработанное, чтобы быть прослушивателей события.</span><span class="sxs-lookup"><span data-stu-id="332d7-837">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="332d7-838">С концептуальной точки зрения это событие (и другие события кнопки мыши <xref:System.Windows.ContentElement>) быть мыши «служба» (с помощью определения службы, предоставляемые <xref:System.Windows.Input.Mouse> класса).</span><span class="sxs-lookup"><span data-stu-id="332d7-838">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="332d7-839">Событие добавляет удобство нет необходимости проверять состояние кнопок мыши (слева направо, вверх вниз) исходного события мыши в данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-839">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="332d7-840">Для более сложных сценариев, таких как проверка состояния стандартным кнопок может потребоваться использовать [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] на <xref:System.Windows.Input.Mouse> класса вместо тех, на <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="332d7-840">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="332d7-841">Несколько <xref:System.Windows.ContentElement> производным классам, характеризующимся наличием поведение элемента управления, например, <xref:System.Windows.Documents.Hyperlink>, может быть реализована собственная обработка событий кнопки мыши.</span><span class="sxs-lookup"><span data-stu-id="332d7-841">A few <xref:System.Windows.ContentElement> derived classes that have control-like behavior, for example, <xref:System.Windows.Documents.Hyperlink>, might have inherent class handling for mouse button events.</span></span> <span data-ttu-id="332d7-842">Событие нажатия кнопки мыши является наиболее вероятным событием с обработкой классов в элементе управления.</span><span class="sxs-lookup"><span data-stu-id="332d7-842">The left mouse button down event is the most likely event to have class handling in a control.</span></span> <span data-ttu-id="332d7-843">Обработчик часто класса помечает базовый <xref:System.Windows.Input.Mouse> класс событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-843">The class handling often marks the underlying <xref:System.Windows.Input.Mouse> class event as handled.</span></span> <span data-ttu-id="332d7-844">Когда событие помечено как обработанное, другие обработчики экземпляра, присоединенные к данному элементу, не инициируются.</span><span class="sxs-lookup"><span data-stu-id="332d7-844">Once the event is marked handled, other instance handlers that are attached to that element are not ordinarily raised.</span></span> <span data-ttu-id="332d7-845">Любые другие обработчики класса или экземпляра, присоединенные к элементам в восходящем направлении к корню дерева пользовательского интерфейса, также обычно не инициируются.</span><span class="sxs-lookup"><span data-stu-id="332d7-845">Any other class or instance handlers that are attached to elements in the bubbling direction towards the root in the UI tree are also not ordinarily raised.</span></span>  
  
 <span data-ttu-id="332d7-846">Можно устранить проблему, описанную в Важном и по-прежнему получать <xref:System.Windows.ContentElement.MouseLeftButtonDown> событий для кнопки мыши в производном классе с обработкой класса с помощью любого из следующих решений:</span><span class="sxs-lookup"><span data-stu-id="332d7-846">You can resolve the issue that is outlined in the preceding Important and still receive <xref:System.Windows.ContentElement.MouseLeftButtonDown> events for left mouse button down events on a derived class that has class handling by using either of these solutions:</span></span>  
  
-   <span data-ttu-id="332d7-847">Присоединение обработчиков для <xref:System.Windows.ContentElement.PreviewMouseDown> события, который не помечен как обработанное в элементах управления.</span><span class="sxs-lookup"><span data-stu-id="332d7-847">Attach handlers for the <xref:System.Windows.ContentElement.PreviewMouseDown> event, which is not marked as handled by the controls.</span></span> <span data-ttu-id="332d7-848">Обратите внимание, что это события предварительного просмотра, маршрут начинается с корневого элемента следует к элементу управления.</span><span class="sxs-lookup"><span data-stu-id="332d7-848">Notice that because this is a preview event, the route starts at the root and tunnels down to the control.</span></span>  
  
-   <span data-ttu-id="332d7-849">Зарегистрируйте обработчик в элементе управления с помощью процедур, вызвав <xref:System.Windows.ContentElement.AddHandler%2A> и выбрав параметр подписи, который позволяет обработчикам прослушивать события, даже если они помечены как обработанное в данные о событии.</span><span class="sxs-lookup"><span data-stu-id="332d7-849">Register a handler on the control procedurally by calling <xref:System.Windows.ContentElement.AddHandler%2A> and choosing the signature option that enables handlers to listen for events even if they are already marked as handled in the routed event data.</span></span>  
  
<a name="routedEventInfo_MouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-850">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-850">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-851">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-851">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseLeftButtonDownEvent>|  
|<span data-ttu-id="332d7-852">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-852">Routing strategy</span></span>|<span data-ttu-id="332d7-853">Direct</span><span class="sxs-lookup"><span data-stu-id="332d7-853">Direct</span></span>|  
|<span data-ttu-id="332d7-854">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-854">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="332d7-855">Переопределить <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-855">Override <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-856">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-856">Identifies the <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-857">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-857">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-858">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-858">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-859">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-859">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-860">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-860">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-861">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-861">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseLeftButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-862">Происходит при отпускании левой кнопки мыши в тот момент, когда указатель мыши находится над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-862">Occurs when the left mouse button is released while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-863">Несмотря на то что это [направлено Общие сведения о событиях](~/docs/framework/wpf/advanced/routed-events-overview.md) кажется маршруту через дерево элементов, фактически является прямой перенаправленного события, которое возникает и восходящему на дереве элементов каждым <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="332d7-863">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="332d7-864">Это событие является одним из нескольких связанных событий, сообщающих кнопки мыши базовая <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> события, который является вложенным событием, которое обрабатывается каждым элементом на маршруте событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-864">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="332d7-865">Аргументы события предоставляют аргументов базового <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-865">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="332d7-866">Если это событие помечено как обработанное на маршруте события, по-прежнему возникают определенные события кнопки мыши; Тем не менее, необходимо добавить обработчики событий кнопки мыши путем явного вызова <xref:System.Windows.ContentElement.AddHandler%2A>, с помощью параметра для обработки событий, которые уже помечено как обработанное, чтобы быть прослушивателей события.</span><span class="sxs-lookup"><span data-stu-id="332d7-866">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="332d7-867">С концептуальной точки зрения это событие (и другие события кнопки мыши <xref:System.Windows.ContentElement>) быть мыши «служба» (с помощью определения службы, предоставляемые <xref:System.Windows.Input.Mouse> класса).</span><span class="sxs-lookup"><span data-stu-id="332d7-867">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="332d7-868">Событие добавляет удобство нет необходимости проверять состояние кнопок мыши (слева направо, вверх вниз) исходного события мыши в данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-868">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="332d7-869">Для более сложных сценариев, таких как проверка состояния стандартным кнопок может потребоваться использовать [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] на <xref:System.Windows.Input.Mouse> класса вместо тех, на <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="332d7-869">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_MouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-870">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-870">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-871">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-871">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseLeftButtonUpEvent>|  
|<span data-ttu-id="332d7-872">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-872">Routing strategy</span></span>|<span data-ttu-id="332d7-873">Direct</span><span class="sxs-lookup"><span data-stu-id="332d7-873">Direct</span></span>|  
|<span data-ttu-id="332d7-874">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-874">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="332d7-875">Переопределить <xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-875">Override <xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseLeftButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-876">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-876">Identifies the <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-877">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-877">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-878">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-878">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-879">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-879">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-880">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-880">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-881">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-881">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler MouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler MouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ MouseMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-882">Происходит при перемещении указателя мыши над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-882">Occurs when the mouse pointer moves while over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-883">Это событие создается псевдоним для <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.MouseMove> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-883">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-884">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.MouseMove> событий присоединяются к базовому объекту <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-884">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseMove> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-885">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-885">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-886">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-886">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseMoveEvent>|  
|<span data-ttu-id="332d7-887">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-887">Routing strategy</span></span>|<span data-ttu-id="332d7-888">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-888">Bubbling</span></span>|  
|<span data-ttu-id="332d7-889">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-889">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="332d7-890">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewMouseMove>.</span><span class="sxs-lookup"><span data-stu-id="332d7-890">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseMove>.</span></span>  
  
-   <span data-ttu-id="332d7-891">Переопределить <xref:System.Windows.ContentElement.OnMouseMove%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-891">Override <xref:System.Windows.ContentElement.OnMouseMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="MouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-892">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.MouseMove" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-892">Identifies the <see cref="E:System.Windows.ContentElement.MouseMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-893">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-893">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-894">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-894">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-895">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-895">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-896">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-896">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-897">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-897">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-898">Происходит при нажатии правой кнопки мыши в тот момент, когда указатель мыши находится над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-898">Occurs when the right mouse button is pressed while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-899">Несмотря на то что это [направлено Общие сведения о событиях](~/docs/framework/wpf/advanced/routed-events-overview.md) кажется маршруту через дерево элементов, фактически является прямой перенаправленного события, которое возникает и восходящему на дереве элементов каждым <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="332d7-899">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="332d7-900">Это событие является одним из нескольких связанных событий, сообщающих кнопки мыши базовая <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> события, который является вложенным событием, которое обрабатывается каждым элементом на маршруте событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-900">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="332d7-901">Аргументы события предоставляют аргументов базового <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-901">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="332d7-902">Если это событие помечено как обработанное на маршруте события, по-прежнему возникают определенные события кнопки мыши; Тем не менее, необходимо добавить обработчики событий кнопки мыши путем явного вызова <xref:System.Windows.ContentElement.AddHandler%2A>, с помощью параметра для обработки событий, которые уже помечено как обработанное, чтобы быть прослушивателей события.</span><span class="sxs-lookup"><span data-stu-id="332d7-902">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="332d7-903">С концептуальной точки зрения это событие (и другие события кнопки мыши <xref:System.Windows.ContentElement>) быть мыши «служба» (с помощью определения службы, предоставляемые <xref:System.Windows.Input.Mouse> класса).</span><span class="sxs-lookup"><span data-stu-id="332d7-903">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="332d7-904">Событие добавляет удобство нет необходимости проверять состояние кнопок мыши (слева направо, вверх вниз) исходного события мыши в данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-904">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="332d7-905">Для более сложных сценариев, таких как проверка состояния стандартным кнопок может потребоваться использовать [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] на <xref:System.Windows.Input.Mouse> класса вместо тех, на <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="332d7-905">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="332d7-906">Часто сценарии приложений имеют обработчики для событий правой кнопки мыши.</span><span class="sxs-lookup"><span data-stu-id="332d7-906">Right button mouse events frequently have native handling in application scenarios.</span></span> <span data-ttu-id="332d7-907">Например правой кнопкой мыши вниз может отображаться контекстное меню.</span><span class="sxs-lookup"><span data-stu-id="332d7-907">For instance, a right mouse button down might display a context menu.</span></span> <span data-ttu-id="332d7-908">В разделе [Обзор ContextMenu](~/docs/framework/wpf/controls/contextmenu-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-908">See [ContextMenu Overview](~/docs/framework/wpf/controls/contextmenu-overview.md).</span></span>  
  
<a name="routedEventInfo_MouseRightButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-909">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-909">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-910">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-910">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseRightButtonDownEvent>|  
|<span data-ttu-id="332d7-911">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-911">Routing strategy</span></span>|<span data-ttu-id="332d7-912">Direct</span><span class="sxs-lookup"><span data-stu-id="332d7-912">Direct</span></span>|  
|<span data-ttu-id="332d7-913">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-913">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="332d7-914">Переопределить <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-914">Override <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-915">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-915">Identifies the <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-916">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-916">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-917">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-917">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-918">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-918">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-919">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-919">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-920">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-920">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ MouseRightButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-921">Происходит при отпускании правой кнопки мыши в тот момент, когда указатель мыши находится над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-921">Occurs when the right mouse button is released while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-922">Несмотря на то что это [направлено Общие сведения о событиях](~/docs/framework/wpf/advanced/routed-events-overview.md) кажется маршруту через дерево элементов, фактически является прямой перенаправленного события, которое возникает и восходящему на дереве элементов каждым <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="332d7-922">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a bubbling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="332d7-923">Это событие является одним из нескольких связанных событий, сообщающих кнопки мыши базовая <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> события, который является вложенным событием, которое обрабатывается каждым элементом на маршруте событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-923">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="332d7-924">Аргументы события предоставляют аргументов базового <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-924">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="332d7-925">Если это событие помечено как обработанное на маршруте события, по-прежнему возникают определенные события кнопки мыши; Тем не менее, необходимо добавить обработчики событий кнопки мыши путем явного вызова <xref:System.Windows.ContentElement.AddHandler%2A>, с помощью параметра для обработки событий, которые уже помечено как обработанное, чтобы быть прослушивателей события.</span><span class="sxs-lookup"><span data-stu-id="332d7-925">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="332d7-926">С концептуальной точки зрения это событие (и другие события кнопки мыши <xref:System.Windows.ContentElement>) быть мыши «служба» (с помощью определения службы, предоставляемые <xref:System.Windows.Input.Mouse> класса).</span><span class="sxs-lookup"><span data-stu-id="332d7-926">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="332d7-927">Событие добавляет удобство нет необходимости проверять состояние кнопок мыши (слева направо, вверх вниз) исходного события мыши в данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-927">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="332d7-928">Для более сложных сценариев, таких как проверка состояния стандартным кнопок может потребоваться использовать [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] на <xref:System.Windows.Input.Mouse> класса вместо тех, на <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="332d7-928">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_MouseRightButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-929">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-929">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-930">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-930">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseRightButtonUpEvent>|  
|<span data-ttu-id="332d7-931">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-931">Routing strategy</span></span>|<span data-ttu-id="332d7-932">Direct</span><span class="sxs-lookup"><span data-stu-id="332d7-932">Direct</span></span>|  
|<span data-ttu-id="332d7-933">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-933">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="332d7-934">Переопределить <xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-934">Override <xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="MouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseRightButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-935">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-935">Identifies the <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-936">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-936">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-937">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-937">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-938">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-938">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-939">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-939">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-940">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-940">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler MouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler MouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ MouseUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-941">Происходит при отпускании любой кнопки мыши в тот момент, когда указатель мыши находится над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-941">Occurs when any mouse button is released over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-942">Это событие создается псевдоним для <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.MouseUp> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-942">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-943">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.MouseUp> событий присоединяются к базовому объекту <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-943">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseUp> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="332d7-944"><xref:System.Windows.ContentElement.MouseUp> Событие часто возникает вместе с либо <xref:System.Windows.ContentElement.MouseLeftButtonUp> или <xref:System.Windows.ContentElement.MouseRightButtonUp>, которые соответствуют выпуск одну из двух кнопок стандартных действий мыши.</span><span class="sxs-lookup"><span data-stu-id="332d7-944">The <xref:System.Windows.ContentElement.MouseUp> event is often raised together with either <xref:System.Windows.ContentElement.MouseLeftButtonUp> or <xref:System.Windows.ContentElement.MouseRightButtonUp>, which correspond to a release of one of the two standard mouse buttons.</span></span> <span data-ttu-id="332d7-945"><xref:System.Windows.ContentElement.MouseLeftButtonUp> и <xref:System.Windows.ContentElement.MouseRightButtonUp> также перенаправленные события, но они являются прямой перенаправленные события, и возникает соответствующее событие кнопками при <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> событий достигает этого элемента на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-945"><xref:System.Windows.ContentElement.MouseLeftButtonUp> and <xref:System.Windows.ContentElement.MouseRightButtonUp> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="332d7-946">См. заметки для <xref:System.Windows.ContentElement.MouseLeftButtonUp> или <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span><span class="sxs-lookup"><span data-stu-id="332d7-946">See Remarks for <xref:System.Windows.ContentElement.MouseLeftButtonUp> or <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span></span>  
  
<a name="routedEventInfo_MouseUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-947">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-947">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-948">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-948">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseUpEvent>|  
|<span data-ttu-id="332d7-949">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-949">Routing strategy</span></span>|<span data-ttu-id="332d7-950">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-950">Bubbling</span></span>|  
|<span data-ttu-id="332d7-951">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-951">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="332d7-952">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewMouseUp>.</span><span class="sxs-lookup"><span data-stu-id="332d7-952">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseUp>.</span></span>  
  
-   <span data-ttu-id="332d7-953">Переопределить <xref:System.Windows.ContentElement.OnMouseUp%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-953">Override <xref:System.Windows.ContentElement.OnMouseUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-954">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.MouseUp" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-954">Identifies the <see cref="E:System.Windows.ContentElement.MouseUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-955">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-955">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-956">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-956">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-957">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-957">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-958">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-958">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-959">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-959">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler MouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler MouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.MouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event MouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ MouseWheel;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.MouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-960">Происходит при вращении колесика мыши в тот момент, когда указатель мыши находится над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-960">Occurs when the user rotates the mouse wheel while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-961">Фокус или захват мыши имеют приоритет над которого указатель мыши; Таким образом при получении <xref:System.Windows.ContentElement.MouseWheel> события из элемента или получившего указатель мыши может фактически находиться над другим элементом.</span><span class="sxs-lookup"><span data-stu-id="332d7-961">Focus or mouse capture take precedence over where the mouse pointer is; therefore, if you receive the <xref:System.Windows.ContentElement.MouseWheel> event from a focused or captured element, the mouse pointer might actually be over another element.</span></span>  
  
 <span data-ttu-id="332d7-962">Это событие создается псевдоним для <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.MouseWheel> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-962">This event creates an alias for the <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.MouseWheel> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-963">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.MouseWheel> событий присоединяются к базовому объекту <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-963">Event handlers that are attached to the <xref:System.Windows.ContentElement.MouseWheel> event are attached to the underlying <xref:System.Windows.Input.Mouse.MouseWheel?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_MouseWheel"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-964">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-964">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-965">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-965">Identifier field</span></span>|<xref:System.Windows.ContentElement.MouseWheelEvent>|  
|<span data-ttu-id="332d7-966">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-966">Routing strategy</span></span>|<span data-ttu-id="332d7-967">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-967">Bubbling</span></span>|  
|<span data-ttu-id="332d7-968">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-968">Delegate</span></span>|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   <span data-ttu-id="332d7-969">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewMouseWheel>.</span><span class="sxs-lookup"><span data-stu-id="332d7-969">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewMouseWheel>.</span></span>  
  
-   <span data-ttu-id="332d7-970">Переопределить <xref:System.Windows.ContentElement.OnMouseWheel%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-970">Override <xref:System.Windows.ContentElement.OnMouseWheel%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent MouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent MouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.MouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ MouseWheelEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-971">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.MouseWheel" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-971">Identifies the <see cref="E:System.Windows.ContentElement.MouseWheel" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-972">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-972">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-973">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-973">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-974">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-974">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-975">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-975">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-976">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-976">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public virtual bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">
          <span data-ttu-id="332d7-977">Запрос перемещения, содержащий свойство, которое определяет способ перемещения в соответствующем порядке по вкладкам, или направление для визуального перемещения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-977">A traversal request, which contains a property that indicates either a mode to traverse in existing tab order, or a direction to move visually.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-978">Предпринимает попытки переместить фокус с данного элемента на иной.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-978">Attempts to move focus from this element to another element.</span>
          </span>
          <span data-ttu-id="332d7-979">Направления для перемещения фокуса задается указанием направления, которое обрабатывается внутри видимого родительского элемента данного элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-979">The direction to move focus is specified by a guidance direction, which is interpreted within the organization of the visual parent for this element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="332d7-980">
            <see langword="true" />, если запрос на перемещение выполнен; иначе, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-980">
              <see langword="true" /> if the requested traversal was performed; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-981">Убедитесь, что проверяйте возвращаемое значение этого метода.</span><span class="sxs-lookup"><span data-stu-id="332d7-981">Make sure you check the return value of this method.</span></span> <span data-ttu-id="332d7-982">Возвращаемое значение `false` может быть возвращено, если затребована остановки вкладку и запрос обхода не запрашивали программы-оболочки.</span><span class="sxs-lookup"><span data-stu-id="332d7-982">A return value of `false` might be returned if the traversal runs into a tab stop that is defined by a control's composition, and the traversal request did not request to wrap.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="332d7-983">Возвращает определяющиеся классом <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> реализации для [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] инфраструктуры.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-983">Returns class-specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementations for the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="332d7-984">Реализация <see cref="T:System.Windows.Automation.Peers.AutomationPeer" />, зависящая от конкретного типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-984">The type-specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementation.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="332d7-985">Обычно является реализация этого метода для вызова конкретного конструктора <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> реализации и возвращает его в качестве возвращаемого значения.</span>
            <span class="sxs-lookup">
              <span data-stu-id="332d7-985">The implementation of this method is typically to call the constructor of a specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementation, and return it as the return value.</span>
            </span>
            <span data-ttu-id="332d7-986">Все <see cref="T:System.Windows.ContentElement" /> производные классы должны реализовать этот метод, чтобы обеспечить собственные определенного <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> реализации [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] инфраструктуры.</span>
            <span class="sxs-lookup">
              <span data-stu-id="332d7-986">All <see cref="T:System.Windows.ContentElement" /> derived classes should implement this method in order to provide their own specific <see cref="T:System.Windows.Automation.Peers.AutomationPeer" /> implementations to the [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] infrastructure.</span>
            </span>
            <span data-ttu-id="332d7-987">Дополнительные сведения о реализации данного шаблона см. в разделе <see cref="T:System.Windows.Automation.Peers.AutomationPeer" />.</span>
            <span class="sxs-lookup">
              <span data-stu-id="332d7-987">For details on implementing this pattern, see <see cref="T:System.Windows.Automation.Peers.AutomationPeer" />.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnDragEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-988">Объект класса <see cref="T:System.Windows.DragEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-988">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-989">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.DragDrop.DragEnter" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-989">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragEnter" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-990">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-990">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-991">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-991">This method has no default implementation.</span></span> <span data-ttu-id="332d7-992">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-992">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-993">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-993">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-994">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-994">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-995">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-995">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-996">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-996">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-997">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-997">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-998">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-998">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-999">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-999">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnDragLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1000">Объект класса <see cref="T:System.Windows.DragEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1000">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1001">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.DragDrop.DragLeave" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1001">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragLeave" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1002">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1002">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1003">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1003">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1004">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1004">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1005">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1005">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1006">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1006">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1007">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1007">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1008">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1008">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1009">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1009">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1010">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1010">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1011">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1011">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnDragOver">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1012">Объект класса <see cref="T:System.Windows.DragEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1012">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1013">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.DragDrop.DragOver" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1013">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragOver" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1014">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1014">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1015">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1015">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1016">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1016">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1017">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1017">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1018">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1018">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1019">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1019">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1020">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1020">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1021">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1021">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1022">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1022">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1023">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1023">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.DragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnDrop">
      <MemberSignature Language="C#" Value="protected internal virtual void OnDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1024">Объект класса <see cref="T:System.Windows.DragEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1024">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1025">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.DragDrop.DragEnter" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1025">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.DragEnter" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1026">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1026">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1027">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1027">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1028">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1028">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1029">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1029">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1030">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1030">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1031">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1031">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1032">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1032">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1033">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1033">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1034">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1034">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1035">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1035">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.Drop" />
      </Docs>
    </Member>
    <Member MemberName="OnGiveFeedback">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1036">Объект класса <see cref="T:System.Windows.GiveFeedbackEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1036">The <see cref="T:System.Windows.GiveFeedbackEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1037">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.DragDrop.GiveFeedback" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1037">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.GiveFeedback" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1038">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1038">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1039">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1039">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1040">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1040">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1041">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1041">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1042">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1042">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1043">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1043">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1044">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1044">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1045">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1045">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1046">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1046">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1047">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1047">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1048">Объект <see cref="T:System.Windows.RoutedEventArgs" />, содержащий данные события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1048">A <see cref="T:System.Windows.RoutedEventArgs" /> that contains event data.</span>
          </span>
          <span data-ttu-id="332d7-1049">Данные о событии должны содержать идентификатор для события <see cref="E:System.Windows.ContentElement.GotFocus" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1049">This event data must contain the identifier for the <see cref="E:System.Windows.ContentElement.GotFocus" /> event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1050">Вызывает перенаправленное событие <see cref="E:System.Windows.ContentElement.GotFocus" /> с помощью предоставленных данных события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1050">Raises the <see cref="E:System.Windows.ContentElement.GotFocus" /> routed event by using the event data provided.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1051">Этот метод, хотя виртуальным, имеет реализацию по умолчанию, который инициирует событие.</span><span class="sxs-lookup"><span data-stu-id="332d7-1051">This method, although virtual, does have a default implementation that raises the event.</span></span>  
  
 <span data-ttu-id="332d7-1052">Это на \* реализации метода предназначен для вызова события, и эта же реализация вызывается внутренне для инициирования события при <xref:System.Windows.ContentElement.IsFocused%2A> изменении значения свойства.</span><span class="sxs-lookup"><span data-stu-id="332d7-1052">This On\* method implementation is intended to raise the event, and this same method implementation is invoked internally to raise the event when the <xref:System.Windows.ContentElement.IsFocused%2A> property value changes.</span></span> <span data-ttu-id="332d7-1053"><xref:System.Windows.ContentElement.OnGotFocus%2A> Реализация отличается от некоторых других [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] на \* реализации, которые только предоставляют удобный способ добавить обработчик класса для этого события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1053">The <xref:System.Windows.ContentElement.OnGotFocus%2A> implementation differs from some other [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] On\* implementations, which only provide a convenient way to add class handling for that event.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="332d7-1054">При отсутствии тщательного следует инициирует события фокуса, убедитесь, что ваша реализация вызывает базовую реализацию.</span>
            <span class="sxs-lookup">
              <span data-stu-id="332d7-1054">Unless you have a deliberate and unusual need to not raise the focus events, make sure that your implementation calls the base implementation.</span>
            </span>
            <span data-ttu-id="332d7-1055">В противном случае <see cref="E:System.Windows.ContentElement.GotFocus" /> событие не происходит при выполнении операций типичные действия пользователя, которые обычно устанавливают фокус в данный элемент.</span>
            <span class="sxs-lookup">
              <span data-stu-id="332d7-1055">Otherwise, the <see cref="E:System.Windows.ContentElement.GotFocus" /> event is not raised during typical user operations that ordinarily set focus to this element.</span>
            </span>
            <span data-ttu-id="332d7-1056">Если элемент должен иметь фокус не требуется, вы может помешать элемент может иметь фокус, задав <see cref="P:System.Windows.ContentElement.Focusable" /> для <see langword="false" />.</span>
            <span class="sxs-lookup">
              <span data-stu-id="332d7-1056">If you do not intend your element to be focusable, you can prevent the element from being focusable by setting <see cref="P:System.Windows.ContentElement.Focusable" /> to <see langword="false" />.</span>
            </span>
            <span data-ttu-id="332d7-1057">Обратите внимание, что по умолчанию <see cref="P:System.Windows.ContentElement.Focusable" /> не может иметь фокус, таким образом задание <see cref="P:System.Windows.ContentElement.Focusable" /> намеренно не является обязательной.</span>
            <span class="sxs-lookup">
              <span data-stu-id="332d7-1057">Note that by default a <see cref="P:System.Windows.ContentElement.Focusable" /> is not focusable, therefore setting <see cref="P:System.Windows.ContentElement.Focusable" /> deliberately might not be necessary.</span>
            </span>
          </para>
        </block>
        <altmember cref="P:System.Windows.ContentElement.Focusable" />
        <altmember cref="E:System.Windows.ContentElement.GotFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1058">Объект класса <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1058">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1059">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1059">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.GotKeyboardFocus" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1060">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1060">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1061">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1061">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1062">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1062">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1063">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1063">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1064">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1064">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1065">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1065">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1066">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1066">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1067">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1067">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1068">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1068">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1069">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1069">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnGotMouseCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1070">Объект класса <see cref="T:System.Windows.Input.MouseEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1070">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1071">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1071">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.GotMouseCapture" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1072">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1072">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1073">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1073">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1074">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1074">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1075">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1075">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1076">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1076">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1077">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1077">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1078">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1078">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1079">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1079">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1080">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1080">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1081">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1081">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotStylusCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1082">Объект класса <see cref="T:System.Windows.Input.StylusEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1082">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1083">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1083">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.GotStylusCapture" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1084">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1084">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1085">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1085">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1086">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1086">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1087">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1087">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1088">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1088">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1089">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1089">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1090">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1090">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1091">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1091">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1092">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1092">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1093">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1093">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.GotStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnGotTouchCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnGotTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnGotTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnGotTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnGotTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnGotTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1094">Объект <see cref="T:System.Windows.Input.TouchEventArgs" />, содержащий данные события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1094">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1095">Предоставляет обработку класса для перенаправленного события <see cref="E:System.Windows.ContentElement.GotTouchCapture" />, которое происходит при захвате сенсорного ввода данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1095">Provides class handling for the <see cref="E:System.Windows.ContentElement.GotTouchCapture" /> routed event that occurs when a touch is captured to this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1096"><xref:System.Windows.ContentElement.OnGotTouchCapture%2A> У метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1096">The <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> method has no default implementation.</span></span> <span data-ttu-id="332d7-1097">Переопределить <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> в производном классе позволяет обработать <xref:System.Windows.ContentElement.GotTouchCapture> событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-1097">Override <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> in a derived class to handle the <xref:System.Windows.ContentElement.GotTouchCapture> event.</span></span> <span data-ttu-id="332d7-1098">Необходимо вызвать метод базового класса <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> метод, базовые классы получили событие.</span><span class="sxs-lookup"><span data-stu-id="332d7-1098">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnGotTouchCapture%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsKeyboardFocusedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1099">Объект класса <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1099">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1100">Вызывается, когда в данном элементе инициируется необработанное событие <see cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1100">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsKeyboardFocusedChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="332d7-1101">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1101">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1102">Этот виртуальный метод вызывается при значение <xref:System.Windows.ContentElement.IsKeyboardFocused%2A> изменения свойств зависимостей.</span><span class="sxs-lookup"><span data-stu-id="332d7-1102">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsKeyboardFocused%2A> dependency property changes.</span></span> <span data-ttu-id="332d7-1103">Виртуальный метод вызывается первым и может использовать данные события, при необходимости.</span><span class="sxs-lookup"><span data-stu-id="332d7-1103">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="332d7-1104">Затем <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> события с этого же экземпляра данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1104">Then the <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="332d7-1105">Обратите внимание, что <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> событие не является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1105">Notice that the  <xref:System.Windows.ContentElement.IsKeyboardFocusedChanged> event is not a routed event.</span></span> <span data-ttu-id="332d7-1106">Поэтому его нельзя пометить как обработанное в обработчике класса.</span><span class="sxs-lookup"><span data-stu-id="332d7-1106">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="332d7-1107">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1107">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1108">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1108">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="332d7-1109">Вызов базовой реализации можно до или после специальной обработки, в зависимости от требований.</span><span class="sxs-lookup"><span data-stu-id="332d7-1109">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsKeyboardFocusWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsKeyboardFocusWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsKeyboardFocusWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsKeyboardFocusWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsKeyboardFocusWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsKeyboardFocusWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1110">Объект <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />, содержащий данные события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1110">A <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1111">Вызывается непосредственно перед генерацией данным элементом события <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1111">Invoked just before the <see cref="E:System.Windows.ContentElement.IsKeyboardFocusWithinChanged" /> event is raised by this element.</span>
          </span>
          <span data-ttu-id="332d7-1112">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1112">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1113">Этот виртуальный метод вызывается при значение <xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> свойств зависимостей изменяется значение.</span><span class="sxs-lookup"><span data-stu-id="332d7-1113">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsKeyboardFocusWithin%2A> dependency property changes its value.</span></span> <span data-ttu-id="332d7-1114">Виртуальный метод вызывается первым и может использовать данные события, при необходимости.</span><span class="sxs-lookup"><span data-stu-id="332d7-1114">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="332d7-1115">Затем <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> события с этого же экземпляра данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1115">Then the <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="332d7-1116">Обратите внимание, что <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> событие не является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1116">Notice that the <xref:System.Windows.ContentElement.IsKeyboardFocusWithinChanged> event is not a routed event.</span></span> <span data-ttu-id="332d7-1117">Поэтому его нельзя пометить как обработанное в обработчике класса.</span><span class="sxs-lookup"><span data-stu-id="332d7-1117">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="332d7-1118">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1118">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1119">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1119">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="332d7-1120">Вызов базовой реализации можно до или после специальной обработки, в зависимости от требований.</span><span class="sxs-lookup"><span data-stu-id="332d7-1120">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1121">Объект класса <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1121">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1122">Вызывается, когда в данном элементе инициируется необработанное событие <see cref="E:System.Windows.ContentElement.IsMouseCapturedChanged" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1122">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsMouseCapturedChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="332d7-1123">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1123">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1124">Этот виртуальный метод вызывается при значение <xref:System.Windows.ContentElement.IsMouseCaptured%2A> свойств зависимостей изменяется значение.</span><span class="sxs-lookup"><span data-stu-id="332d7-1124">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsMouseCaptured%2A> dependency property changes its value.</span></span> <span data-ttu-id="332d7-1125">Виртуальный метод вызывается первым и может использовать данные события, при необходимости.</span><span class="sxs-lookup"><span data-stu-id="332d7-1125">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="332d7-1126">Затем <xref:System.Windows.ContentElement.IsMouseCapturedChanged> события с этого же экземпляра данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1126">Then the <xref:System.Windows.ContentElement.IsMouseCapturedChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="332d7-1127">Обратите внимание, что <xref:System.Windows.ContentElement.IsMouseCapturedChanged> событие не является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1127">Notice that the <xref:System.Windows.ContentElement.IsMouseCapturedChanged> event is not a routed event.</span></span> <span data-ttu-id="332d7-1128">Поэтому его нельзя пометить как обработанное в обработчике класса.</span><span class="sxs-lookup"><span data-stu-id="332d7-1128">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="332d7-1129">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1129">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1130">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1130">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="332d7-1131">Вызов базовой реализации можно до или после специальной обработки, в зависимости от требований.</span><span class="sxs-lookup"><span data-stu-id="332d7-1131">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1132">Объект <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />, содержащий данные события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1132">A <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1133">Вызывается, когда в данном элементе инициируется необработанное событие <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1133">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="332d7-1134">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1134">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="332d7-1135">Этот виртуальный метод вызывается при значение <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> свойств зависимостей изменяется значение.</span>
            <span class="sxs-lookup">
              <span data-stu-id="332d7-1135">This virtual method is raised when the value of the <see cref="P:System.Windows.ContentElement.IsMouseCaptureWithin" /> dependency property changes its value.</span>
            </span>
            <span data-ttu-id="332d7-1136">Виртуальный метод вызывается первым и может использовать данные события, при необходимости.</span>
            <span class="sxs-lookup">
              <span data-stu-id="332d7-1136">The virtual method is raised first and can manipulate the event data as necessary.</span>
            </span>
            <span data-ttu-id="332d7-1137">Затем <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> события с этого же экземпляра данных события.</span>
            <span class="sxs-lookup">
              <span data-stu-id="332d7-1137">Then the <see cref="E:System.Windows.ContentElement.IsMouseCaptureWithinChanged" /> event is raised with that same event data instance.</span>
            </span>
            <span data-ttu-id="332d7-1138">Обратите внимание, что событие не является маршрутизируемым; Поэтому его нельзя пометить как обработанное в обработчике класса.</span>
            <span class="sxs-lookup">
              <span data-stu-id="332d7-1138">Notice that the event is not a routed event; Therefore,  you cannot mark it as handled in the class handler.</span>
            </span>
            <span data-ttu-id="332d7-1139">У этого метода нет реализации по умолчанию.</span>
            <span class="sxs-lookup">
              <span data-stu-id="332d7-1139">This method has no default implementation.</span>
            </span>
            <span data-ttu-id="332d7-1140">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span>
            <span class="sxs-lookup">
              <span data-stu-id="332d7-1140">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span>
            </span>
            <span data-ttu-id="332d7-1141">Вызов базовой реализации можно до или после специальной обработки, в зависимости от требований.</span>
            <span class="sxs-lookup">
              <span data-stu-id="332d7-1141">You may call base either before or after your special handling, depending on your requirements.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnIsMouseDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsMouseDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsMouseDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsMouseDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsMouseDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsMouseDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1142">Объект класса <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1142">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1143">Вызывается, когда в данном элементе инициируется необработанное событие <see cref="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1143">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsMouseDirectlyOverChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="332d7-1144">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1144">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1145">Этот виртуальный метод вызывается при значение <xref:System.Windows.ContentElement.IsMouseDirectlyOver%2A> свойств зависимостей изменяется значение.</span><span class="sxs-lookup"><span data-stu-id="332d7-1145">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsMouseDirectlyOver%2A> dependency property changes its value.</span></span> <span data-ttu-id="332d7-1146">Виртуальный метод вызывается первым и может использовать данные события, при необходимости.</span><span class="sxs-lookup"><span data-stu-id="332d7-1146">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="332d7-1147">Затем <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> события с этого же экземпляра данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1147">Then the <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="332d7-1148">Обратите внимание, что <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> событие не является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1148">Notice that the <xref:System.Windows.ContentElement.IsMouseDirectlyOverChanged> event is not a routed event.</span></span> <span data-ttu-id="332d7-1149">Поэтому его нельзя пометить как обработанное в обработчике класса.</span><span class="sxs-lookup"><span data-stu-id="332d7-1149">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="332d7-1150">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1150">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1151">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1151">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="332d7-1152">Вызов базовой реализации можно до или после специальной обработки, в зависимости от требований.</span><span class="sxs-lookup"><span data-stu-id="332d7-1152">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCapturedChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCapturedChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCapturedChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusCapturedChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCapturedChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCapturedChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1153">Объект <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />, содержащий данные события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1153">A <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1154">Вызывается, когда в данном элементе инициируется необработанное событие <see cref="E:System.Windows.ContentElement.IsStylusCapturedChanged" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1154">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsStylusCapturedChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="332d7-1155">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1155">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1156">Этот виртуальный метод вызывается при значение <xref:System.Windows.ContentElement.IsStylusCaptured%2A> свойств зависимостей изменяется значение.</span><span class="sxs-lookup"><span data-stu-id="332d7-1156">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsStylusCaptured%2A> dependency property changes its value.</span></span> <span data-ttu-id="332d7-1157">Виртуальный метод вызывается первым и может использовать данные события, при необходимости.</span><span class="sxs-lookup"><span data-stu-id="332d7-1157">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="332d7-1158">Затем <xref:System.Windows.ContentElement.IsStylusCapturedChanged> события с этого же экземпляра данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1158">Then the <xref:System.Windows.ContentElement.IsStylusCapturedChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="332d7-1159">Обратите внимание, что событие не является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1159">Notice that the event is not a routed event.</span></span> <span data-ttu-id="332d7-1160">Поэтому его нельзя пометить как обработанное в обработчике класса.</span><span class="sxs-lookup"><span data-stu-id="332d7-1160">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="332d7-1161">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1161">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1162">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1162">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="332d7-1163">Вызов базовой реализации можно до или после специальной обработки, в зависимости от требований.</span><span class="sxs-lookup"><span data-stu-id="332d7-1163">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusCaptureWithinChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusCaptureWithinChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusCaptureWithinChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusCaptureWithinChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusCaptureWithinChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusCaptureWithinChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1164">Объект класса <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1164">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1165">Вызывается, когда в данном элементе инициируется необработанное событие <see cref="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1165">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsStylusCaptureWithinChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="332d7-1166">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1166">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1167">Этот виртуальный метод вызывается при значение <xref:System.Windows.ContentElement.IsStylusCaptureWithin%2A> свойств зависимостей изменяется значение.</span><span class="sxs-lookup"><span data-stu-id="332d7-1167">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsStylusCaptureWithin%2A> dependency property changes its value.</span></span> <span data-ttu-id="332d7-1168">Виртуальный метод вызывается первым и может использовать данные события, при необходимости.</span><span class="sxs-lookup"><span data-stu-id="332d7-1168">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="332d7-1169">Затем <xref:System.Windows.ContentElement.IsStylusCaptureWithinChanged> события с этого же экземпляра данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1169">Then the <xref:System.Windows.ContentElement.IsStylusCaptureWithinChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="332d7-1170">Обратите внимание, что событие не является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1170">Notice that the event is not a routed event.</span></span> <span data-ttu-id="332d7-1171">Поэтому его нельзя пометить как обработанное в обработчике класса.</span><span class="sxs-lookup"><span data-stu-id="332d7-1171">Therefore, you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="332d7-1172">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1172">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1173">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1173">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="332d7-1174">Вызов базовой реализации можно до или после специальной обработки, в зависимости от требований.</span><span class="sxs-lookup"><span data-stu-id="332d7-1174">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnIsStylusDirectlyOverChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnIsStylusDirectlyOverChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnIsStylusDirectlyOverChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnIsStylusDirectlyOverChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnIsStylusDirectlyOverChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnIsStylusDirectlyOverChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1175">Объект класса <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1175">The <see cref="T:System.Windows.DependencyPropertyChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1176">Вызывается, когда в данном элементе инициируется необработанное событие <see cref="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1176">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.IsStylusDirectlyOverChanged" /> event is raised on this element.</span>
          </span>
          <span data-ttu-id="332d7-1177">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1177">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1178">Этот виртуальный метод вызывается при значение <xref:System.Windows.ContentElement.IsStylusDirectlyOver%2A> свойств зависимостей изменяется значение.</span><span class="sxs-lookup"><span data-stu-id="332d7-1178">This virtual method is raised when the value of the <xref:System.Windows.ContentElement.IsStylusDirectlyOver%2A> dependency property changes its value.</span></span> <span data-ttu-id="332d7-1179">Виртуальный метод вызывается первым и может использовать данные события, при необходимости.</span><span class="sxs-lookup"><span data-stu-id="332d7-1179">The virtual method is raised first and can manipulate the event data as necessary.</span></span> <span data-ttu-id="332d7-1180">Затем <xref:System.Windows.ContentElement.IsStylusDirectlyOverChanged> события с этого же экземпляра данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1180">Then the <xref:System.Windows.ContentElement.IsStylusDirectlyOverChanged> event is raised with that same event data instance.</span></span> <span data-ttu-id="332d7-1181">Обратите внимание, что событие не является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1181">Notice that the event is not a routed event.</span></span> <span data-ttu-id="332d7-1182">Поэтому его нельзя пометить как обработанное в обработчике класса.</span><span class="sxs-lookup"><span data-stu-id="332d7-1182">Therefore you cannot mark it as handled in the class handler.</span></span>  
  
 <span data-ttu-id="332d7-1183">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1183">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1184">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1184">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="332d7-1185">Вызов базовой реализации можно до или после специальной обработки, в зависимости от требований.</span><span class="sxs-lookup"><span data-stu-id="332d7-1185">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnKeyDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1186">Объект класса <see cref="T:System.Windows.Input.KeyEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1186">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1187">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1187">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.KeyDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1188">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1188">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1189">Нажатия клавиш обрабатываются выделенным диспетчером ввода.</span><span class="sxs-lookup"><span data-stu-id="332d7-1189">Keystrokes are handled by a dedicated input manager.</span></span> <span data-ttu-id="332d7-1190">Другие программные функции, зависящие от нажатия клавиш, например, ввод и привязка команд, могут обрабатывать нажатие клавиши, прежде чем оно будет представлено как обычное нажатие клавиши.</span><span class="sxs-lookup"><span data-stu-id="332d7-1190">Other programming features that rely on keystrokes, for example, input and command bindings, might handle the keystroke before it is exposed as a general keystroke.</span></span> <span data-ttu-id="332d7-1191">Если эти входные функции системы пометить событие как обработанное, затем <xref:System.Windows.ContentElement.OnKeyDown%2A> не вызывается.</span><span class="sxs-lookup"><span data-stu-id="332d7-1191">If these input system features mark the event as handled, then <xref:System.Windows.ContentElement.OnKeyDown%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="332d7-1192">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1192">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1193">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1193">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1194">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1194">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1195">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1195">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1196">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1196">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1197">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1197">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1198">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1198">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1199">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1199">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1200">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1200">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnKeyUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1201">Объект класса <see cref="T:System.Windows.Input.KeyEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1201">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1202">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1202">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.KeyUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1203">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1203">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1204">Нажатия клавиш обрабатываются выделенным диспетчером ввода.</span><span class="sxs-lookup"><span data-stu-id="332d7-1204">Keystrokes are handled by a dedicated input manager.</span></span> <span data-ttu-id="332d7-1205">Другие программные функции, зависящие от нажатия клавиш, например, ввод и привязка команд, могут обрабатывать нажатие клавиши, прежде чем оно будет представлено как обычное нажатие клавиши.</span><span class="sxs-lookup"><span data-stu-id="332d7-1205">Other programming features that rely on keystrokes, for example, input and command bindings, might handle the keystroke before it is exposed as a general keystroke.</span></span> <span data-ttu-id="332d7-1206">Если эти входные функции системы пометить событие как обработанное, затем <xref:System.Windows.ContentElement.OnKeyUp%2A> не вызывается.</span><span class="sxs-lookup"><span data-stu-id="332d7-1206">If these input system features mark the event as handled, then <xref:System.Windows.ContentElement.OnKeyUp%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="332d7-1207">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1207">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1208">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1208">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1209">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1209">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1210">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1210">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1211">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1211">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1212">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1212">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1213">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1213">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1214">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1214">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1215">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1215">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.KeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnLostFocus">
      <MemberSignature Language="C#" Value="protected virtual void OnLostFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLostFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLostFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLostFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1216">Объект <see cref="T:System.Windows.RoutedEventArgs" />, содержащий данные события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1216">A <see cref="T:System.Windows.RoutedEventArgs" /> that contains event data.</span>
          </span>
          <span data-ttu-id="332d7-1217">Данные о событии должны содержать идентификатор для события <see cref="E:System.Windows.ContentElement.LostFocus" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1217">This event data must contain the identifier for the <see cref="E:System.Windows.ContentElement.LostFocus" /> event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1218">Вызывает перенаправленное событие <see cref="E:System.Windows.ContentElement.LostFocus" /> с помощью предоставленных данных о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1218">Raises the <see cref="E:System.Windows.ContentElement.LostFocus" /> routed event by using the event data that is provided.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1219">Этот метод, хотя виртуальным, имеет реализацию по умолчанию, который инициирует событие.</span><span class="sxs-lookup"><span data-stu-id="332d7-1219">This method, although virtual, does have a default implementation that raises the event.</span></span>  
  
 <span data-ttu-id="332d7-1220">Это на \* реализации метода предназначен для вызова события, и эта же реализация вызывается внутренне для инициирования события при <xref:System.Windows.ContentElement.IsFocused%2A> изменении значения свойства.</span><span class="sxs-lookup"><span data-stu-id="332d7-1220">This On\* method implementation is intended to raise the event, and this same method implementation is invoked internally to raise the event when the <xref:System.Windows.ContentElement.IsFocused%2A> property value changes.</span></span> <span data-ttu-id="332d7-1221">Эта реализация отличается от некоторых других [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] на \* реализации, которые только предоставляют удобный способ добавить обработчик класса для этого события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1221">This implementation differs from some other [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] On\* implementations, which only provide a convenient way to add class handling for that event.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="332d7-1222">При отсутствии тщательного следует инициирует события фокуса, убедитесь, что ваша реализация вызывает базовую реализацию.</span>
            <span class="sxs-lookup">
              <span data-stu-id="332d7-1222">Unless you have a deliberate and unusual need to not raise the focus events, make sure that your implementation calls the base implementation.</span>
            </span>
            <span data-ttu-id="332d7-1223">В противном случае <see cref="E:System.Windows.ContentElement.LostFocus" /> событие не происходит при выполнении операций типичные действия пользователя, которые обычно устанавливают фокус в данный элемент.</span>
            <span class="sxs-lookup">
              <span data-stu-id="332d7-1223">Otherwise, the <see cref="E:System.Windows.ContentElement.LostFocus" /> event is not raised during typical user operations that ordinarily set focus to this element.</span>
            </span>
            <span data-ttu-id="332d7-1224">Если элемент должен иметь фокус не требуется, вы может помешать элемент может иметь фокус, задав <see cref="P:System.Windows.ContentElement.Focusable" /> для <see langword="false" />.</span>
            <span class="sxs-lookup">
              <span data-stu-id="332d7-1224">If you do not intend your element to be focusable, you can prevent the element from being focusable by setting <see cref="P:System.Windows.ContentElement.Focusable" /> to <see langword="false" />.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1225">Объект <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />, который содержит данные события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1225">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1226">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1226">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.LostKeyboardFocus" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1227">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1227">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1228">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1228">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1229">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1229">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1230">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1230">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1231">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1231">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1232">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1232">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1233">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1233">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1234">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1234">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1235">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1235">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1236">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1236">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnLostMouseCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostMouseCapture (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostMouseCapture(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostMouseCapture(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostMouseCapture (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostMouseCapture(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1237">Объект <see cref="T:System.Windows.Input.MouseEventArgs" />, который содержит данные события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1237">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1238">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1238">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.LostMouseCapture" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1239">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1239">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1240">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1240">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1241">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1241">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1242">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1242">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1243">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1243">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1244">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1244">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1245">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1245">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1246">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1246">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1247">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1247">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1248">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1248">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostMouseCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostStylusCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostStylusCapture (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostStylusCapture(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostStylusCapture(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostStylusCapture (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostStylusCapture(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1249">Объект <see cref="T:System.Windows.Input.StylusEventArgs" />, который содержит данные события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1249">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1250">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1250">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.LostStylusCapture" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1251">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1251">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1252">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1252">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1253">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1253">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1254">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1254">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1255">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1255">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1256">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1256">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1257">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1257">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1258">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1258">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1259">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1259">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1260">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1260">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.LostStylusCapture" />
      </Docs>
    </Member>
    <Member MemberName="OnLostTouchCapture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLostTouchCapture (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLostTouchCapture(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnLostTouchCapture(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLostTouchCapture (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLostTouchCapture(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1261">Объект <see cref="T:System.Windows.Input.TouchEventArgs" />, содержащий данные события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1261">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1262">Предоставляет обработку класса для перенаправленного события <see cref="E:System.Windows.ContentElement.LostTouchCapture" />, которое происходит при потере захвата сенсорного ввода данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1262">Provides class handling for the <see cref="E:System.Windows.ContentElement.LostTouchCapture" /> routed event that occurs when this element loses a touch capture.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1263"><xref:System.Windows.ContentElement.OnLostTouchCapture%2A> У метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1263">The <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> method has no default implementation.</span></span> <span data-ttu-id="332d7-1264">Переопределить <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> в производном классе позволяет обработать <xref:System.Windows.ContentElement.LostTouchCapture> событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-1264">Override <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> in a derived class to handle the <xref:System.Windows.ContentElement.LostTouchCapture> event.</span></span> <span data-ttu-id="332d7-1265">Необходимо вызвать метод базового класса <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> метод, базовые классы получили событие.</span><span class="sxs-lookup"><span data-stu-id="332d7-1265">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnLostTouchCapture%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1266">Объект класса <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1266">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="332d7-1267">Данные этого события содержат сведения о нажатой кнопке мыши и состоянии обработки.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1267">This event data reports details about the mouse button that was pressed and the handled state.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1268">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Mouse.MouseDown" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1268">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1269">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1269">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1270">Действия кнопок мыши также обрабатываются выделенным диспетчером ввода.</span><span class="sxs-lookup"><span data-stu-id="332d7-1270">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="332d7-1271">Другие программные функции, зависит от действия кнопок мыши, такие как входные данные и привязки команд, могут вызывать обработчики для действия, прежде чем оно будет представлено как общее действие кнопки мыши.</span><span class="sxs-lookup"><span data-stu-id="332d7-1271">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="332d7-1272">Если эти входные знак компоненты системы <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> событие как обработанное, <xref:System.Windows.ContentElement.OnMouseDown%2A> не вызывается.</span><span class="sxs-lookup"><span data-stu-id="332d7-1272">If these input system features mark the <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnMouseDown%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="332d7-1273">При использовании этого класса обработчика пометить событие как обработанное потенциально повлияет на следующие события: <xref:System.Windows.ContentElement.MouseLeftButtonDown> и <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1273">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.MouseLeftButtonDown> and <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="332d7-1274">Одно из этих событий могут возникать на принимающей элемент при <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> принимается.</span><span class="sxs-lookup"><span data-stu-id="332d7-1274">Either of these events may be raised on the receiving element when <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="332d7-1275">Если пометить это событие как обработанное в обработке класса, вложенные события все равно инициируются; Однако они передают состояние обработки в данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1275">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="332d7-1276">Если событие обрабатывается в обработку класса, обработчиками для под не вызываются до явно использовать <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> с `handledEventsToo` `true` для присоединения обработчиков.</span><span class="sxs-lookup"><span data-stu-id="332d7-1276">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="332d7-1277">Обработчики класса также не вызываются до этих обработчиков классов были зарегистрированы с <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> подпись с `handledEventsToo` `true`.</span><span class="sxs-lookup"><span data-stu-id="332d7-1277">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="332d7-1278">При обработке <xref:System.Windows.ContentElement.OnMouseDown%2A>, подразумевая учета на обработку класса для всех нажатия кнопки мыши возможные действия.</span><span class="sxs-lookup"><span data-stu-id="332d7-1278">By handling <xref:System.Windows.ContentElement.OnMouseDown%2A>, you are implying that your class handling accounted for all possible mouse button down actions.</span></span> <span data-ttu-id="332d7-1279">Это поведение может быть нежелательным; Поэтому необходимо соблюдайте осторожность при использовании данного виртуального метода для пометки события как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1279">This behavior might be unwanted; therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="332d7-1280">Каждое из событий прямой кнопками имеется виртуальный \* метода. Рассмотрите возможность ли переопределение этих обработчиков класса может оказаться более подходящей.</span><span class="sxs-lookup"><span data-stu-id="332d7-1280">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="332d7-1281">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1281">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1282">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1282">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1283">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1283">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1284">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1284">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1285">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1285">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1286">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1286">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1287">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1287">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1288">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1288">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1289">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1289">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseEnter (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseEnter(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseEnter(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseEnter (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseEnter(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1290">Объект класса <see cref="T:System.Windows.Input.MouseEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1290">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1291">Вызывается, когда необработанное присоединенное событие <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> возникает для этого элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1291">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseEnter" /> attached event is raised on this element.</span>
          </span>
          <span data-ttu-id="332d7-1292">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1292">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1293">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1293">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1294">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1294">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="332d7-1295">Вызов базовой реализации можно до или после специальной обработки, в зависимости от требований.</span><span class="sxs-lookup"><span data-stu-id="332d7-1295">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="332d7-1296">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1296">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1297">В этом случае соответствующее событие является маршрутизируемым, с прямой стратегией маршрутизации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1297">In this case the matching event is a routed event, with a direct routing strategy.</span></span> <span data-ttu-id="332d7-1298">Пометка события обрабатываются по-прежнему полезно для предотвращения обработчиками (для которых не указан `handledEventsToo`) вызов.</span><span class="sxs-lookup"><span data-stu-id="332d7-1298">Marking the event as handled is still useful for preventing the typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeave (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeave(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeave(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeave (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeave(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1299">Объект класса <see cref="T:System.Windows.Input.MouseEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1299">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1300">Вызывается, когда необработанное присоединенное событие <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> возникает для этого элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1300">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseLeave" /> attached event is raised on this element.</span>
          </span>
          <span data-ttu-id="332d7-1301">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1301">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1302">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1302">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1303">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1303">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="332d7-1304">Вызов базовой реализации можно до или после специальной обработки, в зависимости от требований.</span><span class="sxs-lookup"><span data-stu-id="332d7-1304">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="332d7-1305">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1305">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1306">В этом случае соответствующее событие является маршрутизируемым, с прямой стратегией маршрутизации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1306">In this case the matching event is a routed event, with a direct routing strategy.</span></span> <span data-ttu-id="332d7-1307">Пометка события обрабатываются по-прежнему полезно для предотвращения обработчиками (для которых не указан `handledEventsToo`) вызов.</span><span class="sxs-lookup"><span data-stu-id="332d7-1307">Marking the event as handled is still useful for preventing the typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1308">Объект класса <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1308">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="332d7-1309">В данных события сообщается о том, что была нажата левая кнопка мыши.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1309">The event data reports that the left mouse button was pressed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1310">Вызывается, когда необработанное перенаправленное событие <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> возникает для этого элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1310">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseLeftButtonDown" /> routed event is raised on this element.</span>
          </span>
          <span data-ttu-id="332d7-1311">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1311">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1312"><xref:System.Windows.ContentElement.MouseLeftButtonDown> Событие отображается передавать маршруту, но фактически перемещается Косвенным способом.</span><span class="sxs-lookup"><span data-stu-id="332d7-1312">The <xref:System.Windows.ContentElement.MouseLeftButtonDown> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="332d7-1313"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> является базовой событие, которое пузырьков маршрутизации и каждый <xref:System.Windows.ContentElement> вдоль событие маршрута идентичные обработка используется для прямого перенаправленное событие <xref:System.Windows.ContentElement.MouseLeftButtonDown>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1313"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseLeftButtonDown>.</span></span> <span data-ttu-id="332d7-1314">Несмотря на то, что вы можете пометить <xref:System.Windows.ContentElement.MouseLeftButtonDown> событие как обработанное в целях данного элемента, состояние обработки выполнения не является постоянным для остальных элементов на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1314">Although you can mark the <xref:System.Windows.ContentElement.MouseLeftButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="332d7-1315">Тем не менее, может потребоваться пометить событие как обработанное, чтобы предотвратить общих обработчиков экземпляра (те, которые не указывает `handledEventsToo`) вызов.</span><span class="sxs-lookup"><span data-stu-id="332d7-1315">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="332d7-1316">Реализация по умолчанию для общих мыши обработка событий в <xref:System.Windows.ContentElement> прослушивает <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> и преобразует его в соответствующий локального события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1316">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="332d7-1317">Если вы хотите переопределить данную логику, необходимо создать производный класс.</span><span class="sxs-lookup"><span data-stu-id="332d7-1317">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="332d7-1318">В статическом конструкторе производного класса, регистрация обработчика альтернативных класса для <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1318">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="332d7-1319">Невозможно изменить поведение обработки мыши <xref:System.Windows.ContentElement> путем переопределения <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1319">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="332d7-1320">Кроме того можно переопределить этот метод, чтобы изменить обработку события для конкретного состояния мыши.</span><span class="sxs-lookup"><span data-stu-id="332d7-1320">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="332d7-1321">Вы можете отказаться от вызвать базовую реализацию зависит от сценария.</span><span class="sxs-lookup"><span data-stu-id="332d7-1321">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="332d7-1322">Если не вызывается базовый отключает обработку ввода по умолчанию для этого события мыши в классах предка, которые также предполагается, что для вызова <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1322">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A>.</span></span> <span data-ttu-id="332d7-1323">Например, можно получить из <xref:System.Windows.Controls.Button> и Переопределите <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> в производном классе без вызова базовой реализации; Однако это переопределение отключает <xref:System.Windows.Controls.Primitives.ButtonBase.Click> событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-1323">For example, you can derive from <xref:System.Windows.Controls.Button> and override <xref:System.Windows.ContentElement.OnMouseLeftButtonDown%2A> in your derived class without calling the base implementation; however, this override disables the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1324">Объект класса <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1324">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="332d7-1325">Данные о событии информируют об отжатии левой кнопки мыши.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1325">The event data reports that the left mouse button was released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1326">Вызывается, когда необработанное перенаправленное событие <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1326">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseLeftButtonUp" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1327">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1327">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1328"><xref:System.Windows.ContentElement.MouseLeftButtonUp> Событие отображается передавать маршруту, но фактически перемещается Косвенным способом.</span><span class="sxs-lookup"><span data-stu-id="332d7-1328">The <xref:System.Windows.ContentElement.MouseLeftButtonUp> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="332d7-1329"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> является базовой событие, которое пузырьков маршрутизации и каждый <xref:System.Windows.ContentElement> вдоль событие маршрута идентичные обработка используется для прямого перенаправленное событие <xref:System.Windows.ContentElement.MouseLeftButtonUp>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1329"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseLeftButtonUp>.</span></span> <span data-ttu-id="332d7-1330">Несмотря на то, что вы можете пометить <xref:System.Windows.ContentElement.MouseLeftButtonUp> событие как обработанное в целях данного элемента, состояние обработки выполнения не является постоянным для остальных элементов на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1330">Although you can mark the <xref:System.Windows.ContentElement.MouseLeftButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="332d7-1331">Тем не менее, может потребоваться пометить событие как обработанное, чтобы предотвратить общих обработчиков экземпляра (те, которые не указывает `handledEventsToo`) вызов.</span><span class="sxs-lookup"><span data-stu-id="332d7-1331">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="332d7-1332">Реализация по умолчанию для общих мыши обработка событий в <xref:System.Windows.ContentElement> прослушивает <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> и преобразует его в соответствующий локального события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1332">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="332d7-1333">Если вы хотите переопределить данную логику, необходимо создать производный класс.</span><span class="sxs-lookup"><span data-stu-id="332d7-1333">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="332d7-1334">В статическом конструкторе производного класса, регистрация обработчика альтернативных класса для <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1334">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="332d7-1335">Невозможно изменить поведение обработки мыши <xref:System.Windows.ContentElement> путем переопределения <xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1335">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseLeftButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1336">Объект класса <see cref="T:System.Windows.Input.MouseEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1336">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1337">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Mouse.MouseMove" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1337">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseMove" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1338">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1338">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1339">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1339">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1340">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1340">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1341">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1341">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1342">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1342">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1343">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1343">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1344">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1344">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1345">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1345">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1346">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1346">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1347">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1347">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1348">Объект класса <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1348">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="332d7-1349">Данные о событии информируют о нажатии правой кнопки мыши.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1349">The event data reports that the right mouse button was pressed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1350">Вызывается, когда необработанное перенаправленное событие <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1350">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseRightButtonDown" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1351">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1351">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1352"><xref:System.Windows.ContentElement.MouseRightButtonDown> Событие отображается передавать маршруту, но фактически перемещается Косвенным способом.</span><span class="sxs-lookup"><span data-stu-id="332d7-1352">The <xref:System.Windows.ContentElement.MouseRightButtonDown> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="332d7-1353"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> является базовой событие, которое пузырьков маршрутизации и каждый <xref:System.Windows.ContentElement> вдоль событие маршрута идентичные обработка используется для прямого перенаправленное событие <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1353"><xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="332d7-1354">Несмотря на то, что вы можете пометить <xref:System.Windows.ContentElement.MouseRightButtonDown> событие как обработанное в целях данного элемента, состояние обработки выполнения не является постоянным для остальных элементов на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1354">Although you can mark the <xref:System.Windows.ContentElement.MouseRightButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="332d7-1355">Тем не менее, может потребоваться пометить событие как обработанное, чтобы предотвратить общих обработчиков экземпляра (те, которые не указывает `handledEventsToo`) вызов.</span><span class="sxs-lookup"><span data-stu-id="332d7-1355">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="332d7-1356">Реализация по умолчанию для общих мыши обработка событий в <xref:System.Windows.ContentElement> прослушивает <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> и преобразует его в соответствующий локального события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1356">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="332d7-1357">Если вы хотите переопределить данную логику, необходимо создать производный класс.</span><span class="sxs-lookup"><span data-stu-id="332d7-1357">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="332d7-1358">В статическом конструкторе производного класса, регистрация обработчика альтернативных класса для <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1358">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="332d7-1359">Невозможно изменить поведение обработки мыши <xref:System.Windows.ContentElement> путем переопределения <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1359">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="332d7-1360">Кроме того можно переопределить этот метод, чтобы изменить обработку события для конкретного состояния мыши.</span><span class="sxs-lookup"><span data-stu-id="332d7-1360">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="332d7-1361">Вы можете отказаться от вызвать базовую реализацию зависит от сценария.</span><span class="sxs-lookup"><span data-stu-id="332d7-1361">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="332d7-1362">Если не вызывается базовый отключает обработку ввода по умолчанию для этого события мыши в классах предка, которые также предполагается, что для вызова <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1362">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A>.</span></span> <span data-ttu-id="332d7-1363">Например, можно получить из <xref:System.Windows.Controls.Control> и Переопределите <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> в производном классе без вызова базового; Однако это переопределение отключает службы меню контекста на элементе управления, которые входят в состав из <xref:System.Windows.Controls.Control> поведение по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1363">For example, you can derive from <xref:System.Windows.Controls.Control> and override <xref:System.Windows.ContentElement.OnMouseRightButtonDown%2A> in your derived class without calling base; however, this override disables the context menu services on your control, which are part of the <xref:System.Windows.Controls.Control> default behavior.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1364">Объект класса <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1364">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="332d7-1365">Данные о событии информируют об отпускании правой кнопки мыши.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1365">The event data reports that the right mouse button was released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1366">Вызывается, когда необработанное перенаправленное событие <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1366">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.MouseRightButtonUp" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1367">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1367">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1368"><xref:System.Windows.ContentElement.MouseRightButtonUp> Событие отображается передавать маршруту, но фактически перемещается Косвенным способом.</span><span class="sxs-lookup"><span data-stu-id="332d7-1368">The <xref:System.Windows.ContentElement.MouseRightButtonUp> event appears to travel a bubbling route but actually travels in an indirect way.</span></span> <span data-ttu-id="332d7-1369"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> является базовой событие, которое пузырьков маршрутизации и каждый <xref:System.Windows.ContentElement> вдоль событие маршрута идентичные обработка используется для прямого перенаправленное событие <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1369"><xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> is the underlying event that is bubble routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span></span> <span data-ttu-id="332d7-1370">Несмотря на то, что вы можете пометить <xref:System.Windows.ContentElement.MouseRightButtonUp> событие как обработанное в целях данного элемента, состояние обработки выполнения не является постоянным для остальных элементов на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1370">Although you can mark the <xref:System.Windows.ContentElement.MouseRightButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="332d7-1371">Тем не менее, может потребоваться пометить событие как обработанное, чтобы предотвратить общих обработчиков экземпляра (те, которые не указывает `handledEventsToo`) вызов.</span><span class="sxs-lookup"><span data-stu-id="332d7-1371">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="332d7-1372">Реализация по умолчанию для общих мыши обработка событий в <xref:System.Windows.ContentElement> прослушивает <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> и преобразует его в соответствующий локального события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1372">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="332d7-1373">Если вы хотите переопределить данную логику, необходимо создать производный класс.</span><span class="sxs-lookup"><span data-stu-id="332d7-1373">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="332d7-1374">В статическом конструкторе производного класса, регистрация обработчика альтернативных класса для <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1374">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="332d7-1375">Невозможно изменить поведение обработки мыши <xref:System.Windows.ContentElement> путем переопределения <xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1375">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnMouseRightButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1376">Объект класса <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1376">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="332d7-1377">Данные о событии информируют об отжатии кнопки мыши.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1377">The event data reports that the mouse button was released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1378">Вызывается, когда необработанное перенаправленное событие <see cref="E:System.Windows.Input.Mouse.MouseUp" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1378">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseUp" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1379">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1379">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1380">Действия кнопок мыши также обрабатываются выделенным диспетчером ввода.</span><span class="sxs-lookup"><span data-stu-id="332d7-1380">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="332d7-1381">Другие программные функции, зависит от действия кнопок мыши, такие как входные данные и привязки команд, могут вызывать обработчики для действия, прежде чем оно будет представлено как общее действие кнопки мыши.</span><span class="sxs-lookup"><span data-stu-id="332d7-1381">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="332d7-1382">Если эти входные знак компоненты системы <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> событие как обработанное, <xref:System.Windows.ContentElement.OnMouseUp%2A> не вызывается.</span><span class="sxs-lookup"><span data-stu-id="332d7-1382">If these input system features mark the <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnMouseUp%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="332d7-1383">При использовании этого класса обработчика пометить событие как обработанное потенциально повлияет на следующие события: <xref:System.Windows.ContentElement.MouseLeftButtonUp> и <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1383">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.MouseLeftButtonUp> and <xref:System.Windows.ContentElement.MouseRightButtonUp>.</span></span> <span data-ttu-id="332d7-1384">Одно из этих событий может быть вызвано в элементе принимающей при <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> принимается.</span><span class="sxs-lookup"><span data-stu-id="332d7-1384">Either of these events might be raised on the receiving element when <xref:System.Windows.Input.Mouse.MouseUp?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="332d7-1385">Если пометить это событие как обработанное в обработке класса, вложенные события все равно инициируются; Однако они передают состояние обработки в данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1385">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="332d7-1386">Если событие обрабатывается в обработку класса, обработчиками для под не вызываются до явно использовать <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> с `handledEventsToo` `true` для присоединения обработчиков.</span><span class="sxs-lookup"><span data-stu-id="332d7-1386">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="332d7-1387">Обработчики класса также не вызываются до этих обработчиков классов были зарегистрированы с <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> подпись с `handledEventsToo` `true`.</span><span class="sxs-lookup"><span data-stu-id="332d7-1387">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="332d7-1388">При обработке <xref:System.Windows.ContentElement.OnMouseUp%2A>, подразумевая учета на обработку класса для всех возможных отпускания кнопки мыши действия.</span><span class="sxs-lookup"><span data-stu-id="332d7-1388">By handling <xref:System.Windows.ContentElement.OnMouseUp%2A>, you are implying that your class handling accounted for all possible mouse button up actions.</span></span> <span data-ttu-id="332d7-1389">Это поведение может быть нежелательным; Поэтому необходимо соблюдайте осторожность при использовании данного виртуального метода для пометки события как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1389">This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="332d7-1390">Каждое из событий прямой кнопками имеется виртуальный \* метода. Рассмотрите возможность ли переопределение этих обработчиков класса может оказаться более подходящей.</span><span class="sxs-lookup"><span data-stu-id="332d7-1390">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="332d7-1391">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1391">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1392">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1392">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1393">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1393">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1394">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1394">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1395">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1395">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1396">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1396">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1397">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1397">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1398">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1398">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1399">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1399">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnMouseWheel">
      <MemberSignature Language="C#" Value="protected internal virtual void OnMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1400">Объект класса <see cref="T:System.Windows.Input.MouseWheelEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1400">The <see cref="T:System.Windows.Input.MouseWheelEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1401">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1401">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.MouseWheel" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1402">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1402">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1403">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1403">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1404">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1404">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1405">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1405">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1406">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1406">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1407">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1407">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1408">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1408">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1409">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1409">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1410">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1410">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1411">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1411">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragEnter (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragEnter(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragEnter(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragEnter (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragEnter(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1412">Объект класса <see cref="T:System.Windows.DragEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1412">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1413">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1413">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDragEnter" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1414">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1414">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1415">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1415">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1416">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1416">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1417">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1417">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1418">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1418">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1419">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1419">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1420">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1420">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1421">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1421">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1422">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1422">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1423">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1423">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="332d7-1424">Еще один сценарий, в частности для предварительного просмотра событий: пометить их как обрабатываемые, чтобы соответствующие восходящие обработчики класса не вызываются.</span><span class="sxs-lookup"><span data-stu-id="332d7-1424">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragLeave (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragLeave(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragLeave(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragLeave (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragLeave(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1425">Объект класса <see cref="T:System.Windows.DragEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1425">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1426">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1426">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDragLeave" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1427">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1427">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1428">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1428">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1429">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1429">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1430">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1430">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1431">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1431">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1432">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1432">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1433">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1433">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1434">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1434">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1435">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1435">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1436">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1436">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="332d7-1437">Еще один сценарий, в частности для предварительного просмотра событий: пометить их как обрабатываемые, чтобы соответствующие восходящие обработчики класса не вызываются.</span><span class="sxs-lookup"><span data-stu-id="332d7-1437">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDragOver">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDragOver (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDragOver(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDragOver(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDragOver (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDragOver(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1438">Объект класса <see cref="T:System.Windows.DragEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1438">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1439">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1439">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDragOver" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1440">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1440">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1441">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1441">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1442">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1442">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1443">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1443">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1444">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1444">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1445">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1445">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1446">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1446">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1447">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1447">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1448">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1448">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1449">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1449">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="332d7-1450">Еще один сценарий, в частности для предварительного просмотра событий: пометить их как обрабатываемые, чтобы соответствующие восходящие обработчики класса не вызываются.</span><span class="sxs-lookup"><span data-stu-id="332d7-1450">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDragOver" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewDrop">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewDrop (System.Windows.DragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewDrop(class System.Windows.DragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewDrop(System.Windows.DragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewDrop (e As DragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewDrop(System::Windows::DragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1451">Объект класса <see cref="T:System.Windows.DragEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1451">The <see cref="T:System.Windows.DragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1452">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.DragDrop.PreviewDrop" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1452">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewDrop" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1453">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1453">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1454">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1454">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1455">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1455">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1456">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1456">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1457">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1457">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1458">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1458">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1459">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1459">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1460">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1460">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1461">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1461">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1462">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1462">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="332d7-1463">Еще один сценарий, в частности для предварительного просмотра событий: пометить их как обрабатываемые, чтобы соответствующие восходящие обработчики класса не вызываются.</span><span class="sxs-lookup"><span data-stu-id="332d7-1463">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewDrop" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGiveFeedback">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewGiveFeedback (System.Windows.GiveFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGiveFeedback(class System.Windows.GiveFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewGiveFeedback(System.Windows.GiveFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewGiveFeedback (e As GiveFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewGiveFeedback(System::Windows::GiveFeedbackEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.GiveFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1464">Объект класса <see cref="T:System.Windows.GiveFeedbackEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1464">The <see cref="T:System.Windows.GiveFeedbackEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1465">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1465">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewGiveFeedback" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1466">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1466">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1467">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1467">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1468">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1468">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1469">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1469">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1470">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1470">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1471">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1471">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1472">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1472">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1473">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1473">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1474">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1474">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1475">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1475">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="332d7-1476">Еще один сценарий, в частности для предварительного просмотра событий: пометить их как обрабатываемые, чтобы соответствующие восходящие обработчики класса не вызываются.</span><span class="sxs-lookup"><span data-stu-id="332d7-1476">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGiveFeedback" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewGotKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewGotKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewGotKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewGotKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewGotKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1477">Объект класса <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1477">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1478">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1478">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1479">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1479">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1480">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1480">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1481">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1481">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1482">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1482">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1483">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1483">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1484">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1484">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1485">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1485">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1486">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1486">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1487">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1487">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1488">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1488">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="332d7-1489">Еще один сценарий, в частности для предварительного просмотра событий: пометить их как обрабатываемые, чтобы соответствующие восходящие обработчики класса не вызываются.</span><span class="sxs-lookup"><span data-stu-id="332d7-1489">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewKeyDown (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyDown(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewKeyDown (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewKeyDown(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1490">Объект класса <see cref="T:System.Windows.Input.KeyEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1490">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1491">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1491">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1492">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1492">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1493">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1493">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1494">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1494">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1495">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1495">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1496">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1496">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1497">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1497">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1498">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1498">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1499">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1499">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1500">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1500">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1501">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1501">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="332d7-1502">Еще один сценарий, в частности для предварительного просмотра событий: пометить их как обрабатываемые, чтобы соответствующие восходящие обработчики класса не вызываются.</span><span class="sxs-lookup"><span data-stu-id="332d7-1502">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewKeyUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewKeyUp (System.Windows.Input.KeyEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewKeyUp(class System.Windows.Input.KeyEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewKeyUp(System.Windows.Input.KeyEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewKeyUp (e As KeyEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewKeyUp(System::Windows::Input::KeyEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1503">Объект класса <see cref="T:System.Windows.Input.KeyEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1503">The <see cref="T:System.Windows.Input.KeyEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1504">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1504">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewKeyUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1505">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1505">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1506">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1506">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1507">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1507">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1508">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1508">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1509">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1509">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1510">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1510">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1511">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1511">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1512">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1512">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1513">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1513">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1514">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1514">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="332d7-1515">Еще один сценарий, в частности для предварительного просмотра событий: пометить их как обрабатываемые, чтобы соответствующие восходящие обработчики класса не вызываются.</span><span class="sxs-lookup"><span data-stu-id="332d7-1515">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewLostKeyboardFocus (System.Windows.Input.KeyboardFocusChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewLostKeyboardFocus(class System.Windows.Input.KeyboardFocusChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewLostKeyboardFocus(System.Windows.Input.KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewLostKeyboardFocus (e As KeyboardFocusChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewLostKeyboardFocus(System::Windows::Input::KeyboardFocusChangedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.KeyboardFocusChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1516">Объект класса <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1516">The <see cref="T:System.Windows.Input.KeyboardFocusChangedEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1517">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1517">Invoked when an unhandled <see cref="E:System.Windows.Input.Keyboard.PreviewKeyDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1518">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1518">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1519">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1519">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1520">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1520">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1521">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1521">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1522">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1522">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1523">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1523">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1524">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1524">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1525">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1525">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1526">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1526">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1527">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1527">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="332d7-1528">Еще один сценарий, в частности для предварительного просмотра событий: пометить их как обрабатываемые, чтобы соответствующие восходящие обработчики класса не вызываются.</span><span class="sxs-lookup"><span data-stu-id="332d7-1528">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1529">Объект класса <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1529">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="332d7-1530">Данные о событии информируют о нажатии одной или нескольких кнопок мыши.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1530">The event data reports that one or more mouse buttons were pressed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1531">Вызывается, когда необработанное присоединенное перенаправленное событие <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1531">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseDown" /> attached routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1532">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1532">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1533">Действия кнопок мыши также обрабатываются выделенным диспетчером ввода.</span><span class="sxs-lookup"><span data-stu-id="332d7-1533">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="332d7-1534">Другие программные функции, зависит от действия кнопок мыши, такие как входные данные и привязки команд, могут вызывать обработчики для действия, прежде чем оно будет представлено как общее действие кнопки мыши.</span><span class="sxs-lookup"><span data-stu-id="332d7-1534">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="332d7-1535">Если эти входные знак компоненты системы <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> событие как обработанное, <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> не вызывается.</span><span class="sxs-lookup"><span data-stu-id="332d7-1535">If these input system features mark the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="332d7-1536">При использовании этого класса обработчика пометить событие как обработанное потенциально повлияет на следующие события: <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> и <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1536">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>.</span></span> <span data-ttu-id="332d7-1537">Одно из этих событий могут возникать на принимающей элемент при <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> принимается.</span><span class="sxs-lookup"><span data-stu-id="332d7-1537">Either of these events may be raised on the receiving element when <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="332d7-1538">Если пометить это событие как обработанное в обработке класса, вложенные события все равно инициируются; Однако они передают состояние обработки в данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1538">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="332d7-1539">Если событие обрабатывается в обработку класса, обработчиками для под не вызываются до явно использовать <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> с `handledEventsToo` `true` для присоединения обработчиков.</span><span class="sxs-lookup"><span data-stu-id="332d7-1539">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="332d7-1540">Обработчики класса также не вызываются до этих обработчиков классов были зарегистрированы с <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> подпись с `handledEventsToo` `true`.</span><span class="sxs-lookup"><span data-stu-id="332d7-1540">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="332d7-1541">При обработке <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>, подразумевая учета на обработку класса для всех нажатия кнопки мыши возможные действия.</span><span class="sxs-lookup"><span data-stu-id="332d7-1541">By handling <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A>, you are implying that your class handling accounted for all possible mouse button down actions.</span></span> <span data-ttu-id="332d7-1542">Это поведение может быть нежелательным; Поэтому необходимо соблюдайте осторожность при использовании данного виртуального метода для пометки события как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1542">This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="332d7-1543">Каждое из событий прямой кнопками имеется виртуальный \* метода. Рассмотрите возможность ли переопределение этих обработчиков класса может оказаться более подходящей.</span><span class="sxs-lookup"><span data-stu-id="332d7-1543">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="332d7-1544">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1544">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1545">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1545">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1546">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1546">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1547">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1547">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1548">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1548">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1549">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1549">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1550">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1550">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1551">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1551">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1552">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1552">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="332d7-1553">Еще один сценарий, в частности для предварительного просмотра событий: пометить их как обрабатываемые, чтобы соответствующие восходящие обработчики класса не вызываются.</span><span class="sxs-lookup"><span data-stu-id="332d7-1553">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseLeftButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseLeftButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseLeftButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1554">Объект класса <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1554">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="332d7-1555">В данных события сообщается о том, что была нажата левая кнопка мыши.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1555">The event data reports that the left mouse button was pressed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1556">Вызывается, когда необработанное перенаправленное событие <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1556">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1557">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1557">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1558"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> Событие отображается передавать нисходящую, но фактически перемещается Косвенным способом.</span><span class="sxs-lookup"><span data-stu-id="332d7-1558">The <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="332d7-1559"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> является базовой событие, которое направлено туннель, при этом каждая <xref:System.Windows.ContentElement> вдоль событие маршрута идентичные обработка используется для прямого перенаправленное событие <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1559"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown>.</span></span> <span data-ttu-id="332d7-1560">Несмотря на то, что вы можете пометить <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> событие как обработанное в целях данного элемента, состояние обработки выполнения не является постоянным для остальных элементов на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1560">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="332d7-1561">Тем не менее, может потребоваться пометить событие как обработанное, чтобы предотвратить общих обработчиков экземпляра (те, которые не указывает `handledEventsToo`) вызов.</span><span class="sxs-lookup"><span data-stu-id="332d7-1561">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="332d7-1562">Реализация по умолчанию для общих мыши обработка событий в <xref:System.Windows.ContentElement> прослушивает <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> и преобразует его в соответствующий локального события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1562">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="332d7-1563">Если вы хотите переопределить данную логику, необходимо создать производный класс.</span><span class="sxs-lookup"><span data-stu-id="332d7-1563">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="332d7-1564">В статическом конструкторе производного класса, регистрация обработчика альтернативных класса для <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1564">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="332d7-1565">Невозможно изменить поведение обработки мыши <xref:System.Windows.ContentElement> путем переопределения <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1565">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="332d7-1566">Кроме того можно переопределить этот метод, чтобы изменить обработку события для конкретного состояния мыши.</span><span class="sxs-lookup"><span data-stu-id="332d7-1566">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="332d7-1567">Вы можете отказаться от вызвать базовую реализацию зависит от сценария.</span><span class="sxs-lookup"><span data-stu-id="332d7-1567">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="332d7-1568">Если не вызывается базовый отключает обработку ввода по умолчанию для этого события мыши в классах предка, которые также предполагается, что для вызова <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1568">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A>.</span></span> <span data-ttu-id="332d7-1569">Например, можно получить из <xref:System.Windows.Controls.Button> и Переопределите <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> в производном классе без вызова базовой реализации; Однако это переопределение отключает <xref:System.Windows.Controls.Primitives.ButtonBase.Click> событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-1569">For example, you can derive from <xref:System.Windows.Controls.Button> and override <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> in your derived class without calling the base implementation; however, this override disables the <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseLeftButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseLeftButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseLeftButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseLeftButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1570">Объект класса <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1570">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="332d7-1571">Данные о событии информируют об отжатии левой кнопки мыши.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1571">The event data reports that the left mouse button was released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1572">Вызывается, когда необработанное перенаправленное событие <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1572">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1573">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1573">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1574"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> Событие отображается передавать нисходящую, но фактически перемещается Косвенным способом.</span><span class="sxs-lookup"><span data-stu-id="332d7-1574">The <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="332d7-1575"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> является базовой событие, которое направлено туннель, при этом каждая <xref:System.Windows.ContentElement> вдоль событие маршрута идентичные обработка используется для прямого перенаправленное событие <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1575"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp>.</span></span> <span data-ttu-id="332d7-1576">Несмотря на то, что вы можете пометить <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> событие как обработанное в целях данного элемента, состояние обработки выполнения не является постоянным для остальных элементов на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1576">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="332d7-1577">Тем не менее, может потребоваться пометить событие как обработанное, чтобы предотвратить общих обработчиков экземпляра (те, которые не указывает `handledEventsToo`) вызов.</span><span class="sxs-lookup"><span data-stu-id="332d7-1577">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="332d7-1578">Реализация по умолчанию для общих мыши обработка событий в <xref:System.Windows.ContentElement> прослушивает <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> и преобразует его в соответствующий локального события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1578">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="332d7-1579">Если вы хотите переопределить данную логику, необходимо создать производный класс.</span><span class="sxs-lookup"><span data-stu-id="332d7-1579">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="332d7-1580">В статическом конструкторе производного класса, регистрация обработчика альтернативных класса для <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1580">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="332d7-1581">Невозможно изменить поведение обработки мыши <xref:System.Windows.ContentElement> путем переопределения <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1581">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseMove (System.Windows.Input.MouseEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseMove(class System.Windows.Input.MouseEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseMove(System.Windows.Input.MouseEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseMove (e As MouseEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseMove(System::Windows::Input::MouseEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1582">Объект класса <see cref="T:System.Windows.Input.MouseEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1582">The <see cref="T:System.Windows.Input.MouseEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1583">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1583">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseMove" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1584">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1584">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1585">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1585">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1586">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1586">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1587">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1587">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1588">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1588">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1589">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1589">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1590">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1590">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1591">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1591">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1592">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1592">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1593">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1593">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="332d7-1594">Еще один сценарий, в частности для предварительного просмотра событий: пометить их как обрабатываемые, чтобы соответствующие восходящие обработчики класса не вызываются.</span><span class="sxs-lookup"><span data-stu-id="332d7-1594">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseRightButtonDown (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonDown(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseRightButtonDown(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseRightButtonDown (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseRightButtonDown(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1595">Объект класса <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1595">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="332d7-1596">Данные о событии информируют о нажатии правой кнопки мыши.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1596">The event data reports that the right mouse button was pressed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1597">Вызывается, когда необработанное перенаправленное событие <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1597">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1598">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1598">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1599"><xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> Событие отображается передавать нисходящую, но фактически перемещается Косвенным способом.</span><span class="sxs-lookup"><span data-stu-id="332d7-1599">The <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="332d7-1600"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> является базовой событие, которое направлено туннель, при этом каждая <xref:System.Windows.ContentElement> вдоль событие маршрута идентичные обработка используется для прямого перенаправленное событие <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1600"><xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.MouseRightButtonDown>.</span></span> <span data-ttu-id="332d7-1601">Несмотря на то, что вы можете пометить <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> событие как обработанное в целях данного элемента, состояние обработки выполнения не является постоянным для остальных элементов на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1601">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="332d7-1602">Тем не менее, может потребоваться пометить событие как обработанное, чтобы предотвратить общих обработчиков экземпляра (те, которые не указывает `handledEventsToo`) вызов.</span><span class="sxs-lookup"><span data-stu-id="332d7-1602">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="332d7-1603">Реализация по умолчанию для общих мыши обработка событий в <xref:System.Windows.ContentElement> прослушивает <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> и преобразует его в соответствующий локального события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1603">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="332d7-1604">Если вы хотите переопределить данную логику, необходимо создать производный класс.</span><span class="sxs-lookup"><span data-stu-id="332d7-1604">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="332d7-1605">В статическом конструкторе производного класса, регистрация обработчика альтернативных класса для <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1605">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType>.</span></span> <span data-ttu-id="332d7-1606">Невозможно изменить поведение обработки мыши <xref:System.Windows.ContentElement> путем переопределения <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1606">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>.</span></span>  
  
 <span data-ttu-id="332d7-1607">Кроме того можно переопределить этот метод, чтобы изменить обработку события для конкретного состояния мыши.</span><span class="sxs-lookup"><span data-stu-id="332d7-1607">Alternatively, you can override this method in order to change event handling for a specific mouse state.</span></span> <span data-ttu-id="332d7-1608">Вы можете отказаться от вызвать базовую реализацию зависит от сценария.</span><span class="sxs-lookup"><span data-stu-id="332d7-1608">Whether you choose to call the base implementation depends on your scenario.</span></span> <span data-ttu-id="332d7-1609">Если не вызывается базовый отключает обработку ввода по умолчанию для этого события мыши в классах предка, которые также предполагается, что для вызова <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1609">Failing to call base disables default input handling for that mouse event on ancestor classes that also expect to invoke <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A>.</span></span> <span data-ttu-id="332d7-1610">Например, можно получить из <xref:System.Windows.Controls.Control> и Переопределите <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> в производном классе без вызова базового; Однако это переопределение отключает службы меню контекста на элементе управления, которые входят в состав из <xref:System.Windows.Controls.Control> поведение по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1610">For example, you can derive from <xref:System.Windows.Controls.Control> and override <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> in your derived class without calling base; however, this override disables the context menu services on your control, which are part of the <xref:System.Windows.Controls.Control> default behavior.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseRightButtonUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseRightButtonUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseRightButtonUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseRightButtonUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseRightButtonUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1611">Объект класса <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1611">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="332d7-1612">Данные о событии информируют об отпускании правой кнопки мыши.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1612">The event data reports that the right mouse button was released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1613">Вызывается, когда необработанное перенаправленное событие <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1613">Invoked when an unhandled <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> routed event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1614">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1614">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1615"><xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> Событие отображается передавать нисходящую, но фактически перемещается Косвенным способом.</span><span class="sxs-lookup"><span data-stu-id="332d7-1615">The <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> event appears to travel a tunneling route but actually travels in an indirect way.</span></span> <span data-ttu-id="332d7-1616"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> является базовой событие, которое направлено туннель, при этом каждая <xref:System.Windows.ContentElement> вдоль событие маршрута идентичные обработка используется для прямого перенаправленное событие <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1616"><xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> is the underlying event that is tunnel routed, and each <xref:System.Windows.ContentElement> along the event route uses identical handling to raise the direct routed event <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span></span> <span data-ttu-id="332d7-1617">Несмотря на то, что вы можете пометить <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> событие как обработанное в целях данного элемента, состояние обработки выполнения не является постоянным для остальных элементов на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1617">Although you can mark the <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> event as handled for purposes of this element, the handled state does not perpetuate to other elements along the event route.</span></span> <span data-ttu-id="332d7-1618">Тем не менее, может потребоваться пометить событие как обработанное, чтобы предотвратить общих обработчиков экземпляра (те, которые не указывает `handledEventsToo`) вызов.</span><span class="sxs-lookup"><span data-stu-id="332d7-1618">However, you might want to mark the event as handled in order to prevent general instance handlers (those that did not specify `handledEventsToo`) from being invoked.</span></span>  
  
 <span data-ttu-id="332d7-1619">Реализация по умолчанию для общих мыши обработка событий в <xref:System.Windows.ContentElement> прослушивает <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> и преобразует его в соответствующий локального события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1619">The default implementation for general mouse event handling in <xref:System.Windows.ContentElement> listens for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> and converts it to an appropriate local event.</span></span> <span data-ttu-id="332d7-1620">Если вы хотите переопределить данную логику, необходимо создать производный класс.</span><span class="sxs-lookup"><span data-stu-id="332d7-1620">If you want to override this logic, you must create a derived class.</span></span> <span data-ttu-id="332d7-1621">В статическом конструкторе производного класса, регистрация обработчика альтернативных класса для <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1621">In the static constructor of your derived class, register an alternative class handler for <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType>.</span></span> <span data-ttu-id="332d7-1622">Невозможно изменить поведение обработки мыши <xref:System.Windows.ContentElement> путем переопределения <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1622">You cannot change the mouse handling behavior of <xref:System.Windows.ContentElement> by overriding <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseUp (System.Windows.Input.MouseButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseUp(class System.Windows.Input.MouseButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseUp(System.Windows.Input.MouseButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseUp (e As MouseButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseUp(System::Windows::Input::MouseButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1623">Объект класса <see cref="T:System.Windows.Input.MouseButtonEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1623">The <see cref="T:System.Windows.Input.MouseButtonEventArgs" /> that contains the event data.</span>
          </span>
          <span data-ttu-id="332d7-1624">Данные о событии информируют об отжатии одной или нескольких кнопок мыши.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1624">The event data reports that one or more mouse buttons were released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1625">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1625">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1626">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1626">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1627">Действия кнопок мыши также обрабатываются выделенным диспетчером ввода.</span><span class="sxs-lookup"><span data-stu-id="332d7-1627">Mouse button actions are also handled by a dedicated input manager.</span></span> <span data-ttu-id="332d7-1628">Другие программные функции, зависит от действия кнопок мыши, такие как входные данные и привязки команд, могут вызывать обработчики для действия, прежде чем оно будет представлено как общее действие кнопки мыши.</span><span class="sxs-lookup"><span data-stu-id="332d7-1628">Other programming features that rely on mouse button actions, such as input and command bindings, might invoke handlers for the action before it is exposed as a general mouse button action.</span></span> <span data-ttu-id="332d7-1629">Если эти входные знак компоненты системы <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> событие как обработанное, <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> не вызывается.</span><span class="sxs-lookup"><span data-stu-id="332d7-1629">If these input system features mark the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event as handled, <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> is not invoked.</span></span>  
  
 <span data-ttu-id="332d7-1630">При использовании этого класса обработчика пометить событие как обработанное потенциально повлияет на следующие события: <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> и <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span><span class="sxs-lookup"><span data-stu-id="332d7-1630">If you use this class handler to mark the event as handled, you potentially impact the following events: <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span></span> <span data-ttu-id="332d7-1631">Одно из этих событий может быть вызвано в элементе принимающей при <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> принимается.</span><span class="sxs-lookup"><span data-stu-id="332d7-1631">Either of these events might be raised on the receiving element when <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> is received.</span></span>  
  
 <span data-ttu-id="332d7-1632">Если пометить это событие как обработанное в обработке класса, вложенные события все равно инициируются; Однако они передают состояние обработки в данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1632">If you mark this event as handled in class handling, subevents are still raised; however, they pass the handled state in the event data.</span></span> <span data-ttu-id="332d7-1633">Если событие обрабатывается в обработку класса, обработчиками для под не вызываются до явно использовать <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> с `handledEventsToo` `true` для присоединения обработчиков.</span><span class="sxs-lookup"><span data-stu-id="332d7-1633">If the event is handled in class handling, instance handlers for the subevents are not invoked unless you explicitly use <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> with `handledEventsToo` `true` in order to attach handlers.</span></span> <span data-ttu-id="332d7-1634">Обработчики класса также не вызываются до этих обработчиков классов были зарегистрированы с <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> подпись с `handledEventsToo` `true`.</span><span class="sxs-lookup"><span data-stu-id="332d7-1634">Class handlers also are not invoked unless those class handlers were registered with the <xref:System.Windows.EventManager.RegisterClassHandler%28System.Type%2CSystem.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature with `handledEventsToo` `true`.</span></span> <span data-ttu-id="332d7-1635">При обработке <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>, подразумевая учета на обработку класса для всех возможных отпускания кнопки мыши действия.</span><span class="sxs-lookup"><span data-stu-id="332d7-1635">By handling <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A>, you are implying that your class handling accounted for all possible mouse button up actions.</span></span> <span data-ttu-id="332d7-1636">Это поведение может быть нежелательным; Поэтому необходимо соблюдайте осторожность при использовании данного виртуального метода для пометки события как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1636">This behavior might be unwanted; Therefore, use caution when you use this virtual method to mark events as handled.</span></span>  
  
 <span data-ttu-id="332d7-1637">Каждое из событий прямой кнопками имеется виртуальный \* метода. Рассмотрите возможность ли переопределение этих обработчиков класса может оказаться более подходящей.</span><span class="sxs-lookup"><span data-stu-id="332d7-1637">Each of the button-specific direct events also has a virtual On\* method; consider whether overriding these button-specific class handlers might be more appropriate.</span></span>  
  
 <span data-ttu-id="332d7-1638">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1638">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1639">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1639">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1640">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1640">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1641">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1641">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1642">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1642">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1643">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1643">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1644">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1644">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1645">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1645">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1646">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1646">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewMouseWheel">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewMouseWheel (System.Windows.Input.MouseWheelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewMouseWheel(class System.Windows.Input.MouseWheelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewMouseWheel(System.Windows.Input.MouseWheelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewMouseWheel (e As MouseWheelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewMouseWheel(System::Windows::Input::MouseWheelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.MouseWheelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1647">Объект класса <see cref="T:System.Windows.Input.MouseWheelEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1647">The <see cref="T:System.Windows.Input.MouseWheelEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1648">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1648">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.PreviewMouseWheel" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1649">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1649">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1650">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1650">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1651">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1651">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1652">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1652">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1653">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1653">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1654">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1654">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1655">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1655">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1656">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1656">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1657">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1657">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1658">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1658">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="332d7-1659">Еще один сценарий, в частности для предварительного просмотра событий: пометить их как обрабатываемые, чтобы соответствующие восходящие обработчики класса не вызываются.</span><span class="sxs-lookup"><span data-stu-id="332d7-1659">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewMouseWheel" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1660">Объект класса <see cref="T:System.Windows.QueryContinueDragEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1660">The <see cref="T:System.Windows.QueryContinueDragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1661">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1661">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.PreviewQueryContinueDrag" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1662">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1662">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1663">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1663">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1664">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1664">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1665">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1665">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1666">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1666">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1667">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1667">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1668">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1668">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1669">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1669">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1670">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1670">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1671">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1671">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="332d7-1672">Еще один сценарий, в частности для предварительного просмотра событий: пометить их как обрабатываемые, чтобы соответствующие восходящие обработчики класса не вызываются.</span><span class="sxs-lookup"><span data-stu-id="332d7-1672">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1673">Объект класса <see cref="T:System.Windows.Input.StylusButtonEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1673">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1674">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1674">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1675">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1675">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1676">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1676">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1677">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1677">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1678">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1678">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1679">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1679">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1680">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1680">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1681">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1681">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1682">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1682">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1683">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1683">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1684">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1684">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="332d7-1685">Еще один сценарий, в частности для предварительного просмотра событий: пометить их как обрабатываемые, чтобы соответствующие восходящие обработчики класса не вызываются.</span><span class="sxs-lookup"><span data-stu-id="332d7-1685">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1686">Объект класса <see cref="T:System.Windows.Input.StylusButtonEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1686">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1687">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1687">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusButtonUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1688">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1688">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1689">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1689">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1690">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1690">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1691">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1691">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1692">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1692">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1693">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1693">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1694">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1694">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1695">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1695">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1696">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1696">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1697">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1697">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="332d7-1698">Еще один сценарий, в частности для предварительного просмотра событий: пометить их как обрабатываемые, чтобы соответствующие восходящие обработчики класса не вызываются.</span><span class="sxs-lookup"><span data-stu-id="332d7-1698">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1699">Объект класса <see cref="T:System.Windows.Input.StylusDownEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1699">The <see cref="T:System.Windows.Input.StylusDownEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1700">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1700">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1701">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1701">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1702">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1702">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1703">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1703">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1704">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1704">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1705">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1705">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1706">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1706">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1707">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1707">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1708">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1708">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1709">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1709">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1710">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1710">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="332d7-1711">Еще один сценарий, в частности для предварительного просмотра событий: пометить их как обрабатываемые, чтобы соответствующие восходящие обработчики класса не вызываются.</span><span class="sxs-lookup"><span data-stu-id="332d7-1711">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1712">Объект класса <see cref="T:System.Windows.Input.StylusEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1712">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1713">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1713">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusInAirMove" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1714">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1714">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1715">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1715">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1716">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1716">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1717">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1717">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1718">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1718">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1719">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1719">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1720">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1720">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1721">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1721">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1722">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1722">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1723">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1723">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="332d7-1724">Еще один сценарий, в частности для предварительного просмотра событий: пометить их как обрабатываемые, чтобы соответствующие восходящие обработчики класса не вызываются.</span><span class="sxs-lookup"><span data-stu-id="332d7-1724">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusInRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1725">Объект класса <see cref="T:System.Windows.Input.StylusEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1725">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1726">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1726">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusInRange" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1727">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1727">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1728">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1728">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1729">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1729">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1730">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1730">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1731">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1731">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1732">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1732">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1733">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1733">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1734">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1734">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1735">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1735">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1736">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1736">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="332d7-1737">Еще один сценарий, в частности для предварительного просмотра событий: пометить их как обрабатываемые, чтобы соответствующие восходящие обработчики класса не вызываются.</span><span class="sxs-lookup"><span data-stu-id="332d7-1737">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1738">Объект класса <see cref="T:System.Windows.Input.StylusEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1738">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1739">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1739">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusMove" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1740">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1740">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1741">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1741">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1742">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1742">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1743">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1743">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1744">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1744">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1745">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1745">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1746">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1746">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1747">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1747">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1748">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1748">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1749">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1749">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="332d7-1750">Еще один сценарий, в частности для предварительного просмотра событий: пометить их как обрабатываемые, чтобы соответствующие восходящие обработчики класса не вызываются.</span><span class="sxs-lookup"><span data-stu-id="332d7-1750">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1751">Объект класса <see cref="T:System.Windows.Input.StylusEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1751">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1752">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1752">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusOutOfRange" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1753">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1753">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1754">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1754">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1755">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1755">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1756">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1756">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1757">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1757">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1758">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1758">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1759">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1759">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1760">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1760">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1761">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1761">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1762">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1762">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="332d7-1763">Еще один сценарий, в частности для предварительного просмотра событий: пометить их как обрабатываемые, чтобы соответствующие восходящие обработчики класса не вызываются.</span><span class="sxs-lookup"><span data-stu-id="332d7-1763">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1764">Объект класса <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1764">The <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1765">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1765">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusSystemGesture" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1766">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1766">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1767">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1767">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1768">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1768">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1769">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1769">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1770">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1770">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1771">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1771">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1772">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1772">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1773">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1773">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1774">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1774">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1775">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1775">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="332d7-1776">Еще один сценарий, в частности для предварительного просмотра событий: пометить их как обрабатываемые, чтобы соответствующие восходящие обработчики класса не вызываются.</span><span class="sxs-lookup"><span data-stu-id="332d7-1776">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewStylusUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1777">Объект класса <see cref="T:System.Windows.Input.StylusEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1777">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1778">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1778">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.PreviewStylusUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1779">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1779">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1780">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1780">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1781">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1781">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1782">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1782">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1783">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1783">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1784">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1784">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1785">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1785">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1786">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1786">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1787">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1787">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1788">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1788">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="332d7-1789">Еще один сценарий, в частности для предварительного просмотра событий: пометить их как обрабатываемые, чтобы соответствующие восходящие обработчики класса не вызываются.</span><span class="sxs-lookup"><span data-stu-id="332d7-1789">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTextInput">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1790">Объект класса <see cref="T:System.Windows.Input.TextCompositionEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1790">The <see cref="T:System.Windows.Input.TextCompositionEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1791">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1791">Invoked when an unhandled <see cref="E:System.Windows.Input.TextCompositionManager.PreviewTextInput" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1792">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1792">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1793">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1793">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1794">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1794">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1795">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1795">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1796">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1796">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1797">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1797">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1798">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1798">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1799">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1799">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1800">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1800">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1801">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1801">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span> <span data-ttu-id="332d7-1802">Еще один сценарий, в частности для предварительного просмотра событий: пометить их как обрабатываемые, чтобы соответствующие восходящие обработчики класса не вызываются.</span><span class="sxs-lookup"><span data-stu-id="332d7-1802">Another scenario that is specifically for Preview events is to mark them handled so that the matching bubbling class handlers are not invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.OnPreviewKeyDown(System.Windows.Input.KeyEventArgs)" />
        <altmember cref="E:System.Windows.ContentElement.PreviewTextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1803">Объект <see cref="T:System.Windows.Input.TouchEventArgs" />, содержащий данные события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1803">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1804">Предоставляет обработку класса для перенаправленного события <see cref="E:System.Windows.ContentElement.PreviewTouchDown" />, которое происходит при сенсорном нажатии данного элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1804">Provides class handling for the <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> routed event that occurs when a touch presses this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1805"><xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> У метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1805">The <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> method has no default implementation.</span></span> <span data-ttu-id="332d7-1806">Переопределить <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> в производном классе позволяет обработать <xref:System.Windows.ContentElement.PreviewTouchDown> событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-1806">Override <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> in a derived class to handle the <xref:System.Windows.ContentElement.PreviewTouchDown> event.</span></span> <span data-ttu-id="332d7-1807">Необходимо вызвать метод базового класса <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> метод, базовые классы получили событие.</span><span class="sxs-lookup"><span data-stu-id="332d7-1807">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1808">Объект <see cref="T:System.Windows.Input.TouchEventArgs" />, содержащий данные события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1808">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1809">Предоставляет обработку класса для маршрутизируемого события <see cref="E:System.Windows.ContentElement.PreviewTouchMove" />, которое происходит при перемещении касания внутри этого элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1809">Provides class handling for the <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> routed event that occurs when a touch moves while inside this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1810"><xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> У метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1810">The <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> method has no default implementation.</span></span> <span data-ttu-id="332d7-1811">Переопределить <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> в производном классе позволяет обработать <xref:System.Windows.ContentElement.PreviewTouchMove> событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-1811">Override <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> in a derived class to handle the <xref:System.Windows.ContentElement.PreviewTouchMove> event.</span></span> <span data-ttu-id="332d7-1812">Необходимо вызвать метод базового класса <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> метод, базовые классы получили событие.</span><span class="sxs-lookup"><span data-stu-id="332d7-1812">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPreviewTouchUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreviewTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreviewTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnPreviewTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreviewTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreviewTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1813">Объект <see cref="T:System.Windows.Input.TouchEventArgs" />, содержащий данные события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1813">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1814">Предоставляет обработку класса для перенаправленного события <see cref="E:System.Windows.ContentElement.PreviewTouchUp" />, которое происходит при прекращении сенсорного нажатия внутри элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1814">Provides class handling for the <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> routed event that occurs when a touch is released inside this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1815"><xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> У метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1815">The <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> method has no default implementation.</span></span> <span data-ttu-id="332d7-1816">Переопределить <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> в производном классе позволяет обработать <xref:System.Windows.ContentElement.PreviewTouchUp> событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-1816">Override <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> in a derived class to handle the <xref:System.Windows.ContentElement.PreviewTouchUp> event.</span></span> <span data-ttu-id="332d7-1817">Необходимо вызвать метод базового класса <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> метод, базовые классы получили событие.</span><span class="sxs-lookup"><span data-stu-id="332d7-1817">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnQueryContinueDrag">
      <MemberSignature Language="C#" Value="protected internal virtual void OnQueryContinueDrag (System.Windows.QueryContinueDragEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryContinueDrag(class System.Windows.QueryContinueDragEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnQueryContinueDrag(System.Windows.QueryContinueDragEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnQueryContinueDrag (e As QueryContinueDragEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnQueryContinueDrag(System::Windows::QueryContinueDragEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.QueryContinueDragEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1818">Объект класса <see cref="T:System.Windows.QueryContinueDragEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1818">The <see cref="T:System.Windows.QueryContinueDragEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1819">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1819">Invoked when an unhandled <see cref="E:System.Windows.DragDrop.QueryContinueDrag" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1820">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1820">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1821">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1821">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1822">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1822">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1823">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1823">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1824">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1824">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1825">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1825">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1826">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1826">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1827">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1827">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1828">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1828">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1829">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1829">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryContinueDrag" />
      </Docs>
    </Member>
    <Member MemberName="OnQueryCursor">
      <MemberSignature Language="C#" Value="protected internal virtual void OnQueryCursor (System.Windows.Input.QueryCursorEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnQueryCursor(class System.Windows.Input.QueryCursorEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnQueryCursor(System.Windows.Input.QueryCursorEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnQueryCursor (e As QueryCursorEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnQueryCursor(System::Windows::Input::QueryCursorEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.QueryCursorEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1830">Объект класса <see cref="T:System.Windows.Input.QueryCursorEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1830">The <see cref="T:System.Windows.Input.QueryCursorEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1831">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1831">Invoked when an unhandled <see cref="E:System.Windows.Input.Mouse.QueryCursor" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1832">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1832">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1833">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1833">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1834">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1834">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1835">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1835">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1836">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1836">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1837">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1837">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1838">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1838">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1839">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1839">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1840">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1840">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1841">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1841">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.QueryCursor" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusButtonDown (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonDown(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusButtonDown(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusButtonDown (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusButtonDown(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1842">Объект класса <see cref="T:System.Windows.Input.StylusButtonEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1842">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1843">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1843">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusButtonDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1844">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1844">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1845">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1845">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1846">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1846">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1847">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1847">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1848">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1848">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1849">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1849">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1850">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1850">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1851">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1851">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1852">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1852">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1853">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1853">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusButtonUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusButtonUp (System.Windows.Input.StylusButtonEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusButtonUp(class System.Windows.Input.StylusButtonEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusButtonUp(System.Windows.Input.StylusButtonEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusButtonUp (e As StylusButtonEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusButtonUp(System::Windows::Input::StylusButtonEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusButtonEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1854">Объект класса <see cref="T:System.Windows.Input.StylusButtonEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1854">The <see cref="T:System.Windows.Input.StylusButtonEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1855">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1855">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusButtonUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1856">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1856">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1857">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1857">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1858">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1858">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1859">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1859">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1860">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1860">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1861">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1861">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1862">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1862">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1863">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1863">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1864">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1864">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1865">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1865">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusDown (System.Windows.Input.StylusDownEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusDown(class System.Windows.Input.StylusDownEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusDown(System.Windows.Input.StylusDownEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusDown (e As StylusDownEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusDown(System::Windows::Input::StylusDownEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusDownEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1866">Объект класса <see cref="T:System.Windows.Input.StylusDownEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1866">The <see cref="T:System.Windows.Input.StylusDownEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1867">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.StylusDown" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1867">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusDown" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1868">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1868">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1869">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1869">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1870">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1870">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1871">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1871">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1872">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1872">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1873">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1873">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1874">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1874">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1875">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1875">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1876">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1876">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1877">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1877">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusDown" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusEnter (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusEnter(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusEnter(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusEnter (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusEnter(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1878">Объект класса <see cref="T:System.Windows.Input.StylusEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1878">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1879">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> вызывается этим элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1879">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusEnter" /> attached event is raised by this element.</span>
          </span>
          <span data-ttu-id="332d7-1880">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1880">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1881">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1881">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1882">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1882">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="332d7-1883">Вызов базовой реализации можно до или после специальной обработки, в зависимости от требований.</span><span class="sxs-lookup"><span data-stu-id="332d7-1883">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="332d7-1884">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1884">The purpose of this method is similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1885">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1885">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1886">Пометка события обрабатываются по-прежнему полезно для предотвращения обработчиками (для которых не указан `handledEventsToo`) вызов.</span><span class="sxs-lookup"><span data-stu-id="332d7-1886">Marking the event as handled is still useful for preventing typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusEnter" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInAirMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusInAirMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInAirMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusInAirMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusInAirMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusInAirMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1887">Объект класса <see cref="T:System.Windows.Input.StylusEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1887">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1888">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1888">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusInAirMove" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1889">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1889">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1890">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1890">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1891">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1891">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1892">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1892">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1893">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1893">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1894">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1894">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1895">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1895">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1896">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1896">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1897">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1897">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1898">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1898">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusInAirMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusInRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusInRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusInRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusInRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusInRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusInRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1899">Объект класса <see cref="T:System.Windows.Input.StylusEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1899">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1900">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1900">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusInRange" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1901">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1901">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1902">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1902">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1903">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1903">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1904">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1904">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1905">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1905">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1906">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1906">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1907">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1907">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1908">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1908">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1909">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1909">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1910">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1910">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusInRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusLeave (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusLeave(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusLeave(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusLeave (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusLeave(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1911">Объект класса <see cref="T:System.Windows.Input.StylusEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1911">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1912">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> вызывается этим элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1912">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusLeave" /> attached event is raised by this element.</span>
          </span>
          <span data-ttu-id="332d7-1913">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1913">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1914">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1914">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1915">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1915">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span> <span data-ttu-id="332d7-1916">Вызов базовой реализации можно до или после специальной обработки, в зависимости от требований.</span><span class="sxs-lookup"><span data-stu-id="332d7-1916">You may call base either before or after your special handling, depending on your requirements.</span></span>  
  
 <span data-ttu-id="332d7-1917">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1917">The purpose of this method is similar to [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1918">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1918">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1919">Пометка события обрабатываются по-прежнему полезно для предотвращения обработчиками (для которых не указан `handledEventsToo`) вызов.</span><span class="sxs-lookup"><span data-stu-id="332d7-1919">Marking the event as handled is still useful for preventing typical instance handlers (those that do not specify `handledEventsToo`) from being invoked.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusLeave" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusMove (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusMove(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusMove(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusMove (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusMove(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1920">Объект класса <see cref="T:System.Windows.Input.StylusEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1920">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1921">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.StylusMove" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1921">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusMove" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1922">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1922">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1923">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1923">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1924">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1924">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1925">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1925">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1926">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1926">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1927">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1927">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1928">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1928">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1929">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1929">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1930">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1930">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1931">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1931">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusMove" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusOutOfRange">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusOutOfRange (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusOutOfRange(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusOutOfRange(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusOutOfRange (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusOutOfRange(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1932">Объект класса <see cref="T:System.Windows.Input.StylusEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1932">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1933">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1933">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusOutOfRange" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1934">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1934">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1935">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1935">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1936">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1936">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1937">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1937">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1938">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1938">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1939">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1939">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1940">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1940">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1941">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1941">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1942">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1942">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1943">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1943">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusOutOfRange" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusSystemGesture">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusSystemGesture (System.Windows.Input.StylusSystemGestureEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusSystemGesture(class System.Windows.Input.StylusSystemGestureEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusSystemGesture(System.Windows.Input.StylusSystemGestureEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusSystemGesture (e As StylusSystemGestureEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusSystemGesture(System::Windows::Input::StylusSystemGestureEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusSystemGestureEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1944">Объект класса <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1944">The <see cref="T:System.Windows.Input.StylusSystemGestureEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1945">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1945">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusSystemGesture" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1946">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1946">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1947">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1947">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1948">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1948">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1949">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1949">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1950">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1950">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1951">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1951">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1952">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1952">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1953">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1953">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1954">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1954">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1955">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1955">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusSystemGesture" />
      </Docs>
    </Member>
    <Member MemberName="OnStylusUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStylusUp (System.Windows.Input.StylusEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStylusUp(class System.Windows.Input.StylusEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnStylusUp(System.Windows.Input.StylusEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStylusUp (e As StylusEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStylusUp(System::Windows::Input::StylusEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.StylusEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1956">Объект класса <see cref="T:System.Windows.Input.StylusEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1956">The <see cref="T:System.Windows.Input.StylusEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1957">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.Stylus.StylusUp" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1957">Invoked when an unhandled <see cref="E:System.Windows.Input.Stylus.StylusUp" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1958">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1958">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1959">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1959">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1960">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1960">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1961">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1961">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1962">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1962">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1963">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1963">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1964">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1964">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1965">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1965">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1966">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1966">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1967">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1967">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusUp" />
      </Docs>
    </Member>
    <Member MemberName="OnTextInput">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTextInput (System.Windows.Input.TextCompositionEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTextInput(class System.Windows.Input.TextCompositionEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTextInput(System.Windows.Input.TextCompositionEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTextInput (e As TextCompositionEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTextInput(System::Windows::Input::TextCompositionEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TextCompositionEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1968">Объект класса <see cref="T:System.Windows.Input.TextCompositionEventArgs" />, содержащий данные о событии.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1968">The <see cref="T:System.Windows.Input.TextCompositionEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1969">Вызывается, когда необработанное вложенное событие <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> встречает на своем маршруте элемент, производный от этого класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1969">Invoked when an unhandled <see cref="E:System.Windows.Input.TextCompositionManager.TextInput" /> attached event reaches an element in its route that is derived from this class.</span>
          </span>
          <span data-ttu-id="332d7-1970">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1970">Implement this method to add class handling for this event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1971">У этого метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1971">This method has no default implementation.</span></span> <span data-ttu-id="332d7-1972">Поскольку промежуточный класс в цепочке наследования может реализовать этот метод, рекомендуется вызывать базовую реализацию в реализации.</span><span class="sxs-lookup"><span data-stu-id="332d7-1972">Because an intermediate class in the inheritance might implement this method, we recommend that you call the base implementation in your implementation.</span></span>  
  
 <span data-ttu-id="332d7-1973">Этот метод аналогичен [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On \* методы: этот метод предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</span><span class="sxs-lookup"><span data-stu-id="332d7-1973">The purpose of this method is similar to the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] event pattern On\* methods: this method provides the means to handle the matching event from derived classes by establishing a class handler instead of an instance handler.</span></span> <span data-ttu-id="332d7-1974">В этом случае соответствующее событие является маршрутизируемым.</span><span class="sxs-lookup"><span data-stu-id="332d7-1974">In this case the matching event is a routed event.</span></span> <span data-ttu-id="332d7-1975">Шаблон реализации методов On \* отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, который не обязательно является элемент, который будет вызывать обработчики.</span><span class="sxs-lookup"><span data-stu-id="332d7-1975">The implementation pattern of the On\* methods is different for routed events because a routed event can be raised by a child element, which is not necessarily the element that will invoke handlers.</span></span> <span data-ttu-id="332d7-1976">Таким образом реализации необходимо изучить исходные свойства данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1976">Therefore, your implementation needs to examine the source properties of the event data.</span></span> <span data-ttu-id="332d7-1977">Чтобы повторно инициировать событие в большинстве случаев не рекомендуется.</span><span class="sxs-lookup"><span data-stu-id="332d7-1977">It should not try to reraise the event in most cases.</span></span>  
  
 <span data-ttu-id="332d7-1978">Путем переопределения этого метода или путем регистрации класса обработчиков с <xref:System.Windows.EventManager.RegisterClassHandler%2A>, классы, унаследованные от <xref:System.Windows.ContentElement> может вызывать методы обработчика закрытый класс, при получении события на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-1978">Either by overriding this method or by registering class handlers with <xref:System.Windows.EventManager.RegisterClassHandler%2A>, derived classes of <xref:System.Windows.ContentElement> can call private class handler methods when the event is received along the event route.</span></span> <span data-ttu-id="332d7-1979">Один сценарий, где обработка класса является управление данными события и пометить перенаправленное событие как обработанное.</span><span class="sxs-lookup"><span data-stu-id="332d7-1979">One scenario where class handling is appropriate is to manipulate the event data and mark the routed event as handled.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.TextInput" />
      </Docs>
    </Member>
    <Member MemberName="OnTouchDown">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchDown (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchDown(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchDown(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchDown (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchDown(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1980">Объект <see cref="T:System.Windows.Input.TouchEventArgs" />, содержащий данные события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1980">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1981">Предоставляет обработку класса для перенаправленного события <see cref="E:System.Windows.ContentElement.TouchDown" />, которое происходит при сенсорном нажатии внутри данного элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1981">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchDown" /> routed event that occurs when a touch presses inside this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1982"><xref:System.Windows.ContentElement.OnTouchDown%2A> У метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1982">The <xref:System.Windows.ContentElement.OnTouchDown%2A> method has no default implementation.</span></span> <span data-ttu-id="332d7-1983">Переопределить <xref:System.Windows.ContentElement.OnTouchDown%2A> в производном классе позволяет обработать <xref:System.Windows.ContentElement.TouchDown> событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-1983">Override <xref:System.Windows.ContentElement.OnTouchDown%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchDown> event.</span></span> <span data-ttu-id="332d7-1984">Необходимо вызвать метод базового класса <xref:System.Windows.ContentElement.OnTouchDown%2A> метод, базовые классы получили событие.</span><span class="sxs-lookup"><span data-stu-id="332d7-1984">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnTouchDown%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchEnter">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchEnter (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchEnter(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchEnter(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchEnter (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchEnter(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1985">Объект <see cref="T:System.Windows.Input.TouchEventArgs" />, содержащий данные события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1985">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1986">Предоставляет обработку класса для перенаправленного события <see cref="E:System.Windows.ContentElement.TouchEnter" />, которое происходит при сенсорном перемещении внутрь данного элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1986">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchEnter" /> routed event that occurs when a touch moves from outside to inside the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1987"><xref:System.Windows.ContentElement.OnTouchEnter%2A> У метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1987">The <xref:System.Windows.ContentElement.OnTouchEnter%2A> method has no default implementation.</span></span> <span data-ttu-id="332d7-1988">Переопределить <xref:System.Windows.ContentElement.OnTouchEnter%2A> в производном классе позволяет обработать <xref:System.Windows.ContentElement.TouchEnter> событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-1988">Override <xref:System.Windows.ContentElement.OnTouchEnter%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchEnter> event.</span></span> <span data-ttu-id="332d7-1989">Необходимо вызвать метод базового класса <xref:System.Windows.ContentElement.OnTouchEnter%2A> метод, базовые классы получили событие.</span><span class="sxs-lookup"><span data-stu-id="332d7-1989">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnTouchEnter%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchLeave">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchLeave (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchLeave(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchLeave(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchLeave (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchLeave(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1990">Объект <see cref="T:System.Windows.Input.TouchEventArgs" />, содержащий данные события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1990">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1991">Предоставляет обработку класса для перенаправленного события <see cref="E:System.Windows.ContentElement.TouchLeave" />, которое происходит при сенсорном перемещении за границы данного элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1991">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchLeave" /> routed event that occurs when a touch moves from inside to outside the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1992"><xref:System.Windows.ContentElement.OnTouchLeave%2A> У метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1992">The <xref:System.Windows.ContentElement.OnTouchLeave%2A> method has no default implementation.</span></span> <span data-ttu-id="332d7-1993">Переопределить <xref:System.Windows.ContentElement.OnTouchLeave%2A> в производном классе позволяет обработать <xref:System.Windows.ContentElement.TouchLeave> событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-1993">Override <xref:System.Windows.ContentElement.OnTouchLeave%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchLeave> event.</span></span> <span data-ttu-id="332d7-1994">Необходимо вызвать метод базового класса <xref:System.Windows.ContentElement.OnTouchLeave%2A> метод, базовые классы получили событие.</span><span class="sxs-lookup"><span data-stu-id="332d7-1994">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnTouchLeave%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchMove">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchMove (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchMove(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchMove(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchMove (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchMove(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-1995">Объект <see cref="T:System.Windows.Input.TouchEventArgs" />, содержащий данные события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1995">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-1996">Предоставляет обработку класса для маршрутизируемого события <see cref="E:System.Windows.ContentElement.TouchMove" />, которое происходит при перемещении касания внутри этого элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-1996">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchMove" /> routed event that occurs when a touch moves while inside this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-1997"><xref:System.Windows.ContentElement.OnTouchMove%2A> У метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-1997">The <xref:System.Windows.ContentElement.OnTouchMove%2A> method has no default implementation.</span></span> <span data-ttu-id="332d7-1998">Переопределить <xref:System.Windows.ContentElement.OnTouchMove%2A> в производном классе позволяет обработать <xref:System.Windows.ContentElement.TouchMove> событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-1998">Override <xref:System.Windows.ContentElement.OnTouchMove%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchMove> event.</span></span> <span data-ttu-id="332d7-1999">Необходимо вызвать метод базового класса <xref:System.Windows.ContentElement.OnTouchMove%2A> метод, базовые классы получили событие.</span><span class="sxs-lookup"><span data-stu-id="332d7-1999">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnTouchMove%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnTouchUp">
      <MemberSignature Language="C#" Value="protected internal virtual void OnTouchUp (System.Windows.Input.TouchEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnTouchUp(class System.Windows.Input.TouchEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.OnTouchUp(System.Windows.Input.TouchEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnTouchUp (e As TouchEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnTouchUp(System::Windows::Input::TouchEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.TouchEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-2000">Объект <see cref="T:System.Windows.Input.TouchEventArgs" />, содержащий данные события.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2000">A <see cref="T:System.Windows.Input.TouchEventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-2001">Предоставляет обработку класса для перенаправленного события <see cref="E:System.Windows.ContentElement.TouchUp" />, которое происходит при прекращении сенсорного нажатия внутри элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2001">Provides class handling for the <see cref="E:System.Windows.ContentElement.TouchUp" /> routed event that occurs when a touch is released inside this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2002"><xref:System.Windows.ContentElement.OnTouchUp%2A> У метода нет реализации по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-2002">The <xref:System.Windows.ContentElement.OnTouchUp%2A> method has no default implementation.</span></span> <span data-ttu-id="332d7-2003">Переопределить <xref:System.Windows.ContentElement.OnTouchUp%2A> в производном классе позволяет обработать <xref:System.Windows.ContentElement.TouchUp> событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-2003">Override <xref:System.Windows.ContentElement.OnTouchUp%2A> in a derived class to handle the <xref:System.Windows.ContentElement.TouchUp> event.</span></span> <span data-ttu-id="332d7-2004">Необходимо вызвать метод базового класса <xref:System.Windows.ContentElement.OnTouchUp%2A> метод, базовые классы получили событие.</span><span class="sxs-lookup"><span data-stu-id="332d7-2004">Be sure to call the base class’s <xref:System.Windows.ContentElement.OnTouchUp%2A> method so that base classes receive the event.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public virtual System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">
          <span data-ttu-id="332d7-2005">Главное направление запроса на перемещение фокуса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2005">The direction of the requested focus traversal.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-2006">При переопределении в производном классе возвращает элемент, который должен получить фокус для указанного направления перемещения фокуса без перемещения фокуса на этот элемент.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2006">When overridden in a derived class, returns the element that would receive focus for a specified focus traversal direction, without actually moving focus to that element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="332d7-2007">Элемент, который мог получить фокус при фактическом вызове <see cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2007">The element that would have received focus if <see cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /> were actually invoked.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2008">Реализация по умолчанию этого метода в данном классе является неполной и всегда возвращает `null`.</span><span class="sxs-lookup"><span data-stu-id="332d7-2008">The default implementation of this method in this class is incomplete and always returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragEnter As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragEnter;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2009">Возникает, когда система ввода сообщает о соответствующем событии перетаскивания, имеющем в качестве источника перетаскивания этот элемент.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2009">Occurs when the input system reports an underlying drag event with this element as the drag target.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2010">Это событие создается псевдоним для <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewDragEnter> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2010">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDragEnter> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2011">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewDragEnter> событий присоединяются к базовому объекту <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2011">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDragEnter> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDragEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDragEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2012">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2012">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2013">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2013">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDragEnterEvent>|  
|<span data-ttu-id="332d7-2014">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2014">Routing strategy</span></span>|<span data-ttu-id="332d7-2015">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="332d7-2015">Tunneling</span></span>|  
|<span data-ttu-id="332d7-2016">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2016">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="332d7-2017">Соответствующий восходящей событие <xref:System.Windows.ContentElement.DragEnter>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2017">The corresponding bubbling event is <xref:System.Windows.ContentElement.DragEnter>.</span></span>  
  
-   <span data-ttu-id="332d7-2018">Переопределить <xref:System.Windows.ContentElement.OnPreviewDragEnter%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2018">Override <xref:System.Windows.ContentElement.OnPreviewDragEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragEnterEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2019">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewDragEnter" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2019">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDragEnter" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2020">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2020">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2021">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2021">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2022">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2022">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2023">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2023">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2024">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2024">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragLeave As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragLeave;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2025">Возникает, когда система ввода сообщает о соответствующем событии перетаскивания, имеющем в качестве источника перетаскивания этот элемент.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2025">Occurs when the input system reports an underlying drag event with this element as the drag origin.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2026">Это событие создается псевдоним для <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewDragLeave> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2026">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDragLeave> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2027">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewDragLeave> событий присоединяются к базовому объекту <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2027">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDragLeave> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDragLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDragLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2028">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2028">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2029">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2029">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDragLeaveEvent>|  
|<span data-ttu-id="332d7-2030">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2030">Routing strategy</span></span>|<span data-ttu-id="332d7-2031">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="332d7-2031">Tunneling</span></span>|  
|<span data-ttu-id="332d7-2032">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2032">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="332d7-2033">Соответствующий восходящей событие <xref:System.Windows.ContentElement.DragLeave>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2033">The corresponding bubbling event is <xref:System.Windows.ContentElement.DragLeave>.</span></span>  
  
-   <span data-ttu-id="332d7-2034">Переопределить <xref:System.Windows.ContentElement.OnPreviewDragLeave%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2034">Override <xref:System.Windows.ContentElement.OnPreviewDragLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragLeaveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2035">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewDragLeave" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2035">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDragLeave" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2036">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2036">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2037">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2037">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2038">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2038">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2039">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2039">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2040">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2040">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOver">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDragOver;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDragOver" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDragOver" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDragOver As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDragOver;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2041">Происходит, когда подсистема ввода сообщает о соответствующем событии перетаскивания, имеющем в качестве потенциальной цели данный элемент.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2041">Occurs when the input system reports an underlying drag event with this element as the potential drop target.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2042">Это событие создается псевдоним для <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewDragOver> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2042">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDragOver> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2043">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewDragOver> событий присоединяются к базовому объекту <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2043">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDragOver> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDragOver?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDragOver"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2044">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2044">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2045">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2045">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDragOverEvent>|  
|<span data-ttu-id="332d7-2046">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2046">Routing strategy</span></span>|<span data-ttu-id="332d7-2047">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="332d7-2047">Tunneling</span></span>|  
|<span data-ttu-id="332d7-2048">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2048">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="332d7-2049">Соответствующий восходящей событие <xref:System.Windows.ContentElement.DragOver>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2049">The corresponding bubbling event is <xref:System.Windows.ContentElement.DragOver>.</span></span>  
  
-   <span data-ttu-id="332d7-2050">Переопределить <xref:System.Windows.ContentElement.OnPreviewDragOver%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2050">Override <xref:System.Windows.ContentElement.OnPreviewDragOver%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDragOverEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDragOverEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDragOverEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDragOverEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDragOverEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDragOverEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2051">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewDragOver" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2051">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDragOver" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2052">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2052">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2053">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2053">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2054">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2054">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2055">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2055">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2056">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2056">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDrop">
      <MemberSignature Language="C#" Value="public event System.Windows.DragEventHandler PreviewDrop;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DragEventHandler PreviewDrop" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewDrop" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewDrop As DragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DragEventHandler ^ PreviewDrop;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2057">Происходит, когда система ввода сообщает о базовом событии удаления с этим элементом в качестве цели удаления.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2057">Occurs when the input system reports an underlying drop event with this element as the drop target.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2058">Это событие создается псевдоним для <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewDrop> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2058">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewDrop> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2059">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewDrop> событий присоединяются к базовому объекту <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2059">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewDrop> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewDrop?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewDrop"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2060">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2060">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2061">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2061">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewDropEvent>|  
|<span data-ttu-id="332d7-2062">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2062">Routing strategy</span></span>|<span data-ttu-id="332d7-2063">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="332d7-2063">Tunneling</span></span>|  
|<span data-ttu-id="332d7-2064">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2064">Delegate</span></span>|<xref:System.Windows.DragEventHandler>|  
  
-   <span data-ttu-id="332d7-2065">Соответствующий восходящей событие <xref:System.Windows.ContentElement.Drop>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2065">The corresponding bubbling event is <xref:System.Windows.ContentElement.Drop>.</span></span>  
  
-   <span data-ttu-id="332d7-2066">Переопределить <xref:System.Windows.ContentElement.OnPreviewDrop%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2066">Override <xref:System.Windows.ContentElement.OnPreviewDrop%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewDropEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewDropEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewDropEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewDropEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewDropEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewDropEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2067">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewDrop" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2067">Identifies the <see cref="E:System.Windows.ContentElement.PreviewDrop" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2068">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2068">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2069">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2069">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2070">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2070">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2071">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2071">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2072">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2072">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedback">
      <MemberSignature Language="C#" Value="public event System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.GiveFeedbackEventHandler PreviewGiveFeedback" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewGiveFeedback" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGiveFeedback As GiveFeedbackEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::GiveFeedbackEventHandler ^ PreviewGiveFeedback;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.GiveFeedbackEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2073">Происходит при начале операции перетаскивания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2073">Occurs when a drag-and-drop operation is started.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2074"><xref:System.Windows.ContentElement.PreviewGiveFeedback> Событий позволяет источнику события перетаскивания изменять внешний вид указателя мыши, чтобы дать пользователю визуальную обратную связь во время операции перетаскивания и вставки.</span><span class="sxs-lookup"><span data-stu-id="332d7-2074">The <xref:System.Windows.ContentElement.PreviewGiveFeedback> event enables the source of a drag event to modify the appearance of the mouse pointer, in order to give the user visual feedback during a drag-and-drop operation.</span></span>  
  
 <span data-ttu-id="332d7-2075">Это событие создается псевдоним для <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewGiveFeedback> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2075">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewGiveFeedback> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2076">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewGiveFeedback> событий присоединяются к базовому объекту <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2076">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewGiveFeedback> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewGiveFeedback?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewGiveFeedback"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2077">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2077">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2078">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2078">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewGiveFeedbackEvent>|  
|<span data-ttu-id="332d7-2079">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2079">Routing strategy</span></span>|<span data-ttu-id="332d7-2080">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="332d7-2080">Tunneling</span></span>|  
|<span data-ttu-id="332d7-2081">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2081">Delegate</span></span>|<xref:System.Windows.GiveFeedbackEventHandler>|  
  
-   <span data-ttu-id="332d7-2082">Соответствующий восходящей событие <xref:System.Windows.ContentElement.GiveFeedback>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2082">The corresponding bubbling event is <xref:System.Windows.ContentElement.GiveFeedback>.</span></span>  
  
-   <span data-ttu-id="332d7-2083">Переопределить <xref:System.Windows.ContentElement.OnPreviewGiveFeedback%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2083">Override <xref:System.Windows.ContentElement.OnPreviewGiveFeedback%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGiveFeedbackEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGiveFeedbackEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGiveFeedbackEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewGiveFeedbackEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGiveFeedbackEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGiveFeedbackEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2084">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewGiveFeedback" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2084">Identifies the <see cref="E:System.Windows.ContentElement.PreviewGiveFeedback" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2085">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2085">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2086">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2086">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2087">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2087">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2088">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2088">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2089">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2089">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewGotKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewGotKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewGotKeyboardFocus;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewGotKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2090">Происходит при получении данным элементом фокуса ввода с клавиатуры.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2090">Occurs when the keyboard is focused on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2091">Так как это событие нисходящей маршрутизации элемент, имеющий фокус может быть дочерний элемент, а не элемента, которому фактически присоединен обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-2091">Because this event uses tunneling routing, the element that has focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="332d7-2092">Проверьте <xref:System.Windows.RoutedEventArgs.Source%2A> в данных события, чтобы определить фактический элемент, имеющий фокус.</span><span class="sxs-lookup"><span data-stu-id="332d7-2092">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that has focus.</span></span>  
  
 <span data-ttu-id="332d7-2093">Это событие создается псевдоним для <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2093">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2094">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> событий присоединяются к базовому объекту <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2094">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewGotKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewGotKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewGotKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2095">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2095">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2096">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2096">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewGotKeyboardFocusEvent>|  
|<span data-ttu-id="332d7-2097">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2097">Routing strategy</span></span>|<span data-ttu-id="332d7-2098">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="332d7-2098">Tunneling</span></span>|  
|<span data-ttu-id="332d7-2099">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2099">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="332d7-2100">Соответствующий восходящей событие <xref:System.Windows.ContentElement.GotKeyboardFocus>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2100">The corresponding bubbling event is <xref:System.Windows.ContentElement.GotKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="332d7-2101">Переопределить <xref:System.Windows.ContentElement.OnPreviewGotKeyboardFocus%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2101">Override <xref:System.Windows.ContentElement.OnPreviewGotKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewGotKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewGotKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewGotKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewGotKeyboardFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2102">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2102">Identifies the <see cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2103">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2103">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2104">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2104">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2105">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2105">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2106">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2106">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2107">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2107">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewKeyDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyDown As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2108">Происходит при нажатии клавиши, если фокус ввода с клавиатуры находится на данном элементе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2108">Occurs when a key is pressed while the keyboard is focused on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2109">Обработка клавиш взаимодействует с другими функциями платформы, такие как выполнение команд и композиция текста.</span><span class="sxs-lookup"><span data-stu-id="332d7-2109">Key handling interacts with other platform features such as commanding and text composition.</span></span> <span data-ttu-id="332d7-2110"><xref:System.Windows.ContentElement.KeyDown> Событие является событием входной текст нижнего уровня, могут работать некорректно, в некоторых элементах управления.</span><span class="sxs-lookup"><span data-stu-id="332d7-2110">The <xref:System.Windows.ContentElement.KeyDown> event is a lower-level text input event that might not behave as expected on certain controls.</span></span> <span data-ttu-id="332d7-2111">Это так, как некоторые элементы управления имеют композиции элементов управления или обработку ввода обработку класса, который предоставляет более высокого уровня версия текста, а также связанные события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2111">This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</span></span>  
  
 <span data-ttu-id="332d7-2112">Это событие создается псевдоним для <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewKeyDown> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2112">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewKeyDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2113">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewKeyDown> событий присоединяются к базовому объекту <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2113">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewKeyDown> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewKeyDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewKeyDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2114">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2114">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2115">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2115">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewKeyDownEvent>|  
|<span data-ttu-id="332d7-2116">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2116">Routing strategy</span></span>|<span data-ttu-id="332d7-2117">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="332d7-2117">Tunneling</span></span>|  
|<span data-ttu-id="332d7-2118">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2118">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="332d7-2119">Соответствующий восходящей событие <xref:System.Windows.ContentElement.KeyDown>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2119">The corresponding bubbling event is <xref:System.Windows.ContentElement.KeyDown>.</span></span>  
  
-   <span data-ttu-id="332d7-2120">Переопределить <xref:System.Windows.ContentElement.OnPreviewKeyDown%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2120">Override <xref:System.Windows.ContentElement.OnPreviewKeyDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewKeyDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2121">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewKeyDown" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2121">Identifies the <see cref="E:System.Windows.ContentElement.PreviewKeyDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2122">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2122">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2123">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2123">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2124">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2124">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2125">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2125">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2126">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2126">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyEventHandler PreviewKeyUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyEventHandler PreviewKeyUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewKeyUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewKeyUp As KeyEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyEventHandler ^ PreviewKeyUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewKeyUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2127">Происходит при отпускании клавиши, если фокус ввода с клавиатуры находится на данном элементе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2127">Occurs when a key is released while the keyboard is focused on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2128">Обработка клавиш взаимодействует с другими функциями платформы, такие как выполнение команд и композиция текста.</span><span class="sxs-lookup"><span data-stu-id="332d7-2128">Key handling interacts with other platform features such as commanding and text composition.</span></span> <span data-ttu-id="332d7-2129"><xref:System.Windows.ContentElement.KeyUp> Событие является событием входной текст нижнего уровня, могут работать некорректно, в некоторых элементах управления.</span><span class="sxs-lookup"><span data-stu-id="332d7-2129">The <xref:System.Windows.ContentElement.KeyUp> event is a lower-level text input event that might not behave as expected on certain controls.</span></span> <span data-ttu-id="332d7-2130">Это так, как некоторые элементы управления имеют композиции элементов управления или обработку ввода обработку класса, который предоставляет более высокого уровня версия текста, а также связанные события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2130">This is because some controls have control compositing or class handling that provides a higher-level version of text input handling and related events.</span></span> <span data-ttu-id="332d7-2131">Дополнительные сведения обратитесь к документации для отдельных элементов управления.</span><span class="sxs-lookup"><span data-stu-id="332d7-2131">For details, check the documentation for individual controls.</span></span>  
  
 <span data-ttu-id="332d7-2132">Это событие создается псевдоним для <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewKeyUp> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2132">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewKeyUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2133">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewKeyUp> событий присоединяются к базовому объекту <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2133">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewKeyUp> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewKeyUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewKeyUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2134">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2134">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2135">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2135">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewKeyUpEvent>|  
|<span data-ttu-id="332d7-2136">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2136">Routing strategy</span></span>|<span data-ttu-id="332d7-2137">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="332d7-2137">Tunneling</span></span>|  
|<span data-ttu-id="332d7-2138">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2138">Delegate</span></span>|<xref:System.Windows.Input.KeyEventHandler>|  
  
-   <span data-ttu-id="332d7-2139">Соответствующий восходящей событие <xref:System.Windows.ContentElement.KeyUp>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2139">The corresponding bubbling event is <xref:System.Windows.ContentElement.KeyUp>.</span></span>  
  
-   <span data-ttu-id="332d7-2140">Переопределить <xref:System.Windows.ContentElement.OnPreviewKeyUp%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2140">Override <xref:System.Windows.ContentElement.OnPreviewKeyUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewKeyUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewKeyUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewKeyUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewKeyUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewKeyUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewKeyUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2141">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewKeyUp" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2141">Identifies the <see cref="E:System.Windows.ContentElement.PreviewKeyUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2142">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2142">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2143">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2143">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2144">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2144">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2145">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2145">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2146">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2146">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocus">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.KeyboardFocusChangedEventHandler PreviewLostKeyboardFocus" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewLostKeyboardFocus As KeyboardFocusChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::KeyboardFocusChangedEventHandler ^ PreviewLostKeyboardFocus;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewLostKeyboardFocus</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.KeyboardFocusChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2147">Происходит при потере данным элементом фокуса ввода с клавиатуры.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2147">Occurs when the keyboard is no longer focused on this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2148">Так как это событие нисходящей маршрутизации элемент, который потерял фокус может быть дочерний элемент, а не элемента, которому фактически присоединен обработчик событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-2148">Because this event uses tunneling routing, the element that lost focus might be a child element instead of the element where the event handler is actually attached.</span></span> <span data-ttu-id="332d7-2149">Проверьте <xref:System.Windows.RoutedEventArgs.Source%2A> в данных события, чтобы определить фактический элемент, который теряет фокус.</span><span class="sxs-lookup"><span data-stu-id="332d7-2149">Check the <xref:System.Windows.RoutedEventArgs.Source%2A> in the event data to determine the actual element that lost focus.</span></span>  
  
 <span data-ttu-id="332d7-2150">Это событие создается псевдоним для <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2150">This event creates an alias for the <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2151">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> событий присоединяются к базовому объекту <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2151">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewLostKeyboardFocus> event are attached to the underlying <xref:System.Windows.Input.Keyboard.PreviewLostKeyboardFocus?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewLostKeyboardFocus"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2152">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2152">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2153">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2153">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewLostKeyboardFocusEvent>|  
|<span data-ttu-id="332d7-2154">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2154">Routing strategy</span></span>|<span data-ttu-id="332d7-2155">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="332d7-2155">Tunneling</span></span>|  
|<span data-ttu-id="332d7-2156">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2156">Delegate</span></span>|<xref:System.Windows.Input.KeyboardFocusChangedEventHandler>|  
  
-   <span data-ttu-id="332d7-2157">Соответствующий восходящей событие <xref:System.Windows.ContentElement.LostKeyboardFocus>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2157">The corresponding bubbling event is <xref:System.Windows.ContentElement.LostKeyboardFocus>.</span></span>  
  
-   <span data-ttu-id="332d7-2158">Переопределить <xref:System.Windows.ContentElement.OnPreviewLostKeyboardFocus%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2158">Override <xref:System.Windows.ContentElement.OnPreviewLostKeyboardFocus%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewGotKeyboardFocus" />
      </Docs>
    </Member>
    <Member MemberName="PreviewLostKeyboardFocusEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewLostKeyboardFocusEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewLostKeyboardFocusEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewLostKeyboardFocusEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2159">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2159">Identifies the <see cref="E:System.Windows.ContentElement.PreviewLostKeyboardFocus" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2160">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2160">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2161">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2161">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2162">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2162">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2163">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2163">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2164">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2164">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2165">Происходит при нажатии любой кнопки мыши в тот момент, когда указатель мыши находится над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2165">Occurs when any mouse button is pressed while the pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2166">Это событие создается псевдоним для <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewMouseDown> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2166">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2167">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewMouseDown> событий присоединяются к базовому объекту <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2167">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseDown> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="332d7-2168"><xref:System.Windows.ContentElement.PreviewMouseDown> Событие часто возникает вместе с либо <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> или <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>, которые соответствуют нажмите одну из двух кнопок мыши стандартные.</span><span class="sxs-lookup"><span data-stu-id="332d7-2168">The <xref:System.Windows.ContentElement.PreviewMouseDown> event is often raised together with either <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>, which correspond to a press of one of the two standard mouse buttons.</span></span> <span data-ttu-id="332d7-2169"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> и <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> также перенаправленные события, но они являются прямой перенаправленные события, и возникает соответствующее событие кнопками при <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> событий достигает этого элемента на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2169"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="332d7-2170">См. заметки для <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> или <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2170">See Remarks for <xref:System.Windows.ContentElement.PreviewMouseLeftButtonDown> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonDown>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2171">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2171">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2172">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2172">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseDownEvent>|  
|<span data-ttu-id="332d7-2173">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2173">Routing strategy</span></span>|<span data-ttu-id="332d7-2174">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="332d7-2174">Tunneling</span></span>|  
|<span data-ttu-id="332d7-2175">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2175">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="332d7-2176">Соответствующий восходящей событие <xref:System.Windows.ContentElement.MouseDown>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2176">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseDown>.</span></span>  
  
-   <span data-ttu-id="332d7-2177">Переопределить <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2177">Override <xref:System.Windows.ContentElement.OnPreviewMouseDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2178">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewMouseDown" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2178">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2179">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2179">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2180">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2180">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2181">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2181">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2182">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2182">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2183">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2183">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2184">Происходит при нажатии левой кнопки мыши в тот момент, когда указатель мыши находится над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2184">Occurs when the left mouse button is pressed while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2185">Несмотря на то что это [направлено Общие сведения о событиях](~/docs/framework/wpf/advanced/routed-events-overview.md) вероятно, нисходящую через дерево элементов, фактически является прямой перенаправленного события, которое возникает и восходящему на дереве элементов каждым <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2185">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="332d7-2186">Это событие является одним из нескольких связанных событий, сообщающих кнопки мыши базовая <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> события, который является вложенным событием, которое обрабатывается каждым элементом на маршруте событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-2186">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="332d7-2187">Аргументы события предоставляют аргументов базового <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-2187">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="332d7-2188">Если это событие помечено как обработанное на маршруте события, по-прежнему возникают определенные события кнопки мыши; Тем не менее, необходимо добавить обработчики событий кнопки мыши путем явного вызова <xref:System.Windows.ContentElement.AddHandler%2A>, с помощью параметра для обработки событий, которые уже помечено как обработанное, чтобы быть прослушивателей события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2188">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="332d7-2189">С концептуальной точки зрения это событие (и другие события кнопки мыши <xref:System.Windows.ContentElement>) быть мыши «служба» (с помощью определения службы, предоставляемые <xref:System.Windows.Input.Mouse> класса).</span><span class="sxs-lookup"><span data-stu-id="332d7-2189">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="332d7-2190">Событие добавляет удобство нет необходимости проверять состояние кнопок мыши (слева направо, вверх вниз) исходного события мыши в данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2190">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="332d7-2191">Для более сложных сценариев, таких как проверка состояния стандартным кнопок может потребоваться использовать [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] на <xref:System.Windows.Input.Mouse> класса вместо тех, на <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2191">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseLeftButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2192">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2192">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2193">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2193">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent>|  
|<span data-ttu-id="332d7-2194">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2194">Routing strategy</span></span>|<span data-ttu-id="332d7-2195">Direct</span><span class="sxs-lookup"><span data-stu-id="332d7-2195">Direct</span></span>|  
|<span data-ttu-id="332d7-2196">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2196">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="332d7-2197">Переопределить <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2197">Override <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseLeftButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseLeftButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2198">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2198">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2199">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2199">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2200">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2200">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2201">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2201">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2202">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2202">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2203">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2203">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseLeftButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseLeftButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseLeftButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseLeftButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2204">Происходит при отпускании левой кнопки мыши в тот момент, когда указатель мыши находится над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2204">Occurs when the left mouse button is released while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2205">Несмотря на то что это [направлено Общие сведения о событиях](~/docs/framework/wpf/advanced/routed-events-overview.md) вероятно, нисходящую через дерево элементов, фактически является прямой перенаправленного события, которое возникает и восходящему на дереве элементов каждым <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2205">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="332d7-2206">Это событие является одним из нескольких связанных событий, сообщающих кнопки мыши базовая <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> события, который является вложенным событием, которое обрабатывается каждым элементом на маршруте событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-2206">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="332d7-2207">Аргументы события предоставляют аргументов базового <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-2207">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="332d7-2208">Если это событие помечено как обработанное на маршруте события, по-прежнему возникают определенные события кнопки мыши; Тем не менее, необходимо добавить обработчики событий кнопки мыши путем явного вызова <xref:System.Windows.ContentElement.AddHandler%2A>, с помощью параметра для обработки событий, которые уже помечено как обработанное, чтобы быть прослушивателей события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2208">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="332d7-2209">С концептуальной точки зрения это событие (и другие события кнопки мыши <xref:System.Windows.ContentElement>) быть мыши «служба» (с помощью определения службы, предоставляемые <xref:System.Windows.Input.Mouse> класса).</span><span class="sxs-lookup"><span data-stu-id="332d7-2209">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="332d7-2210">Событие добавляет удобство нет необходимости проверять состояние кнопок мыши (слева направо, вверх вниз) исходного события мыши в данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2210">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="332d7-2211">Для более сложных сценариев, таких как проверка состояния стандартным кнопок может потребоваться использовать [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] на <xref:System.Windows.Input.Mouse> класса вместо тех, на <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2211">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseLeftButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2212">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2212">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2213">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2213">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent>|  
|<span data-ttu-id="332d7-2214">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2214">Routing strategy</span></span>|<span data-ttu-id="332d7-2215">Direct</span><span class="sxs-lookup"><span data-stu-id="332d7-2215">Direct</span></span>|  
|<span data-ttu-id="332d7-2216">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2216">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="332d7-2217">Переопределить <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2217">Override <xref:System.Windows.ContentElement.OnPreviewMouseLeftButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseLeftButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseLeftButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseLeftButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseLeftButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2218">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2218">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseLeftButtonUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2219">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2219">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2220">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2220">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2221">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2221">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2222">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2222">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2223">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2223">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseEventHandler PreviewMouseMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseEventHandler PreviewMouseMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseMove As MouseEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseEventHandler ^ PreviewMouseMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2224">Происходит при перемещении указателя мыши, когда он находится над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2224">Occurs when the mouse pointer moves while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2225">Это событие происходит, и когда указатель мыши входит в пределы элемента, а также при перемещении указателя мыши оставаясь в пределах границ элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2225">This event occurs both when the mouse pointer first enters into the element bounds, and also when the mouse pointer moves while still remaining within the element bounds.</span></span>  
  
 <span data-ttu-id="332d7-2226">Это событие создается псевдоним для <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewMouseMove> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2226">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2227">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewMouseMove> событий присоединяются к базовому объекту <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2227">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseMove> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewMouseMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2228">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2228">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2229">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2229">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseMoveEvent>|  
|<span data-ttu-id="332d7-2230">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2230">Routing strategy</span></span>|<span data-ttu-id="332d7-2231">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="332d7-2231">Tunneling</span></span>|  
|<span data-ttu-id="332d7-2232">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2232">Delegate</span></span>|<xref:System.Windows.Input.MouseEventHandler>|  
  
-   <span data-ttu-id="332d7-2233">Соответствующий восходящей событие <xref:System.Windows.ContentElement.MouseMove>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2233">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseMove>.</span></span>  
  
-   <span data-ttu-id="332d7-2234">Переопределить <xref:System.Windows.ContentElement.OnPreviewMouseMove%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2234">Override <xref:System.Windows.ContentElement.OnPreviewMouseMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2235">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewMouseMove" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2235">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2236">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2236">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2237">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2237">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2238">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2238">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2239">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2239">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2240">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2240">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonDown As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2241">Происходит при нажатии правой кнопки мыши в тот момент, когда указатель мыши находится над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2241">Occurs when the right mouse button is pressed while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2242">Несмотря на то что это [направлено Общие сведения о событиях](~/docs/framework/wpf/advanced/routed-events-overview.md) вероятно, нисходящую через дерево элементов, фактически является прямой перенаправленного события, которое возникает и восходящему на дереве элементов каждым <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2242">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="332d7-2243">Это событие является одним из нескольких связанных событий, сообщающих кнопки мыши базовая <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> события, который является вложенным событием, которое обрабатывается каждым элементом на маршруте событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-2243">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="332d7-2244">Аргументы события предоставляют аргументов базового <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-2244">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseDown?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="332d7-2245">Если это событие помечено как обработанное на маршруте события, по-прежнему возникают определенные события кнопки мыши; Тем не менее, необходимо добавить обработчики событий кнопки мыши путем явного вызова <xref:System.Windows.ContentElement.AddHandler%2A>, с помощью параметра для обработки событий, которые уже помечено как обработанное, чтобы быть прослушивателей события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2245">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="332d7-2246">С концептуальной точки зрения это событие (и другие события кнопки мыши <xref:System.Windows.ContentElement>) быть мыши «служба» (с помощью определения службы, предоставляемые <xref:System.Windows.Input.Mouse> класса).</span><span class="sxs-lookup"><span data-stu-id="332d7-2246">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="332d7-2247">Событие добавляет удобство нет необходимости проверять состояние кнопок мыши (слева направо, вверх вниз) исходного события мыши в данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2247">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="332d7-2248">Для более сложных сценариев, таких как проверка состояния стандартным кнопок может потребоваться использовать [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] на <xref:System.Windows.Input.Mouse> класса вместо тех, на <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2248">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseRightButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2249">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2249">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2250">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2250">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseRightButtonDownEvent>|  
|<span data-ttu-id="332d7-2251">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2251">Routing strategy</span></span>|<span data-ttu-id="332d7-2252">Direct</span><span class="sxs-lookup"><span data-stu-id="332d7-2252">Direct</span></span>|  
|<span data-ttu-id="332d7-2253">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2253">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="332d7-2254">Переопределить <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2254">Override <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseRightButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseRightButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2255">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2255">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2256">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2256">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2257">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2257">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2258">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2258">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2259">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2259">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2260">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2260">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseRightButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseRightButtonUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseRightButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseRightButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2261">Происходит при отпускании правой кнопки мыши в тот момент, когда указатель мыши находится над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2261">Occurs when the right mouse button is released while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2262">Несмотря на то что это [направлено Общие сведения о событиях](~/docs/framework/wpf/advanced/routed-events-overview.md) вероятно, нисходящую через дерево элементов, фактически является прямой перенаправленного события, которое возникает и восходящему на дереве элементов каждым <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2262">Although this [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) seems to follow a tunneling route through an element tree, it actually is a direct routed event that is raised and reraised along the element tree by each <xref:System.Windows.ContentElement>.</span></span>  
  
 <span data-ttu-id="332d7-2263">Это событие является одним из нескольких связанных событий, сообщающих кнопки мыши базовая <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> события, который является вложенным событием, которое обрабатывается каждым элементом на маршруте событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-2263">This event is one of several related events that report the mouse-button specifics of an underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event, which is an attached event that is processed by each element along an event route.</span></span>  
  
 <span data-ttu-id="332d7-2264">Аргументы события предоставляют аргументов базового <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> событий.</span><span class="sxs-lookup"><span data-stu-id="332d7-2264">The arguments of this event expose the arguments of the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="332d7-2265">Если это событие помечено как обработанное на маршруте события, по-прежнему возникают определенные события кнопки мыши; Тем не менее, необходимо добавить обработчики событий кнопки мыши путем явного вызова <xref:System.Windows.ContentElement.AddHandler%2A>, с помощью параметра для обработки событий, которые уже помечено как обработанное, чтобы быть прослушивателей события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2265">If that event is marked as handled along the event route, the mouse-button specific events are still raised; however, handlers of the mouse-button specific events must be added by explicitly calling <xref:System.Windows.ContentElement.AddHandler%2A>, with the option to handle events that are already marked as handled, in order to be listeners to the event.</span></span>  
  
 <span data-ttu-id="332d7-2266">С концептуальной точки зрения это событие (и другие события кнопки мыши <xref:System.Windows.ContentElement>) быть мыши «служба» (с помощью определения службы, предоставляемые <xref:System.Windows.Input.Mouse> класса).</span><span class="sxs-lookup"><span data-stu-id="332d7-2266">Conceptually, think of this event (and other mouse-button events on <xref:System.Windows.ContentElement>) to be a mouse "service" (with the service definition provided by the <xref:System.Windows.Input.Mouse> class).</span></span> <span data-ttu-id="332d7-2267">Событие добавляет удобство нет необходимости проверять состояние кнопок мыши (слева направо, вверх вниз) исходного события мыши в данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2267">The event adds the convenience of not needing to check the mouse button states (left-right, up-down) of the original mouse events in the event data.</span></span> <span data-ttu-id="332d7-2268">Для более сложных сценариев, таких как проверка состояния стандартным кнопок может потребоваться использовать [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] на <xref:System.Windows.Input.Mouse> класса вместо тех, на <xref:System.Windows.ContentElement>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2268">For more advanced scenarios, such as checking for states of non-standard buttons, you might need to use the [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] on the <xref:System.Windows.Input.Mouse> class rather than those on <xref:System.Windows.ContentElement>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseRightButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2269">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2269">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2270">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2270">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseRightButtonUpEvent>|  
|<span data-ttu-id="332d7-2271">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2271">Routing strategy</span></span>|<span data-ttu-id="332d7-2272">Direct</span><span class="sxs-lookup"><span data-stu-id="332d7-2272">Direct</span></span>|  
|<span data-ttu-id="332d7-2273">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2273">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="332d7-2274">Переопределить <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2274">Override <xref:System.Windows.ContentElement.OnPreviewMouseRightButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.MouseRightButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseRightButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseRightButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseRightButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseRightButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2275">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2275">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseRightButtonUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2276">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2276">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2277">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2277">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2278">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2278">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2279">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2279">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2280">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2280">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseButtonEventHandler PreviewMouseUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseButtonEventHandler PreviewMouseUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseUp As MouseButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::MouseButtonEventHandler ^ PreviewMouseUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2281">Происходит при отпускании любой кнопки мыши в тот момент, когда указатель мыши находится над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2281">Occurs when any mouse button is released while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2282">Это событие создается псевдоним для <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewMouseUp> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2282">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2283">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewMouseUp> событий присоединяются к базовому объекту <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2283">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseUp> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="332d7-2284"><xref:System.Windows.ContentElement.PreviewMouseUp> Событие часто возникает вместе с либо <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> или <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>, которые соответствуют нажмите одну из двух кнопок мыши стандартные.</span><span class="sxs-lookup"><span data-stu-id="332d7-2284">The <xref:System.Windows.ContentElement.PreviewMouseUp> event is often raised together with either <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>, which correspond to a press of one of the two standard mouse buttons.</span></span> <span data-ttu-id="332d7-2285"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> и <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> также перенаправленные события, но они являются прямой перенаправленные события, и возникает соответствующее событие кнопками при <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> событий достигает этого элемента на маршруте события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2285"><xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> and <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp> are also routed events, but they are direct routed events, and the appropriate button-specific event is raised when the <xref:System.Windows.Input.Mouse.PreviewMouseUp?displayProperty=nameWithType> event reaches this element along the event route.</span></span> <span data-ttu-id="332d7-2286">См. заметки для <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> или <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2286">See Remarks for <xref:System.Windows.ContentElement.PreviewMouseLeftButtonUp> or <xref:System.Windows.ContentElement.PreviewMouseRightButtonUp>.</span></span>  
  
<a name="routedEventInfo_PreviewMouseUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2287">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2287">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2288">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2288">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseUpEvent>|  
|<span data-ttu-id="332d7-2289">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2289">Routing strategy</span></span>|<span data-ttu-id="332d7-2290">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="332d7-2290">Tunneling</span></span>|  
|<span data-ttu-id="332d7-2291">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2291">Delegate</span></span>|<xref:System.Windows.Input.MouseButtonEventHandler>|  
  
-   <span data-ttu-id="332d7-2292">Соответствующий восходящей событие <xref:System.Windows.ContentElement.MouseUp>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2292">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseUp>.</span></span>  
  
-   <span data-ttu-id="332d7-2293">Переопределить <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2293">Override <xref:System.Windows.ContentElement.OnPreviewMouseUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2294">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewMouseUp" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2294">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2295">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2295">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2296">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2296">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2297">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2297">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2298">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2298">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2299">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2299">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheel">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.MouseWheelEventHandler PreviewMouseWheel" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewMouseWheel" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewMouseWheel As MouseWheelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::MouseWheelEventHandler ^ PreviewMouseWheel;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewMouseWheel</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.MouseWheelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2300">Происходит при вращении колесика мыши в тот момент, когда указатель мыши находится над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2300">Occurs when the user rotates the mouse wheel while the mouse pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2301">Фокус или захват мыши имеют приоритет над которого указатель мыши; Таким образом при получении этого события из элемента или получившего, указатель мыши может быть фактически над другим элементом.</span><span class="sxs-lookup"><span data-stu-id="332d7-2301">Focus or mouse capture take precedence over where the mouse pointer is; therefore, if you receive this event from a focused or captured element, the mouse pointer might actually be over another element.</span></span>  
  
 <span data-ttu-id="332d7-2302">Это событие создается псевдоним для <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewMouseMove> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2302">This event creates an alias for the <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewMouseMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2303">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewMouseMove> событий присоединяются к базовому объекту <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2303">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewMouseMove> event are attached to the underlying <xref:System.Windows.Input.Mouse.PreviewMouseWheel?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewMouseWheel"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2304">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2304">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2305">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2305">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewMouseWheelEvent>|  
|<span data-ttu-id="332d7-2306">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2306">Routing strategy</span></span>|<span data-ttu-id="332d7-2307">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="332d7-2307">Tunneling</span></span>|  
|<span data-ttu-id="332d7-2308">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2308">Delegate</span></span>|<xref:System.Windows.Input.MouseWheelEventHandler>|  
  
-   <span data-ttu-id="332d7-2309">Соответствующий восходящей событие <xref:System.Windows.ContentElement.MouseWheel>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2309">The corresponding bubbling event is <xref:System.Windows.ContentElement.MouseWheel>.</span></span>  
  
-   <span data-ttu-id="332d7-2310">Переопределить <xref:System.Windows.ContentElement.OnPreviewMouseWheel%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2310">Override <xref:System.Windows.ContentElement.OnPreviewMouseWheel%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewMouseWheelEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewMouseWheelEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewMouseWheelEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewMouseWheelEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewMouseWheelEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewMouseWheelEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2311">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewMouseWheel" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2311">Identifies the <see cref="E:System.Windows.ContentElement.PreviewMouseWheel" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2312">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2312">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2313">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2313">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2314">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2314">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2315">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2315">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2316">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2316">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler PreviewQueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewQueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewQueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ PreviewQueryContinueDrag;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2317">Происходит, когда состояние клавиши или кнопки мыши изменяется в ходе операции перетаскивания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2317">Occurs when there is a change in the keyboard or mouse button state during a drag-and-drop operation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2318"><xref:System.Windows.ContentElement.PreviewQueryContinueDrag> Событий позволяет источнику перетаскивания для объявления, должна ли быть отменена операция перетаскивания и вставки.</span><span class="sxs-lookup"><span data-stu-id="332d7-2318">The <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> event enables the drag source to declare whether the drag-and-drop operation should be canceled.</span></span>  
  
 <span data-ttu-id="332d7-2319">Это событие создается псевдоним для <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2319">This event creates an alias for the <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2320">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> событий присоединяются к базовому объекту <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2320">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewQueryContinueDrag> event are attached to the underlying <xref:System.Windows.DragDrop.PreviewQueryContinueDrag?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewQueryContinueDrag"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2321">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2321">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2322">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2322">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewQueryContinueDragEvent>|  
|<span data-ttu-id="332d7-2323">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2323">Routing strategy</span></span>|<span data-ttu-id="332d7-2324">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="332d7-2324">Tunneling</span></span>|  
|<span data-ttu-id="332d7-2325">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2325">Delegate</span></span>|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   <span data-ttu-id="332d7-2326">Соответствующий восходящей событие <xref:System.Windows.ContentElement.QueryContinueDrag>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2326">The corresponding bubbling event is <xref:System.Windows.ContentElement.QueryContinueDrag>.</span></span>  
  
-   <span data-ttu-id="332d7-2327">Переопределить <xref:System.Windows.ContentElement.OnPreviewQueryContinueDrag%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2327">Override <xref:System.Windows.ContentElement.OnPreviewQueryContinueDrag%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewQueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewQueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewQueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewQueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewQueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewQueryContinueDragEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2328">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2328">Identifies the <see cref="E:System.Windows.ContentElement.PreviewQueryContinueDrag" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2329">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2329">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2330">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2330">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2331">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2331">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2332">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2332">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2333">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2333">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2334">Происходит при нажатии кнопки пера в тот момент, когда указатель находится над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2334">Occurs when the stylus button is pressed while the pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2335">Это событие создается псевдоним для <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewStylusButtonDown> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2335">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusButtonDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2336">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewStylusButtonDown> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2336">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusButtonDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusButtonDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="332d7-2337">Сенсорный ввод, мышь и ввод от пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="332d7-2337">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="332d7-2338">Дополнительные сведения см. в разделе [фокусе](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-2338">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2339">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2339">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2340">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2340">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusButtonDownEvent>|  
|<span data-ttu-id="332d7-2341">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2341">Routing strategy</span></span>|<span data-ttu-id="332d7-2342">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="332d7-2342">Tunneling</span></span>|  
|<span data-ttu-id="332d7-2343">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2343">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="332d7-2344">Соответствующий восходящей событие <xref:System.Windows.ContentElement.StylusButtonDown>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2344">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusButtonDown>.</span></span>  
  
-   <span data-ttu-id="332d7-2345">Переопределить <xref:System.Windows.ContentElement.OnPreviewStylusButtonDown%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2345">Override <xref:System.Windows.ContentElement.OnPreviewStylusButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.StylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2346">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2346">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2347">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2347">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2348">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2348">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2349">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2349">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2350">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2350">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2351">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2351">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler PreviewStylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ PreviewStylusButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2352">Происходит при отпускании кнопки пера в тот момент, когда указатель находится над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2352">Occurs when the stylus button is released while the pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2353">Это событие создается псевдоним для <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewStylusButtonUp> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2353">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusButtonUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2354">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewStylusButtonUp> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2354">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusButtonUp> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusButtonUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="332d7-2355">Сенсорный ввод, мышь и ввод от пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="332d7-2355">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="332d7-2356">Дополнительные сведения см. в разделе [фокусе](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-2356">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2357">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2357">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2358">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2358">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusButtonUpEvent>|  
|<span data-ttu-id="332d7-2359">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2359">Routing strategy</span></span>|<span data-ttu-id="332d7-2360">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="332d7-2360">Tunneling</span></span>|  
|<span data-ttu-id="332d7-2361">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2361">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="332d7-2362">Соответствующий восходящей событие <xref:System.Windows.ContentElement.StylusButtonUp>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2362">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusButtonUp>.</span></span>  
  
-   <span data-ttu-id="332d7-2363">Переопределить <xref:System.Windows.ContentElement.OnPreviewStylusButtonUp%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2363">Override <xref:System.Windows.ContentElement.OnPreviewStylusButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2364">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2364">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2365">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2365">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2366">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2366">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2367">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2367">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2368">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2368">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2369">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2369">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler PreviewStylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler PreviewStylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ PreviewStylusDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2370">Происходит при касании дигитайзера пером в тот момент, когда оно находится над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2370">Occurs when the stylus touches the digitizer while it is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2371">Это событие создается псевдоним для <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewStylusDown> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2371">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2372">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewStylusDown> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2372">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="332d7-2373">Сенсорный ввод, мышь и ввод от пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="332d7-2373">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="332d7-2374">Дополнительные сведения см. в разделе [фокусе](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-2374">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2375">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2375">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2376">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2376">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusDownEvent>|  
|<span data-ttu-id="332d7-2377">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2377">Routing strategy</span></span>|<span data-ttu-id="332d7-2378">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="332d7-2378">Tunneling</span></span>|  
|<span data-ttu-id="332d7-2379">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2379">Delegate</span></span>|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   <span data-ttu-id="332d7-2380">Соответствующий восходящей событие <xref:System.Windows.ContentElement.StylusDown>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2380">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusDown>.</span></span>  
  
-   <span data-ttu-id="332d7-2381">Переопределить <xref:System.Windows.ContentElement.OnPreviewStylusDown%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2381">Override <xref:System.Windows.ContentElement.OnPreviewStylusDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2382">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewStylusDown" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2382">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2383">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2383">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2384">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2384">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2385">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2385">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2386">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2386">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2387">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2387">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInAirMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2388">Происходит при движении пера над элементом без касания дигитайзера.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2388">Occurs when the stylus moves over an element without actually touching the digitizer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2389">Это событие создается псевдоним для <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewStylusInAirMove> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2389">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusInAirMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2390">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewStylusInAirMove> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2390">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusInAirMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusInAirMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="332d7-2391">Сенсорный ввод, мышь и ввод от пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="332d7-2391">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="332d7-2392">Дополнительные сведения см. в разделе [фокусе](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-2392">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusInAirMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2393">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2393">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2394">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2394">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusInAirMoveEvent>|  
|<span data-ttu-id="332d7-2395">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2395">Routing strategy</span></span>|<span data-ttu-id="332d7-2396">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="332d7-2396">Tunneling</span></span>|  
|<span data-ttu-id="332d7-2397">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2397">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="332d7-2398">Соответствующий восходящей событие <xref:System.Windows.ContentElement.StylusInAirMove>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2398">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusInAirMove>.</span></span>  
  
-   <span data-ttu-id="332d7-2399">Переопределить <xref:System.Windows.ContentElement.OnPreviewStylusInAirMove%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2399">Override <xref:System.Windows.ContentElement.OnPreviewStylusInAirMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInAirMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2400">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2400">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2401">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2401">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2402">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2402">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2403">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2403">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2404">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2404">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2405">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2405">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusInRange;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2406">Происходит при нахождении пера над данным элементом достаточно близко для того, чтобы перо было обнаружено дигитайзером.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2406">Occurs when the stylus is close enough to the digitizer to be detected, while over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2407">Это событие создается псевдоним для <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewStylusInRange> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2407">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusInRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2408">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewStylusInRange> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2408">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusInRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusInRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="332d7-2409">Сенсорный ввод, мышь и ввод от пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="332d7-2409">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="332d7-2410">Дополнительные сведения см. в разделе [фокусе](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-2410">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusInRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2411">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2411">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2412">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2412">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusInRangeEvent>|  
|<span data-ttu-id="332d7-2413">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2413">Routing strategy</span></span>|<span data-ttu-id="332d7-2414">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="332d7-2414">Tunneling</span></span>|  
|<span data-ttu-id="332d7-2415">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2415">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="332d7-2416">Соответствующий восходящей событие <xref:System.Windows.ContentElement.StylusInRange>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2416">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusInRange>.</span></span>  
  
-   <span data-ttu-id="332d7-2417">Переопределить <xref:System.Windows.ContentElement.OnPreviewStylusInRange%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2417">Override <xref:System.Windows.ContentElement.OnPreviewStylusInRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusInRangeEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2418">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewStylusInRange" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2418">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusInRange" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2419">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2419">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2420">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2420">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2421">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2421">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2422">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2422">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2423">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2423">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2424">Происходит при перемещении пера над элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2424">Occurs when the stylus moves while over the element.</span>
          </span>
          <span data-ttu-id="332d7-2425">Для вызова этого события перемещаемое перо должно быть обнаружено дигитайзером; в противном случае вызывается <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2425">The stylus must move while being detected by the  digitizer  to raise this event, otherwise, <see cref="E:System.Windows.ContentElement.PreviewStylusInAirMove" /> is raised instead.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2426">Это событие создается псевдоним для <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewStylusMove> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2426">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2427">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewStylusMove> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2427">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="332d7-2428">Сенсорный ввод, мышь и ввод от пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="332d7-2428">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="332d7-2429">Дополнительные сведения см. в разделе [фокусе](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-2429">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2430">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2430">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2431">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2431">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusMoveEvent>|  
|<span data-ttu-id="332d7-2432">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2432">Routing strategy</span></span>|<span data-ttu-id="332d7-2433">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="332d7-2433">Tunneling</span></span>|  
|<span data-ttu-id="332d7-2434">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2434">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="332d7-2435">Соответствующий восходящей событие <xref:System.Windows.ContentElement.StylusMove>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2435">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusMove>.</span></span>  
  
-   <span data-ttu-id="332d7-2436">Переопределить <xref:System.Windows.ContentElement.OnPreviewStylusMove%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2436">Override <xref:System.Windows.ContentElement.OnPreviewStylusMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2437">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewStylusMove" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2437">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2438">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2438">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2439">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2439">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2440">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2440">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2441">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2441">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2442">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2442">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusOutOfRange;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2443">Происходит, когда перо находится слишком далеко от дигитайзера, чтобы быть обнаруженным.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2443">Occurs when the stylus is too far from the digitizer to be detected.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2444">Это событие создается псевдоним для <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2444">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2445">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2445">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusOutOfRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusOutOfRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="332d7-2446">Сенсорный ввод, мышь и ввод от пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="332d7-2446">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="332d7-2447">Дополнительные сведения см. в разделе [фокусе](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-2447">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusOutOfRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2448">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2448">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2449">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2449">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusOutOfRangeEvent>|  
|<span data-ttu-id="332d7-2450">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2450">Routing strategy</span></span>|<span data-ttu-id="332d7-2451">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="332d7-2451">Tunneling</span></span>|  
|<span data-ttu-id="332d7-2452">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2452">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="332d7-2453">Соответствующий восходящей событие <xref:System.Windows.ContentElement.StylusOutOfRange>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2453">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusOutOfRange>.</span></span>  
  
-   <span data-ttu-id="332d7-2454">Переопределить <xref:System.Windows.ContentElement.OnPreviewStylusOutOfRange%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2454">Override <xref:System.Windows.ContentElement.OnPreviewStylusOutOfRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusOutOfRangeEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2455">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2455">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusOutOfRange" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2456">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2456">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2457">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2457">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2458">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2458">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2459">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2459">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2460">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2460">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler PreviewStylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ PreviewStylusSystemGesture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2461">Происходит при использовании пользователем одного из жестов пером.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2461">Occurs when a user performs one of several stylus gestures.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2462">Сведения о жестах пера см. в разделе <xref:System.Windows.Input.SystemGesture>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2462">For information about stylus gestures, see <xref:System.Windows.Input.SystemGesture>.</span></span>  
  
 <span data-ttu-id="332d7-2463">Это событие создается псевдоним для <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2463">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2464">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2464">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusSystemGesture> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusSystemGesture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="332d7-2465">Сенсорный ввод, мышь и ввод от пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="332d7-2465">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="332d7-2466">Дополнительные сведения см. в разделе [фокусе](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-2466">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusSystemGesture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2467">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2467">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2468">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2468">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusSystemGestureEvent>|  
|<span data-ttu-id="332d7-2469">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2469">Routing strategy</span></span>|<span data-ttu-id="332d7-2470">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="332d7-2470">Tunneling</span></span>|  
|<span data-ttu-id="332d7-2471">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2471">Delegate</span></span>|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   <span data-ttu-id="332d7-2472">Соответствующий восходящей событие <xref:System.Windows.ContentElement.StylusSystemGesture>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2472">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusSystemGesture>.</span></span>  
  
-   <span data-ttu-id="332d7-2473">Переопределить <xref:System.Windows.ContentElement.OnPreviewStylusSystemGesture%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2473">Override <xref:System.Windows.ContentElement.OnPreviewStylusSystemGesture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusSystemGestureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2474">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2474">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusSystemGesture" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2475">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2475">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2476">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2476">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2477">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2477">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2478">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2478">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2479">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2479">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler PreviewStylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler PreviewStylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewStylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewStylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ PreviewStylusUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewStylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2480">Происходит, когда пользователь отрывает перо от поверхности дигитайзера в тот момент, когда оно находится над этим элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2480">Occurs when the user raises the stylus off the digitizer while the stylus is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2481">Это событие создается псевдоним для <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewStylusDown> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2481">This event creates an alias for the <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewStylusDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2482">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewStylusDown> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2482">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewStylusDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.PreviewStylusUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="332d7-2483">Сенсорный ввод, мышь и ввод от пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="332d7-2483">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="332d7-2484">Дополнительные сведения см. в разделе [фокусе](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-2484">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_PreviewStylusUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2485">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2485">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2486">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2486">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewStylusUpEvent>|  
|<span data-ttu-id="332d7-2487">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2487">Routing strategy</span></span>|<span data-ttu-id="332d7-2488">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="332d7-2488">Tunneling</span></span>|  
|<span data-ttu-id="332d7-2489">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2489">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="332d7-2490">Соответствующий восходящей событие <xref:System.Windows.ContentElement.StylusUp>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2490">The corresponding bubbling event is <xref:System.Windows.ContentElement.StylusUp>.</span></span>  
  
-   <span data-ttu-id="332d7-2491">Переопределить <xref:System.Windows.ContentElement.OnPreviewStylusUp%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2491">Override <xref:System.Windows.ContentElement.OnPreviewStylusUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewStylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewStylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewStylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewStylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewStylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewStylusUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2492">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewStylusUp" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2492">Identifies the <see cref="E:System.Windows.ContentElement.PreviewStylusUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2493">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2493">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2494">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2494">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2495">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2495">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2496">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2496">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2497">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2497">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler PreviewTextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler PreviewTextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ PreviewTextInput;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.PreviewTextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2498">Происходит при получении этим элементом текста аппаратно-независимым способом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2498">Occurs when this element gets text in a device-independent manner.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2499"><xref:System.Windows.ContentElement.PreviewTextInput> Событий позволяет компонента или приложения для прослушивания ввода текста в аппаратно независимым способом.</span><span class="sxs-lookup"><span data-stu-id="332d7-2499">The <xref:System.Windows.ContentElement.PreviewTextInput> event allows a component or application to listen for text input in a device-independent manner.</span></span> <span data-ttu-id="332d7-2500">Клавиатура является основным средством для <xref:System.Windows.ContentElement.PreviewTextInput>; но также могут создаваться речи, рукописного ввода и других устройств ввода <xref:System.Windows.ContentElement.PreviewTextInput>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2500">The keyboard is the primary means of <xref:System.Windows.ContentElement.PreviewTextInput>; but speech, handwriting, and other input devices can also generate <xref:System.Windows.ContentElement.PreviewTextInput>.</span></span>  
  
 <span data-ttu-id="332d7-2501">Из-за сочетания клавиш — клавиатуры по умолчанию или редакторам методов ввода, несколько событий клавиш могут сгенерировать только одно событие ввода текста.</span><span class="sxs-lookup"><span data-stu-id="332d7-2501">Because of key combinations—either in default keyboards or through input method editors—multiple key events may raise just one text input event.</span></span>  
  
 <span data-ttu-id="332d7-2502">Это событие создается псевдоним для <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.PreviewTextInput> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2502">This event creates an alias for the <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.PreviewTextInput> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2503">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.PreviewTextInput> событий присоединяются к базовому объекту <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2503">Event handlers that are attached to the <xref:System.Windows.ContentElement.PreviewTextInput> event are attached to the underlying <xref:System.Windows.Input.TextCompositionManager.PreviewTextInput?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_PreviewTextInput"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2504">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2504">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2505">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2505">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTextInputEvent>|  
|<span data-ttu-id="332d7-2506">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2506">Routing strategy</span></span>|<span data-ttu-id="332d7-2507">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="332d7-2507">Tunneling</span></span>|  
|<span data-ttu-id="332d7-2508">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2508">Delegate</span></span>|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   <span data-ttu-id="332d7-2509">Соответствующий восходящей событие <xref:System.Windows.ContentElement.TextInput>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2509">The corresponding bubbling event is <xref:System.Windows.ContentElement.TextInput>.</span></span>  
  
-   <span data-ttu-id="332d7-2510">Переопределить <xref:System.Windows.ContentElement.OnPreviewTextInput%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2510">Override <xref:System.Windows.ContentElement.OnPreviewTextInput%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewKeyDown" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTextInputEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2511">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewTextInput" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2511">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTextInput" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2512">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2512">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2513">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2513">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2514">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2514">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2515">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2515">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2516">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2516">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2517">Происходит при касании пальцем экрана, когда палец находится над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2517">Occurs when a finger touches the screen while the finger is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2518">По умолчанию <xref:System.Windows.ContentElement.PreviewTouchDown> и <xref:System.Windows.ContentElement.TouchDown> событий не выполняется до пальцем экрана касается и перемещает.</span><span class="sxs-lookup"><span data-stu-id="332d7-2518">By default, the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events do not occur until a finger touches the screen and moves.</span></span> <span data-ttu-id="332d7-2519">Нажав пальцем на экране и удерживая без его перемещения вызывает нажать клавиши и удерживайте поведение <xref:System.Windows.Input.Stylus>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2519">Pressing a finger on the screen and holding it without moving it causes the press and hold behavior of a <xref:System.Windows.Input.Stylus>.</span></span> <span data-ttu-id="332d7-2520">Поведение нажатия и удерживания соответствует щелчку правой кнопкой мыши.</span><span class="sxs-lookup"><span data-stu-id="332d7-2520">The press and hold behavior is equivalent to a mouse right-click.</span></span>  
  
 <span data-ttu-id="332d7-2521">Чтобы вызвать <xref:System.Windows.ContentElement.PreviewTouchDown> и <xref:System.Windows.ContentElement.TouchDown> события к как можно скорее касании пальцем экрана, задать <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> присоединенного свойства для `false` для этого элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2521">To cause the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events to occur as soon as a finger touches the screen, set the <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> attached property to `false` for this element.</span></span>  
  
<a name="routedEventInfo_PreviewTouchDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2522">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2522">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2523">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2523">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTouchDownEvent>|  
|<span data-ttu-id="332d7-2524">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2524">Routing strategy</span></span>|<span data-ttu-id="332d7-2525">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="332d7-2525">Tunneling</span></span>|  
|<span data-ttu-id="332d7-2526">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2526">Delegate</span></span>|<span data-ttu-id="332d7-2527"><xref:System.EventHandler%601> имеет тип данных <xref:System.Windows.Input.TouchEventArgs>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2527"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="332d7-2528">Соответствующий восходящей событие <xref:System.Windows.ContentElement.TouchDown>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2528">The corresponding bubbling event is <xref:System.Windows.ContentElement.TouchDown>.</span></span>  
  
-   <span data-ttu-id="332d7-2529">Переопределить <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2529">Override <xref:System.Windows.ContentElement.OnPreviewTouchDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2530">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewTouchDown" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2530">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTouchDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchMove;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2531">Возникает при перемещении пальца по экрану при условии, если палец находится над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2531">Occurs when a finger moves on the screen while the finger is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2532">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2532">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2533">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2533">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTouchMoveEvent>|  
|<span data-ttu-id="332d7-2534">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2534">Routing strategy</span></span>|<span data-ttu-id="332d7-2535">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="332d7-2535">Tunneling</span></span>|  
|<span data-ttu-id="332d7-2536">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2536">Delegate</span></span>|<span data-ttu-id="332d7-2537"><xref:System.EventHandler%601> имеет тип данных <xref:System.Windows.Input.TouchEventArgs>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2537"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="332d7-2538">Соответствующий восходящей событие <xref:System.Windows.ContentElement.TouchMove>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2538">The corresponding bubbling event is <xref:System.Windows.ContentElement.TouchMove>.</span></span>  
  
-   <span data-ttu-id="332d7-2539">Переопределить <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2539">Override <xref:System.Windows.ContentElement.OnPreviewTouchMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2540">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewTouchMove" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2540">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTouchMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; PreviewTouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.PreviewTouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event PreviewTouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ PreviewTouchUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2541">Возникает, когда палец отрывается от экрана при условии, что палец находится над этим элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2541">Occurs when a finger is raised off of the screen while the finger is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_PreviewTouchUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2542">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2542">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2543">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2543">Identifier field</span></span>|<xref:System.Windows.ContentElement.PreviewTouchUpEvent>|  
|<span data-ttu-id="332d7-2544">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2544">Routing strategy</span></span>|<span data-ttu-id="332d7-2545">Туннелирование</span><span class="sxs-lookup"><span data-stu-id="332d7-2545">Tunneling</span></span>|  
|<span data-ttu-id="332d7-2546">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2546">Delegate</span></span>|<span data-ttu-id="332d7-2547"><xref:System.EventHandler%601> имеет тип данных <xref:System.Windows.Input.TouchEventArgs>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2547"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="332d7-2548">Соответствующий восходящей событие <xref:System.Windows.ContentElement.TouchUp>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2548">The corresponding bubbling event is <xref:System.Windows.ContentElement.TouchUp>.</span></span>  
  
-   <span data-ttu-id="332d7-2549">Переопределить <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2549">Override <xref:System.Windows.ContentElement.OnPreviewTouchUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PreviewTouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent PreviewTouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent PreviewTouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.PreviewTouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly PreviewTouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ PreviewTouchUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2550">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.PreviewTouchUp" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2550">Identifies the <see cref="E:System.Windows.ContentElement.PreviewTouchUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDrag">
      <MemberSignature Language="C#" Value="public event System.Windows.QueryContinueDragEventHandler QueryContinueDrag;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.QueryContinueDragEventHandler QueryContinueDrag" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.QueryContinueDrag" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryContinueDrag As QueryContinueDragEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::QueryContinueDragEventHandler ^ QueryContinueDrag;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.QueryContinueDragEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2551">Происходит, когда состояние клавиши или кнопки мыши изменяется в ходе операции перетаскивания.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2551">Occurs when there is a change in the keyboard or mouse button state during a drag-and-drop operation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2552"><xref:System.Windows.ContentElement.QueryContinueDrag> Событий позволяет источнику перетаскивания определить, должна ли быть отменена операция перетаскивания и вставки.</span><span class="sxs-lookup"><span data-stu-id="332d7-2552">The <xref:System.Windows.ContentElement.QueryContinueDrag> event enables the drag source to determine whether the drag-and-drop operation should be canceled.</span></span>  
  
 <span data-ttu-id="332d7-2553">Это событие создается псевдоним для <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.QueryContinueDrag> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2553">This event creates an alias for the <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.QueryContinueDrag> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2554">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.QueryContinueDrag> событий присоединяются к базовому объекту <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2554">Event handlers that are attached to the <xref:System.Windows.ContentElement.QueryContinueDrag> event are attached to the underlying <xref:System.Windows.DragDrop.QueryContinueDrag?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_QueryContinueDrag"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2555">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2555">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2556">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2556">Identifier field</span></span>|<xref:System.Windows.ContentElement.QueryContinueDragEvent>|  
|<span data-ttu-id="332d7-2557">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2557">Routing strategy</span></span>|<span data-ttu-id="332d7-2558">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-2558">Bubbling</span></span>|  
|<span data-ttu-id="332d7-2559">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2559">Delegate</span></span>|<xref:System.Windows.QueryContinueDragEventHandler>|  
  
-   <span data-ttu-id="332d7-2560">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewQueryContinueDrag>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2560">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewQueryContinueDrag>.</span></span>  
  
-   <span data-ttu-id="332d7-2561">Переопределить <xref:System.Windows.ContentElement.OnQueryContinueDrag%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2561">Override <xref:System.Windows.ContentElement.OnQueryContinueDrag%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryContinueDragEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryContinueDragEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryContinueDragEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.QueryContinueDragEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryContinueDragEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryContinueDragEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2562">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.QueryContinueDrag" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2562">Identifies the <see cref="E:System.Windows.ContentElement.QueryContinueDrag" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2563">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2563">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2564">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2564">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2565">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2565">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2566">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2566">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2567">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2567">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueryCursor">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.QueryCursorEventHandler QueryCursor;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.QueryCursorEventHandler QueryCursor" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.QueryCursor" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event QueryCursor As QueryCursorEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Input::QueryCursorEventHandler ^ QueryCursor;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.QueryCursorEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2568">Происходит при запросе отображения курсора.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2568">Occurs when the cursor is requested to display.</span>
          </span>
          <span data-ttu-id="332d7-2569">Это событие возникает для элемента каждый раз, когда указатель мыши перемещается в новое положение, что может послужить причиной изменения его внешнего вида.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2569">This event is raised on an element each time that the mouse pointer moves to a new location, which means the cursor object might need to be changed based on its new position.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2570">Это событие создается псевдоним для <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.QueryCursor> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2570">This event creates an alias for the <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.QueryCursor> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2571">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.QueryCursor> событий присоединяются к базовому объекту <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2571">Event handlers that are attached to the <xref:System.Windows.ContentElement.QueryCursor> event are attached to the underlying <xref:System.Windows.Input.Mouse.QueryCursor?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="332d7-2572">Курсор, который ссылается данное имя события не обязательно текстового курсора (которую иногда называют курсора).</span><span class="sxs-lookup"><span data-stu-id="332d7-2572">The cursor being referred to by this event name is not necessarily the text cursor (sometimes known as the insertion point).</span></span> <span data-ttu-id="332d7-2573">Вместо этого в данном контексте курсор является объект, который объявляет графическое отображение на экране, связанные с несколькими возможными устройствами ввода или концепциями в [!INCLUDE[TLA2#tla_win](~/includes/tla2sharptla-win-md.md)] программирования.</span><span class="sxs-lookup"><span data-stu-id="332d7-2573">Instead, the cursor in this context is the object that declares the onscreen graphical display related to several possible input-related devices or concepts in [!INCLUDE[TLA2#tla_win](~/includes/tla2sharptla-win-md.md)] programming.</span></span> <span data-ttu-id="332d7-2574">Этот объект представляется <xref:System.Windows.Input.Cursor> в класс [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)].</span><span class="sxs-lookup"><span data-stu-id="332d7-2574">That object is represented by the <xref:System.Windows.Input.Cursor> class in [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)].</span></span> <span data-ttu-id="332d7-2575">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] Система ввода позволяет изменять этот курсор, когда он представляет экранную позицию указателя мыши.</span><span class="sxs-lookup"><span data-stu-id="332d7-2575">The [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] input system enables you to change this cursor when it represents the onscreen position of the mouse pointer.</span></span> <span data-ttu-id="332d7-2576">Можно использовать стандартные значения из <xref:System.Windows.Input.Cursors> перечисления, либо можно объявить пользовательский курсор в файл изображения.</span><span class="sxs-lookup"><span data-stu-id="332d7-2576">You can use predefined values from the <xref:System.Windows.Input.Cursors> enumeration, or you can declare a custom cursor as an image file.</span></span>  
  
 <span data-ttu-id="332d7-2577">Прослушивание <xref:System.Windows.ContentElement.QueryCursor> событие не является эффективным методика управления курсора.</span><span class="sxs-lookup"><span data-stu-id="332d7-2577">Listening for the <xref:System.Windows.ContentElement.QueryCursor> event is not an efficient technique for cursor management.</span></span> <span data-ttu-id="332d7-2578">Вместо этого каждый элемент должен определить свое поведение курсора с <xref:System.Windows.FrameworkContentElement.Cursor%2A> и <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2578">Instead, each element should define its own cursor behavior with <xref:System.Windows.FrameworkContentElement.Cursor%2A> and <xref:System.Windows.FrameworkContentElement.ForceCursor%2A>.</span></span> <span data-ttu-id="332d7-2579">Следует полагаться на <xref:System.Windows.ContentElement.QueryCursor> Если не используются базовые элементы уровня платформы WPF или в непредвиденных случаях когда определение работы курсоров, на основе каждого элемента не соответствует вашим потребностям.</span><span class="sxs-lookup"><span data-stu-id="332d7-2579">You should only rely on <xref:System.Windows.ContentElement.QueryCursor> if you are not using the WPF framework-level base elements, or in extraordinary circumstances where defining cursor behavior on a per-element basis does not meet your needs.</span></span> <span data-ttu-id="332d7-2580">Дополнительные сведения о реализации поведение курсора в ответ на <xref:System.Windows.ContentElement.QueryCursor>, в разделе <xref:System.Windows.Input.QueryCursorEventHandler>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2580">For more information on implementing cursor behavior in response to <xref:System.Windows.ContentElement.QueryCursor>, see <xref:System.Windows.Input.QueryCursorEventHandler>.</span></span>  
  
<a name="routedEventInfo_QueryCursor"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2581">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2581">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2582">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2582">Identifier field</span></span>|<xref:System.Windows.ContentElement.QueryCursorEvent>|  
|<span data-ttu-id="332d7-2583">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2583">Routing strategy</span></span>|<span data-ttu-id="332d7-2584">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-2584">Bubbling</span></span>|  
|<span data-ttu-id="332d7-2585">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2585">Delegate</span></span>|<xref:System.Windows.Input.QueryCursorEventHandler>|  
  
-   <span data-ttu-id="332d7-2586">Нет определенного события, соответствующие туннелирования.</span><span class="sxs-lookup"><span data-stu-id="332d7-2586">There is no defined corresponding tunneling event.</span></span>  
  
-   <span data-ttu-id="332d7-2587">Переопределить <xref:System.Windows.ContentElement.OnQueryCursor%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2587">Override <xref:System.Windows.ContentElement.OnQueryCursor%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="QueryCursorEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent QueryCursorEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent QueryCursorEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.QueryCursorEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly QueryCursorEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ QueryCursorEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2588">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.QueryCursor" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2588">Identifies the <see cref="E:System.Windows.ContentElement.QueryCursor" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2589">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2589">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2590">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2590">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2591">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2591">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2592">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2592">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2593">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2593">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RaiseEvent">
      <MemberSignature Language="C#" Value="public void RaiseEvent (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RaiseEvent(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RaiseEvent (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RaiseEvent(System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RaiseEvent(System.Windows.RoutedEventArgs)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="332d7-2594">
            <see cref="T:System.Windows.RoutedEventArgs" />, содержащий данные о событии и идентифицирующий событие, которое следует сгенерировать.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2594">A <see cref="T:System.Windows.RoutedEventArgs" /> that contains the event data and also identifies the event to raise.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-2595">Инициирует определенное перенаправленное событие.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2595">Raises a specific routed event.</span>
          </span>
          <span data-ttu-id="332d7-2596">
            <see cref="T:System.Windows.RoutedEvent" />, которое должно быть идентифицировано в предоставленном экземпляре <see cref="T:System.Windows.RoutedEventArgs" /> (как и свойство <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> данных события).</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2596">The <see cref="T:System.Windows.RoutedEvent" /> to be raised is identified within the <see cref="T:System.Windows.RoutedEventArgs" /> instance that is provided (as the <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> property of that event data).</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2597">`e` Параметр типизируется как общий базовый тип для всех данных маршрутизируемого события; тем не менее, данные о событии должны быть предоставлены как наиболее конкретный тип данных события, доступные для события, так как <xref:System.Windows.RoutedEventArgs> содержать производные классы определенные свойства данных, предназначенные для конкретного события, если оно возникает.</span><span class="sxs-lookup"><span data-stu-id="332d7-2597">The `e` parameter is typed as the common base type for all routed event data; however, the event data should be given as the most specific event data type that is available for the event being raised, because <xref:System.Windows.RoutedEventArgs> derived classes contain the actual specific data properties that are intended for the specific event when it is raised.</span></span>  
  
 <span data-ttu-id="332d7-2598"><xref:System.Windows.RoutedEventArgs> не только свойства состояния события; Он также определяет какие перенаправленного события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2598"><xref:System.Windows.RoutedEventArgs> is not just the state properties for the event; it also identifies which routed event to raise.</span></span> <span data-ttu-id="332d7-2599">Данный шаблон генерации событий и данные о событии и отличаться от [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] классы событий и данных, которые обычно содержат свойства, относящиеся к событию.</span><span class="sxs-lookup"><span data-stu-id="332d7-2599">This event-raising pattern and the routed event data both differ from [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] events and data classes, which typically just contain properties that are related to the event.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="332d7-2600">Следующий пример создает данные события, добавляет идентификатор события к и затем использует экземпляр данных события для создания пользовательского перенаправленного события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2600">The following example creates event data, appends the event identifier to the data, and then uses the event data instance to raise a custom routed event.</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/page1.xaml.cs#raiseevent)]
 [!code-vb[ContentElementsSmorgasbord#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/page1.xaml.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseAllTouchCaptures">
      <MemberSignature Language="C#" Value="public void ReleaseAllTouchCaptures ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseAllTouchCaptures() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseAllTouchCaptures" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseAllTouchCaptures ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseAllTouchCaptures();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2601">Освобождает все полученные сенсорные устройства для данного элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2601">Releases all captured touch devices from this element.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMouseCapture">
      <MemberSignature Language="C#" Value="public void ReleaseMouseCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseMouseCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseMouseCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMouseCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseMouseCapture();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseMouseCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2602">Освобождает мышь, если элемент произвел ее захват.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2602">Releases the mouse capture, if this element held the capture.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2603">Если этот элемент не содержит записи, вызов этого метода не оказывает влияния.</span><span class="sxs-lookup"><span data-stu-id="332d7-2603">If this element did not hold the capture, calling this method has no effect.</span></span> <span data-ttu-id="332d7-2604">Рассмотрите возможность проверки значения <xref:System.Windows.ContentElement.IsMouseCaptured%2A> перед вызовом этого метода.</span><span class="sxs-lookup"><span data-stu-id="332d7-2604">Consider checking the value of <xref:System.Windows.ContentElement.IsMouseCaptured%2A> before you call this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="332d7-2605">Следующий обработчик перехватывает или освобождает захват мыши согласно состояние кнопок мыши.</span><span class="sxs-lookup"><span data-stu-id="332d7-2605">The following handler captures or releases mouse capture according to mouse button states.</span></span> <span data-ttu-id="332d7-2606">В примере показано использование движения захваченной мыши целях альтернативой, отличные от перемещения указателя мыши в [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span><span class="sxs-lookup"><span data-stu-id="332d7-2606">The example shows how to use captured mouse movement for alternative purposes other than moving the mouse pointer in the [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].</span></span>  
  
 [!code-csharp[ContentElementsSmorgasbord#UIElementMouseCapture](~/samples/snippets/csharp/VS_Snippets_Wpf/ContentElementsSmorgasbord/CSharp/Trackball.cs#uielementmousecapture)]
 [!code-vb[ContentElementsSmorgasbord#UIElementMouseCapture](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ContentElementsSmorgasbord/visualbasic/trackball.vb#uielementmousecapture)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.ContentElement.IsMouseCaptured" />
      </Docs>
    </Member>
    <Member MemberName="ReleaseStylusCapture">
      <MemberSignature Language="C#" Value="public void ReleaseStylusCapture ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReleaseStylusCapture() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseStylusCapture" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseStylusCapture ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ReleaseStylusCapture();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.ReleaseStylusCapture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2607">Освобождает перо, если элемент произвел его захват.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2607">Releases the stylus device capture, if this element held the capture.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2608">Если этот элемент не содержит записи, вызов этого метода не оказывает влияния.</span><span class="sxs-lookup"><span data-stu-id="332d7-2608">If this element did not hold the capture, calling this method has no effect.</span></span> <span data-ttu-id="332d7-2609">Рассмотрите возможность проверки значения <xref:System.Windows.ContentElement.IsStylusCaptured%2A> перед вызовом этого метода.</span><span class="sxs-lookup"><span data-stu-id="332d7-2609">Consider checking the value of <xref:System.Windows.ContentElement.IsStylusCaptured%2A> before you call this method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseTouchCapture">
      <MemberSignature Language="C#" Value="public bool ReleaseTouchCapture (System.Windows.Input.TouchDevice touchDevice);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReleaseTouchCapture(class System.Windows.Input.TouchDevice touchDevice) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ReleaseTouchCapture(System.Windows.Input.TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReleaseTouchCapture(System::Windows::Input::TouchDevice ^ touchDevice);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="touchDevice" Type="System.Windows.Input.TouchDevice" />
      </Parameters>
      <Docs>
        <param name="touchDevice">
          <span data-ttu-id="332d7-2610">Освобождаемое устройство.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2610">The device to release.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-2611">Предпринимает попытку освободить заданное сенсорное устройство из этого элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2611">Attempts to release the specified touch device from this element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="332d7-2612">Значение <see langword="true" />, если устройство сенсорного ввода освобождено; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2612">
              <see langword="true" /> if the touch device is released; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="332d7-2613">Свойство <paramref name="touchDevice" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2613">
              <paramref name="touchDevice" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RemoveHandler">
      <MemberSignature Language="C#" Value="public void RemoveHandler (System.Windows.RoutedEvent routedEvent, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void RemoveHandler(class System.Windows.RoutedEvent routedEvent, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void RemoveHandler(System::Windows::RoutedEvent ^ routedEvent, Delegate ^ handler);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.IInputElement.RemoveHandler(System.Windows.RoutedEvent,System.Delegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="routedEvent">
          <span data-ttu-id="332d7-2614">Идентификатор перенаправленного события, к которому присоединен обработчик.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2614">The identifier of the.routed event for which the handler is attached.</span>
          </span>
        </param>
        <param name="handler">
          <span data-ttu-id="332d7-2615">Конкретная реализация удаляемого обработчика из коллекции обработчиков событий этого элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2615">The specific handler implementation to remove from the event handler collection on this element.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="332d7-2616">Удаляет указанный обработчик маршрутизируемого события из этого элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2616">Removes the specified routed event handler from this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2617">Наиболее распространенный сценарий с помощью этого [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] — при реализации [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] «программу-оболочку» события, связанный с пользовательских перенаправленных событий, особенно при реализовать логику «удалить» для обработчиков [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] уровне.</span><span class="sxs-lookup"><span data-stu-id="332d7-2617">The most common scenario for using this [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] is when you implement the [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] "wrapper" event that is associated with a custom routed event, specifically when you implement the "remove" logic for handlers at the [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] level.</span></span> <span data-ttu-id="332d7-2618">Это в следующем примере иллюстрируются сценарием примечания.</span><span class="sxs-lookup"><span data-stu-id="332d7-2618">The example that follows this remarks section illustrates this scenario.</span></span>  
  
 <span data-ttu-id="332d7-2619">Вызов этого метода имеет смысл, если обработчики, зарегистрированные с критериями, соответствующие входным параметрам для вызова данного метода, отсутствуют.</span><span class="sxs-lookup"><span data-stu-id="332d7-2619">Calling this method has no effect if there were no handlers registered with criteria that match the input parameters for the method call.</span></span>  
  
 <span data-ttu-id="332d7-2620">Если более чем один обработчик присоединяется, соответствующих критериям, только первый обработчик в случае, когда обработчик хранилище будет удалено.</span><span class="sxs-lookup"><span data-stu-id="332d7-2620">If more than one handler is attached that matched the criteria, only the first handler in the event handler store is removed.</span></span> <span data-ttu-id="332d7-2621">Такое поведение согласуется с [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] поведение `-=` оператор.</span><span class="sxs-lookup"><span data-stu-id="332d7-2621">This behavior is consistent with [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] behavior of the `-=` operator.</span></span>  
  
 <span data-ttu-id="332d7-2622">Ни `routedEvent` , ни `handler` может быть `null`.</span><span class="sxs-lookup"><span data-stu-id="332d7-2622">Neither `routedEvent` nor `handler` may be `null`.</span></span> <span data-ttu-id="332d7-2623">Попытка присвоить значение, либо как `null` вызовет исключение.</span><span class="sxs-lookup"><span data-stu-id="332d7-2623">Attempting to provide either value as `null` will raise an exception.</span></span>  
  
 <span data-ttu-id="332d7-2624">Этот метод игнорирует `handledEventsToo` добавлены сведения о параметрах, который предоставляется, если обработчик был первоначально с <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> подпись, которая включает обработку событий уже обработано.</span><span class="sxs-lookup"><span data-stu-id="332d7-2624">This method ignores the `handledEventsToo` parameter information, which is provided if the handler was first added with the <xref:System.Windows.ContentElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> signature that enables handling of already-handled events.</span></span> <span data-ttu-id="332d7-2625">Любой из типов обработчика удаляется.</span><span class="sxs-lookup"><span data-stu-id="332d7-2625">Either type of handler is removed.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.ContentElement.AddHandler(System.Windows.RoutedEvent,System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeCommandBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeCommandBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeCommandBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ShouldSerializeCommandBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeCommandBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeCommandBindings();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2626">Возвращает логическое значение, указывающее, следует ли процессам сериализации сериализировать содержимое свойства <see cref="P:System.Windows.ContentElement.CommandBindings" /> в экземплярах данного класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2626">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.ContentElement.CommandBindings" /> property on instances of this class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="332d7-2627">Значение <see langword="true" />, если значение свойства <see cref="P:System.Windows.ContentElement.CommandBindings" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2627">
              <see langword="true" /> if the <see cref="P:System.Windows.ContentElement.CommandBindings" /> property value should be serialized; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2628">Будет возвращен `true` Если <xref:System.Windows.ContentElement.CommandBindings%2A> установлено локально.</span><span class="sxs-lookup"><span data-stu-id="332d7-2628">This will return `true` if <xref:System.Windows.ContentElement.CommandBindings%2A> is locally set.</span></span>  
  
 <span data-ttu-id="332d7-2629">Это `ShouldSerialize` метод предоставляется, поскольку <xref:System.Windows.UIElement.CommandBindings%2A> свойство не имеет значения по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-2629">This `ShouldSerialize` method is provided because the <xref:System.Windows.UIElement.CommandBindings%2A> property does not have a simple default value.</span></span> <span data-ttu-id="332d7-2630">Этот метод указывает, изменилось ли свойство со значением по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-2630">This method indicates whether the property has changed from its default value.</span></span> <span data-ttu-id="332d7-2631">Этот метод обычно вызывается при либо разработке либо конструктора или при разработке собственного элемента управления с включением <xref:System.Windows.UIElement>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2631">You typically invoke this method if you are either developing a designer or developing your own control incorporating a <xref:System.Windows.UIElement>.</span></span>  
  
 <span data-ttu-id="332d7-2632">Дополнительные сведения см. в разделе [определение значения по умолчанию с ShouldSerialize и Reset методы](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-2632">For more information, see [Defining Default Values with the ShouldSerialize and Reset Methods](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeInputBindings">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeInputBindings ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeInputBindings() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.ContentElement.ShouldSerializeInputBindings" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeInputBindings () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeInputBindings();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2633">Возвращает логическое значение, указывающее, следует ли процессам сериализации сериализировать содержимое свойства <see cref="P:System.Windows.ContentElement.InputBindings" /> в экземплярах данного класса.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2633">Returns whether serialization processes should serialize the contents of the <see cref="P:System.Windows.ContentElement.InputBindings" /> property on instances of this class.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="332d7-2634">Значение <see langword="true" />, если значение свойства <see cref="P:System.Windows.ContentElement.InputBindings" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2634">
              <see langword="true" /> if the <see cref="P:System.Windows.ContentElement.InputBindings" /> property value should be serialized; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2635">Будет возвращен `true` Если <xref:System.Windows.ContentElement.InputBindings%2A> установлено локально.</span><span class="sxs-lookup"><span data-stu-id="332d7-2635">This will return `true` if <xref:System.Windows.ContentElement.InputBindings%2A> is locally set.</span></span>  
  
 <span data-ttu-id="332d7-2636">Это `ShouldSerialize` метод предоставляется, поскольку <xref:System.Windows.UIElement.InputBindings%2A> свойство не имеет значения по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-2636">This `ShouldSerialize` method is provided because the <xref:System.Windows.UIElement.InputBindings%2A> property does not have a simple default value.</span></span> <span data-ttu-id="332d7-2637">Этот метод указывает, изменилось ли свойство со значением по умолчанию.</span><span class="sxs-lookup"><span data-stu-id="332d7-2637">This method indicates whether the property has changed from its default value.</span></span> <span data-ttu-id="332d7-2638">Этот метод обычно вызывается при либо разработке либо конструктора или при разработке собственного элемента управления с включением <xref:System.Windows.UIElement>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2638">You typically invoke this method if you are either developing a designer or developing your own control incorporating a <xref:System.Windows.UIElement>.</span></span>  
  
 <span data-ttu-id="332d7-2639">Дополнительные сведения см. в разделе [определение значения по умолчанию с ShouldSerialize и Reset методы](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-2639">For more information, see [Defining Default Values with the ShouldSerialize and Reset Methods](~/docs/framework/winforms/controls/defining-default-values-with-the-shouldserialize-and-reset-methods.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusButtonDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonDown As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2640">Происходит при нажатии кнопки пера в тот момент, когда указатель находится над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2640">Occurs when the stylus button is pressed while the pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2641">Это событие создается псевдоним для <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.StylusButtonDown> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2641">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusButtonDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2642">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.StylusButtonDown> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2642">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusButtonDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusButtonDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="332d7-2643">Сенсорный ввод, мышь и ввод от пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="332d7-2643">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="332d7-2644">Дополнительные сведения см. в разделе [фокусе](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-2644">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusButtonDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2645">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2645">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2646">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2646">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusButtonDownEvent>|  
|<span data-ttu-id="332d7-2647">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2647">Routing strategy</span></span>|<span data-ttu-id="332d7-2648">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-2648">Bubbling</span></span>|  
|<span data-ttu-id="332d7-2649">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2649">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="332d7-2650">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewStylusButtonDown>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2650">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusButtonDown>.</span></span>  
  
-   <span data-ttu-id="332d7-2651">Переопределить <xref:System.Windows.ContentElement.OnStylusButtonDown%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2651">Override <xref:System.Windows.ContentElement.OnStylusButtonDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonDown" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusButtonDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2652">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.StylusButtonDown" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2652">Identifies the <see cref="E:System.Windows.ContentElement.StylusButtonDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2653">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2653">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2654">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2654">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2655">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2655">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2656">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2656">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2657">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2657">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusButtonEventHandler StylusButtonUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusButtonEventHandler StylusButtonUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusButtonUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusButtonUp As StylusButtonEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusButtonEventHandler ^ StylusButtonUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusButtonUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusButtonEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2658">Происходит при отпускании кнопки пера в тот момент, когда указатель находится над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2658">Occurs when the stylus button is released while the pointer is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2659">Это событие создается псевдоним для <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.StylusButtonUp> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2659">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusButtonUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2660">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.StylusButtonUp> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2660">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusButtonUp> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusButtonUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="332d7-2661">Сенсорный ввод, мышь и ввод от пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="332d7-2661">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="332d7-2662">Дополнительные сведения см. в разделе [фокусе](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-2662">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusButtonUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2663">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2663">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2664">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2664">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusButtonUpEvent>|  
|<span data-ttu-id="332d7-2665">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2665">Routing strategy</span></span>|<span data-ttu-id="332d7-2666">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-2666">Bubbling</span></span>|  
|<span data-ttu-id="332d7-2667">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2667">Delegate</span></span>|<xref:System.Windows.Input.StylusButtonEventHandler>|  
  
-   <span data-ttu-id="332d7-2668">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewStylusButtonUp>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2668">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusButtonUp>.</span></span>  
  
-   <span data-ttu-id="332d7-2669">Переопределить <xref:System.Windows.ContentElement.OnStylusButtonUp%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2669">Override <xref:System.Windows.ContentElement.OnStylusButtonUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.ContentElement.PreviewStylusButtonUp" />
      </Docs>
    </Member>
    <Member MemberName="StylusButtonUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusButtonUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusButtonUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusButtonUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusButtonUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusButtonUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2670">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.StylusButtonUp" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2670">Identifies the <see cref="E:System.Windows.ContentElement.StylusButtonUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2671">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2671">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2672">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2672">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2673">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2673">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2674">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2674">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2675">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2675">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDown">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusDownEventHandler StylusDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusDownEventHandler StylusDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusDown As StylusDownEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusDownEventHandler ^ StylusDown;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusDown</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusDownEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2676">Происходит при касании дигитайзера пером в тот момент, когда оно находится над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2676">Occurs when the stylus touches the digitizer while the stylus is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2677">Это событие создается псевдоним для <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.StylusDown> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2677">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusDown> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2678">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.StylusDown> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2678">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusDown> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusDown?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="332d7-2679">Сенсорный ввод, мышь и ввод от пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="332d7-2679">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="332d7-2680">Дополнительные сведения см. в разделе [фокусе](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-2680">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2681">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2681">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2682">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2682">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusDownEvent>|  
|<span data-ttu-id="332d7-2683">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2683">Routing strategy</span></span>|<span data-ttu-id="332d7-2684">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-2684">Bubbling</span></span>|  
|<span data-ttu-id="332d7-2685">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2685">Delegate</span></span>|<xref:System.Windows.Input.StylusDownEventHandler>|  
  
-   <span data-ttu-id="332d7-2686">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewStylusDown>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2686">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusDown>.</span></span>  
  
-   <span data-ttu-id="332d7-2687">Переопределить <xref:System.Windows.ContentElement.OnStylusDown%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2687">Override <xref:System.Windows.ContentElement.OnStylusDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2688">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.StylusDown" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2688">Identifies the <see cref="E:System.Windows.ContentElement.StylusDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2689">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2689">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2690">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2690">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2691">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2691">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2692">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2692">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2693">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2693">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnter">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusEnter As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusEnter;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusEnter</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2694">Происходит, когда перо попадает внутрь границ данного элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2694">Occurs when the stylus enters the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2695"><xref:System.Windows.ContentElement.StylusEnter> — [направлено Общие сведения о событиях](~/docs/framework/wpf/advanced/routed-events-overview.md) , использующий прямой обработки стратегия маршрутизации события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2695"><xref:System.Windows.ContentElement.StylusEnter> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="332d7-2696">Прямые перенаправленные события не вызываются по маршруту; Вместо этого они обрабатываются в том же элементе где они возникли.</span><span class="sxs-lookup"><span data-stu-id="332d7-2696">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="332d7-2697">Тем не менее они включают другие аспекты поведения маршрутизируемых событий, например триггеры событий в стилях.</span><span class="sxs-lookup"><span data-stu-id="332d7-2697">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="332d7-2698">Несмотря на то что <xref:System.Windows.ContentElement.StylusEnter> отслеживает, когда перо попадает внутрь границ элемента, это событие больше о том, что буквально <xref:System.Windows.ContentElement.IsStylusOver%2A> значение свойства было изменено с `false` для `true` для этого элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2698">Although <xref:System.Windows.ContentElement.StylusEnter> tracks when the stylus enters the bounds of an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsStylusOver%2A> property value has changed from `false` to `true` on this element.</span></span>  
  
 <span data-ttu-id="332d7-2699">Это событие создается псевдоним для <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.StylusEnter> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2699">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusEnter> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2700">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.StylusEnter> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2700">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusEnter> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusEnter?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="332d7-2701">Сенсорный ввод, мышь и ввод от пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="332d7-2701">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="332d7-2702">Дополнительные сведения см. в разделе [фокусе](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-2702">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2703">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2703">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2704">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2704">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusEnterEvent>|  
|<span data-ttu-id="332d7-2705">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2705">Routing strategy</span></span>|<span data-ttu-id="332d7-2706">Direct</span><span class="sxs-lookup"><span data-stu-id="332d7-2706">Direct</span></span>|  
|<span data-ttu-id="332d7-2707">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2707">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="332d7-2708">Переопределить <xref:System.Windows.ContentElement.OnStylusEnter%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2708">Override <xref:System.Windows.ContentElement.OnStylusEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusEnterEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2709">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.StylusEnter" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2709">Identifies the <see cref="E:System.Windows.ContentElement.StylusEnter" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2710">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2710">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2711">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2711">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2712">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2712">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2713">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2713">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2714">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2714">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInAirMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInAirMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusInAirMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInAirMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInAirMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInAirMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2715">Происходит при движении пера над элементом без касания дигитайзера.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2715">Occurs when the stylus moves over an element without actually touching the digitizer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2716">Это событие создается псевдоним для <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.StylusInAirMove> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2716">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusInAirMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2717">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.StylusInAirMove> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2717">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusInAirMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusInAirMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="332d7-2718">Сенсорный ввод, мышь и ввод от пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="332d7-2718">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="332d7-2719">Дополнительные сведения см. в разделе [фокусе](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-2719">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusInAirMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2720">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2720">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2721">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2721">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusInAirMoveEvent>|  
|<span data-ttu-id="332d7-2722">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2722">Routing strategy</span></span>|<span data-ttu-id="332d7-2723">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-2723">Bubbling</span></span>|  
|<span data-ttu-id="332d7-2724">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2724">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="332d7-2725">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewStylusInAirMove>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2725">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusInAirMove>.</span></span>  
  
-   <span data-ttu-id="332d7-2726">Переопределить <xref:System.Windows.ContentElement.OnStylusInAirMove%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2726">Override <xref:System.Windows.ContentElement.OnStylusInAirMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInAirMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInAirMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInAirMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusInAirMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInAirMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInAirMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2727">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.StylusInAirMove" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2727">Identifies the <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2728">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2728">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2729">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2729">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2730">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2730">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2731">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2731">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2732">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2732">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusInRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusInRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusInRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusInRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusInRange;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusInRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2733">Происходит при нахождении пера над данным элементом достаточно близко для того, чтобы перо было обнаружено дигитайзером.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2733">Occurs when the stylus is close enough to the digitizer to be detected, while over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2734">Это событие создается псевдоним для <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.StylusInRange> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2734">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusInRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2735">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.StylusInRange> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2735">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusInRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusInRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="332d7-2736">Сенсорный ввод, мышь и ввод от пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="332d7-2736">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="332d7-2737">Дополнительные сведения см. в разделе [фокусе](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-2737">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusInRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2738">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2738">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2739">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2739">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusInRangeEvent>|  
|<span data-ttu-id="332d7-2740">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2740">Routing strategy</span></span>|<span data-ttu-id="332d7-2741">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-2741">Bubbling</span></span>|  
|<span data-ttu-id="332d7-2742">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2742">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="332d7-2743">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewStylusInRange>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2743">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusInRange>.</span></span>  
  
-   <span data-ttu-id="332d7-2744">Переопределить <xref:System.Windows.ContentElement.OnStylusInRange%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2744">Override <xref:System.Windows.ContentElement.OnStylusInRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusInRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusInRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusInRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusInRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusInRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusInRangeEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2745">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.StylusInRange" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2745">Identifies the <see cref="E:System.Windows.ContentElement.StylusInRange" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2746">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2746">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2747">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2747">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2748">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2748">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2749">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2749">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2750">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2750">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeave">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusLeave As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusLeave;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusLeave</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2751">Происходит, когда перо покидает границы элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2751">Occurs when the stylus leaves the bounds of the element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2752"><xref:System.Windows.ContentElement.StylusLeave> — [направлено Общие сведения о событиях](~/docs/framework/wpf/advanced/routed-events-overview.md) , использующий прямой обработки стратегия маршрутизации события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2752"><xref:System.Windows.ContentElement.StylusLeave> is a [Routed Events Overview](~/docs/framework/wpf/advanced/routed-events-overview.md) that uses the direct event handling routing strategy.</span></span> <span data-ttu-id="332d7-2753">Прямые перенаправленные события не вызываются по маршруту; Вместо этого они обрабатываются в том же элементе где они возникли.</span><span class="sxs-lookup"><span data-stu-id="332d7-2753">Direct routed events are not raised along a route; instead, they are handled in the same element where they are raised.</span></span> <span data-ttu-id="332d7-2754">Тем не менее они включают другие аспекты поведения маршрутизируемых событий, например триггеры событий в стилях.</span><span class="sxs-lookup"><span data-stu-id="332d7-2754">However, they do enable other aspects of routed event behavior, such as event triggers in styles.</span></span>  
  
 <span data-ttu-id="332d7-2755">Несмотря на то что <xref:System.Windows.ContentElement.StylusLeave> отслеживает, когда перо покидает границы элемента, это событие больше о том, что буквально <xref:System.Windows.ContentElement.IsStylusOver%2A> значение свойства было изменено с `true` для `false` для этого элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2755">Although <xref:System.Windows.ContentElement.StylusLeave> tracks when the stylus leaves the bounds of an element, this event more literally reports that the <xref:System.Windows.ContentElement.IsStylusOver%2A> property value has changed from `true` to `false` on this element.</span></span>  
  
 <span data-ttu-id="332d7-2756">Это событие создается псевдоним для <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.StylusLeave> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2756">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusLeave> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2757">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.StylusLeave> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2757">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusLeave> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusLeave?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="332d7-2758">Сенсорный ввод, мышь и ввод от пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="332d7-2758">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="332d7-2759">Дополнительные сведения см. в разделе [фокусе](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-2759">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2760">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2760">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2761">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2761">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusLeaveEvent>|  
|<span data-ttu-id="332d7-2762">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2762">Routing strategy</span></span>|<span data-ttu-id="332d7-2763">Direct</span><span class="sxs-lookup"><span data-stu-id="332d7-2763">Direct</span></span>|  
|<span data-ttu-id="332d7-2764">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2764">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="332d7-2765">Переопределить <xref:System.Windows.ContentElement.OnStylusLeave%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2765">Override <xref:System.Windows.ContentElement.OnStylusLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusLeaveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2766">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.StylusLeave" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2766">Identifies the <see cref="E:System.Windows.ContentElement.StylusLeave" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2767">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2767">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2768">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2768">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2769">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2769">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2770">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2770">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2771">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2771">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMove">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusMove As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusMove;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusMove</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2772">Происходит при движении пера над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2772">Occurs when the stylus moves over this element.</span>
          </span>
          <span data-ttu-id="332d7-2773">Для вызова этого события перо должно перемещаться по дигитайзеру.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2773">The stylus must move while on the digitizer to raise this event.</span>
          </span>
          <span data-ttu-id="332d7-2774">В противном случае вместо данного события инициируется <see cref="E:System.Windows.ContentElement.StylusInAirMove" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2774">Otherwise, <see cref="E:System.Windows.ContentElement.StylusInAirMove" /> is raised instead.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2775">Это событие создается псевдоним для <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.StylusMove> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2775">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusMove> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2776">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.StylusMove> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2776">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusMove> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusMove?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="332d7-2777">Сенсорный ввод, мышь и ввод от пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="332d7-2777">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="332d7-2778">Дополнительные сведения см. в разделе [фокусе](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-2778">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2779">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2779">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2780">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2780">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusMoveEvent>|  
|<span data-ttu-id="332d7-2781">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2781">Routing strategy</span></span>|<span data-ttu-id="332d7-2782">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-2782">Bubbling</span></span>|  
|<span data-ttu-id="332d7-2783">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2783">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="332d7-2784">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewStylusMove>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2784">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusMove>.</span></span>  
  
-   <span data-ttu-id="332d7-2785">Переопределить <xref:System.Windows.ContentElement.OnStylusMove%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2785">Override <xref:System.Windows.ContentElement.OnStylusMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2786">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.StylusMove" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2786">Identifies the <see cref="E:System.Windows.ContentElement.StylusMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2787">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2787">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2788">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2788">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2789">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2789">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2790">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2790">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2791">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2791">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRange">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusOutOfRange;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusOutOfRange" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusOutOfRange" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusOutOfRange As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusOutOfRange;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusOutOfRange</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2792">Возникает, когда расстояние между пером и дигитайзером слишком велико для обнаружения пера при условии, что перо находится над этим элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2792">Occurs when the stylus is too far from the digitizer to be detected, while over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2793">Это событие создается псевдоним для <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.StylusOutOfRange> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2793">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusOutOfRange> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2794">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.StylusOutOfRange> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2794">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusOutOfRange> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusOutOfRange?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="332d7-2795">Сенсорный ввод, мышь и ввод от пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="332d7-2795">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="332d7-2796">Дополнительные сведения см. в разделе [фокусе](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-2796">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusOutOfRange"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2797">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2797">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2798">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2798">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusOutOfRangeEvent>|  
|<span data-ttu-id="332d7-2799">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2799">Routing strategy</span></span>|<span data-ttu-id="332d7-2800">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-2800">Bubbling</span></span>|  
|<span data-ttu-id="332d7-2801">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2801">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="332d7-2802">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewStylusOutOfRange>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2802">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusOutOfRange>.</span></span>  
  
-   <span data-ttu-id="332d7-2803">Переопределить <xref:System.Windows.ContentElement.OnStylusOutOfRange%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2803">Override <xref:System.Windows.ContentElement.OnStylusOutOfRange%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusOutOfRangeEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusOutOfRangeEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusOutOfRangeEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusOutOfRangeEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusOutOfRangeEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusOutOfRangeEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2804">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.StylusOutOfRange" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2804">Identifies the <see cref="E:System.Windows.ContentElement.StylusOutOfRange" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2805">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2805">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2806">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2806">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2807">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2807">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2808">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2808">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2809">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2809">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGesture">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusSystemGestureEventHandler StylusSystemGesture" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusSystemGesture" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusSystemGesture As StylusSystemGestureEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusSystemGestureEventHandler ^ StylusSystemGesture;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusSystemGesture</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusSystemGestureEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2810">Происходит при использовании пользователем одного из жестов пером.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2810">Occurs when a user performs one of several stylus gestures.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2811">Дополнительные сведения о жестах пера см. в разделе <xref:System.Windows.Input.SystemGesture>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2811">For more information about stylus gestures, see <xref:System.Windows.Input.SystemGesture>.</span></span>  
  
 <span data-ttu-id="332d7-2812">Это событие создается псевдоним для <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.StylusSystemGesture> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2812">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusSystemGesture> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2813">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.StylusSystemGesture> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2813">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusSystemGesture> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusSystemGesture?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="332d7-2814">Сенсорный ввод, мышь и ввод от пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="332d7-2814">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="332d7-2815">Дополнительные сведения см. в разделе [фокусе](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-2815">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusSystemGesture"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2816">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2816">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2817">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2817">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusSystemGestureEvent>|  
|<span data-ttu-id="332d7-2818">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2818">Routing strategy</span></span>|<span data-ttu-id="332d7-2819">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-2819">Bubbling</span></span>|  
|<span data-ttu-id="332d7-2820">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2820">Delegate</span></span>|<xref:System.Windows.Input.StylusSystemGestureEventHandler>|  
  
-   <span data-ttu-id="332d7-2821">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewStylusSystemGesture>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2821">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusSystemGesture>.</span></span>  
  
-   <span data-ttu-id="332d7-2822">Переопределить <xref:System.Windows.ContentElement.OnStylusSystemGesture%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2822">Override <xref:System.Windows.ContentElement.OnStylusSystemGesture%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusSystemGestureEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusSystemGestureEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusSystemGestureEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusSystemGestureEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusSystemGestureEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusSystemGestureEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2823">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.StylusSystemGesture" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2823">Identifies the <see cref="E:System.Windows.ContentElement.StylusSystemGesture" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2824">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2824">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2825">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2825">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2826">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2826">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2827">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2827">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2828">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2828">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUp">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.StylusEventHandler StylusUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.StylusEventHandler StylusUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.StylusUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StylusUp As StylusEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::StylusEventHandler ^ StylusUp;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.StylusUp</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.StylusEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2829">Происходит, когда пользователь отрывает перо от поверхности дигитайзера в тот момент, когда оно находится над этим элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2829">Occurs when the user raises the stylus off the digitizer while it is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2830">Это событие создается псевдоним для <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.StylusUp> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2830">This event creates an alias for the <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.StylusUp> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2831">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.StylusUp> событий присоединяются к базовому объекту <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2831">Event handlers that are attached to the <xref:System.Windows.ContentElement.StylusUp> event are attached to the underlying <xref:System.Windows.Input.Stylus.StylusUp?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
 <span data-ttu-id="332d7-2832">Сенсорный ввод, мышь и ввод от пера существует определенная связь.</span><span class="sxs-lookup"><span data-stu-id="332d7-2832">Touch, mouse, and stylus input exist in a particular relationship.</span></span> <span data-ttu-id="332d7-2833">Дополнительные сведения см. в разделе [фокусе](~/docs/framework/wpf/advanced/input-overview.md).</span><span class="sxs-lookup"><span data-stu-id="332d7-2833">For more information, see [Input Overview](~/docs/framework/wpf/advanced/input-overview.md).</span></span>  
  
<a name="routedEventInfo_StylusUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2834">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2834">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2835">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2835">Identifier field</span></span>|<xref:System.Windows.ContentElement.StylusUpEvent>|  
|<span data-ttu-id="332d7-2836">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2836">Routing strategy</span></span>|<span data-ttu-id="332d7-2837">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-2837">Bubbling</span></span>|  
|<span data-ttu-id="332d7-2838">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2838">Delegate</span></span>|<xref:System.Windows.Input.StylusEventHandler>|  
  
-   <span data-ttu-id="332d7-2839">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewStylusUp>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2839">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewStylusUp>.</span></span>  
  
-   <span data-ttu-id="332d7-2840">Переопределить <xref:System.Windows.ContentElement.OnStylusUp%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2840">Override <xref:System.Windows.ContentElement.OnStylusUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StylusUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent StylusUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent StylusUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.StylusUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StylusUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ StylusUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2841">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.StylusUp" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2841">Identifies the <see cref="E:System.Windows.ContentElement.StylusUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2842">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2842">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2843">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2843">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2844">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2844">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2845">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2845">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2846">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2846">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInput">
      <MemberSignature Language="C#" Value="public event System.Windows.Input.TextCompositionEventHandler TextInput;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Input.TextCompositionEventHandler TextInput" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TextInput" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TextInput As TextCompositionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Windows::Input::TextCompositionEventHandler ^ TextInput;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Windows.IInputElement.TextInput</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.TextCompositionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2847">Происходит при получении этим элементом текста аппаратно-независимым способом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2847">Occurs when this element gets text in a device-independent manner.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="332d7-2848">Это событие уже может быть помечено как обработанное внутренними реализациями составных элементов управления.</span><span class="sxs-lookup"><span data-stu-id="332d7-2848">This event might already be marked as handled by the internal implementations of composited controls.</span></span> <span data-ttu-id="332d7-2849">См. примечания ниже.</span><span class="sxs-lookup"><span data-stu-id="332d7-2849">See Remark below.</span></span>  
  
 <span data-ttu-id="332d7-2850"><xref:System.Windows.ContentElement.TextInput> Событие уже может быть помечено как обработанное внутренними реализациями составных элементов управления.</span><span class="sxs-lookup"><span data-stu-id="332d7-2850">The <xref:System.Windows.ContentElement.TextInput> event may already be marked as handled by the internal implementations of composited controls.</span></span> <span data-ttu-id="332d7-2851">Например <xref:System.Windows.Controls.TextBox> является составной элемент управления где <xref:System.Windows.ContentElement.TextInput> событие уже помечено как обработанное; внутри элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2851">For example, a <xref:System.Windows.Controls.TextBox> is a composited control where the <xref:System.Windows.ContentElement.TextInput> event is already marked as handled; within its compositing.</span></span> <span data-ttu-id="332d7-2852">Элементы управления этого, так как он должен определять некоторые виды ввода, например клавиши со стрелками, как имеющие специальное значение для этого элемента управления.</span><span class="sxs-lookup"><span data-stu-id="332d7-2852">Controls do this because the control needs to interpret some types of input, such as arrow keys, as having special meaning to that control.</span></span> <span data-ttu-id="332d7-2853">Если вы используете <xref:System.Windows.ContentElement.PreviewTextInput> как события, где присоединение обработчиков для ввода текста, может появиться лучшие результаты.</span><span class="sxs-lookup"><span data-stu-id="332d7-2853">If you use <xref:System.Windows.ContentElement.PreviewTextInput> as the event where you attach handlers for text input, you may receive better results.</span></span> <span data-ttu-id="332d7-2854">Этот прием позволяет обойти большинство случаях данное событие уже помечено как обработанное и предотвращает получение событий на маршруте события обработчиком композиции элемента управления.</span><span class="sxs-lookup"><span data-stu-id="332d7-2854">This technique circumvents most cases where control composition has already marked this event as handled and prevents your handler from receiving the event along the event route.</span></span>  
  
 <span data-ttu-id="332d7-2855"><xref:System.Windows.ContentElement.TextInput> Событий позволяет компонента или приложения для прослушивания ввода текста в аппаратно независимым способом.</span><span class="sxs-lookup"><span data-stu-id="332d7-2855">The <xref:System.Windows.ContentElement.TextInput> event allows a component or application to listen for text input in a device-independent manner.</span></span> <span data-ttu-id="332d7-2856">Клавиатура является основным средством для <xref:System.Windows.ContentElement.TextInput>, но также может вызывать речи, рукописного ввода и других устройств ввода <xref:System.Windows.ContentElement.TextInput>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2856">The keyboard is the primary means of <xref:System.Windows.ContentElement.TextInput>, but speech, handwriting, and other input devices can also raise <xref:System.Windows.ContentElement.TextInput>.</span></span>  
  
 <span data-ttu-id="332d7-2857">Из-за сочетания клавиш — клавиатуры по умолчанию или редакторам методов ввода, несколько событий клавиш могут сгенерировать только одно событие ввода текста.</span><span class="sxs-lookup"><span data-stu-id="332d7-2857">Because of key combinations—either in default keyboards or through input method editors—multiple key events might raise just one text input event.</span></span>  
  
 <span data-ttu-id="332d7-2858">Это событие создается псевдоним для <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> вложенное событие для этого класса, чтобы <xref:System.Windows.ContentElement.TextInput> входит в состав класса список членов, когда <xref:System.Windows.ContentElement> наследуется от базового элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2858">This event creates an alias for the <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> attached event for this class, so that <xref:System.Windows.ContentElement.TextInput> is part of the class members list when <xref:System.Windows.ContentElement> is inherited as a base element.</span></span> <span data-ttu-id="332d7-2859">Обработчики событий, присоединенные к <xref:System.Windows.ContentElement.TextInput> событий присоединяются к базовому объекту <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> вложенное событие и получить тот же экземпляр данных события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2859">Event handlers that are attached to the <xref:System.Windows.ContentElement.TextInput> event are attached to the underlying <xref:System.Windows.Input.TextCompositionManager.TextInput?displayProperty=nameWithType> attached event and receive the same event data instance.</span></span>  
  
<a name="routedEventInfo_TextInput"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2860">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2860">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2861">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2861">Identifier field</span></span>|<xref:System.Windows.ContentElement.TextInputEvent>|  
|<span data-ttu-id="332d7-2862">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2862">Routing strategy</span></span>|<span data-ttu-id="332d7-2863">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-2863">Bubbling</span></span>|  
|<span data-ttu-id="332d7-2864">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2864">Delegate</span></span>|<xref:System.Windows.Input.TextCompositionEventHandler>|  
  
-   <span data-ttu-id="332d7-2865">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewTextInput>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2865">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTextInput>.</span></span>  
  
-   <span data-ttu-id="332d7-2866">Переопределить <xref:System.Windows.ContentElement.OnTextInput%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2866">Override <xref:System.Windows.ContentElement.OnTextInput%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TextInputEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TextInputEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TextInputEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TextInputEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TextInputEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TextInputEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2867">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.TextInput" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2867">Identifies the <see cref="E:System.Windows.ContentElement.TextInput" /> routed event.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2868">Идентификаторы перенаправленных событий создаются при их регистрации.</span><span class="sxs-lookup"><span data-stu-id="332d7-2868">Routed event identifiers are created when routed events are registered.</span></span> <span data-ttu-id="332d7-2869">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</span><span class="sxs-lookup"><span data-stu-id="332d7-2869">These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</span></span> <span data-ttu-id="332d7-2870">Эти идентификаторы можно использовать для добавления обработчиков классов.</span><span class="sxs-lookup"><span data-stu-id="332d7-2870">You can use these identifiers to add class handlers.</span></span>  
  
 <span data-ttu-id="332d7-2871">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2871">For more information about registering routed events, see <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>.</span></span> <span data-ttu-id="332d7-2872">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2872">For more information about using routed event identifiers to add class handlers, see <xref:System.Windows.EventManager.RegisterClassHandler%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchDown">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchDown;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchDown" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchDown" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchDown As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchDown;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2873">Происходит при касании пальцем экрана, когда палец находится над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2873">Occurs when a finger touches the screen while the finger is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2874">По умолчанию <xref:System.Windows.ContentElement.PreviewTouchDown> и <xref:System.Windows.ContentElement.TouchDown> событий не выполняется до пальцем экрана касается и перемещает.</span><span class="sxs-lookup"><span data-stu-id="332d7-2874">By default, the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events do not occur until a finger touches the screen and moves.</span></span> <span data-ttu-id="332d7-2875">Нажав пальцем на экране и удерживая без его перемещения вызывает нажать клавиши и удерживайте поведение <xref:System.Windows.Input.Stylus>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2875">Pressing a finger on the screen and holding it without moving it causes the press and hold behavior of a <xref:System.Windows.Input.Stylus>.</span></span> <span data-ttu-id="332d7-2876">Поведение нажатия и удерживания соответствует щелчку правой кнопкой мыши.</span><span class="sxs-lookup"><span data-stu-id="332d7-2876">The press and hold behavior is equivalent to a mouse right-click.</span></span>  
  
 <span data-ttu-id="332d7-2877">Чтобы вызвать <xref:System.Windows.ContentElement.PreviewTouchDown> и <xref:System.Windows.ContentElement.TouchDown> события к как можно скорее касании пальцем экрана, задать <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> присоединенного свойства для `false` для этого элемента.</span><span class="sxs-lookup"><span data-stu-id="332d7-2877">To cause the <xref:System.Windows.ContentElement.PreviewTouchDown> and <xref:System.Windows.ContentElement.TouchDown> events to occur as soon as a finger touches the screen, set the <xref:System.Windows.Input.Stylus.IsPressAndHoldEnabled%2A?displayProperty=nameWithType> attached property to `false` for this element.</span></span>  
  
<a name="routedEventInfo_TouchDown"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2878">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2878">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2879">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2879">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchDownEvent>|  
|<span data-ttu-id="332d7-2880">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2880">Routing strategy</span></span>|<span data-ttu-id="332d7-2881">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-2881">Bubbling</span></span>|  
|<span data-ttu-id="332d7-2882">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2882">Delegate</span></span>|<span data-ttu-id="332d7-2883"><xref:System.EventHandler%601> имеет тип данных <xref:System.Windows.Input.TouchEventArgs>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2883"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="332d7-2884">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewTouchDown>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2884">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTouchDown>.</span></span>  
  
-   <span data-ttu-id="332d7-2885">Переопределить <xref:System.Windows.ContentElement.OnTouchDown%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2885">Override <xref:System.Windows.ContentElement.OnTouchDown%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Input.Stylus.IsPressAndHoldEnabled" />
        <altmember cref="M:System.Windows.Input.Stylus.GetIsPressAndHoldEnabled(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Input.Stylus.SetIsPressAndHoldEnabled(System.Windows.DependencyObject,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="TouchDownEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchDownEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchDownEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchDownEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchDownEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchDownEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2886">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.TouchDown" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2886">Identifies the <see cref="E:System.Windows.ContentElement.TouchDown" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnter">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchEnter;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchEnter" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchEnter" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchEnter As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchEnter;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2887">Происходит при перемещении касания внутрь данного элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2887">Occurs when a touch moves from outside to inside the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="332d7-2888">Это событие всегда возникает, независимо от захвата сенсорного устройства элементом пользовательского интерфейса.</span><span class="sxs-lookup"><span data-stu-id="332d7-2888">This event is always raised, whether or not the touch device is captured to this UI element.</span></span>  
  
<a name="routedEventInfo_TouchEnter"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2889">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2889">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2890">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2890">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchEnterEvent>|  
|<span data-ttu-id="332d7-2891">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2891">Routing strategy</span></span>|<span data-ttu-id="332d7-2892">Direct</span><span class="sxs-lookup"><span data-stu-id="332d7-2892">Direct</span></span>|  
|<span data-ttu-id="332d7-2893">Делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2893">Delegate</span></span>|<span data-ttu-id="332d7-2894"><xref:System.EventHandler%601> имеет тип данных <xref:System.Windows.Input.TouchEventArgs>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2894"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="332d7-2895">Переопределить <xref:System.Windows.ContentElement.OnTouchEnter%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2895">Override <xref:System.Windows.ContentElement.OnTouchEnter%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchEnterEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchEnterEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchEnterEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchEnterEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchEnterEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchEnterEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2896">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.TouchEnter" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2896">Identifies the <see cref="E:System.Windows.ContentElement.TouchEnter" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCaptured">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCaptured { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCaptured" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesCaptured" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCaptured As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCaptured { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2897">Получает все сенсорные устройства, переданные в данный элемент.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2897">Gets all touch devices that are captured to this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="332d7-2898">Перечисление объектов <see cref="T:System.Windows.Input.TouchDevice" />, полученных этим элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2898">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are captured to this element.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesCapturedWithin">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesCapturedWithin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesCapturedWithin" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesCapturedWithin As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesCapturedWithin { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2899">Получает все сенсорные устройства, переданные в этот элемент или какой-либо из его дочерних элементов в визуальном дереве.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2899">Gets all touch devices that are captured to this element or any child elements in its visual tree.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="332d7-2900">Перечисление объектов <see cref="T:System.Windows.Input.TouchDevice" />, полученных этим элементом или каким-либо из его дочерних элементов в визуальном дереве.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2900">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are captured to this element or any child elements in its visual tree.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesDirectlyOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesDirectlyOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesDirectlyOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesDirectlyOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesDirectlyOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2901">Получает все сенсорные устройства, находящиеся над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2901">Gets all touch devices that are over this element.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="332d7-2902">Перечисление объектов <see cref="T:System.Windows.Input.TouchDevice" />, находящихся над этим элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2902">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are over this element.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchesOver">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt; TouchesOver { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Windows.Input.TouchDevice&gt; TouchesOver" />
      <MemberSignature Language="DocId" Value="P:System.Windows.ContentElement.TouchesOver" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TouchesOver As IEnumerable(Of TouchDevice)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ TouchesOver { System::Collections::Generic::IEnumerable&lt;System::Windows::Input::TouchDevice ^&gt; ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Windows.Input.TouchDevice&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2903">Получает все сенсорные устройства, находящиеся над этим элементом или каким-либо из его дочерних элементов в визуальном дереве.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2903">Gets all touch devices that are over this element or any child elements in its visual tree.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="332d7-2904">Перечисление объектов <see cref="T:System.Windows.Input.TouchDevice" />, которые находятся над этим элементом или каким-либо из его дочерних элементов в визуальном дереве.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2904">An enumeration of <see cref="T:System.Windows.Input.TouchDevice" /> objects that are over this element or any child elements in its visual tree.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeave">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchLeave;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchLeave" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchLeave" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchLeave As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchLeave;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2905">Происходит при перемещении касания за границы элемента.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2905">Occurs when a touch moves from inside to outside the bounds of this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchLeave"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2906">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2906">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2907">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2907">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchLeaveEvent>|  
|<span data-ttu-id="332d7-2908">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2908">Routing strategy</span></span>|<span data-ttu-id="332d7-2909">Direct</span><span class="sxs-lookup"><span data-stu-id="332d7-2909">Direct</span></span>|  
|<span data-ttu-id="332d7-2910">Делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2910">Delegate</span></span>|<span data-ttu-id="332d7-2911"><xref:System.EventHandler%601> имеет тип данных <xref:System.Windows.Input.TouchEventArgs>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2911"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="332d7-2912">Переопределить <xref:System.Windows.ContentElement.OnTouchLeave%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2912">Override <xref:System.Windows.ContentElement.OnTouchLeave%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchLeaveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchLeaveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchLeaveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchLeaveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchLeaveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchLeaveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2913">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.TouchLeave" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2913">Identifies the <see cref="E:System.Windows.ContentElement.TouchLeave" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMove">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchMove;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchMove" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchMove" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchMove As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchMove;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2914">Возникает при перемещении пальца по экрану при условии, если палец находится над данным элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2914">Occurs when a finger moves on the screen while the finger is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchMove"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2915">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2915">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2916">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2916">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchMoveEvent>|  
|<span data-ttu-id="332d7-2917">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2917">Routing strategy</span></span>|<span data-ttu-id="332d7-2918">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-2918">Bubbling</span></span>|  
|<span data-ttu-id="332d7-2919">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2919">Delegate</span></span>|<span data-ttu-id="332d7-2920"><xref:System.EventHandler%601> имеет тип данных <xref:System.Windows.Input.TouchEventArgs>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2920"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="332d7-2921">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewTouchMove>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2921">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTouchMove>.</span></span>  
  
-   <span data-ttu-id="332d7-2922">Переопределить <xref:System.Windows.ContentElement.OnTouchMove%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2922">Override <xref:System.Windows.ContentElement.OnTouchMove%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchMoveEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchMoveEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchMoveEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchMoveEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchMoveEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchMoveEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2923">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.TouchMove" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2923">Identifies the <see cref="E:System.Windows.ContentElement.TouchMove" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUp">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Input.TouchEventArgs&gt; TouchUp;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Input.TouchEventArgs&gt; TouchUp" />
      <MemberSignature Language="DocId" Value="E:System.Windows.ContentElement.TouchUp" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TouchUp As EventHandler(Of TouchEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Input::TouchEventArgs ^&gt; ^ TouchUp;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Input.TouchEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2924">Возникает, когда палец отрывается от экрана при условии, что палец находится над этим элементом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2924">Occurs when a finger is raised off of the screen while the finger is over this element.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
<a name="routedEventInfo_TouchUp"></a>   
## <a name="routed-event-information"></a><span data-ttu-id="332d7-2925">Сведения о маршрутизируемом событии</span><span class="sxs-lookup"><span data-stu-id="332d7-2925">Routed Event Information</span></span>  
  
|||  
|-|-|  
|<span data-ttu-id="332d7-2926">Поле идентификатора</span><span class="sxs-lookup"><span data-stu-id="332d7-2926">Identifier field</span></span>|<xref:System.Windows.ContentElement.TouchUpEvent>|  
|<span data-ttu-id="332d7-2927">Стратегия маршрутизации</span><span class="sxs-lookup"><span data-stu-id="332d7-2927">Routing strategy</span></span>|<span data-ttu-id="332d7-2928">Вверх</span><span class="sxs-lookup"><span data-stu-id="332d7-2928">Bubbling</span></span>|  
|<span data-ttu-id="332d7-2929">делегат</span><span class="sxs-lookup"><span data-stu-id="332d7-2929">Delegate</span></span>|<span data-ttu-id="332d7-2930"><xref:System.EventHandler%601> имеет тип данных <xref:System.Windows.Input.TouchEventArgs>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2930"><xref:System.EventHandler%601> of type <xref:System.Windows.Input.TouchEventArgs>.</span></span>|  
  
-   <span data-ttu-id="332d7-2931">Соответствующее событие нисходящей маршрутизации является <xref:System.Windows.ContentElement.PreviewTouchUp>.</span><span class="sxs-lookup"><span data-stu-id="332d7-2931">The corresponding tunneling event is <xref:System.Windows.ContentElement.PreviewTouchUp>.</span></span>  
  
-   <span data-ttu-id="332d7-2932">Переопределить <xref:System.Windows.ContentElement.OnTouchUp%2A> реализации класса обработчик данного события в производных классах.</span><span class="sxs-lookup"><span data-stu-id="332d7-2932">Override <xref:System.Windows.ContentElement.OnTouchUp%2A> to implement class handling for this event in derived classes.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TouchUpEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent TouchUpEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent TouchUpEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.ContentElement.TouchUpEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TouchUpEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ TouchUpEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="332d7-2933">Идентифицирует направленное событие <see cref="E:System.Windows.ContentElement.TouchUp" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="332d7-2933">Identifies the <see cref="E:System.Windows.ContentElement.TouchUp" /> routed event.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>