<Type Name="DependencyObject" FullName="System.Windows.DependencyObject">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="93e067f8bf97d79f7e4525a57db08a4a8d5109c2" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30680318" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class DependencyObject : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit DependencyObject extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyObject" />
  <TypeSignature Language="VB.NET" Value="Public Class DependencyObject&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyObject : System::Windows::Threading::DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeDescriptionProvider(typeof(MS.Internal.ComponentModel.DependencyObjectProvider))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.NameScopeProperty("NameScope", typeof(System.Windows.NameScope))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет объект, участвующий в системе свойств зависимостей.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyObject> Класса включает [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] служб системы свойств на многие производные классы.  
  
 Основной функцией системы свойств является вычисление значений свойств и Системное уведомление о значениях, которые были изменены. Является другим классом ключа, который участвует в системе свойств <xref:System.Windows.DependencyProperty>. <xref:System.Windows.DependencyProperty> включает регистрацию свойства зависимостей в системе свойств и обеспечивает идентификации и сведения о каждом свойстве зависимостей, а <xref:System.Windows.DependencyObject> как базовый класс позволяет объектам использовать свойства зависимостей.  
  
 <xref:System.Windows.DependencyObject> службы и характеристики включают следующее:  
  
-   Поддержка размещения свойств зависимостей. Зарегистрируйте свойство зависимостей, вызвав <xref:System.Windows.DependencyProperty.Register%2A> метод и сохранения возвращаемого значения метода как открытое статическое поле в классе.  
  
-   Поддержка размещения вложенных свойств. Вложенное свойство зарегистрировать вызвав <xref:System.Windows.DependencyProperty.RegisterAttached%2A> метод и хранение возвращаемого значения метода в виде открытого статического поля только для чтения в классе. (Также есть дополнительные требования к членам; Обратите внимание, что это значение представляет [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] реализации для вложенных свойств. Дополнительные сведения см. в разделе [зависимостей](~/docs/framework/wpf/advanced/attached-properties-overview.md).) Вложенное свойство затем может устанавливаться на любой класс, производный от <xref:System.Windows.DependencyObject>.  
  
-   Get, set и очистить служебные методы для значения всех свойств зависимостей, которые существуют на <xref:System.Windows.DependencyObject>.  
  
-   Метаданные, приведение поддержка значения, изменения свойств уведомления и обратные вызовы переопределения для свойства зависимостей или присоединенного свойства. Кроме того <xref:System.Windows.DependencyObject> класс облегчает-владельцев метаданные свойства зависимостей.  
  
-   Общий базовый класс для классов, производных от <xref:System.Windows.ContentElement>, <xref:System.Windows.Freezable>, или <xref:System.Windows.Media.Visual>. (<xref:System.Windows.UIElement>, другой класс базового элемента содержит иерархию классов, которая включает <xref:System.Windows.Media.Visual>.)  
  
   
  
## Examples  
 Следующий пример является производным от <xref:System.Windows.DependencyObject> создать новый абстрактный класс. Затем класс регистрирует присоединенное свойство и включает в себя элементы поддержки для этого вложенного свойства.  
  
 [!code-csharp[WPFAquariumSln#DOMain](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#domain)]
 [!code-vb[WPFAquariumSln#DOMain](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#domain)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public DependencyObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; DependencyObject();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ClearValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Очищает локальное значение свойства.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Очищаемое свойство зависимости, указанное объектной ссылкой <see cref="T:System.Windows.DependencyProperty" />.</param>
        <summary>Очищает локальное значение свойства. Очищаемое свойство задается идентификатором <see cref="T:System.Windows.DependencyProperty" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Очистка значения свойства путем вызова <xref:System.Windows.DependencyObject.ClearValue%2A> не дает обязательно свойства зависимостей значение по умолчанию, которая указана в метаданные свойства зависимостей. Очистка свойства только очистку любого локального значения были применены. Дополнительные сведения см. в разделе [Приоритет значений свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
   
  
## Examples  
 Следующий пример выполняет итерацию всех свойств, которые заданы локальные значения для объекта, затем вызывает метод <xref:System.Windows.DependencyObject.ClearValue%2A> удалить значения каждого из таких свойств.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Пытается вызвать метод <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> для запечатанного <see cref="T:System.Windows.DependencyObject" />.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="P:System.Windows.DependencyObject.IsSealed" />
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="ClearValue">
      <MemberSignature Language="C#" Value="public void ClearValue (System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ClearValue(class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearValue (key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ClearValue(System::Windows::DependencyPropertyKey ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="key">Ключ очищаемого свойства зависимостей.</param>
        <summary>Очищает локальное значение доступного только для чтения свойства. Очищаемое свойство задается объектом <see cref="T:System.Windows.DependencyPropertyKey" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Windows.DependencyPropertyKey> идентифицирует свойство зависимостей только для чтения для операций системы свойств. Классы, определяющие свойства зависимости только для чтения, не должны предоставлять этот ключ в открытый доступ. Открытый ключ будет обеспечивают передачу открытого кода, инвертировано символов только для чтения свойства, если такие методы, как <xref:System.Windows.DependencyObject.ClearValue%2A> или <xref:System.Windows.DependencyObject.SetValue%2A> можно вызвать вне класса или сборки, ссылающиеся на ключ.  
  
 Очистка значения свойства путем вызова <xref:System.Windows.DependencyObject.ClearValue%2A> не дает обязательно свойства зависимостей значение по умолчанию, которая указана в метаданные свойства зависимостей. Очистка значения только очистку любого локального значения были применены. Дополнительные сведения см. в разделе [Приоритет значений свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Пытается вызвать метод <see cref="M:System.Windows.DependencyObject.ClearValue(System.Windows.DependencyProperty)" /> для запечатанного <see cref="T:System.Windows.DependencyObject" />.</exception>
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
        <altmember cref="T:System.Windows.DependencyPropertyKey" />
      </Docs>
    </Member>
    <Member MemberName="CoerceValue">
      <MemberSignature Language="C#" Value="public void CoerceValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CoerceValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CoerceValue (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CoerceValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор приводимого свойства зависимостей.</param>
        <summary>Приводит значение указанного свойства зависимостей. Это осуществляется путем вызова какой-либо функции <see cref="T:System.Windows.CoerceValueCallback" />, указанной в метаданных свойства зависимостей, которое существует в вызывающем объекте <see cref="T:System.Windows.DependencyObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Помимо явно, вызываемому посредством вызова метода <xref:System.Windows.DependencyObject.CoerceValue%2A>, <xref:System.Windows.CoerceValueCallback> зависимости свойства также вызывается внутренне всякий раз, когда значение свойства зависимостей повторно вычисляется по [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] системы свойств.  
  
 При вызове <xref:System.Windows.DependencyObject.CoerceValue%2A> метода, в конечном итоге вызываются принудительного обратного вызова значения для свойства, которое можно указать. Обычно будет вызывать <xref:System.Windows.DependencyObject.CoerceValue%2A> только в том случае, если известно, что существует принудительного обратного вызова значения и если вы знаете критерии обратного вызова для приведения.  
  
 Наиболее распространенным сценарием для вызова <xref:System.Windows.DependencyObject.CoerceValue%2A> находится в пределах класса или свойства обработки изменений обратные вызовы из связанных свойств, которые влияют друг друга значения в виде зависимые. Дополнительные сведения см. в разделе [Проверка и обратные вызовы свойства зависимостей](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Windows.DependencyObject.CoerceValue%2A> в <xref:System.Windows.PropertyChangedCallback> реализацию, которая используется в качестве <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> для свойств различных зависимостей в том же классе. Это распространенный подход для внедрения истинных зависимостей значений между свойствами зависимости.  
  
 [!code-csharp[DPCallbackOverride#OnPCCurrent](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#onpccurrent)]
 [!code-vb[DPCallbackOverride#OnPCCurrent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#onpccurrent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Указанный параметр <paramref name="dp" /> или его значение недопустимы, или их не существует.</exception>
        <altmember cref="T:System.Windows.CoerceValueCallback" />
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="DependencyObjectType">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObjectType DependencyObjectType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObjectType DependencyObjectType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.DependencyObjectType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyObjectType As DependencyObjectType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObjectType ^ DependencyObjectType { System::Windows::DependencyObjectType ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObjectType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает <see cref="T:System.Windows.DependencyObjectType" />, который создает обертку для типа [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] данного экземпляра.</summary>
        <value>
          <see cref="T:System.Windows.DependencyObjectType" />, который создает обертку для типа [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] данного экземпляра.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство полезно, если объект, возвращаемый из метода имеет тип возвращаемого значения <xref:System.Windows.DependencyObject> и требуется для выполнения операций системы свойств определенного на нем в зависимости от его типа. Например эффективнее вызывать <xref:System.Windows.DependencyProperty.GetMetadata%28System.Windows.DependencyObjectType%29> с помощью <xref:System.Windows.DependencyObjectType> вместо [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] типа. <xref:System.Windows.DependencyObjectType> обеспечивает более быстрый поиск.  
  
   
  
## Examples  
 В следующем примере псевдокода `MySubClass` можно предвидеть, что дополнительные производные классы могут изменить значение по умолчанию `MyCustom` свойства зависимостей. Класс реализует конструктор по умолчанию, можно определить фактическое производного класса, используя преимущества полиморфизма <xref:System.Windows.DependencyObjectType> значение всякий раз, когда этот конструктор используется в качестве средства создания экземпляров производного класса.  
  
 `public DOClass() : base()`  
  
 `{`  
  
 `__customPropertyCache = (CustomDP)`  
  
 `CustomDPProperty.GetMetadata(DependencyObjectType).DefaultValue;`  
  
 `}`  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
        <altmember cref="T:System.Windows.DependencyObjectType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override sealed bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <see cref="T:System.Windows.DependencyObject" /> для сравнения с текущим экземпляром.</param>
        <summary>Определяет, является ли указанный <see cref="T:System.Windows.DependencyObject" /> эквивалентом текущего <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>
          <see langword="true" />, если два экземпляра одинаковы; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данная реализация учитывает только равенство ссылок и не пытается вычислить равенство свойств.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.DependencyObject" /> переопределяет и затем запечатывает два basic <see cref="T:System.Object" /> методы: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> и <see cref="M:System.Windows.DependencyObject.GetHashCode" />. Вызов переопределения <see cref="T:System.Object" /> реализаций, что приводит к поведению равенства объектов. Эти намеренных переопределений предназначена для предотвращения попыток для определения равенства значений для производных классов <see cref="T:System.Windows.DependencyObject" />. Значение равенства для <see cref="T:System.Windows.DependencyObject" /> никогда не будут точными из-за исходному направлению свойство изменение значение возможности <see cref="T:System.Windows.DependencyObject" /> и его свойств зависимостей. Сюда входят основные [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] функции, такие как привязка данных и [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] системы свойств.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override sealed int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код для данного объекта <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Подписанный хэш-код в виде 32-разрядного целого числа.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.DependencyObject" /> переопределяет и затем запечатывает два <see cref="T:System.Object" /> методы: <see cref="M:System.Windows.DependencyObject.Equals(System.Object)" /> и <see cref="M:System.Windows.DependencyObject.GetHashCode" />. Вызов переопределения <see cref="T:System.Object" /> реализаций, что приводит к поведению равенства объектов. Эти намеренных переопределений предназначена для предотвращения попыток для определения равенства значений для производных классов <see cref="T:System.Windows.DependencyObject" />. Значение равенства для <see cref="T:System.Windows.DependencyObject" /> никогда не будут точными из-за исходному направлению свойство изменение значение возможности <see cref="T:System.Windows.DependencyObject" /> и его свойств зависимостей. Сюда входят основные [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] функции, такие как привязка данных и [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] системы свойств.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetLocalValueEnumerator">
      <MemberSignature Language="C#" Value="public System.Windows.LocalValueEnumerator GetLocalValueEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.LocalValueEnumerator GetLocalValueEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLocalValueEnumerator () As LocalValueEnumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::LocalValueEnumerator GetLocalValueEnumerator();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.LocalValueEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает специализированный перечислитель для определения свойств зависимостей, которые локально установили значения для данного <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Специализированный перечислитель локальных значений.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект *локальное значение* имеет любое значение свойства зависимостей, заданное <xref:System.Windows.DependencyObject.SetValue%2A>, в отличие от других аспектов системы свойств.  
  
 <xref:System.Windows.LocalValueEnumerator> Получается вызовом <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> можно использовать для перечисления свойств, имеющих локально заданное значение в <xref:System.Windows.DependencyObject> экземпляра. Каждый из таких свойств представляется в перечислителе с циклом по <xref:System.Windows.LocalValueEntry> object, который содержит свойства, которые ссылаются на конкретные <xref:System.Windows.DependencyProperty> и его значения. Этот прием перечисления локально заданного значения могут использоваться для оптимизации или другой обработки локальных значений, например, чтобы определить, какие значения свойств <xref:System.Windows.DependencyObject> изменится, если они были очищены.  
  
> [!IMPORTANT]
>  Возвращенный <xref:System.Windows.LocalValueEnumerator> может содержать <xref:System.Windows.LocalValueEntry> записей для свойства зависимостей, которые доступны только для чтения или свойств зависимостей, где значения вычисляются системой свойств. Например, элемент visual framework, который имеет установленное ширину через макета будет сообщать локальное значение для <xref:System.Windows.FrameworkElement.ActualWidth%2A>. Если вы получаете локальных значений для сброса, проверьте <xref:System.Windows.DependencyProperty.ReadOnly%2A> значение свойства содержит идентификатор каждого <xref:System.Windows.LocalValueEntry> и убедитесь, что <xref:System.Windows.DependencyProperty> рассматриваемой не только для чтения.  
  
   
  
## Examples  
 Следующий пример выполняет итерацию всех свойств, которые заданы локальные значения для объекта, затем вызывает метод <xref:System.Windows.DependencyObject.ClearValue%2A> удалить значения каждого из таких свойств.  
  
 [!code-csharp[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/csharp/VS_Snippets_Wpf/DPClearValue/CSharp/default.xaml.cs#iteratelocalvaluesandclear)]
 [!code-vb[DPClearValue#IterateLocalValuesAndClear](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPClearValue/VisualBasic/default.xaml.vb#iteratelocalvaluesandclear)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.LocalValueEntry" />
      </Docs>
    </Member>
    <Member MemberName="GetValue">
      <MemberSignature Language="C#" Value="public object GetValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор <see cref="T:System.Windows.DependencyProperty" /> свойства, из которого извлекается значение.</param>
        <summary>Возвращает текущее действующее значение свойства зависимостей в этом экземпляре <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Возвращает текущее действующее значение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Действительное значение* является значением свойства, которое возвращается системой свойств любому вызывающему объекту, запрашивающему значение. Действительное значение является результатом вычисления всех возможных входных значений, участвующих в приоритет значений свойств системы системой свойств. Это включает приведение и анимация. Дополнительные сведения см. в разделе [Приоритет значений свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Этот метод никогда не возвращает <xref:System.Windows.DependencyProperty.UnsetValue>. <xref:System.Windows.DependencyProperty.UnsetValue> Является контрольного значения для системы свойств, который используется в различных емкости внутренне и иногда также предоставляются через обратные вызовы приведение.  
  
 Если вы не уверены, тип свойства, которое должно быть, можно запросить идентификатор запрошенного свойства зависимостей, чтобы определить, является ли более конкретного <xref:System.Windows.DependencyProperty.PropertyType%2A> , возвращаемое значение преобразуется.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Указанный параметр <paramref name="dp" /> или его значение были недопустимы, или указанного параметра <paramref name="dp" /> не существует.</exception>
        <altmember cref="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
        <altmember cref="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InvalidateProperty">
      <MemberSignature Language="C#" Value="public void InvalidateProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void InvalidateProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.InvalidateProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Sub InvalidateProperty (dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void InvalidateProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор <see cref="T:System.Windows.DependencyProperty" /> свойства, которое следует сделать недействительным.</param>
        <summary>Повторно вычисляет действующее значение для указанного свойства зависимостей</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При вызове <xref:System.Windows.DependencyObject.InvalidateProperty%2A>, все связанные и является применимым <xref:System.Windows.CoerceValueCallback> или <xref:System.Windows.PropertyChangedCallback> функции, зарегистрированные для этого свойства зависимости может быть вызван.  
  
 Вызов <xref:System.Windows.DependencyObject.InvalidateProperty%2A> для свойства, которое у локального значение не будет действовать, так как локальное значение имеет приоритет над входных данных системы другие свойства, за исключением анимации. Тем не менее, может вызвать <xref:System.Windows.DependencyObject.ClearValue%2A>, затем вызовите <xref:System.Windows.DependencyObject.InvalidateProperty%2A>. Дополнительные сведения см. в разделе [Приоритет значений свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Вызов <xref:System.Windows.DependencyObject.InvalidateProperty%2A> может быть неприменимо для многих сценариев свойств зависимостей. Если свойство зависимостей станет недействительным из-за изменения значений в любом из компонентов, в системе свойств делает недействительными и повторно автоматически проверяет свойство зависимостей. Тем не менее, все еще существуют некоторые подходящие сценарии где <xref:System.Windows.DependencyObject.InvalidateProperty%2A> полезно. В частности, можно использовать <xref:System.Windows.DependencyObject.InvalidateProperty%2A> внутри приведенное значение или свойство изменено обратного вызова для свойства зависимостей в другой. Можно также использовать <xref:System.Windows.DependencyObject.InvalidateProperty%2A> для принудительного повторное вычисление привязки к источнику данных, который не может реализовать рекомендуемую <xref:System.ComponentModel.INotifyPropertyChanged> механизм уведомлений (возможно при использовании классов данных, не может быть производным от или где данными является статическим элемент).  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Windows.DependencyObject.InvalidateProperty%2A> на пользовательское свойство, каждый раз, когда свойства, которые участвуют в вычислениях недопустимое свойство изменить. Это альтернативный способ вызова <xref:System.Windows.DependencyObject.CoerceValue%2A> метод, так как делает недействительными свойство будет также вызвать любой зарегистрирован <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/SDKSampleLibrary/class1.cs#invalidateproperty)]
 [!code-vb[PropertySystemEsoterics#InvalidateProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/sdksamplelibrary/class1.vb#invalidateproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Windows.DependencyProperty.UnsetValue" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyObject.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, является ли этот экземпляр в данный момент запечатанным (доступным только для чтения).</summary>
        <value>
          <see langword="true" />, если этот экземпляр запечатан; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это значение внутренним образом.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkElementFactory" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Данные события, в которых будет содержаться интересующий идентификатор свойства зависимостей, метаданные свойства для типа, а также старое и новое значения.</param>
        <summary>Вызывается всякий раз при обновлении действующего значения какого-либо свойства зависимостей относительно данного элемента <see cref="T:System.Windows.DependencyObject" />. Конкретное измененное свойство зависимостей сообщается в данных события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не предназначен для общего выявления изменений отдельных свойств или аннулирования свойств для каждого случая. <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> Вместо него предназначено для изменения общего шаблона недействительности, если известна определенная информация о широких классификациях свойств. Например, изменения в <xref:System.Windows.Freezable> могут быть изменения в типы значений <xref:System.Windows.Freezable>, или могут быть вложенные свойства, в которых изменения в другие <xref:System.Windows.Freezable> ссылки. <xref:System.Windows.Freezable> Переопределить реализацию <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> использует внутренние сведения, чтобы определить, являются вложенными свойств и обеспечивает логику соответствующего базового класса для обоих случаях.  
  
 <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> потенциально вызывается несколько раз за время существования объекта. Таким образом, можно улучшить производительность системы общее свойство, если переопределения метаданных свойств, а затем подключите <xref:System.Windows.CoerceValueCallback> или <xref:System.Windows.PropertyChangedCallback> функции для отдельных свойств. Тем не менее, будет использовать этот метод, если <xref:System.Windows.DependencyObject> включает значительное количество свойств зависимостей с взаимосвязанными значениями, или если он содержит логику, например поведение отрисовки, необходимо повторно для нескольких связанных случаев недействительности свойств.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Всегда вызовите базовую реализацию. В противном случае значительно отключит всего [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] системы свойств, вызывая будут сообщены неверные значения.</para>
        </block>
        <altmember cref="T:System.Windows.FrameworkElement" />
      </Docs>
    </Member>
    <Member MemberName="ReadLocalValue">
      <MemberSignature Language="C#" Value="public object ReadLocalValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object ReadLocalValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ReadLocalValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadLocalValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ ReadLocalValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор <see cref="T:System.Windows.DependencyProperty" /> свойства, из которого извлекается значение.</param>
        <summary>Возвращает локальное значение свойства зависимостей, если оно существует.</summary>
        <returns>Возвращает локальное значение, или значение-метку <see cref="F:System.Windows.DependencyProperty.UnsetValue" />, если локальное значение не задано.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Следует использовать <xref:System.Windows.DependencyObject.GetValue%2A> для наиболее типичных операций «получить» для свойства зависимостей. <xref:System.Windows.DependencyObject.ReadLocalValue%2A> не возвращает действительное значение для различных ситуациях, где значение не было установлено локально.  
  
 Значения, заданные стили, темы, шаблоны, значение по умолчанию из метаданных или наследование значения свойства не считаются локальными. Тем не менее привязки и другие выражения считаются локальными значениями, после их вычисления.  
  
 Если локальное значение не задано, этот метод возвращает <xref:System.Windows.DependencyProperty.UnsetValue>.  
  
 Если возвращаемое значение отличается от <xref:System.Windows.DependencyProperty.UnsetValue>, можно запросить метаданные запрошенного свойства зависимостей, чтобы определить, является ли более конкретный тип, возвращаемое значение преобразуется.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyObject.GetLocalValueEnumerator" />
        <altmember cref="M:System.Windows.DependencyObject.GetValue(System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentValue">
      <MemberSignature Language="C#" Value="public void SetCurrentValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCurrentValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetCurrentValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCurrentValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCurrentValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор задаваемого свойства зависимостей.</param>
        <param name="value">Новое локальное значение.</param>
        <summary>Задает значение свойства зависимостей, не изменяя источник значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется компонентом, который программно задает значение одного из собственных свойств без отключения объявленного использование свойства приложения. <xref:System.Windows.DependencyObject.SetCurrentValue%2A> Метод изменения действующего значения свойства, но существующие триггеры привязки данных и стили будут продолжать работать.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Попытка изменить доступное только для чтения свойство зависимостей, или свойство в запечатанном <see cref="T:System.Windows.DependencyObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> не был корректным типом, зарегистрированным для свойства <paramref name="dp" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetValue">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Задает локальное значение свойства зависимостей, если оно существует.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyProperty dp, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyProperty dp, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (dp As DependencyProperty, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyProperty ^ dp, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор задаваемого свойства зависимостей.</param>
        <param name="value">Новое локальное значение.</param>
        <summary>Задает локальное значение свойства зависимостей, определяемое идентификатором свойства зависимостей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если указанный тип не соответствует тип, объявленный для свойства зависимостей, как оно было изначально зарегистрировано, создается исключение. `value` Параметр всегда должны быть предоставлены как соответствующего типа.  
  
 Условия возникновения исключений потенциально влияет <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> обратный вызов, который существует на идентификатор свойства зависимостей устанавливаемое свойство зависимостей. В противном случае указанное значение может не соответствовать Общие условия проверки типа (например, передача строки, когда собственный тип — Double).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Попытка изменить доступное только для чтения свойство зависимостей, или свойство в запечатанном <see cref="T:System.Windows.DependencyObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> не был корректным типом, зарегистрированным для свойства <paramref name="dp" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetValue">
      <MemberSignature Language="C#" Value="public void SetValue (System.Windows.DependencyPropertyKey key, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetValue(class System.Windows.DependencyPropertyKey key, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.SetValue(System.Windows.DependencyPropertyKey,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetValue (key As DependencyPropertyKey, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetValue(System::Windows::DependencyPropertyKey ^ key, System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="key">Идентификатор <see cref="T:System.Windows.DependencyPropertyKey" /> задаваемого свойства.</param>
        <param name="value">Новое локальное значение.</param>
        <summary>Задает локальное значение свойства зависимости только для чтения, определяемое идентификатором <see cref="T:System.Windows.DependencyPropertyKey" /> свойства зависимостей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта подпись обычно используется при задании значений для свойства зависимостей только для чтения, которые определяются пользовательские классы. Как правило <xref:System.Windows.DependencyObject.SetValue%2A> вызывается только из типа, которая зарегистрирована этого свойства зависимостей, который реализует внутренняя логика, которая предоставляет заданного значения для свойства зависимостей. Дополнительные сведения см. в разделе [Свойства зависимостей "только для чтения"](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
 Если указанный тип не соответствует тип, объявленный для свойства зависимостей, как оно было изначально зарегистрировано, создается исключение. `value` Параметр всегда должны быть предоставлены как соответствующего типа. Условия возникновения исключений потенциально влияет <xref:System.Windows.DependencyProperty.ValidateValueCallback%2A> обратный вызов, который существует на идентификатор свойства зависимостей устанавливаемое свойство зависимостей.  
  
   
  
## Examples  
 В следующем примере определяется свойство зависимостей только для чтения, вместе с `public static readonly` <xref:System.Windows.DependencyProperty> , предоставляющий необходимые уязвимость только для чтения к потребителям свойство и метод доступа get для [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] программы-оболочки.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeProperty">
      <MemberSignature Language="C#" Value="protected internal virtual bool ShouldSerializeProperty (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool ShouldSerializeProperty(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyObject.ShouldSerializeProperty(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function ShouldSerializeProperty (dp As DependencyProperty) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool ShouldSerializeProperty(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Идентификатор для сериализуемого свойства зависимостей.</param>
        <summary>Возвращает значение, указывающее, должны ли процессы сериализации сериализовать значение предоставленного свойства зависимостей.</summary>
        <returns>
          <see langword="true" />, если значение переданного свойства зависимостей следует сериализовать; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Реализация по умолчанию возвращает `true` во всех случаях, когда свойство зависимостей было установлено на локальное значение <xref:System.Windows.DependencyObject>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Переопределения этого метода могут по-разному обрабатывать особые свойства зависимостей.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>