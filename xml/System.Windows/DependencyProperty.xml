<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3e36dd257b906b7c94742536f4e333ac2cac8cd0" />
    <Meta Name="ms.sourcegitcommit" Value="058bfa0b75b777d3171411d35da8f11617fc06b0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="05/04/2018" />
    <Meta Name="ms.locfileid" Value="33660024" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет свойство, которое можно задать с помощью методов, например стили, привязки данных, анимации и наследование.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Windows.DependencyProperty> поддерживает следующие возможности в [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]:  
  
-   Это свойство можно задать в style. Более подробную информацию см. в разделе [Стилизация и использование шаблонов](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
-   Свойство может быть задано через привязку данных. Дополнительные сведения о привязке данных свойств зависимостей см. в разделе [как: привязки свойства из двух элементов управления](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md).  
  
-   Свойство может быть задано со ссылкой на динамический ресурс. Дополнительные сведения см. в разделе [Ресурсы XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
-   Свойство может наследовать его значение автоматически от родительского элемента в дереве элементов. Дополнительные сведения см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
-   Свойства могут быть анимированы. Более подробную информацию см. в разделе [Общие сведения об эффектах анимации](~/docs/framework/wpf/graphics-multimedia/animation-overview.md).  
  
-   Свойство может сообщать, когда предыдущее значение свойства было изменено и можно выполнить приведение значения свойства. Дополнительные сведения см. в разделе [Проверка и обратные вызовы свойства зависимостей](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
-   Свойство сообщает информацию для [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], такие как ли изменение значения свойства требуется системе макета, чтобы представлять визуализации элемента.  
  
-   Свойство получает поддержку в [!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)].  Например, можно изменить свойство в **свойства** окна.  
  
 Дополнительные сведения о свойствах зависимостей см. в разделе [Общие сведения о свойствах зависимостей](~/docs/framework/wpf/advanced/dependency-properties-overview.md). Если требуется свойства на пользовательских типов для поддержки возможностей в предыдущем списке, следует создать свойство зависимостей.  Описание способов создания пользовательских свойств зависимостей, в разделе [пользовательских свойств зависимостей](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
 Вложенное свойство является свойством, позволяющий любого объекта, для передачи сведений типа, который определяет вложенное свойство. В [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], любой тип, наследующий от <xref:System.Windows.DependencyObject> можно использовать вложенное свойство независимо от того, является ли тип наследует от типа, определяющего свойство. Вложенное свойство — это функция [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] языка.  Чтобы задать присоединенное свойство в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], используйте *ownerType*.* propertyName* синтаксиса. Является примером вложенное свойство <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> свойство. Если вы хотите создать свойство, которое может использоваться для всех <xref:System.Windows.DependencyObject> типов, следует создать вложенное свойство. Дополнительные сведения о вложенных свойств, включая создание, в разделе [зависимостей](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="dependencyPropertyName"/>  
- or -  
<object property="ownerType.dependencyPropertyName"/>  
- or -  
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a>Значения XAML  
 `dependencyPropertyName`  
 Строка, указывающая <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType> свойства требуемой зависимостей. Это может предшествовать префикс пространства имен XML, если свойство не существует в пространстве имен XML по умолчанию (Дополнительные сведения см. в разделе [пространства имен XAML и сопоставление пространства имен WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).)  
  
 `ownerType`.`dependencyPropertyName`  
 Строка, указывающая тип владельца свойства зависимостей, точка (.), то <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>. `ownerType` Можно также предшествовать префикс пространства имен XML. Для позднего связывания стили и шаблоны, где необходимо указать владельца свойства зависимостей для синтаксического анализа контекста, так как такое использование `TargetType` еще не известна. Более подробную информацию см. в разделе [Стилизация и использование шаблонов](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
 `attachedPropertyOwnerType` *.* `attachedPropertyName`  
 Строка, задающая владельца вложенного свойства, точка (.), а затем имя вложенного свойства. `attachedPropertyOwnerType` Можно также предшествовать префикс пространства имен XML.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет другой тип в качестве владельца свойства зависимостей, который уже был зарегистрирован для типа.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">Тип для добавления в качестве владельца данного свойства зависимостей.</param>
        <summary>Добавляет другой тип в качестве владельца свойства зависимостей, которое уже зарегистрировано.</summary>
        <returns>Ссылка на исходный идентификатор <see cref="T:System.Windows.DependencyProperty" />, который определяет свойство зависимостей. Этот идентификатор должен быть представлен путем добавления класса в качестве поля <see langword="public static readonly" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод позволяет распознавать свойства зависимостей для типа, который изначально не зарегистрировала это конкретное свойство зависимостей в системе свойств.  
  
 Как правило <xref:System.Windows.DependencyProperty.AddOwner%2A> используется для добавления свойств зависимостей в классы, которые еще не предоставляют это свойство зависимостей через наследование управляемого класса (наследование класса вызовет свойства оболочки должны наследоваться от базового класса и, следовательно, обеспечит общей таблице членов доступ к свойству зависимостей уже). <xref:System.Windows.DependencyProperty.AddOwner%2A> позволяет распознавать свойства зависимостей для типа, который изначально не зарегистрировала это свойство зависимостей в системе свойств.  
  
 Эта подпись не позволяет указывать метаданные.  При использовании этого метода метаданные автоматически создается для нового <xref:System.Windows.DependencyProperty> и ее типа владельца. Метаданные автоматически созданный является результатом объединения метаданных из всех базовых типов, для которых определено это свойство. Если нет объединенных метаданных нет, то используется метаданных по умолчанию для свойства. Если оно регистрируется с помощью <xref:System.Windows.DependencyProperty.RegisterAttached%2A> метод, то метаданные по умолчанию является таким же, как метаданные, создаваемой при <xref:System.Windows.DependencyProperty.RegisterAttached%2A> был вызван. В противном случае <xref:System.Windows.PropertyMetadata> создан объект с <xref:System.Windows.PropertyMetadata.DefaultValue%2A> свойства, значение по умолчанию тип свойства, а все остальные свойства <xref:System.Windows.PropertyMetadata> равно `null`. Используйте <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> подпись, чтобы предоставлять метаданные для версии свойства зависимостей, по мере добавления в указанный тип.  
  
 Возвращаемое значение этого метода обычно используется для объявления и предоставления свойства зависимостей, сохраняя идентификатор свойства зависимостей. Идентификатор предоставляет доступ к свойству зависимостей, если вы хотите вызвать системы свойств [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] к свойству зависимостей, особенно, когда существует на добавляемом классе владельца. Одно и то же имя свойства для первоначального владельца и добавленного владельцев следует использовать, чтобы указать на схожую функциональность. Следует использовать <xref:System.Windows.DependencyProperty> возвращаемое значение <xref:System.Windows.DependencyProperty.AddOwner%2A> метод для определения идентификатора свойства зависимости, а также для объявления [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] оболочки свойства для свойства зависимостей, которые добавляются с помощью типов <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 <xref:System.Windows.DependencyProperty.AddOwner%2A> Методологии рекомендуется выше используется при создании свойства зависимости, которые объявлены внутри [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. Например, оба <xref:System.Windows.Controls.Border> и <xref:System.Windows.Controls.Control> определить `BorderBrush` свойства зависимостей, имеющих аналогичные функциональные возможности. <xref:System.Windows.Controls.Control> определяет его `BorderBrush` свойства в системе свойств путем вызова <xref:System.Windows.DependencyProperty.AddOwner%2A> зависимости от первоначального владельца <xref:System.Windows.Controls.Border> и его зарегистрированные <xref:System.Windows.Controls.Border.BorderBrushProperty> идентификатор свойства зависимостей. <xref:System.Windows.DependencyProperty.AddOwner%2A> Возвращают значение затем используется для установления новый статический <xref:System.Windows.DependencyProperty> поля (<xref:System.Windows.Controls.Control.BorderBrushProperty>) для этого свойства для добавленного владельцев и `BorderBrush` также объявляется свойство программы-оболочки.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">Тип для добавления в качестве владельца данного свойства зависимостей.</param>
        <param name="typeMetadata">Метаданные, квалифицирующие свойство зависимостей в том виде, в котором оно существует в указанном типе.</param>
        <summary>Добавляет другой тип в качестве владельца свойства зависимостей, который уже был зарегистрирован, предоставляя метаданные свойства зависимости для свойства зависимостей в том виде, в котором оно будет существовать в предоставленном типе владельца.</summary>
        <returns>Ссылка на исходный идентификатор <see cref="T:System.Windows.DependencyProperty" />, который определяет свойство зависимостей. Этот идентификатор должен быть представлен путем добавления класса в качестве поля <see langword="public static readonly" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод позволяет распознавать свойства зависимостей для типа, который изначально не зарегистрировала это конкретное свойство зависимостей в системе свойств.  
  
 Возвращаемое значение этого метода используется для объявления и предоставления свойству зависимостей, особенно в том случае, как оно существует в добавляемом классе владельца. Как правило то же имя свойства для первоначального владельца и добавленного владельцев следует использовать для указания на схожую функциональность. Рекомендуется предоставлять идентификаторы, а также новые [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] оболочки свойства для свойства зависимостей, которые добавляются с помощью типов <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 <xref:System.Windows.DependencyProperty.AddOwner%2A> Методологии рекомендуется выше используется при создании [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] объявленная внутри [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. Например, оба <xref:System.Windows.Controls.Border> и <xref:System.Windows.Controls.Control> определить `BorderBrush` свойства зависимостей, имеющих аналогичные функциональные возможности. <xref:System.Windows.Controls.Control> определяет его `BorderBrush` свойства в системе свойств путем вызова <xref:System.Windows.DependencyProperty.AddOwner%2A> на исходный владелец <xref:System.Windows.Controls.Border> и его зарегистрированные <xref:System.Windows.Controls.Border.BorderBrushProperty> идентификатор свойства зависимостей. <xref:System.Windows.DependencyProperty.AddOwner%2A> Возвращают значение затем используется для установления статический <xref:System.Windows.DependencyProperty> поля (<xref:System.Windows.Controls.Control.BorderBrushProperty>) для этого свойства для добавленного владельцев и `BorderBrush` также объявляется свойство программы-оболочки.  
  
 Идентификатор для свойства зависимостей добавленного владельцев должен использоваться для операций таких как <xref:System.Windows.DependencyObject.GetValue%2A>. Однако конкретного типа операций, включающих типов или экземпляров класса, который был добавлен как владелец с различные метаданные будут по-прежнему возвращать даже если ожидаемые результаты исходного (не добавлены владельца) указан идентификатор свойства зависимостей в вызовы методов, например <xref:System.Windows.DependencyObject.GetValue%2A> или <xref:System.Windows.DependencyProperty.GetMetadata%2A>. Метаданные для добавленного владельцев сохраняются по <xref:System.Windows.DependencyProperty.AddOwner%2A> вызывает самого ссылается не обязательно исключительно поле идентификатора класса Добавление владельца. Тем не менее, рекомендуется для предоставления идентификатора, а также новые [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] оболочки свойства для свойства зависимостей, которые добавляются с помощью типов <xref:System.Windows.DependencyProperty.AddOwner%2A>, поскольку Несоблюдение этого различие между [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] и [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] представления свойств.  
  
 Предоставленных метаданных объединяется с метаданными для свойства зависимостей, которое существует в базовом владельце. Характеристики, которые были указаны в исходных базовых метаданных, сохранятся. Только характеристики, специально измененные в новых метаданных, переопределят характеристики базовых метаданных. Некоторые характеристики, такие как <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, заменяются в случае, если они указаны в новых метаданных. Другие, такие как <xref:System.Windows.PropertyChangedCallback>, объединяются. В конечном счете, поведение при объединении зависит от типа метаданных свойства используется для переопределения, поэтому для существующих классов метаданных свойств, используемых поведения, описанного здесь [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] свойств зависимостей. Дополнительные сведения см. в разделе [метаданные свойства зависимостей](~/docs/framework/wpf/advanced/dependency-property-metadata.md) и [метаданных свойств среды](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает метаданные свойства зависимостей по умолчанию.</summary>
        <value>Метаданные свойства зависимостей по умолчанию.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию метаданные, метаданные свойства, доступные для конкретного объекта или объекта производного типа, где альтернативные метаданные не был предоставлен явный <xref:System.Windows.DependencyProperty.Register%2A> или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> вызова.  
  
 Если владелец исходного метаданных применяется к первому <xref:System.Windows.DependencyProperty.Register%2A> вызов, установить свойству зависимостей, а затем эти метаданные возвращаются в виде <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
 Если метаданные не было применено в исходной коллекции <xref:System.Windows.DependencyProperty.Register%2A> вызвать, формируется с помощью метаданных по умолчанию <xref:System.Windows.DependencyProperty.Register%2A> вызова и это значение возвращается в виде <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
 Основным назначением которых по умолчанию метаданные, связанные с <xref:System.Windows.DependencyProperty> — предоставить значение по умолчанию для этого свойства для какого-либо <xref:System.Windows.DependencyObject> или производный тип.  
  
 Для невложенных свойств тип метаданных, возвращенный этим свойством нельзя привести к производные типы <xref:System.Windows.PropertyMetadata> тип, даже если свойство было изначально зарегистрировано с производным типом метаданных. Изначально зарегистрированных метаданных, включая его исходным типом возможно производные метаданные вызвать <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29> вместо этого, передача исходной регистрации типу как параметр.  
  
 Для вложенных свойств тип метаданных, возвращенный этим свойством будет соответствовать типу, заданному в исходной <xref:System.Windows.DependencyProperty.RegisterAttached%2A> метод регистрации.  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код для объекта <see cref="T:System.Windows.DependencyProperty" />.</summary>
        <returns>Хэш-код для этого экземпляра <see cref="T:System.Windows.DependencyProperty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В системе свойств использует свой собственный уникальный идентификатор <xref:System.Windows.DependencyProperty.GlobalIndex%2A>, и возвращается значение этого свойства <xref:System.Windows.DependencyProperty.GetHashCode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает метаданные, связанные с данным свойством зависимостей в том виде, в котором оно существует для конкретного типа. Это может быть тип, в котором свойство зависимостей было изначально зарегистрировано, тип, к которому оно было добавлено позже, или тип, в котором свойство зависимостей было получено путем наследования, но метаданные были переопределены.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">Конкретный тип, из которого необходимо извлечь метаданные свойства зависимостей.</param>
        <summary>Возвращает метаданные для этого свойства зависимостей в том виде, в котором оно представлено в указанном существующем типе.</summary>
        <returns>Объект метаданных свойств.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Указание типа или ссылкой на объект для использования в качестве типа является обязательным, поскольку метаданные могут отличаться от исходной регистрации ввиду <xref:System.Windows.DependencyProperty.AddOwner%2A> или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> вызовы, изменять метаданные свойства зависимостей, как оно существует в типе.  
  
   
  
## Examples  
 Следующий пример возвращает метаданные для свойства зависимостей, в зависимости от его типа. Тип осуществляется при помощи `typeof` оператор.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">Объект зависимости, проверяемый на наличие типа, чтобы определить, из какой типозависимой версии свойства зависимости нужно использовать метаданные.</param>
        <summary>Возвращает метаданные для этого свойства зависимостей в том виде,в котором оно существует в указанном экземпляре объекта.</summary>
        <returns>Объект метаданных свойств.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Указание типа или ссылкой на объект является необходимым, поскольку метаданные любое заданное свойство зависимостей может изменяться от исходной регистрации ввиду <xref:System.Windows.DependencyProperty.AddOwner%2A> или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> вызовы, которые можно уточнить метаданные свойства, которое существует в тип.  
  
 При запросе метаданных свойства на основе экземпляра это просто передачи экземпляра, его тип может вычисляться внутренним образом. Метаданные свойства зависимостей не зависит от конкретного экземпляра. всегда является согласованным для любой комбинации типа и свойства.  
  
   
  
## Examples  
 Следующий пример получает метаданные для свойства зависимостей, в зависимости от конкретного <xref:System.Windows.DependencyObject> экземпляра.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">Специальный объект, который записывает тип объекта зависимости, из которого запрашиваются метаданные свойства зависимостей.</param>
        <summary>Возвращает метаданные для этого свойства зависимостей в том виде, в каком они представлены в указанном типе.</summary>
        <returns>Объект метаданных свойств.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Указание типа или ссылкой на объект является необходимым, поскольку метаданные любое заданное свойство зависимостей может изменяться от исходной регистрации ввиду <xref:System.Windows.DependencyProperty.AddOwner%2A> или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> вызовы, которые можно уточнить метаданные свойства, которое существует в тип.  
  
   
  
## Examples  
 Следующий пример получает метаданные для свойства зависимостей на основе его <xref:System.Windows.DependencyObjectType>.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает внутреннее сгенерированное значение, уникальным образом идентифицирующее свойство зависимостей.</summary>
        <value>Уникальный числовой идентификатор.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это значение является целым числом, не глобальный уникальный идентификатор (GUID). Как правило это значение индекса не требуется и нет индекса доступа к таблицам всех свойств зависимостей. Свойства зависимостей вместо этого следует ссылаться их идентификатор поля.  
  
 <xref:System.Windows.DependencyProperty.GlobalIndex%2A> используется внутренним образом для ускорения доступа к структурам данных, использующих <xref:System.Windows.DependencyProperty.GlobalIndex%2A> как массив, начинающийся с нуля индекс. Подобное использование может применяться для конструкторов или инструментов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Проверяемое значение.</param>
        <summary>Определяет, приемлемо ли указанное значение для типа данного свойства зависимостей, проверяя его по типу свойства, указанного при исходной регистрации свойства зависимостей.</summary>
        <returns>
          <see langword="true" />, если указанное значение принадлежит к зарегистрированному типу свойства или приемлемому производному типу; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение `null` является допустимым типом для свойств зависимостей ссылочного типа или <xref:System.Nullable%601> свойства зависимостей и будет возвращать `true` для таких случаев. В случаях, когда свойство зависимостей ни ссылку и не является <xref:System.Nullable%601> типа, <xref:System.Windows.DependencyProperty.IsValidType%2A> вернет `false` значение null, а не создавать исключение.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Windows.DependencyProperty.IsValidType%2A> проверку перед вызовом метода <xref:System.Windows.DependencyObject.SetValue%2A> для свойства зависимостей.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Проверяемое значение.</param>
        <summary>Определяет, приемлемо ли указанное значение для типа свойства, путем базовой проверки типа, а также, находится ли оно потенциально в пределах разрешенного диапазона значений для данного типа.</summary>
        <returns>
          <see langword="true" />, если значение приемлемо и принадлежит к надлежащему или производному типу; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для свойства зависимостей, можно указать разрешенный диапазон значений для этого типа с помощью <xref:System.Windows.ValidateValueCallback> , предоставляется при регистрации свойства зависимостей.  
  
 Этот метод вызывает метод <xref:System.Windows.DependencyProperty.IsValidType%2A> внутренним образом. Если свойство зависимостей в вопросе не имеет <xref:System.Windows.ValidateValueCallback>, то вызов этого метода, эффективно аналогичен вызову <xref:System.Windows.DependencyProperty.IsValidType%2A>. Если свойство зависимости имеет <xref:System.Windows.ValidateValueCallback>и если <xref:System.Windows.DependencyProperty.IsValidType%2A> возвращала бы `true`, то возвращаемое значение будет иметь реализации обратного вызова.  
  
 Значение null является допустимым значением для свойства зависимостей типа ссылки или <xref:System.Nullable%601> свойства зависимостей и будет возвращать `true` для таких случаев. В случаях, когда свойство зависимостей ни ссылку и не является <xref:System.Nullable%601> типа, <xref:System.Windows.DependencyProperty.IsValidType%2A> вернет `false` значение null, а не создавать исключение.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Windows.DependencyProperty.IsValidValue%2A> проверку перед вызовом метода <xref:System.Windows.DependencyObject.SetValue%2A> для свойства зависимостей.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает имя свойства зависимостей.</summary>
        <value>Имя свойства.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство получает имя, указанное как `name` параметр во время регистрации свойства зависимостей. Это имя является постоянным и не может быть `null` или является пустой строкой. Повторяющееся имя регистрации на том же типе владельца не разрешены и возникает исключение при попытке зарегистрировать дубликат.  
  
> [!IMPORTANT]
>  <xref:System.Windows.DependencyProperty.Name%2A> Зависимости свойства должны соответствовать соглашению совпадающих имя его идентификатор для свойства зависимостей минус суффикс «Свойство». Дополнительные сведения см. в разделе [Пользовательские свойства зависимостей](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
   
  
## Examples  
 В следующем примере запрашивается различные характеристики идентификатор свойства зависимостей, включая <xref:System.Windows.DependencyProperty.Name%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Предоставляет альтернативные метаданные для этого свойства зависимостей, когда оно присутствует в экземплярах указанного типа по сравнению с метаданными, предоставленными регистрацией первоначального свойства зависимостей.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">Тип, где это свойство зависимостей наследуется и где будут применены указанные альтернативные метаданные.</param>
        <param name="typeMetadata">Метаданные для применения к свойству зависимостей в переопределяемом типе.</param>
        <summary>Задает альтернативные метаданные для этого свойства зависимостей, если оно присутствует в экземплярах указанного типа, переопределяя метаданные, которые существовали для данного свойства зависимостей в том виде, в котором оно было унаследовано от базовых типов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В системе свойств использует свойства зависимостей, следует переопределить метаданные свойства зависимостей. Это соответствует времени, определенные экземпляры создаются с помощью класса, регистрирующего свойство зависимостей. Вызовы <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> следует выполнять только в статическом конструкторе типа, предоставляющего себя в качестве `forType` параметр этого метода, или с помощью аналогичные при создании экземпляра. Попытка изменить метаданные после экземпляров типа-владельца не возникнет исключения, но приведет к несогласованному поведению в системе свойств.  
  
 После установки с помощью этого метода метаданные для определенного производного класса переопределения последующие попытки переопределения метаданных на этом же производном классе вызывает исключение.  
  
 Предоставленных метаданных объединяется с метаданными для свойства зависимостей, которое существует в базовом владельце. Характеристики, которые были указаны в исходных базовых метаданных будет сохранено; только характеристики, специально измененные в новых метаданных, переопределят характеристики базовых метаданных. Некоторые характеристики, такие как <xref:System.Windows.PropertyMetadata.DefaultValue%2A> заменяются, если он указан в новые метаданные. Другие, такие как <xref:System.Windows.PropertyChangedCallback>, объединяются. В конечном счете, поведение при объединении зависит от типа метаданных свойства используется для переопределения, поэтому для существующих классов метаданных свойств, используемых поведения, описанного здесь [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] свойств зависимостей. Дополнительные сведения см. в разделе [метаданные свойства зависимостей](~/docs/framework/wpf/advanced/dependency-property-metadata.md) и [метаданных свойств среды](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Была предпринята попытка переопределения метаданных в доступном только для чтения свойстве зависимости (операция не может быть выполнена с помощью данной сигнатуры).</exception>
        <exception cref="T:System.ArgumentException">Метаданные уже были установлены для данного свойства зависимостей в том виде, в котором оно существует в предоставленном типе.</exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">Тип, где это свойство зависимостей наследуется и где будут применены указанные альтернативные метаданные.</param>
        <param name="typeMetadata">Метаданные для применения к свойству зависимостей в переопределяемом типе.</param>
        <param name="key">Ключ доступа для свойства зависимостей, доступного только для чтения.</param>
        <summary>Предоставляет альтернативные метаданные для свойства зависимостей, доступного только для чтения, когда оно присутствует в экземплярах указанного типа, переопределяя метаданные, предоставленные при первоначальной регистрации свойства зависимостей. Для доступного только для чтения свойства зависимости необходимо передать <see cref="T:System.Windows.DependencyPropertyKey" />, чтобы избежать исключения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта подпись предоставляет базовую реализацию для идентификатора свойства зависимости только для чтения (<xref:System.Windows.DependencyPropertyKey>) метод. Для переопределения метаданных для свойства зависимостей для чтения и записи, используйте <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>.  
  
 В системе свойств использует свойства зависимостей, следует переопределить метаданные свойства зависимостей. Это равно времени создания конкретных объектов для класса, который регистрирует свойство зависимости. Вызовы <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> следует выполнять только в статическом конструкторе типа, предоставляющего себя в качестве `forType` параметр этого метода, или с помощью аналогичные при создании экземпляра. Попытка изменить метаданные после экземпляров типа-владельца не возникнет исключения, но приведет к несогласованному поведению в системе свойств.  
  
 После установки с помощью этого метода метаданные для определенного производного класса переопределения последующие попытки переопределения метаданных на этом же производном классе вызывает исключение.  
  
 Предоставленных метаданных объединяется с метаданными для свойства зависимостей, которое существует в базовом владельце. Характеристики, которые были указаны в исходных базовых метаданных будет сохранено; только характеристики, специально измененные в новых метаданных, переопределят характеристики базовых метаданных. Некоторые характеристики, такие как <xref:System.Windows.PropertyMetadata.DefaultValue%2A> заменяются, если он указан в новые метаданные. Другие, такие как <xref:System.Windows.PropertyChangedCallback>, объединяются. Поведение при объединении зависит от используемого для переопределения типа метаданных свойства. Дополнительные сведения см. в разделе [метаданные свойства зависимостей](~/docs/framework/wpf/advanced/dependency-property-metadata.md) и [метаданных свойств среды](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает тип объекта, зарегистрировавшего свойство зависимостей в системе свойств или добавившего себя в качестве владельца свойства.</summary>
        <value>Тип объекта, зарегистрировавшего свойство или добавившего себя в качестве владельца свойства.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данное значение было указано во время регистрации свойства. Владельцем будет либо исходного регистрации типа в случае использования <xref:System.Windows.DependencyProperty> идентификатор, созданный из <xref:System.Windows.DependencyProperty.Register%2A> вызова или тип, добавившего себя в качестве владельца для <xref:System.Windows.DependencyProperty> идентификатор, созданный из <xref:System.Windows.DependencyProperty.AddOwner%2A> вызова.  
  
 <xref:System.Windows.DependencyProperty.OwnerType%2A> С заданным <xref:System.Windows.DependencyProperty> является постоянным и не может быть `null` в допустимое <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 Следующий пример получает тип владельца, исходя из идентификатора свойства зависимости `dp`, а затем возвращает метаданные для типа владельца по тому же идентификатору. Эта операция эквивалентно фактически получению <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> на `dp`.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает тип, используемый свойством зависимостей для его значения.</summary>
        <value>
          <see cref="T:System.Type" /> значения свойства.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство сообщает тип значения свойства, объявленные в исходной регистрации свойства через `propertyType` параметра. Аналогично <xref:System.Windows.DependencyProperty.Name%2A>, тип свойства для свойства зависимостей нельзя изменить после регистрации.  
  
   
  
## Examples  
 В следующем примере запрашивается различные характеристики идентификатор свойства зависимостей, включая <xref:System.Windows.DependencyProperty.PropertyType%2A>. Строка имени типа <xref:System.Windows.DependencyProperty.PropertyType%2A> получается из возвращенного <xref:System.Type>.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, является ли свойство зависимостей, идентифицируемое данным экземпляром <see cref="T:System.Windows.DependencyProperty" />, доступным только для чтения.</summary>
        <value>
          <see langword="true" />, если свойство зависимостей доступно только для чтения; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойства зависимости только для чтения зарегистрированного в системе свойств путем вызова метода <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> метода, в отличие от <xref:System.Windows.DependencyProperty.Register%2A> метод. Вложенные свойства также можно зарегистрировать только для чтения; в разделе <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.  
  
 Свойства зависимости только для чтения требуют <xref:System.Windows.DependencyPropertyKey> идентификатор, а не <xref:System.Windows.DependencyProperty> идентификатор для выполнения операций с метаданными, например переопределения метаданных или установка значения. Если получить коллекцию <xref:System.Windows.DependencyProperty> идентификаторы посредством вызова <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> или другой [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] , предоставляющий идентификаторов, проверьте <xref:System.Windows.DependencyProperty.ReadOnly%2A> значение, прежде чем пытаться вызвать <xref:System.Windows.DependencyObject.SetValue%2A> или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> , использование идентификатор для свойства зависимостей в качестве входного параметра, чтобы убедиться, что свойством зависимостей, которое представляет идентификатор не только для чтения. Если значение <xref:System.Windows.DependencyProperty.ReadOnly%2A> — `true` для свойства зависимостей, нет возможности для получения ссылки на программный <xref:System.Windows.DependencyPropertyKey> идентификатора этого свойства зависимостей, из метаданных или <xref:System.Windows.DependencyProperty> идентификатор; идентификатор должен быть доступен как статическое поле для вызова <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> для свойства зависимостей только для чтения.  
  
 При создании пользовательского свойства зависимостей и зарегистрируйте его только для чтения, следует определить только метод доступа get для [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] свойство программы-оболочки. В противном случае ваш класс будет иметь несогласованную объектную модель для обертки свойства, по сравнению с доступом к базовому свойству зависимостей. Дополнительные сведения см. в разделе [свойств зависимостей](~/docs/framework/wpf/advanced/custom-dependency-properties.md) или [свойства зависимости только для чтения](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
   
  
## Examples  
 В следующем примере получает метаданные по умолчанию и идентификатора свойства зависимостей из различных полей свойства зависимостей и использует сведения для заполнения таблицы и реализации «обозревателя метаданных».  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует свойство зависимостей.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей. Имя должно быть уникальным в пределах пространства имен регистрации для типа владельца.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <summary>Регистрирует свойство зависимостей с указанием имени свойства, типа свойства и типа владельца.</summary>
        <returns>Идентификатор свойства зависимостей, который следует использовать для задания значения поля <see langword="public static readonly" /> в классе. Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о регистрации свойств зависимостей см. в разделе <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <param name="typeMetadata">Метаданные свойства зависимостей.</param>
        <summary>Регистрирует свойство зависимостей с указанным именем свойства, типом свойства, типом владельца и метаданными свойства.</summary>
        <returns>Идентификатор свойства зависимостей, который следует использовать для задания значения поля <see langword="public static readonly" /> в классе. Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о регистрации свойств зависимостей см. в разделе <xref:System.Windows.DependencyProperty>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <param name="typeMetadata">Метаданные свойства зависимостей.</param>
        <param name="validateValueCallback">Ссылка на обратный вызов, который должен выполнить пользовательскую проверку значения свойства зависимостей после обычной проверки типа.</param>
        <summary>Регистрирует свойство зависимостей с указанным именем свойства, типом свойства, типом владельца, метаданными свойства и обратным вызовом проверки значения для свойства.</summary>
        <returns>Идентификатор свойства зависимостей, который следует использовать для задания значения поля <see langword="public static readonly" /> в классе. Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о регистрации свойств зависимостей см. в разделе <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 В следующем примере регистрируется свойство зависимостей, включая обратный вызов проверки (определение обратного вызова не показано; Дополнительные сведения об определении обратного вызова см. в разделе <xref:System.Windows.ValidateValueCallback>).  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует присоединенное свойство в системе свойств.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <summary>Регистрирует присоединенное свойство с указанием имени свойства, типа свойства и типа владельца.</summary>
        <returns>Идентификатор свойства зависимостей, который следует использовать для задания значения поля <see langword="public static readonly" /> в классе. Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вложенное свойство является свойством понятием [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] реализует вложенные свойства как свойства зависимости. Поскольку [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] вложенные свойства являются свойствами зависимости, они могут быть применены метаданные, который может использоваться для операции, такие как сообщение о характеристиках структуры системой общих свойств. Дополнительные сведения см. в разделе [Общие сведения о вложенных свойствах](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Дополнительные сведения о регистрации свойств зависимостей см. в разделе <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 В следующем примере регистрируется вложенное свойство для абстрактного класса с помощью этого <xref:System.Windows.DependencyProperty.RegisterAttached%2A> подписи.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <param name="defaultMetadata">Метаданные свойства зависимостей. Могут включать значение по умолчанию и другие характеристики.</param>
        <summary>Регистрирует присоединенное свойство с указанным именем и типом свойства, типом владельца и метаданными свойства.</summary>
        <returns>Идентификатор свойства зависимостей, который следует использовать для задания значения поля <see langword="public static readonly" /> в классе. Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вложенное свойство является свойством понятием [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] реализует вложенные свойства как свойства зависимости. Поскольку [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] вложенные свойства являются свойствами зависимости, они могут быть применены метаданные, который может использоваться для операции, такие как сообщение о характеристиках структуры системой общих свойств. Дополнительные сведения см. в разделе [Общие сведения о вложенных свойствах](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Дополнительные сведения о регистрации свойств зависимостей см. в разделе <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Использование RegisterAttached для наследования значения свойств зависимостей  
 Один из сценариев для регистрации свойства зависимостей с <xref:System.Windows.DependencyProperty.RegisterAttached%2A> вместо <xref:System.Windows.DependencyProperty.Register%2A> предназначен для поддержки наследования значения свойства. Необходимо зарегистрировать наследование значения свойства зависимостей с <xref:System.Windows.DependencyProperty.RegisterAttached%2A> даже если класс определяет оболочку свойствам, которые предоставляют свойство зависимостей, и даже если не требуется предоставлять Get * и набор * статические методы для предоставления присоединенного значение true Поддержка доступа к свойствам.   Несмотря на то, что наследование значения свойства могут быть выполнены для неприсоединенных свойств зависимости, поведение наследования для неприсоединенного свойства в определенных границах элемента в дереве среды выполнения не определено. Регистрация свойства как вложенного фактически делает вложенное свойство глобальным для системы свойств и гарантирует, что наследование значения свойства работает через все границы в дереве элементов. Всегда используйте <xref:System.Windows.DependencyProperty.RegisterAttached%2A> для регистрации свойства, где указываются <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> в метаданных. Дополнительные сведения см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <param name="defaultMetadata">Метаданные свойства зависимостей. Могут включать значение по умолчанию и другие характеристики.</param>
        <param name="validateValueCallback">Ссылка на обратный вызов, который должен выполнить пользовательскую проверку значения свойства зависимостей после обычной проверки типа.</param>
        <summary>Регистрирует присоединенное свойство с указанным типом свойства, типом владельца, метаданными свойства и обратным вызовом для проверки значения свойства.</summary>
        <returns>Идентификатор свойства зависимостей, который следует использовать для задания значения поля <see langword="public static readonly" /> в классе. Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вложенное свойство является свойством понятием [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] реализует вложенные свойства как свойства зависимости. Поскольку [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] вложенные свойства являются свойствами зависимости, они могут быть применены метаданные, который может использоваться для операции, такие как сообщение о характеристиках структуры системой общих свойств. Дополнительные сведения см. в разделе [Общие сведения о вложенных свойствах](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Дополнительные сведения о регистрации свойств зависимостей см. в разделе <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Использование RegisterAttached для наследования значения свойств зависимостей  
 Один из сценариев для регистрации свойства зависимостей с <xref:System.Windows.DependencyProperty.RegisterAttached%2A> вместо <xref:System.Windows.DependencyProperty.Register%2A> предназначен для поддержки наследования значения свойства. Необходимо зарегистрировать наследование значения свойства зависимостей с <xref:System.Windows.DependencyProperty.RegisterAttached%2A> даже если класс определяет оболочку свойствам, которые предоставляют свойство зависимостей, и даже если не требуется предоставлять Get * и набор * статические методы для предоставления присоединенного значение true Поддержка доступа к свойствам.   Несмотря на то, что наследование значения свойства могут быть выполнены для неприсоединенных свойств зависимости, поведение наследования для неприсоединенного свойства в определенных границах элемента в дереве среды выполнения не определено. Регистрация свойства как вложенного фактически делает вложенное свойство глобальным для системы свойств и гарантирует, что наследование значения свойства работает через все границы в дереве элементов. Всегда используйте <xref:System.Windows.DependencyProperty.RegisterAttached%2A> для регистрации свойства, где указываются <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> в метаданных. Дополнительные сведения см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
   
  
## Examples  
 В следующем примере регистрируется вложенное свойство для абстрактного класса с помощью этого <xref:System.Windows.DependencyProperty.RegisterAttached%2A> подписи. Это вложенное свойство является свойством типа перечисления и при регистрации добавляется обратный вызов проверки для проверки, предоставленное значение является значением перечисления.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует присоединенное свойство зависимостей, предназначенное только для чтения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <param name="defaultMetadata">Метаданные свойства зависимостей.</param>
        <summary>Регистрирует доступное только для чтения присоединенное свойство с указанным типом свойства, типом владельца и метаданными свойства.</summary>
        <returns>Ключ свойства зависимостей, который следует использовать для задания значения статического доступного только для чтения поля в вашем классе, которое затем используется для ссылки на свойство зависимостей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает тип <xref:System.Windows.DependencyPropertyKey>, тогда как <xref:System.Windows.DependencyProperty.RegisterAttached%2A> возвращает тип <xref:System.Windows.DependencyProperty>. Как правило, ключи, представляющие свойства только для чтения не становятся открытым, поскольку ключи можно использовать для задания значения свойства зависимостей, вызвав <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Структура класса повлияет вашим требованиям, но обычно рекомендуется ограничить доступ и видимость любого <xref:System.Windows.DependencyPropertyKey> для только те части кода, которые необходимы для установки этого свойства зависимостей как часть логики класса или приложения. Кроме того, рекомендуется предоставить идентификатор свойства зависимостей для свойства зависимостей только для чтения, обеспечивая значение <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> как `public static readonly` поля в вашем классе.  
  
 Вложенные свойства только для чтения используются редко, так как его использование в основной скрипт для вложенного свойства [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Без открытого переключателя невозможно задать присоединенное свойство в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] синтаксиса.  
  
 Дополнительные сведения о регистрации свойств зависимостей см. в разделе <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Использование RegisterAttached для наследования значения свойств зависимостей  
 Один из сценариев регистрации свойств зависимостей как вложенного заключается в поддержке наследования значения свойства. Необходимо зарегистрировать наследование значения свойства зависимостей с <xref:System.Windows.DependencyProperty.RegisterAttached%2A> даже если класс определяет оболочку свойствам, которые предоставляют свойство зависимостей, и даже если не требуется предоставлять Get * и набор * статические методы для предоставления присоединенного значение true Поддержка доступа к свойствам.   Несмотря на то, что наследование значения свойства могут быть выполнены для неприсоединенных свойств зависимости, поведение наследования для неприсоединенного свойства в определенных границах элемента в дереве среды выполнения не определено. Регистрация свойства как вложенного фактически делает вложенное свойство глобальным для системы свойств и гарантирует, что наследование значения свойства работает через все границы в дереве элементов. Всегда используйте <xref:System.Windows.DependencyProperty.RegisterAttached%2A> для регистрации свойства, где указываются <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> в метаданных. Дополнительные сведения см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <param name="defaultMetadata">Метаданные свойства зависимостей.</param>
        <param name="validateValueCallback">Ссылка на созданный пользователем обратный вызов, который должен выполнить пользовательскую проверку значения свойства зависимостей после обычной проверки типа.</param>
        <summary>Регистрирует доступное только для чтения присоединенное свойство с указанным типом свойства, типом владельца, метаданными свойства и обратным вызовом для проверки.</summary>
        <returns>Ключ свойства зависимостей, который следует использовать для задания значения статического доступного только для чтения поля в вашем классе, которое затем используется для ссылки на свойство зависимостей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает тип <xref:System.Windows.DependencyPropertyKey>, тогда как <xref:System.Windows.DependencyProperty.RegisterAttached%2A> возвращает тип <xref:System.Windows.DependencyProperty>. Как правило, ключи, представляющие тип <xref:System.Windows.DependencyProperty>. Как правило, ключи, представляющие свойства только для чтения не становятся открытым, поскольку ключи можно использовать для задания значения свойства зависимостей, вызвав <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Структура класса повлияет вашим требованиям, но обычно рекомендуется ограничить доступ и видимость любого <xref:System.Windows.DependencyPropertyKey> для только те части кода, которые необходимы для установки этого свойства зависимостей как часть логики класса или приложения. Кроме того, рекомендуется предоставить идентификатор свойства зависимостей для свойства зависимостей только для чтения, обеспечивая значение <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> как `public static readonly` поля в вашем классе.  
  
 Вложенные свойства только для чтения используются редко, так как его использование в основной скрипт для вложенного свойства [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Без открытого переключателя невозможно задать присоединенное свойство в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] синтаксиса.  
  
 Дополнительные сведения о регистрации свойств зависимостей см. в разделе <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Использование RegisterAttached для наследования значения свойств зависимостей  
 Один из сценариев регистрации свойств зависимостей как подключенные вместо <xref:System.Windows.DependencyProperty.Register%2A> предназначен для поддержки наследования значения свойства. Необходимо зарегистрировать наследование значения свойства зависимостей с <xref:System.Windows.DependencyProperty.RegisterAttached%2A> даже если класс определяет оболочку свойствам, которые предоставляют свойство зависимостей, и даже если не требуется предоставлять Get * и набор * статические методы для предоставления присоединенного значение true Поддержка доступа к свойствам.   Несмотря на то, что наследование значения свойства могут быть выполнены для неприсоединенных свойств зависимости, поведение наследования для неприсоединенного свойства в определенных границах элемента в дереве среды выполнения не определено. Регистрация свойства как вложенного фактически делает вложенное свойство глобальным для системы свойств и гарантирует, что наследование значения свойства работает через все границы в дереве элементов. Всегда используйте <xref:System.Windows.DependencyProperty.RegisterAttached%2A> для регистрации свойства, где указываются <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> в метаданных. Дополнительные сведения см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Регистрирует свойство зависимостей как свойство зависимостей только для чтения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <param name="typeMetadata">Метаданные свойства зависимостей.</param>
        <summary>Регистрирует доступное только для чтения свойство зависимостей с указанным типом свойства, типом владельца и метаданными свойства.</summary>
        <returns>Ключ свойства зависимостей, который следует использовать для задания значения статического доступного только для чтения поля в вашем классе, которое затем используется для ссылки на свойство зависимостей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает тип <xref:System.Windows.DependencyPropertyKey>, тогда как <xref:System.Windows.DependencyProperty.RegisterAttached%2A> возвращает тип <xref:System.Windows.DependencyProperty>. Как правило, ключи, представляющие свойства только для чтения не становятся открытым, поскольку ключи можно использовать для задания значения свойства зависимостей, вызвав <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Структура класса повлияет вашим требованиям, но обычно рекомендуется ограничить доступ и видимость любого <xref:System.Windows.DependencyPropertyKey> для только те части кода, которые необходимы для установки этого свойства зависимостей как часть логики класса или приложения. Кроме того, рекомендуется предоставить идентификатор свойства зависимостей для свойства зависимостей только для чтения, обеспечивая значение <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> как `public static readonly` поля в вашем классе.  
  
 Свойства зависимости только для чтения, это весьма распространенный сценарий как в существующем [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] и сценарии настройки, так как другие [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] функциям может требоваться свойство зависимостей, даже если это свойство не планируется сделать доступным для установки по вызывающие объекты. Значение свойства зависимости только для чтения можно использовать как основу для других операций системы свойств, принимающих свойство зависимостей, например основан <xref:System.Windows.Trigger> для свойства зависимостей в стиле.  
  
 Дополнительные сведения о регистрации свойств зависимостей см. в разделе <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 В следующем примере регистрируется `AquariumSize` свойство зависимостей только для чтения. В примере определяется `AquariumSizeKey` как внутренний ключ (, чтобы другие классы в сборке могли переопределять метаданные) и предоставляет идентификатор свойства зависимостей на основе такого ключа как `AquariumSizeProperty`. Кроме того, создается программа-оболочка для `AquariumSize`, с помощью только метод доступа get.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">Имя регистрируемого свойства зависимостей.</param>
        <param name="propertyType">Тип свойства.</param>
        <param name="ownerType">Тип владельца, регистрирующий свойство зависимостей.</param>
        <param name="typeMetadata">Метаданные свойства зависимостей.</param>
        <param name="validateValueCallback">Ссылка на созданный пользователем обратный вызов, который должен выполнить пользовательскую проверку значения свойства зависимостей после обычной проверки типа.</param>
        <summary>Регистрирует доступное только для чтения свойство зависимостей с указанным типом свойства, типом владельца, метаданными свойства и обратным вызовом для проверки.</summary>
        <returns>Ключ свойства зависимостей, который следует использовать для задания значения статического доступного только для чтения поля в вашем классе, которое затем используется для ссылки на свойство зависимостей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает тип <xref:System.Windows.DependencyPropertyKey>, тогда как <xref:System.Windows.DependencyProperty.RegisterAttached%2A> возвращает тип <xref:System.Windows.DependencyProperty>. Как правило, ключи, представляющие свойства только для чтения не становятся открытым, поскольку ключи можно использовать для задания значения свойства зависимостей, вызвав <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Структура класса повлияет вашим требованиям, но обычно рекомендуется ограничить доступ и видимость любого <xref:System.Windows.DependencyPropertyKey> для только те части кода, которые необходимы для установки этого свойства зависимостей как часть логики класса или приложения. Кроме того, рекомендуется предоставить идентификатор свойства зависимостей для свойства зависимостей только для чтения, обеспечивая значение <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> как `public static readonly` поля в вашем классе.  
  
 Свойства зависимости только для чтения — это весьма распространенный сценарий. Значение свойства зависимости только для чтения можно использовать как основу для других операций системы свойств, принимающих свойство зависимостей, например основан <xref:System.Windows.Trigger> для свойства зависимостей в стиле.  
  
 Дополнительные сведения о регистрации свойств зависимостей см. в разделе <xref:System.Windows.DependencyProperty>.  
  
 Проверка на доступное только для чтения свойство зависимостей может быть менее важна. Уровень доступа к закрытым, заданный для ключа снижает вероятность произвольного недопустимого ввода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает строковое представление свойства зависимостей.</summary>
        <returns>Строковое представление свойства зависимостей.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта реализация возвращает <xref:System.Windows.DependencyProperty.Name%2A> значение свойства.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Задает статическое значение, используемое системой свойств [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] вместо <see langword="null" /> для указания того, что свойство существует, но его значение не задано системой свойств.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyProperty.UnsetValue> имеет значение-метку, который используется для сценариев, где [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] системы свойств не может определить запрошенный <xref:System.Windows.DependencyProperty> значение. <xref:System.Windows.DependencyProperty.UnsetValue> используется вместо `null`, так как `null` может быть является допустимым значением свойства, а также является допустимым (и часто используемые) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> никогда не возвращается из <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>. При вызове <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType> для свойства зависимостей на <xref:System.Windows.DependencyObject> применяется экземпляр, одно из следующих:  
  
-   Свойство зависимости имеет значение по умолчанию, установленное в метаданных и возвращается это значение. Это значение может быть получено из <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
-   Системой свойств установлено другое значение и значение по умолчанию больше не нужны. Дополнительные сведения см. в разделе [Приоритет значений свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Установка <xref:System.Windows.PropertyMetadata.DefaultValue%2A> из <xref:System.Windows.DependencyProperty.UnsetValue> специально не разрешено.  
  
 <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> Возвращает <xref:System.Windows.DependencyProperty.UnsetValue> Если запрошенное свойство не задано локально.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> имеет особое значение при использовании в качестве возвращаемого значения <xref:System.Windows.CoerceValueCallback>. Дополнительные сведения см. в разделе [обратных вызовах свойства зависимости и проверки](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 При привязке к базе данных, обратите внимание, что <xref:System.Windows.DependencyProperty.UnsetValue> не эквивалентен <xref:System.DBNull.Value>, аналогично тому, как <xref:System.DBNull.Value> не соответствует параметру значение true, значение null.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает обратный вызов для проверки значения свойства зависимостей.</summary>
        <value>Обратный вызов для проверки значения данного свойства зависимостей, указанный параметром <paramref name="validateValueCallback" /> при изначальной регистрации свойства зависимостей.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство будет содержать `null` для любого свойства зависимостей без зарегистрированного обратного вызова проверки.  
  
 Проверить значение обратные вызовы должны действовать статически: проверка, применяемая через <xref:System.Windows.ValidateValueCallback> не может определить, является ли указанное значение допустимым для какой-либо экземпляр. Обратный вызов может только определить, следует ли все объекты, которые обладают свойством зависимостей, или не должен принимать указанное значение как допустимое. Если необходимо выполнять проверку, полагаясь на знание значений других свойств зависимостей в определенном экземпляре, используйте <xref:System.Windows.CoerceValueCallback> вместо него. <xref:System.Windows.CoerceValueCallback> Зарегистрирован как часть метаданных свойства зависимостей, а не непосредственно в идентификатор свойства зависимостей. Дополнительные сведения см. в разделе [обратных вызовах свойства зависимости и проверки](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>