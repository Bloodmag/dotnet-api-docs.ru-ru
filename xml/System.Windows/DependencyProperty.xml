<Type Name="DependencyProperty" FullName="System.Windows.DependencyProperty">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f9af7c7588dee4a02565170423aec4646b42e947" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37550313" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DependencyProperty" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyProperty extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyProperty" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyProperty" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyProperty sealed" />
  <TypeSignature Language="F#" Value="type DependencyProperty = class" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.TypeConverter("System.Windows.Markup.DependencyPropertyConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.ValueSerializer(typeof(System.Windows.DependencyPropertyValueSerializer))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a property that can be set through methods such as, styling, data binding, animation, and inheritance.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Windows.DependencyProperty> поддерживает следующие возможности в [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]:  
  
-   Свойство может быть задано в стиле. Более подробную информацию см. в разделе [Стилизация и использование шаблонов](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
-   Свойство может устанавливаться через привязку данных. Дополнительные сведения о свойствах зависимостей привязки данных, см. в разделе [как: привязка свойств двух элементов управления](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md).  
  
-   Свойство может быть задано со ссылкой на динамический ресурс. Дополнительные сведения см. в разделе [Ресурсы XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
-   Свойство может наследовать свое значение автоматически от родительского элемента в дереве элементов. Дополнительные сведения см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
-   Свойства могут быть анимированы. Более подробную информацию см. в разделе [Общие сведения об эффектах анимации](~/docs/framework/wpf/graphics-multimedia/animation-overview.md).  
  
-   Свойство может сообщать, когда предыдущее значение свойства было изменено, и можно ли привести значение свойства. Дополнительные сведения см. в разделе [Проверка и обратные вызовы свойства зависимостей](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
-   Свойство сообщает информацию для [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], такие как изменение значения свойства следует, требуется ли системе макета, чтобы представлять визуализации для элемента.  
  
-   Свойство получает поддержки в [!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)].  Например, можно изменить свойство в **свойства** окна.  
  
 Дополнительные сведения о свойствах зависимостей см. в разделе [Общие сведения о свойствах зависимостей](~/docs/framework/wpf/advanced/dependency-properties-overview.md). Если вы хотите свойства на пользовательские типы для поддержки возможностей в списке выше, следует создать свойство зависимостей.  Чтобы научиться создавать пользовательские свойства взаимозависимости, см. в разделе [пользовательские свойства зависимости](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
 Присоединенное свойство — это свойство, которое включает любой объект, чтобы сообщить сведения о тип, который определяет присоединенное свойство. В [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)], любой тип, наследующий от <xref:System.Windows.DependencyObject> можно использовать независимо от того, является ли тип наследуется от типа, который определяет свойство присоединенное свойство. Присоединенное свойство — это функция [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] языка.  Чтобы задать присоединенное свойство в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], использовать *Тип_владельца*.* propertyName* синтаксис. Пример присоединенного свойства — <xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType> свойство. Если вы хотите создать свойство, которое может использоваться на всех <xref:System.Windows.DependencyObject> типов, а затем следует создавать присоединенное свойство. Дополнительные сведения о вложенных свойствах, в том числе о способах их создания, см. в разделе [зависимостей](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
<a name="xamlAttributeUsage_DependencyProperty"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object property="dependencyPropertyName"/>  
- or -  
<object property="ownerType.dependencyPropertyName"/>  
- or -  
<object property="attachedPropertyOwnerType.attachedPropertyName"/>  
```  
  
<a name="xamlValues_DependencyProperty"></a>   
## <a name="xaml-values"></a>Значения XAML  
 `dependencyPropertyName`  
 Строка, указывающая <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType> свойства нужные зависимости. Это может стоять префикс пространства имен XML, если свойство не существует в пространстве имен XML по умолчанию (Дополнительные сведения см. в разделе [пространства имен XAML и сопоставление пространств имен для WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md).)  
  
 `ownerType`.`dependencyPropertyName`  
 Строка, указывающая тип владельца свойства зависимостей, точка (.), а затем <xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType>. `ownerType` может также предшествовать префикс пространства имен XML. Такое использование конкретной с поздним связыванием стили и шаблоны, где необходимо указать владельца свойства зависимостей для синтаксического анализа контекста, так как `TargetType` еще не известна. Более подробную информацию см. в разделе [Стилизация и использование шаблонов](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
 `attachedPropertyOwnerType` *.* `attachedPropertyName`  
 Строковое значение, указывающее владельца присоединенного свойства, точка (.), а затем имя вложенного свойства. `attachedPropertyOwnerType` может также предшествовать префикс пространства имен XML.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.DependencyPropertyHelper" />
  </Docs>
  <Members>
    <MemberGroup MemberName="AddOwner">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Adds another type as an owner of a dependency property that has already been registered to a type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner ownerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="ownerType">The type to add as an owner of this dependency property.</param>
        <summary>Adds another type as an owner of a dependency property that has already been registered.</summary>
        <returns>A reference to the original <see cref="T:System.Windows.DependencyProperty" /> identifier that identifies the dependency property. This identifier should be exposed by the adding class as a <see langword="public static readonly" /> field.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод позволяет системе свойств для распознавания свойства зависимостей для типа, который изначально не зарегистрировано это конкретное свойство зависимостей.  
  
 Как правило <xref:System.Windows.DependencyProperty.AddOwner%2A> используется для добавления свойств зависимостей в классах, которые еще не предоставляют свойство зависимости через наследование управляемого класса (наследование класса вызовет свойства оболочки должны наследоваться от базового класса и, следовательно, разрешающие общей таблицы элементов доступ к свойству зависимостей уже). <xref:System.Windows.DependencyProperty.AddOwner%2A> позволяет системе свойств для распознавания свойства зависимостей для типа, который не зарегистрировало свойства зависимости, что изначально.  
  
 Эта подпись не позволяет указывать метаданные.  При использовании этого метода, автоматически создаются метаданные для нового <xref:System.Windows.DependencyProperty> и типом владельца. Метаданные автоматически генерируемым является результатом объединения метаданных из всех базовых типов, которые определено это свойство. Если нет объединенных метаданных, то используется значение по умолчанию метаданные для свойства. Если данное свойство зарегистрировано с помощью <xref:System.Windows.DependencyProperty.RegisterAttached%2A> метод, то метаданные по умолчанию совпадает со значением метаданных, который создается при <xref:System.Windows.DependencyProperty.RegisterAttached%2A> был вызван. В противном случае <xref:System.Windows.PropertyMetadata> создается объект с <xref:System.Windows.PropertyMetadata.DefaultValue%2A> свойство, значение по умолчанию тип свойства, а все остальные свойства <xref:System.Windows.PropertyMetadata> присваивается `null`. Используйте <xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29> подписи, если вы хотите предоставить метаданные для версии свойства зависимостей по мере добавления в указанный тип.  
  
 Возвращаемое значение этого метода обычно используется для объявления и предоставления свойства зависимостей, сохраняя идентификатор свойства зависимостей. Идентификатор предоставляет доступ к свойству зависимостей, если вы хотите вызвать системы свойств [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] со свойством зависимостей, особенно, когда он существует на добавляемый класс владельца. То же имя свойства для первоначального владельца и добавление владельца должен использоваться для указания аналогичную функциональность. Следует использовать <xref:System.Windows.DependencyProperty> возвращаемое значение <xref:System.Windows.DependencyProperty.AddOwner%2A> метод для определения идентификатора свойства зависимости, а также для объявления [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] оболочки свойства для свойства зависимостей, которые добавляются к типам с помощью <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 <xref:System.Windows.DependencyProperty.AddOwner%2A> Методологии, рекомендованная выше используется при создании свойства зависимостей, объявленных в [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. Например, оба <xref:System.Windows.Controls.Border> и <xref:System.Windows.Controls.Control> определить `BorderBrush` свойство зависимостей, которое имеют схожие функции. <xref:System.Windows.Controls.Control> определяет его `BorderBrush` свойства в системе свойств путем вызова <xref:System.Windows.DependencyProperty.AddOwner%2A> зависимости от первоначального владельца <xref:System.Windows.Controls.Border> и его зарегистрированных <xref:System.Windows.Controls.Border.BorderBrushProperty> идентификатор свойства зависимостей. <xref:System.Windows.DependencyProperty.AddOwner%2A> Возвращают значение используется для установления новую статическую <xref:System.Windows.DependencyProperty> поле (<xref:System.Windows.Controls.Control.BorderBrushProperty>) для этого свойства на добавление владельца и `BorderBrush` оболочки свойства также объявляется.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOwner">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty AddOwner (Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.DependencyProperty AddOwner(class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Function AddOwner (ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::DependencyProperty ^ AddOwner(Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.AddOwner : Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="dependencyProperty.AddOwner (ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="ownerType">The type to add as owner of this dependency property.</param>
        <param name="typeMetadata">The metadata that qualifies the dependency property as it exists on the provided type.</param>
        <summary>Adds another type as an owner of a dependency property that has already been registered, providing dependency property metadata for the dependency property as it will exist on the provided owner type.</summary>
        <returns>A reference to the original <see cref="T:System.Windows.DependencyProperty" /> identifier that identifies the dependency property. This identifier should be exposed by the adding class as a <see langword="public static readonly" /> field.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод позволяет системе свойств для распознавания свойства зависимостей для типа, который изначально не зарегистрировано это конкретное свойство зависимостей.  
  
 Возвращаемое значение этого метода используется для объявления и предоставления свойства зависимостей, особенно в том случае, как оно существует в добавляемом классе владельца. Как правило одно и то же имя свойства для первоначального владельца и добавление владельца должен использоваться для указания аналогичную функциональность. Рекомендуется для предоставления идентификаторов, а также новые [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] оболочки свойства для свойства зависимостей, которые добавляются к типам с помощью <xref:System.Windows.DependencyProperty.AddOwner%2A>.  
  
 <xref:System.Windows.DependencyProperty.AddOwner%2A> Методологии, рекомендованная выше используется при создании [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)] объявлены внутри [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]. Например, оба <xref:System.Windows.Controls.Border> и <xref:System.Windows.Controls.Control> определить `BorderBrush` свойство зависимостей, которое имеют схожие функции. <xref:System.Windows.Controls.Control> определяет его `BorderBrush` свойства в системе свойств путем вызова <xref:System.Windows.DependencyProperty.AddOwner%2A> на оригинал <xref:System.Windows.Controls.Border> и его зарегистрированных <xref:System.Windows.Controls.Border.BorderBrushProperty> идентификатор свойства зависимостей. <xref:System.Windows.DependencyProperty.AddOwner%2A> Возвращают значение используется для установления статический <xref:System.Windows.DependencyProperty> поле (<xref:System.Windows.Controls.Control.BorderBrushProperty>) для этого свойства на добавление владельца и `BorderBrush` оболочки свойства также объявляется.  
  
 Идентификатор свойства зависимостей добавление владельца следует использовать для операций, таких как <xref:System.Windows.DependencyObject.GetValue%2A>. Тем не менее, определенного типа операции, предполагающие или типов экземпляров класса, который был добавлен как владелец с разными метаданными будет по-прежнему возвращать даже если ожидаемые результаты исходного (не добавлены владельца) указанный идентификатор свойства зависимостей в вызовы методов, например <xref:System.Windows.DependencyObject.GetValue%2A> или <xref:System.Windows.DependencyProperty.GetMetadata%2A>. Метаданные для Добавление владельца сохраняются по <xref:System.Windows.DependencyProperty.AddOwner%2A> вызвать сам себя, ссылается не обязательно исключительно поле идентификатора класса Добавление владельца. Тем не менее, рекомендуется предоставить идентификатор, а также новые [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] оболочки свойства для свойства зависимостей, которые добавляются к типам с помощью <xref:System.Windows.DependencyProperty.AddOwner%2A>, поскольку сделано несоответствие между [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] и [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] представления свойств.  
  
 Предоставленных метаданных объединяются с метаданные свойства зависимостей, как оно существует в базовом владельце. Характеристики, которые были указаны в исходных базовых метаданных, сохранятся. Только характеристики, которые специально были изменены в новых метаданных, переопределят характеристики базовых метаданных. Некоторые характеристики, такие как <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, заменяются в случае, если они указаны в новые метаданные. Другие, такие как <xref:System.Windows.PropertyChangedCallback>, объединяются. В конечном счете, поведение при объединении зависит от типа метаданных свойства используется для переопределения, поэтому поведения, описанного здесь не для существующих классов метаданных свойств, используемых [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] свойств зависимостей. Дополнительные сведения см. в разделе [метаданные свойства зависимости](~/docs/framework/wpf/advanced/dependency-property-metadata.md) и [метаданные свойств среды](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata DefaultMetadata { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyMetadata DefaultMetadata" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DefaultMetadata As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyMetadata ^ DefaultMetadata { System::Windows::PropertyMetadata ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultMetadata : System.Windows.PropertyMetadata" Usage="System.Windows.DependencyProperty.DefaultMetadata" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the default metadata of the dependency property.</summary>
        <value>По умолчанию метаданные свойства зависимостей.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метаданные по умолчанию — это метаданные свойства, доступные для определенного объекта или объект производного типа, где альтернативные метаданные не предоставлен явно <xref:System.Windows.DependencyProperty.Register%2A> или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> вызова.  
  
 Если исходный владелец применения метаданных к первому <xref:System.Windows.DependencyProperty.Register%2A> вызова, которое установлено свойство зависимостей, то эти метаданные возвращаются в виде <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
 Если метаданные не был применен в исходном <xref:System.Windows.DependencyProperty.Register%2A> вызова, то метаданные по умолчанию создается изнутри <xref:System.Windows.DependencyProperty.Register%2A> вызов и это значение возвращается в виде <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
 Основной цели по умолчанию метаданные, связанные с <xref:System.Windows.DependencyProperty> — предоставить значение по умолчанию для этого свойства для какого-либо <xref:System.Windows.DependencyObject> или производный тип.  
  
 Для неприсоединенных свойств тип метаданных, возвращенный этим свойством не может быть приведен к производным типам из <xref:System.Windows.PropertyMetadata> тип, даже если свойство было изначально зарегистрировано с производным типом метаданных. Если требуется первоначально зарегистрированные метаданные, включая его исходному типу возможно производных метаданных, вызовите <xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29> вместо этого, передача исходной регистрации введите в качестве параметра.  
  
 Для присоединенных свойств тип метаданных, возвращенный этим свойством будет соответствовать тип, заданный в исходном <xref:System.Windows.DependencyProperty.RegisterAttached%2A> метод регистрации.  
  
   
  
## Examples  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpdefaultvalue)]
[!code-vb[PropertySystemEsoterics#DPDefaultValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpdefaultvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="dependencyProperty.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a hash code for this <see cref="T:System.Windows.DependencyProperty" />.</summary>
        <returns>The hash code for this <see cref="T:System.Windows.DependencyProperty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Система свойств использует свой собственный уникальный идентификатор <xref:System.Windows.DependencyProperty.GlobalIndex%2A>, и значение этого свойства возвращается <xref:System.Windows.DependencyProperty.GetHashCode%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Returns the metadata associated with this dependency property as it exists for a particular type. This can be the type where the dependency property was first registered, one to which it was added subsequently, or a type where the dependency property was obtained through inheritance but the metadata was specifically overridden.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (Type forType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Type forType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMetadata (forType As Type) As PropertyMetadata" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(Type ^ forType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : Type -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata forType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="forType">The specific type from which to retrieve the dependency property metadata.</param>
        <summary>Returns the metadata for this dependency property as it exists on a specified existing type.</summary>
        <returns>A property metadata object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Указание типа или ссылка на объект для использования в качестве типа является необходимым, поскольку метаданные могут отличаться от исходной регистрации ввиду <xref:System.Windows.DependencyProperty.AddOwner%2A> или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> вызовы, изменять метаданные свойства зависимостей, как оно существует в типе.  
  
   
  
## Examples  
 В следующем примере возвращаются метаданные для свойства зависимостей, в зависимости от его типа. Этот тип получается с помощью `typeof` оператор.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatatype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatatype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObject -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">A dependency object that is checked for type, to determine which type-specific version of the dependency property the metadata should come from.</param>
        <summary>Returns the metadata for this dependency property as it exists on the specified object instance.</summary>
        <returns>A property metadata object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Указание типа или ссылка на объект необходима, так как метаданные любое заданное свойство зависимостей может варьироваться от исходной регистрации ввиду <xref:System.Windows.DependencyProperty.AddOwner%2A> или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> вызовов, которые можно уточнить метаданные свойства, как оно существует в тип.  
  
 При запросе метаданных свойства на основе экземпляра, это просто передаются экземпляр таким образом, чтобы его тип может вычисляться внутренним образом. Метаданные свойства зависимостей не зависит от конкретного экземпляра; всегда является согласованным для любой комбинации типа и свойства.  
  
   
  
## Examples  
 В следующем примере возвращаются метаданные для свойства зависимостей, в зависимости от конкретного <xref:System.Windows.DependencyObject> экземпляра.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadoinstance)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOInstance](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadoinstance)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMetadata">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyMetadata GetMetadata (System.Windows.DependencyObjectType dependencyObjectType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.PropertyMetadata GetMetadata(class System.Windows.DependencyObjectType dependencyObjectType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::PropertyMetadata ^ GetMetadata(System::Windows::DependencyObjectType ^ dependencyObjectType);" />
      <MemberSignature Language="F#" Value="member this.GetMetadata : System.Windows.DependencyObjectType -&gt; System.Windows.PropertyMetadata" Usage="dependencyProperty.GetMetadata dependencyObjectType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyMetadata</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObjectType" Type="System.Windows.DependencyObjectType" />
      </Parameters>
      <Docs>
        <param name="dependencyObjectType">A specific object that records the dependency object type from which the dependency property metadata is desired.</param>
        <summary>Returns the metadata for this dependency property as it exists on a specified type.</summary>
        <returns>A property metadata object.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Указание типа или ссылка на объект необходима, так как метаданные любое заданное свойство зависимостей может варьироваться от исходной регистрации ввиду <xref:System.Windows.DependencyProperty.AddOwner%2A> или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> вызовов, которые можно уточнить метаданные свойства, как оно существует в тип.  
  
   
  
## Examples  
 В следующем примере возвращаются метаданные для свойства зависимостей, на основе его <xref:System.Windows.DependencyObjectType>.  
  
 [!code-csharp[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/default.xaml.cs#getmetadatadotype)]
 [!code-vb[PropertySystemEsoterics#GetMetadataDOType](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/default.xaml.vb#getmetadatadotype)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GlobalIndex">
      <MemberSignature Language="C#" Value="public int GlobalIndex { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GlobalIndex" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.GlobalIndex" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property GlobalIndex As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int GlobalIndex { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalIndex : int" Usage="System.Windows.DependencyProperty.GlobalIndex" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an internally generated value that uniquely identifies the dependency property.</summary>
        <value>Уникальный числовой идентификатор.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это значение является целым числом, не является глобальным уникальным идентификатором (GUID). Как правило это значение индекса не является обязательным, и нет индекс доступа к таблицам всех свойств зависимостей. Свойства зависимостей вместо этого следует ссылаться их идентификатор поля.  
  
 <xref:System.Windows.DependencyProperty.GlobalIndex%2A> используется внутренне для более быстрого доступа к структурам данных, использующих <xref:System.Windows.DependencyProperty.GlobalIndex%2A> как массив, начинающийся с нуля индекс. Подобное использование может применяться для конструкторов или инструментов.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidType">
      <MemberSignature Language="C#" Value="public bool IsValidType (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidType(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidType (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidType(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidType : obj -&gt; bool" Usage="dependencyProperty.IsValidType value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The value to check.</param>
        <summary>Determines whether a specified value is acceptable for this dependency property's type, as checked against the property type provided in the original dependency property registration.</summary>
        <returns>
          <see langword="true" /> if the specified value is the registered property type or an acceptable derived type; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение `null` является допустимым типом для свойств зависимостей ссылочного типа или <xref:System.Nullable%601> свойства зависимостей и вернет `true` в этих случаях. В случаях, когда свойство зависимостей является ни ссылку и не является <xref:System.Nullable%601> типа, <xref:System.Windows.DependencyProperty.IsValidType%2A> вернет `false` значение null, а не создавать исключение.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Windows.DependencyProperty.IsValidType%2A> как средство проверки перед вызовом метода <xref:System.Windows.DependencyObject.SetValue%2A> для свойства зависимостей.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValue](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvalue)]
 [!code-vb[PropertySystemEsoterics#TrySetValue](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvalue)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsValidValue">
      <MemberSignature Language="C#" Value="public bool IsValidValue (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsValidValue(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.IsValidValue(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsValidValue (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsValidValue(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsValidValue : obj -&gt; bool" Usage="dependencyProperty.IsValidValue value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">The value to check.</param>
        <summary>Determines whether the provided value is accepted for the type of property through basic type checking, and also potentially if it is within the allowed range of values for that type.</summary>
        <returns>
          <see langword="true" /> if the value is acceptable and is of the correct type or a derived type; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для свойства зависимостей, можно указать разрешенный диапазон значений для этого типа с помощью <xref:System.Windows.ValidateValueCallback> , предоставляется при регистрации свойства зависимостей.  
  
 Этот метод вызывает метод <xref:System.Windows.DependencyProperty.IsValidType%2A> внутренним образом. Если рассматриваемое свойство зависимости не имеет <xref:System.Windows.ValidateValueCallback>, то вызов этого метода является фактически эквивалентна вызову <xref:System.Windows.DependencyProperty.IsValidType%2A>. Если свойство зависимости имеет <xref:System.Windows.ValidateValueCallback>и если <xref:System.Windows.DependencyProperty.IsValidType%2A> возвращала бы `true`, то возвращаемое значение будет реализованное в обратный вызов.  
  
 Значение null является допустимым значением для свойства зависимостей типа ссылки или <xref:System.Nullable%601> свойства зависимостей и вернет `true` в этих случаях. В случаях, когда свойство зависимостей является ни ссылку и не является <xref:System.Nullable%601> типа, <xref:System.Windows.DependencyProperty.IsValidType%2A> вернет `false` значение null, а не создавать исключение.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Windows.DependencyProperty.IsValidValue%2A> как средство проверки перед вызовом метода <xref:System.Windows.DependencyObject.SetValue%2A> для свойства зависимостей.  
  
 [!code-csharp[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#trysetvaluewithvalidate)]
 [!code-vb[PropertySystemEsoterics#TrySetValueWithValidate](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#trysetvaluewithvalidate)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Windows.DependencyProperty.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the name of the dependency property.</summary>
        <value>Имя свойства.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает имя, предоставленное как `name` параметр во время регистрации свойства зависимостей. Это имя является неизменяемым и не может быть `null` или является пустой строкой. Повторяющееся имя регистрации на один и тот же тип владельца не разрешены и вызовет исключение при попытке зарегистрировать дубликат.  
  
> [!IMPORTANT]
>  <xref:System.Windows.DependencyProperty.Name%2A> Зависимости свойство должен соответствовать соглашению: соответствующее имени идентификатором свойства зависимостей без суффикса «Свойство». Дополнительные сведения см. в разделе [Пользовательские свойства зависимостей](~/docs/framework/wpf/advanced/custom-dependency-properties.md).  
  
   
  
## Examples  
 В следующем примере запрашивается различные характеристики идентификатор свойства зависимостей, включая <xref:System.Windows.DependencyProperty.Name%2A>.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OverrideMetadata">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Supplies alternate metadata for this dependency property when it is present on instances of a specified type, versus the metadata that was provided in the initial dependency property registration.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">The type where this dependency property is inherited and where the provided alternate metadata will be applied.</param>
        <param name="typeMetadata">The metadata to apply to the dependency property on the overriding type.</param>
        <summary>Specifies alternate metadata for this dependency property when it is present on instances of a specified type, overriding the metadata that existed for the dependency property as it was inherited from base types.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Система свойств использует свойства зависимостей, следует переопределить метаданные свойства зависимостей. Это соответствует времени, определенные экземпляры создаются с помощью класса, который регистрирует свойство зависимости. Вызовы <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> следует выполнять только в статических конструкторах типа, предоставляющего себя в качестве `forType` параметр этого метода, или с помощью аналогично при создании экземпляра. Попытка изменить метаданные после экземпляров для типа владельца не возникнет исключения, но приведет к несогласованному поведению системы свойств.  
  
 После того как метаданные для определенного производного класса переопределения установлено с помощью этого метода, последующие попытки переопределить метаданные для этого же производного класса будет выдано исключение.  
  
 Предоставленных метаданных объединяются с метаданные свойства зависимостей, как оно существует в базовом владельце. Характеристики, которые были указаны в исходные базовые метаданные сохраняются; только характеристики, которые специально были изменены в новых метаданных, переопределят характеристики базовых метаданных. Некоторые характеристики, такие как <xref:System.Windows.PropertyMetadata.DefaultValue%2A> заменяются, если указан в новых метаданных. Другие, такие как <xref:System.Windows.PropertyChangedCallback>, объединяются. В конечном счете, поведение при объединении зависит от типа метаданных свойства используется для переопределения, поэтому поведения, описанного здесь не для существующих классов метаданных свойств, используемых [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] свойств зависимостей. Дополнительные сведения см. в разделе [метаданные свойства зависимости](~/docs/framework/wpf/advanced/dependency-property-metadata.md) и [метаданные свойств среды](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">An attempt was made to override metadata on a read-only dependency property (that operation cannot be done using this signature).</exception>
        <exception cref="T:System.ArgumentException">Metadata was already established for the dependency property as it exists on the provided type.</exception>
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata, System.Windows.DependencyPropertyKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.DependencyPropertyKey key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata, key As DependencyPropertyKey)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::DependencyPropertyKey ^ key);" />
      <MemberSignature Language="F#" Value="member this.OverrideMetadata : Type * System.Windows.PropertyMetadata * System.Windows.DependencyPropertyKey -&gt; unit" Usage="dependencyProperty.OverrideMetadata (forType, typeMetadata, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="key" Type="System.Windows.DependencyPropertyKey" />
      </Parameters>
      <Docs>
        <param name="forType">The type where this dependency property is inherited and where the provided alternate metadata will be applied.</param>
        <param name="typeMetadata">The metadata to apply to the dependency property on the overriding type.</param>
        <param name="key">The access key for a read-only dependency property.</param>
        <summary>Supplies alternate metadata for a read-only dependency property when it is present on instances of a specified type, overriding the metadata that was provided in the initial dependency property registration. You must pass the <see cref="T:System.Windows.DependencyPropertyKey" /> for the read-only dependency property to avoid raising an exception.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта подпись предоставляет базовую реализацию для идентификатора свойства зависимости только для чтения (<xref:System.Windows.DependencyPropertyKey>) метод. Если переопределение метаданных для свойства зависимостей для чтения и записи, используйте <xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29>.  
  
 Система свойств использует свойства зависимостей, следует переопределить метаданные свойства зависимостей. Это соответствует времени создания конкретных объектов для класса, который регистрирует свойство зависимости. Вызовы <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> следует выполнять только в статических конструкторах типа, предоставляющего себя в качестве `forType` параметр этого метода, или с помощью аналогично при создании экземпляра. Попытка изменить метаданные после экземпляров для типа владельца не возникнет исключения, но приведет к несогласованному поведению системы свойств.  
  
 После того как метаданные для определенного производного класса переопределения установлено с помощью этого метода, последующие попытки переопределить метаданные для этого же производного класса будет выдано исключение.  
  
 Предоставленных метаданных объединяются с метаданные свойства зависимостей, как оно существует в базовом владельце. Характеристики, которые были указаны в исходные базовые метаданные сохраняются; только характеристики, которые специально были изменены в новых метаданных, переопределят характеристики базовых метаданных. Некоторые характеристики, такие как <xref:System.Windows.PropertyMetadata.DefaultValue%2A> заменяются, если указан в новых метаданных. Другие, такие как <xref:System.Windows.PropertyChangedCallback>, объединяются. Поведение при объединении зависит от используемого для переопределения типа метаданных свойства. Дополнительные сведения см. в разделе [метаданные свойства зависимости](~/docs/framework/wpf/advanced/dependency-property-metadata.md) и [метаданные свойств среды](~/docs/framework/wpf/advanced/framework-property-metadata.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OwnerType">
      <MemberSignature Language="C#" Value="public Type OwnerType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type OwnerType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.OwnerType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnerType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ OwnerType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OwnerType : Type" Usage="System.Windows.DependencyProperty.OwnerType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the type of the object that registered the dependency property with the property system, or added itself as owner of the property.</summary>
        <value>Тип объекта, зарегистрировавшего свойство или добавившего себя в качестве владельца свойства.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это значение было предоставлено во время регистрации свойства. Владельцем будет либо исходного регистрации типа в случае использования <xref:System.Windows.DependencyProperty> идентификатор, созданный из <xref:System.Windows.DependencyProperty.Register%2A> вызова либо тип, который добавившего себя в качестве владельца в случае использования <xref:System.Windows.DependencyProperty> идентификатор, созданный из <xref:System.Windows.DependencyProperty.AddOwner%2A> вызова.  
  
 <xref:System.Windows.DependencyProperty.OwnerType%2A> С заданным <xref:System.Windows.DependencyProperty> является постоянным и не может быть `null` в допустимое <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 В следующем примере возвращается тип владельца, в зависимости от идентификатора свойства зависимостей `dp`, а затем получает метаданные для типа владельца по тому же идентификатору. Эта операция фактически эквивалентна начало <xref:System.Windows.DependencyProperty.DefaultMetadata%2A> на `dp`.  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyType">
      <MemberSignature Language="C#" Value="public Type PropertyType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type PropertyType" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.PropertyType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PropertyType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Type ^ PropertyType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PropertyType : Type" Usage="System.Windows.DependencyProperty.PropertyType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the type that the dependency property uses for its value.</summary>
        <value>
          <see cref="T:System.Type" /> Значения свойства.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство сообщает тип значения свойства, объявленные в исходной регистрации свойства, через `propertyType` параметра. Аналогичную <xref:System.Windows.DependencyProperty.Name%2A>, тип свойства, свойства зависимостей, нельзя изменить после регистрации.  
  
   
  
## Examples  
 В следующем примере запрашивается различные характеристики идентификатор свойства зависимостей, включая <xref:System.Windows.DependencyProperty.PropertyType%2A>. Строка имени типа <xref:System.Windows.DependencyProperty.PropertyType%2A> получается из возвращаемого <xref:System.Type>.  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadOnly">
      <MemberSignature Language="C#" Value="public bool ReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ReadOnly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReadOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadOnly : bool" Usage="System.Windows.DependencyProperty.ReadOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the dependency property identified by this <see cref="T:System.Windows.DependencyProperty" /> instance is a read-only dependency property.</summary>
        <value>
          <see langword="true" /> Если свойство зависимостей только для чтения; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойства зависимостей только для чтения регистрируются в системе свойств путем вызова <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> метод, в отличие от <xref:System.Windows.DependencyProperty.Register%2A> метод. Вложенные свойства также можно зарегистрировать только для чтения; см. в разделе <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.  
  
 Свойства зависимостей только для чтения требуют <xref:System.Windows.DependencyPropertyKey> идентификатор вместо <xref:System.Windows.DependencyProperty> идентификатор для выполнения операций с метаданными, например переопределения метаданных или настройки значения. Если вы приобрели коллекцию <xref:System.Windows.DependencyProperty> идентификаторы, путем вызова <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> или другой [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] , предоставляющий идентификаторы, проверка <xref:System.Windows.DependencyProperty.ReadOnly%2A> значение перед повторным вызовом <xref:System.Windows.DependencyObject.SetValue%2A> или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> , используя идентификатор свойства зависимостей как входной параметр, чтобы убедиться, что свойства зависимостей, которое представляет идентификатор не только для чтения. Если значение <xref:System.Windows.DependencyProperty.ReadOnly%2A> — `true` в свойстве зависимости, не существует способа для получения ссылки на программный <xref:System.Windows.DependencyPropertyKey> идентификатор этого свойства зависимостей, из метаданных или <xref:System.Windows.DependencyProperty> идентификатор; идентификатор Чтобы выполнить вызов должен быть доступен как статическое поле <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29> свойством зависимостей только для чтения.  
  
 При создании настраиваемого свойства зависимостей и зарегистрировать его как доступный только для чтения, необходимо определить только метод доступа get для [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] свойства-оболочки. В противном случае класс получит несогласованную объектную модель для оболочки свойства по сравнению с доступом к свойству зависимостей резервного. Дополнительные сведения см. в разделе [пользовательские свойства зависимостей](~/docs/framework/wpf/advanced/custom-dependency-properties.md) или [свойств зависимостей только для чтения](~/docs/framework/wpf/advanced/read-only-dependency-properties.md).  
  
   
  
## Examples  
 Следующий пример получает метаданные по умолчанию и идентификатора свойства зависимостей из различных полей свойства зависимостей и использует данные для заполнения таблицы и реализации «обозревателя метаданных».  
  
 [!code-csharp[PropertySystemEsoterics#DPProps](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpprops)]
 [!code-vb[PropertySystemEsoterics#DPProps](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpprops)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Register">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registers a dependency property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register. The name must be unique within the registration namespace of the owner type.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <summary>Registers a dependency property with the specified property name, property type, and owner type.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о регистрации свойства зависимостей, см. в разделе <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 [!code-csharp[WPFAquariumSln#Register3Param](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#register3param)]
 [!code-vb[WPFAquariumSln#Register3Param](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#register3param)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Register (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="typeMetadata">Property metadata for the dependency property.</param>
        <summary>Registers a dependency property with the specified property name, property type, owner type, and property metadata.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о регистрации свойства зависимостей, см. в разделе <xref:System.Windows.DependencyProperty>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="Register">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty Register (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty Register(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ Register(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member Register : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.Register (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="typeMetadata">Property metadata for the dependency property.</param>
        <param name="validateValueCallback">A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</param>
        <summary>Registers a dependency property with the specified property name, property type, owner type, property metadata, and a value validation callback for the property.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о регистрации свойства зависимостей, см. в разделе <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 В следующем примере регистрируется свойство зависимости, включая обратный вызов проверки (определение обратного вызова не указывается; Дополнительные сведения об определении обратного вызова, см. в разделе <xref:System.Windows.ValidateValueCallback>).  
  
 [!code-csharp[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/csharp/VS_Snippets_Wpf/DPCallbackOverride/CSharp/SDKSampleLibrary/class1.cs#currentdefinitionwithwrapper)]
 [!code-vb[DPCallbackOverride#CurrentDefinitionWithWrapper](~/samples/snippets/visualbasic/VS_Snippets_Wpf/DPCallbackOverride/visualbasic/sdksamplelibrary/class1.vb#currentdefinitionwithwrapper)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttached">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registers an attached property with the property system.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <summary>Registers an attached property with the specified property name, property type, and owner type.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Присоединенное свойство — свойство понятием [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] реализует присоединенные свойства как свойства зависимости. Так как [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] присоединенные свойства являются свойствами зависимостей, они могут быть применены метаданные, который может использоваться системой свойств, общие для операций, например характеристики разметки для составления отчетов. Дополнительные сведения см. в разделе [Общие сведения о вложенных свойствах](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Дополнительные сведения о регистрации свойства зависимостей, см. в разделе <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 В следующем примере регистрируется присоединенного свойства в абстрактный класс, с помощью этого <xref:System.Windows.DependencyProperty.RegisterAttached%2A> подписи.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttached (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="defaultMetadata">Property metadata for the dependency property. This can include the default value as well as other characteristics.</param>
        <summary>Registers an attached property with the specified property name, property type, owner type, and property metadata.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Присоединенное свойство — свойство понятием [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] реализует присоединенные свойства как свойства зависимости. Так как [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] присоединенные свойства являются свойствами зависимостей, они могут быть применены метаданные, который может использоваться системой свойств, общие для операций, например характеристики разметки для составления отчетов. Дополнительные сведения см. в разделе [Общие сведения о вложенных свойствах](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Дополнительные сведения о регистрации свойства зависимостей, см. в разделе <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Использование RegisterAttached для наследования значения свойства зависимостей  
 Один из сценариев регистрации свойства зависимостей с <xref:System.Windows.DependencyProperty.RegisterAttached%2A> вместо <xref:System.Windows.DependencyProperty.Register%2A> предназначен для поддержки наследования значений свойств. Необходимо зарегистрировать наследования значения свойств зависимостей с помощью <xref:System.Windows.DependencyProperty.RegisterAttached%2A> даже, если класс определяет программы-оболочки к свойствам, которые предоставляют свойство зависимостей, и даже если не требуется предоставлять Get * и Set * статические методы для предоставления true подключен Поддержка доступа к свойствам.   Несмотря на то, что наследование значения свойства могут быть выполнены для неприсоединенных свойств зависимостей, поведение наследования для таких свойств через определенные границы элементов в дереве среды выполнения не определено. Регистрация свойства как вложенного фактически делает вложенное свойство глобальное свойство для системы свойств и гарантирует, что наследование значения свойства работает через все границы в дереве элементов. Всегда используйте <xref:System.Windows.DependencyProperty.RegisterAttached%2A> для регистрации вы зададите свойства <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> в метаданных. Дополнительные сведения см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterAttached">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyProperty RegisterAttached (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyProperty RegisterAttached(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyProperty ^ RegisterAttached(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttached : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyProperty" Usage="System.Windows.DependencyProperty.RegisterAttached (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="defaultMetadata">Property metadata for the dependency property. This can include the default value as well as other characteristics.</param>
        <param name="validateValueCallback">A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</param>
        <summary>Registers an attached property with the specified property type, owner type, property metadata, and value validation callback for the property.</summary>
        <returns>A dependency property identifier that should be used to set the value of a <see langword="public static readonly" /> field in your class. That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Присоединенное свойство — свойство понятием [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] реализует присоединенные свойства как свойства зависимости. Так как [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] присоединенные свойства являются свойствами зависимостей, они могут быть применены метаданные, который может использоваться системой свойств, общие для операций, например характеристики разметки для составления отчетов. Дополнительные сведения см. в разделе [Общие сведения о вложенных свойствах](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Дополнительные сведения о регистрации свойства зависимостей, см. в разделе <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Использование RegisterAttached для наследования значения свойства зависимостей  
 Один из сценариев регистрации свойства зависимостей с <xref:System.Windows.DependencyProperty.RegisterAttached%2A> вместо <xref:System.Windows.DependencyProperty.Register%2A> предназначен для поддержки наследования значений свойств. Необходимо зарегистрировать наследования значения свойств зависимостей с помощью <xref:System.Windows.DependencyProperty.RegisterAttached%2A> даже, если класс определяет программы-оболочки к свойствам, которые предоставляют свойство зависимостей, и даже если не требуется предоставлять Get * и Set * статические методы для предоставления true подключен Поддержка доступа к свойствам.   Несмотря на то, что наследование значения свойства могут быть выполнены для неприсоединенных свойств зависимостей, поведение наследования для таких свойств через определенные границы элементов в дереве среды выполнения не определено. Регистрация свойства как вложенного фактически делает вложенное свойство глобальное свойство для системы свойств и гарантирует, что наследование значения свойства работает через все границы в дереве элементов. Всегда используйте <xref:System.Windows.DependencyProperty.RegisterAttached%2A> для регистрации вы зададите свойства <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> в метаданных. Дополнительные сведения см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
   
  
## Examples  
 В следующем примере регистрируется присоединенного свойства в абстрактный класс, с помощью этого <xref:System.Windows.DependencyProperty.RegisterAttached%2A> подписи. Это вложенное свойство является свойством типа перечисления и регистрации добавляет обратный вызов проверки, чтобы убедиться, что переданное значение имеет значение перечисления.  
  
 [!code-csharp[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#registerattachedbubbler2)]
 [!code-vb[WPFAquariumSln#RegisterAttachedBubbler2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#registerattachedbubbler2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
        <altmember cref="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterAttachedReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registers a read-only attached property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterAttachedReadOnly (name As String, propertyType As Type, ownerType As Type, defaultMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="defaultMetadata">Property metadata for the dependency property.</param>
        <summary>Registers a read-only attached property, with the specified property type, owner type, and property metadata.</summary>
        <returns>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает тип <xref:System.Windows.DependencyPropertyKey>, тогда как <xref:System.Windows.DependencyProperty.RegisterAttached%2A> возвращает тип <xref:System.Windows.DependencyProperty>. Как правило, ключи, представляющие свойства только для чтения не сделаны открытыми, так как ключи можно использовать для задания значения свойства зависимостей путем вызова <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Структура класса повлияет на ваши требования, но обычно рекомендуется ограничить доступ и видимость любого <xref:System.Windows.DependencyPropertyKey> к только те части кода, которые необходимы для установки этого свойства зависимостей как часть класса или приложения логики. Кроме того, рекомендуется предоставлять идентификатор свойства зависимостей для свойства зависимостей только для чтения, предоставляя значение <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> как `public static readonly` на ваш класс.  
  
 Только для чтения присоединенные свойства являются редко, так как основным сценарием для присоединенного свойства является его использование в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Без открытого метода задания присоединенного свойства не могут определяться [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] синтаксис.  
  
 Дополнительные сведения о регистрации свойства зависимостей, см. в разделе <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Использование RegisterAttached для наследования значения свойства зависимостей  
 Один из сценариев регистрации свойства зависимостей как вложенного заключается в поддержке наследования значений свойств. Необходимо зарегистрировать наследования значения свойств зависимостей с помощью <xref:System.Windows.DependencyProperty.RegisterAttached%2A> даже, если класс определяет программы-оболочки к свойствам, которые предоставляют свойство зависимостей, и даже если не требуется предоставлять Get * и Set * статические методы для предоставления true подключен Поддержка доступа к свойствам.   Несмотря на то, что наследование значения свойства могут быть выполнены для неприсоединенных свойств зависимостей, поведение наследования для таких свойств через определенные границы элементов в дереве среды выполнения не определено. Регистрация свойства как вложенного фактически делает вложенное свойство глобальное свойство для системы свойств и гарантирует, что наследование значения свойства работает через все границы в дереве элементов. Всегда используйте <xref:System.Windows.DependencyProperty.RegisterAttached%2A> для регистрации вы зададите свойства <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> в метаданных. Дополнительные сведения см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterAttachedReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterAttachedReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata defaultMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterAttachedReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata defaultMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterAttachedReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ defaultMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterAttachedReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterAttachedReadOnly (name, propertyType, ownerType, defaultMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="defaultMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="defaultMetadata">Property metadata for the dependency property.</param>
        <param name="validateValueCallback">A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</param>
        <summary>Registers a read-only attached property, with the specified property type, owner type, property metadata, and a validation callback.</summary>
        <returns>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает тип <xref:System.Windows.DependencyPropertyKey>, тогда как <xref:System.Windows.DependencyProperty.RegisterAttached%2A> возвращает тип <xref:System.Windows.DependencyProperty>. Как правило, ключи, которые принадлежат к типу <xref:System.Windows.DependencyProperty>. Как правило, ключи, представляющие свойства только для чтения не сделаны открытыми, так как ключи можно использовать для задания значения свойства зависимостей путем вызова <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Структура класса повлияет на ваши требования, но обычно рекомендуется ограничить доступ и видимость любого <xref:System.Windows.DependencyPropertyKey> к только те части кода, которые необходимы для установки этого свойства зависимостей как часть класса или приложения логики. Кроме того, рекомендуется предоставлять идентификатор свойства зависимостей для свойства зависимостей только для чтения, предоставляя значение <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> как `public static readonly` на ваш класс.  
  
 Только для чтения присоединенные свойства являются редко, так как основным сценарием для присоединенного свойства является его использование в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]. Без открытого метода задания присоединенного свойства не могут определяться [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] синтаксис.  
  
 Дополнительные сведения о регистрации свойства зависимостей, см. в разделе <xref:System.Windows.DependencyProperty>.  
  
## <a name="use-registerattached-for-value-inheriting-dependency-properties"></a>Использование RegisterAttached для наследования значения свойства зависимостей  
 Один из сценариев регистрации свойства зависимостей, как прикрепить вместо <xref:System.Windows.DependencyProperty.Register%2A> предназначен для поддержки наследования значений свойств. Необходимо зарегистрировать наследования значения свойств зависимостей с помощью <xref:System.Windows.DependencyProperty.RegisterAttached%2A> даже, если класс определяет программы-оболочки к свойствам, которые предоставляют свойство зависимостей, и даже если не требуется предоставлять Get * и Set * статические методы для предоставления true подключен Поддержка доступа к свойствам.   Несмотря на то, что наследование значения свойства могут быть выполнены для неприсоединенных свойств зависимостей, поведение наследования для таких свойств через определенные границы элементов в дереве среды выполнения не определено. Регистрация свойства как вложенного фактически делает вложенное свойство глобальное свойство для системы свойств и гарантирует, что наследование значения свойства работает через все границы в дереве элементов. Всегда используйте <xref:System.Windows.DependencyProperty.RegisterAttached%2A> для регистрации вы зададите свойства <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> в метаданных. Дополнительные сведения см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterReadOnly">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Registers a dependency property as a read-only dependency property.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterReadOnly (name As String, propertyType As Type, ownerType As Type, typeMetadata As PropertyMetadata) As DependencyPropertyKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="typeMetadata">Property metadata for the dependency property.</param>
        <summary>Registers a read-only dependency property, with the specified property type, owner type, and property metadata.</summary>
        <returns>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает тип <xref:System.Windows.DependencyPropertyKey>, тогда как <xref:System.Windows.DependencyProperty.RegisterAttached%2A> возвращает тип <xref:System.Windows.DependencyProperty>. Как правило, ключи, представляющие свойства только для чтения не сделаны открытыми, так как ключи можно использовать для задания значения свойства зависимостей путем вызова <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Структура класса повлияет на ваши требования, но обычно рекомендуется ограничить доступ и видимость любого <xref:System.Windows.DependencyPropertyKey> к только те части кода, которые необходимы для установки этого свойства зависимостей как часть класса или приложения логики. Кроме того, рекомендуется предоставлять идентификатор свойства зависимостей для свойства зависимостей только для чтения, предоставляя значение <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> как `public static readonly` на ваш класс.  
  
 Свойства зависимостей только для чтения — это довольно типичный сценарий обоих в существующем [!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)] и сценарии настройки, так как другие [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] функциям может требоваться свойство зависимостей, даже если это свойство не должно устанавливаться по вызывающие объекты. Значение свойства зависимостей только для чтения можно использовать как основу для других операций системы свойств, которые принимают свойства зависимостей, таких как создание основе <xref:System.Windows.Trigger> для свойства зависимостей в стиле.  
  
 Дополнительные сведения о регистрации свойства зависимостей, см. в разделе <xref:System.Windows.DependencyProperty>.  
  
   
  
## Examples  
 В следующем примере регистрируется `AquariumSize` свойство зависимостей только для чтения. В примере определяется `AquariumSizeKey` как внутренний ключ (чтобы другие классы в сборке может переопределить метаданные) и предоставляет идентификатор свойства зависимостей на основе этого ключа как `AquariumSizeProperty`. Кроме того, создается оболочка для `AquariumSize`, с помощью только метода доступа get.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RegisterReadOnly">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyPropertyKey RegisterReadOnly (string name, Type propertyType, Type ownerType, System.Windows.PropertyMetadata typeMetadata, System.Windows.ValidateValueCallback validateValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyPropertyKey RegisterReadOnly(string name, class System.Type propertyType, class System.Type ownerType, class System.Windows.PropertyMetadata typeMetadata, class System.Windows.ValidateValueCallback validateValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyPropertyKey ^ RegisterReadOnly(System::String ^ name, Type ^ propertyType, Type ^ ownerType, System::Windows::PropertyMetadata ^ typeMetadata, System::Windows::ValidateValueCallback ^ validateValueCallback);" />
      <MemberSignature Language="F#" Value="static member RegisterReadOnly : string * Type * Type * System.Windows.PropertyMetadata * System.Windows.ValidateValueCallback -&gt; System.Windows.DependencyPropertyKey" Usage="System.Windows.DependencyProperty.RegisterReadOnly (name, propertyType, ownerType, typeMetadata, validateValueCallback)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="propertyType" Type="System.Type" />
        <Parameter Name="ownerType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="validateValueCallback" Type="System.Windows.ValidateValueCallback" />
      </Parameters>
      <Docs>
        <param name="name">The name of the dependency property to register.</param>
        <param name="propertyType">The type of the property.</param>
        <param name="ownerType">The owner type that is registering the dependency property.</param>
        <param name="typeMetadata">Property metadata for the dependency property.</param>
        <param name="validateValueCallback">A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</param>
        <summary>Registers a read-only dependency property, with the specified property type, owner type, property metadata, and a validation callback.</summary>
        <returns>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает тип <xref:System.Windows.DependencyPropertyKey>, тогда как <xref:System.Windows.DependencyProperty.RegisterAttached%2A> возвращает тип <xref:System.Windows.DependencyProperty>. Как правило, ключи, представляющие свойства только для чтения не сделаны открытыми, так как ключи можно использовать для задания значения свойства зависимостей путем вызова <xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29>. Структура класса повлияет на ваши требования, но обычно рекомендуется ограничить доступ и видимость любого <xref:System.Windows.DependencyPropertyKey> к только те части кода, которые необходимы для установки этого свойства зависимостей как часть класса или приложения логики. Кроме того, рекомендуется предоставлять идентификатор свойства зависимостей для свойства зависимостей только для чтения, предоставляя значение <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType> как `public static readonly` на ваш класс.  
  
 Свойства зависимостей только для чтения — довольно типичный сценарий. Значение свойства зависимостей только для чтения можно использовать как основу для других операций системы свойств, которые принимают свойства зависимостей, таких как создание основе <xref:System.Windows.Trigger> для свойства зависимостей в стиле.  
  
 Дополнительные сведения о регистрации свойства зависимостей, см. в разделе <xref:System.Windows.DependencyProperty>.  
  
 Проверки в свойстве зависимостей только для чтения может быть менее важна. Уровень доступа к закрытым, указываемые для ключа снижает вероятность произвольного недопустимого ввода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyProperty.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="dependencyProperty.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the string representation of the dependency property.</summary>
        <returns>The string representation of the dependency property.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта реализация возвращает <xref:System.Windows.DependencyProperty.Name%2A> значение свойства.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.DependencyProperty.Name" />
      </Docs>
    </Member>
    <Member MemberName="UnsetValue">
      <MemberSignature Language="C#" Value="public static readonly object UnsetValue;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object UnsetValue" />
      <MemberSignature Language="DocId" Value="F:System.Windows.DependencyProperty.UnsetValue" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnsetValue As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ UnsetValue;" />
      <MemberSignature Language="F#" Value=" staticval mutable UnsetValue : obj" Usage="System.Windows.DependencyProperty.UnsetValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Specifies a static value that is used by the [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] property system rather than <see langword="null" /> to indicate that the property exists, but does not have its value set by the property system.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyProperty.UnsetValue> имеет значение-метку, которая используется для сценариев, где [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] система свойств не удается определить запрошенный <xref:System.Windows.DependencyProperty> значение. <xref:System.Windows.DependencyProperty.UnsetValue> используется вместо `null`, так как `null` может быть является допустимым значением свойства, а также является допустимым (и часто используемые) <xref:System.Windows.PropertyMetadata.DefaultValue%2A>.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> никогда не возвращается из <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType>. При вызове <xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType> на свойства зависимости в <xref:System.Windows.DependencyObject> применяется экземпляр, одно из следующих:  
  
-   Свойство зависимости имеет значение по умолчанию, установленное в метаданных и возвращается это значение. Это значение может быть получена из <xref:System.Windows.DependencyProperty.DefaultMetadata%2A>.  
  
-   Любое другое значение было установлено в системе свойств, и значение по умолчанию больше не нужны. Дополнительные сведения см. в разделе [Приоритет значений свойств зависимостей](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md).  
  
 Установка <xref:System.Windows.PropertyMetadata.DefaultValue%2A> из <xref:System.Windows.DependencyProperty.UnsetValue> специально не допускается.  
  
 <xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType> Возвращает <xref:System.Windows.DependencyProperty.UnsetValue> когда запрошенное свойство не задано локально.  
  
 <xref:System.Windows.DependencyProperty.UnsetValue> имеет специальное значение при использовании в качестве возвращаемого значения <xref:System.Windows.CoerceValueCallback>. Дополнительные сведения см. в разделе [проверка и обратные вызовы свойства зависимостей](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 При привязке к базе данных, обратите внимание, что <xref:System.Windows.DependencyProperty.UnsetValue> не эквивалентен <xref:System.DBNull.Value>, аналогично тому, как <xref:System.DBNull.Value> не соответствует параметру значение true, значение null.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ValidateValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.ValidateValueCallback ValidateValueCallback { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ValidateValueCallback ValidateValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ValidateValueCallback As ValidateValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ValidateValueCallback ^ ValidateValueCallback { System::Windows::ValidateValueCallback ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ValidateValueCallback : System.Windows.ValidateValueCallback" Usage="System.Windows.DependencyProperty.ValidateValueCallback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ValidateValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the value validation callback for the dependency property.</summary>
        <value>Обратный вызов проверки значение для этого свойства зависимостей, как предусмотрено для <paramref name="validateValueCallback" /> параметра при исходной регистрации свойства зависимостей.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство будет содержать `null` для любого свойства зависимостей нет зарегистрированного обратного вызова проверки.  
  
 Проверить значение, обратные вызовы должны действовать статически: проверка, применяемая через <xref:System.Windows.ValidateValueCallback> не может определить, является ли указанное значение допустимым для какой-либо экземпляр. Обратный вызов может определить только в том случае, следует ли не следует принимать предоставленное значение как допустимый все объекты, которые обладают свойством зависимостей. Если вам нужно выполнить проверку, которая зависит от того, знание значений других свойств зависимостей в определенном экземпляре, используйте <xref:System.Windows.CoerceValueCallback> вместо этого. <xref:System.Windows.CoerceValueCallback> Регистрируется как часть метаданных свойства зависимости, а не непосредственно в идентификатор свойства зависимостей. Дополнительные сведения см. в разделе [проверка и обратные вызовы свойства зависимостей](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.ValidateValueCallback" />
      </Docs>
    </Member>
  </Members>
</Type>