<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="DependencyProperty.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5cd5b6a2bc5d76e65fbad41cf01060484fb71b52e.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cd5b6a2bc5d76e65fbad41cf01060484fb71b52e</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Represents a property that can be set through methods such as, styling, data binding, animation, and inheritance.</source>
          <target state="translated">Представляет свойство, которое можно задать с помощью методов, например стили, привязки данных, анимации и наследование.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>A <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> supports the following capabilities in <ph id="ph2">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph>:</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> поддерживает следующие возможности в <ph id="ph2">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph>:</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can be set in a style.</source>
          <target state="translated">Это свойство можно задать в style.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>Styling and Templating<ept id="p1">](~/docs/framework/wpf/controls/styling-and-templating.md)</ept>.</source>
          <target state="translated">Более подробную информацию см. в разделе <bpt id="p1">[</bpt>Стилизация и использование шаблонов<ept id="p1">](~/docs/framework/wpf/controls/styling-and-templating.md)</ept>.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can be set through data binding.</source>
          <target state="translated">Свойство может быть задано через привязку данных.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information about data binding dependency properties, see <bpt id="p1">[</bpt>How to: Bind the Properties of Two Controls<ept id="p1">](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о привязке данных свойств зависимостей см. в разделе <bpt id="p1">[</bpt>как: привязки свойства из двух элементов управления<ept id="p1">](~/docs/framework/wpf/data/how-to-bind-the-properties-of-two-controls.md)</ept>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can be set with a dynamic resource reference.</source>
          <target state="translated">Свойство может быть задано со ссылкой на динамический ресурс.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>XAML Resources<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Ресурсы XAML<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can inherit its value automatically from a parent element in the element tree.</source>
          <target state="translated">Свойство может наследовать его значение автоматически от родительского элемента в дереве элементов.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Наследование значения свойства<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can be animated.</source>
          <target state="translated">Свойства могут быть анимированы.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>Animation Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-overview.md)</ept>.</source>
          <target state="translated">Более подробную информацию см. в разделе <bpt id="p1">[</bpt>Общие сведения об эффектах анимации<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property can report when the previous value of the property has been changed and the property value can be coerced.</source>
          <target state="translated">Свойство может сообщать, когда предыдущее значение свойства было изменено и можно выполнить приведение значения свойства.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>Dependency Property Callbacks and Validation<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Проверка и обратные вызовы свойства зависимостей<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property reports information to <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>, such as whether changing a property value should require the layout system to recompose the visuals for an element.</source>
          <target state="translated">Свойство сообщает информацию для <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>, такие как ли изменение значения свойства требуется системе макета, чтобы представлять визуализации элемента.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>The property receives support in the <ph id="ph1">[!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)]</ph>.</source>
          <target state="translated">Свойство получает поддержку в <ph id="ph1">[!INCLUDE[wpfdesigner_current_long](~/includes/wpfdesigner-current-long-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For example, the property can be edited in the <bpt id="p1">**</bpt>Properties<ept id="p1">**</ept> window.</source>
          <target state="translated">Например, можно изменить свойство в <bpt id="p1">**</bpt>свойства<ept id="p1">**</ept> окна.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>To learn more about dependency properties, see <bpt id="p1">[</bpt>Dependency Properties Overview<ept id="p1">](~/docs/framework/wpf/advanced/dependency-properties-overview.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о свойствах зависимостей см. в разделе <bpt id="p1">[</bpt>Общие сведения о свойствах зависимостей<ept id="p1">](~/docs/framework/wpf/advanced/dependency-properties-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>If you want properties on your custom types to support the capabilities in the preceding list, you should create a dependency property.</source>
          <target state="translated">Если требуется свойства на пользовательских типов для поддержки возможностей в предыдущем списке, следует создать свойство зависимостей.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>To learn how to create custom dependency properties, see <bpt id="p1">[</bpt>Custom Dependency Properties<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept>.</source>
          <target state="translated">Описание способов создания пользовательских свойств зависимостей, в разделе <bpt id="p1">[</bpt>пользовательских свойств зависимостей<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>An attached property is a property that enables any object to report information to the type that defines the attached property.</source>
          <target state="translated">Вложенное свойство является свойством, позволяющий любого объекта, для передачи сведений типа, который определяет вложенное свойство.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>In <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>, any type that inherits from <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> can use an attached property regardless of whether the type inherits from the type that defines the property.</source>
          <target state="translated">В <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>, любой тип, наследующий от <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> можно использовать вложенное свойство независимо от того, является ли тип наследует от типа, определяющего свойство.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>An attached property is a feature of the <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> language.</source>
          <target state="translated">Вложенное свойство — это функция <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> языка.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>To set an attached property in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, use the <bpt id="p1">*</bpt>ownerType<ept id="p1">*</ept>.<bpt id="p2">*</bpt>propertyName<ept id="p2">*</ept> syntax.</source>
          <target state="translated">Чтобы задать присоединенное свойство в <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, используйте <bpt id="p1">*</bpt>ownerType<ept id="p1">*</ept>.<bpt id="p2">*</bpt> propertyName<ept id="p2">*</ept> синтаксиса.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>An example of an attached property is the <ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Является примером вложенное свойство <ph id="ph1">&lt;xref:System.Windows.Controls.DockPanel.Dock%2A?displayProperty=nameWithType&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>If you want to create a property that can be used on all <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> types, then you should create an attached property.</source>
          <target state="translated">Если вы хотите создать свойство, которое может использоваться для всех <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> типов, следует создать вложенное свойство.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>To learn more about attached properties, including how to create them, see <bpt id="p1">[</bpt>Attached Properties Overview<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о вложенных свойств, включая создание, в разделе <bpt id="p1">[</bpt>зависимостей<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>XAML Attribute Usage</source>
          <target state="translated">Использование атрибута XAML</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>XAML Values</source>
          <target state="translated">Значения XAML</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>A string that specifies the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType&gt;</ph> of the desired dependency property.</source>
          <target state="translated">Строка, указывающая <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType&gt;</ph> свойства требуемой зависимостей.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>This can be preceded by an XML namespace prefix if the property is not in the default XML namespace (for details, see <bpt id="p1">[</bpt>XAML Namespaces and Namespace Mapping for WPF XAML<ept id="p1">](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)</ept>.)</source>
          <target state="translated">Это может предшествовать префикс пространства имен XML, если свойство не существует в пространстве имен XML по умолчанию (Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>пространства имен XAML и сопоставление пространства имен WPF XAML<ept id="p1">](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)</ept>.)</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source><ph id="ph1">`ownerType`</ph>.<ph id="ph2">`dependencyPropertyName`</ph></source>
          <target state="translated"><ph id="ph1">`ownerType`</ph>.<ph id="ph2">`dependencyPropertyName`</ph></target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>A string that specifies an owner type of a dependency property, a dot (.), then the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Строка, указывающая тип владельца свойства зависимостей, точка (.), то <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source><ph id="ph1">`ownerType`</ph> can also be preceded by an XML namespace prefix.</source>
          <target state="translated"><ph id="ph1">`ownerType`</ph> Можно также предшествовать префикс пространства имен XML.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>This usage is particular to late-bound styles and templates, where the owner of the dependency property must be specified for parsing context because the <ph id="ph1">`TargetType`</ph> is not yet known.</source>
          <target state="translated">Для позднего связывания стили и шаблоны, где необходимо указать владельца свойства зависимостей для синтаксического анализа контекста, так как такое использование <ph id="ph1">`TargetType`</ph> еще не известна.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>For more information, see <bpt id="p1">[</bpt>Styling and Templating<ept id="p1">](~/docs/framework/wpf/controls/styling-and-templating.md)</ept>.</source>
          <target state="translated">Более подробную информацию см. в разделе <bpt id="p1">[</bpt>Стилизация и использование шаблонов<ept id="p1">](~/docs/framework/wpf/controls/styling-and-templating.md)</ept>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source><ph id="ph1">`attachedPropertyOwnerType`</ph> <bpt id="p1">*</bpt>.<ept id="p1">*</ept></source>
          <target state="translated"><ph id="ph1">`attachedPropertyOwnerType`</ph> <bpt id="p1">*</bpt>.<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source>A string that specifies  the owner of an attached property, a dot (.), then the attached property name.</source>
          <target state="translated">Строка, задающая владельца вложенного свойства, точка (.), а затем имя вложенного свойства.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.DependencyProperty">
          <source><ph id="ph1">`attachedPropertyOwnerType`</ph> can also be preceded by an XML namespace prefix.</source>
          <target state="translated"><ph id="ph1">`attachedPropertyOwnerType`</ph> Можно также предшествовать префикс пространства имен XML.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Adds another type as an owner of a dependency property that has already been registered to a type.</source>
          <target state="translated">Добавляет другой тип в качестве владельца свойства зависимостей, который уже был зарегистрирован для типа.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The type to add as an owner of this dependency property.</source>
          <target state="translated">Тип для добавления в качестве владельца данного свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>Adds another type as an owner of a dependency property that has already been registered.</source>
          <target state="translated">Добавляет другой тип в качестве владельца свойства зависимостей, которое уже зарегистрировано.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>A reference to the original <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> identifier that identifies the dependency property.</source>
          <target state="translated">Ссылка на исходный идентификатор <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>, который определяет свойство зависимостей.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>This identifier should be exposed by the adding class as a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field.</source>
          <target state="translated">Этот идентификатор должен быть представлен путем добавления класса в качестве поля <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>This method enables the property system to recognize a dependency property on a type that did not register that particular dependency property initially.</source>
          <target state="translated">Этот метод позволяет распознавать свойства зависимостей для типа, который изначально не зарегистрировала это конкретное свойство зависимостей в системе свойств.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>Typically, <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> is used to add dependency properties to classes that do not already expose that dependency property through managed class inheritance (class inheritance would cause the wrapper properties to be inherited by the derived class, and thus would provide general members-table access to the dependency property already).</source>
          <target state="translated">Как правило <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> используется для добавления свойств зависимостей в классы, которые еще не предоставляют это свойство зависимостей через наследование управляемого класса (наследование класса вызовет свойства оболочки должны наследоваться от базового класса и, следовательно, обеспечит общей таблице членов доступ к свойству зависимостей уже).</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> enables the property system to recognize a dependency property on a type that did not register that dependency property initially.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> позволяет распознавать свойства зависимостей для типа, который изначально не зарегистрировала это свойство зависимостей в системе свойств.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>This signature does not allow for specifying metadata.</source>
          <target state="translated">Эта подпись не позволяет указывать метаданные.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>When you use this method, the metadata is automatically generated for the new <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> and its owner type.</source>
          <target state="translated">При использовании этого метода метаданные автоматически создается для нового <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> и ее типа владельца.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The auto-generated metadata is the result of the merged metadata from all of the base types that have this property defined.</source>
          <target state="translated">Метаданные автоматически созданный является результатом объединения метаданных из всех базовых типов, для которых определено это свойство.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>If no merged metadata is available, then the default metadata for the property is used.</source>
          <target state="translated">Если нет объединенных метаданных нет, то используется метаданных по умолчанию для свойства.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>If the property is registered by using the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> method, then the default metadata is the same as the metadata that is created when <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> was called.</source>
          <target state="translated">Если оно регистрируется с помощью <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> метод, то метаданные по умолчанию является таким же, как метаданные, создаваемой при <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> был вызван.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>Otherwise, the <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> object is created with the <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> property set to the property type's default and all other properties of the <ph id="ph3">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> is set to <ph id="ph4">`null`</ph>.</source>
          <target state="translated">В противном случае <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> создан объект с <ph id="ph2">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> свойства, значение по умолчанию тип свойства, а все остальные свойства <ph id="ph3">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> равно <ph id="ph4">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>Use the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph> signature if you want to provide metadata for the version of the dependency property as added to the provided type.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph> подпись, чтобы предоставлять метаданные для версии свойства зависимостей, по мере добавления в указанный тип.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The return value of this method is typically used to declare and expose the dependency property by storing a dependency property identifier.</source>
          <target state="translated">Возвращаемое значение этого метода обычно используется для объявления и предоставления свойства зависимостей, сохраняя идентификатор свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The identifier provides access to the dependency property if you want to call property system <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> against the dependency property, particularly as it exists on the adding owner class.</source>
          <target state="translated">Идентификатор предоставляет доступ к свойству зависимостей, если вы хотите вызвать системы свойств <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> к свойству зависимостей, особенно, когда существует на добавляемом классе владельца.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The same property name for both original owner and added owner should be used to indicate the similar functionality.</source>
          <target state="translated">Одно и то же имя свойства для первоначального владельца и добавленного владельцев следует использовать, чтобы указать на схожую функциональность.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>You should use the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> return value of the <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> method to define the dependency property identifier, and also to declare <ph id="ph3">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> property wrappers, for dependency properties that are added to types using <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>.</source>
          <target state="translated">Следует использовать <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> возвращаемое значение <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> метод для определения идентификатора свойства зависимости, а также для объявления <ph id="ph3">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> оболочки свойства для свойства зависимостей, которые добавляются с помощью типов <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> methodology recommended above is used when creating the dependency properties that are declared within <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> Методологии рекомендуется выше используется при создании свойства зависимости, которые объявлены внутри <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>For instance, both <ph id="ph1">&lt;xref:System.Windows.Controls.Border&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> define a <ph id="ph3">`BorderBrush`</ph> dependency property, which have similar functionality.</source>
          <target state="translated">Например, оба <ph id="ph1">&lt;xref:System.Windows.Controls.Border&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> определить <ph id="ph3">`BorderBrush`</ph> свойства зависимостей, имеющих аналогичные функциональные возможности.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source><ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> defines its <ph id="ph2">`BorderBrush`</ph> property to the property system by calling <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> based on the original owner <ph id="ph4">&lt;xref:System.Windows.Controls.Border&gt;</ph> and its registered <ph id="ph5">&lt;xref:System.Windows.Controls.Border.BorderBrushProperty&gt;</ph> dependency property identifer.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> определяет его <ph id="ph2">`BorderBrush`</ph> свойства в системе свойств путем вызова <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> зависимости от первоначального владельца <ph id="ph4">&lt;xref:System.Windows.Controls.Border&gt;</ph> и его зарегистрированные <ph id="ph5">&lt;xref:System.Windows.Controls.Border.BorderBrushProperty&gt;</ph> идентификатор свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> return value is then used to establish a new static <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> field (<ph id="ph3">&lt;xref:System.Windows.Controls.Control.BorderBrushProperty&gt;</ph>) for that property on the added owner, and a <ph id="ph4">`BorderBrush`</ph> property wrapper is also declared.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> Возвращают значение затем используется для установления новый статический <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> поля (<ph id="ph3">&lt;xref:System.Windows.Controls.Control.BorderBrushProperty&gt;</ph>) для этого свойства для добавленного владельцев и <ph id="ph4">`BorderBrush`</ph> также объявляется свойство программы-оболочки.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The type to add as owner of this dependency property.</source>
          <target state="translated">Тип для добавления в качестве владельца данного свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The metadata that qualifies the dependency property as it exists on the provided type.</source>
          <target state="translated">Метаданные, квалифицирующие свойство зависимостей в том виде, в котором оно существует в указанном типе.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Adds another type as an owner of a dependency property that has already been registered, providing dependency property metadata for the dependency property as it will exist on the provided owner type.</source>
          <target state="translated">Добавляет другой тип в качестве владельца свойства зависимостей, который уже был зарегистрирован, предоставляя метаданные свойства зависимости для свойства зависимостей в том виде, в котором оно будет существовать в предоставленном типе владельца.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>A reference to the original <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> identifier that identifies the dependency property.</source>
          <target state="translated">Ссылка на исходный идентификатор <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>, который определяет свойство зависимостей.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>This identifier should be exposed by the adding class as a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field.</source>
          <target state="translated">Этот идентификатор должен быть представлен путем добавления класса в качестве поля <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>This method enables the property system to recognize a dependency property on a type that did not register that particular dependency property initially.</source>
          <target state="translated">Этот метод позволяет распознавать свойства зависимостей для типа, который изначально не зарегистрировала это конкретное свойство зависимостей в системе свойств.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The return value of this method is used to declare and expose the dependency property, particularly as it exists on the adding owner class.</source>
          <target state="translated">Возвращаемое значение этого метода используется для объявления и предоставления свойству зависимостей, особенно в том случае, как оно существует в добавляемом классе владельца.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Generally, the same property name for both original owner and added owner should be used to indicate the similar functionality.</source>
          <target state="translated">Как правило то же имя свойства для первоначального владельца и добавленного владельцев следует использовать для указания на схожую функциональность.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>It is good practice to expose the identifiers, as well as new <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> property wrappers, for dependency properties that are added to types using <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>.</source>
          <target state="translated">Рекомендуется предоставлять идентификаторы, а также новые <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> оболочки свойства для свойства зависимостей, которые добавляются с помощью типов <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> methodology recommended above is used when creating <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> declared within <ph id="ph3">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> Методологии рекомендуется выше используется при создании <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> объявленная внутри <ph id="ph3">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>For instance, both <ph id="ph1">&lt;xref:System.Windows.Controls.Border&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> define a <ph id="ph3">`BorderBrush`</ph> dependency property, which have similar functionality.</source>
          <target state="translated">Например, оба <ph id="ph1">&lt;xref:System.Windows.Controls.Border&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.Controls.Control&gt;</ph> определить <ph id="ph3">`BorderBrush`</ph> свойства зависимостей, имеющих аналогичные функциональные возможности.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source><ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> defines its <ph id="ph2">`BorderBrush`</ph> property to the property system by calling <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> on original owner <ph id="ph4">&lt;xref:System.Windows.Controls.Border&gt;</ph> and its registered <ph id="ph5">&lt;xref:System.Windows.Controls.Border.BorderBrushProperty&gt;</ph> dependency property identifer.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> определяет его <ph id="ph2">`BorderBrush`</ph> свойства в системе свойств путем вызова <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> на исходный владелец <ph id="ph4">&lt;xref:System.Windows.Controls.Border&gt;</ph> и его зарегистрированные <ph id="ph5">&lt;xref:System.Windows.Controls.Border.BorderBrushProperty&gt;</ph> идентификатор свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> return value is then used to establish a static <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> field (<ph id="ph3">&lt;xref:System.Windows.Controls.Control.BorderBrushProperty&gt;</ph>)for that property on the added owner, and a <ph id="ph4">`BorderBrush`</ph> property wrapper is also declared.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> Возвращают значение затем используется для установления статический <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> поля (<ph id="ph3">&lt;xref:System.Windows.Controls.Control.BorderBrushProperty&gt;</ph>) для этого свойства для добавленного владельцев и <ph id="ph4">`BorderBrush`</ph> также объявляется свойство программы-оболочки.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The added owner's dependency property identifier should be used for operations such as <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph>.</source>
          <target state="translated">Идентификатор для свойства зависимостей добавленного владельцев должен использоваться для операций таких как <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>However, type-specific operations involving either types or instances of the class that was added as owner with different metadata will still return the expected results even if the original (not the added owner's) dependency property identifier is specified in calls to methods such as <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GetMetadata%2A&gt;</ph>.</source>
          <target state="translated">Однако конкретного типа операций, включающих типов или экземпляров класса, который был добавлен как владелец с различные метаданные будут по-прежнему возвращать даже если ожидаемые результаты исходного (не добавлены владельца) указан идентификатор свойства зависимостей в вызовы методов, например <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GetMetadata%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The metadata for the added owner is perpetuated by the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> call itself, not necessarily referenced exclusively by the adding owner class identifier field.</source>
          <target state="translated">Метаданные для добавленного владельцев сохраняются по <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> вызывает самого ссылается не обязательно исключительно поле идентификатора класса Добавление владельца.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Nevertheless, it is good practice to expose the  identifier, as well as new <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> property wrappers, for dependency properties that are added to types using <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, because failing to do so creates disparity between the <ph id="ph3">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> and <ph id="ph4">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> representations of your properties.</source>
          <target state="translated">Тем не менее, рекомендуется для предоставления идентификатора, а также новые <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> оболочки свойства для свойства зависимостей, которые добавляются с помощью типов <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph>, поскольку Несоблюдение этого различие между <ph id="ph3">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> и <ph id="ph4">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> представления свойств.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</source>
          <target state="translated">Предоставленных метаданных объединяется с метаданными для свойства зависимостей, которое существует в базовом владельце.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Any characteristics that were specified in the original base metadata will persist.</source>
          <target state="translated">Характеристики, которые были указаны в исходных базовых метаданных, сохранятся.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</source>
          <target state="translated">Только характеристики, специально измененные в новых метаданных, переопределят характеристики базовых метаданных.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Some characteristics, such as <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph>, are replaced if they are specified in the new metadata.</source>
          <target state="translated">Некоторые характеристики, такие как <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph>, заменяются в случае, если они указаны в новых метаданных.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Others, such as <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, are combined.</source>
          <target state="translated">Другие, такие как <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, объединяются.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>Ultimately, the merge behavior depends on the property metadata type being used for the override, so the behavior described here is for the existing property metadata classes used by <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> dependency properties.</source>
          <target state="translated">В конечном счете, поведение при объединении зависит от типа метаданных свойства используется для переопределения, поэтому для существующих классов метаданных свойств, используемых поведения, описанного здесь <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> свойств зависимостей.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.AddOwner(System.Type,System.Windows.PropertyMetadata)">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Metadata<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> and <bpt id="p2">[</bpt>Framework Property Metadata<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>метаданные свойства зависимостей<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> и <bpt id="p2">[</bpt>метаданных свойств среды<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>Gets the default metadata of the dependency property.</source>
          <target state="translated">Возвращает метаданные свойства зависимостей по умолчанию.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>The default metadata of the dependency property.</source>
          <target state="translated">Метаданные свойства зависимостей по умолчанию.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>The default metadata is the property metadata that is available to that particular object or an object of a derived type where no alternative metadata was supplied by an explicit <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> call.</source>
          <target state="translated">По умолчанию метаданные, метаданные свойства, доступные для конкретного объекта или объекта производного типа, где альтернативные метаданные не был предоставлен явный <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> вызова.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>If the original owner applied metadata to the first <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> call that established the dependency property, then that metadata is returned as <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</source>
          <target state="translated">Если владелец исходного метаданных применяется к первому <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> вызов, установить свойству зависимостей, а затем эти метаданные возвращаются в виде <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>If no metadata was applied in the original <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> call, then default metadata is generated from within the <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> call and this value is returned as the <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</source>
          <target state="translated">Если метаданные не было применено в исходной коллекции <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> вызвать, формируется с помощью метаданных по умолчанию <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> вызова и это значение возвращается в виде <ph id="ph3">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>The main purpose of having default metadata associated with a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> is to supply a default value for this property on any <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> or a derived type.</source>
          <target state="translated">Основным назначением которых по умолчанию метаданные, связанные с <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> — предоставить значение по умолчанию для этого свойства для какого-либо <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> или производный тип.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>For nonattached properties, the metadata type returned by this property cannot be cast to derived types of <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> type, even if the property was originally registered with a derived metadata type.</source>
          <target state="translated">Для невложенных свойств тип метаданных, возвращенный этим свойством нельзя привести к производные типы <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata&gt;</ph> тип, даже если свойство было изначально зарегистрировано с производным типом метаданных.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>If you want the originally registered metadata including its original possibly derived metadata type, call <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29&gt;</ph> instead, passing the original registering type as a parameter.</source>
          <target state="translated">Изначально зарегистрированных метаданных, включая его исходным типом возможно производные метаданные вызвать <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GetMetadata%28System.Type%29&gt;</ph> вместо этого, передача исходной регистрации типу как параметр.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.DefaultMetadata">
          <source>For attached properties, the type of the metadata returned by this property will match the type given in the original <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> registration method.</source>
          <target state="translated">Для вложенных свойств тип метаданных, возвращенный этим свойством будет соответствовать типу, заданному в исходной <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> метод регистрации.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetHashCode">
          <source>Returns a hash code for this <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>.</source>
          <target state="translated">Возвращает хэш-код для объекта <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetHashCode">
          <source>The hash code for this <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>.</source>
          <target state="translated">Хэш-код для этого экземпляра <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetHashCode">
          <source>The property system uses its own unique identifier <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph>, and the value of that property is returned by <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GetHashCode%2A&gt;</ph>.</source>
          <target state="translated">В системе свойств использует свой собственный уникальный идентификатор <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph>, и возвращается значение этого свойства <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GetHashCode%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Returns the metadata associated with this dependency property as it exists for a particular type.</source>
          <target state="translated">Возвращает метаданные, связанные с данным свойством зависимостей в том виде, в котором оно существует для конкретного типа.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>This can be the type where the dependency property was first registered, one to which it was added subsequently, or a type where the dependency property was obtained through inheritance but the metadata was specifically overridden.</source>
          <target state="translated">Это может быть тип, в котором свойство зависимостей было изначально зарегистрировано, тип, к которому оно было добавлено позже, или тип, в котором свойство зависимостей было получено путем наследования, но метаданные были переопределены.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>The specific type from which to retrieve the dependency property metadata.</source>
          <target state="translated">Конкретный тип, из которого необходимо извлечь метаданные свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>Returns the metadata for this dependency property as it exists on a specified existing type.</source>
          <target state="translated">Возвращает метаданные для этого свойства зависимостей в том виде, в котором оно представлено в указанном существующем типе.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>A property metadata object.</source>
          <target state="translated">Объект метаданных свойств.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>Specifying either the type or an object reference to use as type is necessary because the metadata can vary from the original registration due either to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> calls that alter the metadata of the dependency property as it exists on a type.</source>
          <target state="translated">Указание типа или ссылкой на объект для использования в качестве типа является обязательным, поскольку метаданные могут отличаться от исходной регистрации ввиду <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> вызовы, изменять метаданные свойства зависимостей, как оно существует в типе.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>The following example gets metadata for a dependency property based on its type.</source>
          <target state="translated">Следующий пример возвращает метаданные для свойства зависимостей, в зависимости от его типа.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Type)">
          <source>The type is obtained by using a <ph id="ph1">`typeof`</ph> operator.</source>
          <target state="translated">Тип осуществляется при помощи <ph id="ph1">`typeof`</ph> оператор.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>A dependency object that is checked for type, to determine which type-specific version of the dependency property the metadata should come from.</source>
          <target state="translated">Объект зависимости, проверяемый на наличие типа, чтобы определить, из какой типозависимой версии свойства зависимости нужно использовать метаданные.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>Returns the metadata for this dependency property as it exists on the specified object instance.</source>
          <target state="translated">Возвращает метаданные для этого свойства зависимостей в том виде,в котором оно существует в указанном экземпляре объекта.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>A property metadata object.</source>
          <target state="translated">Объект метаданных свойств.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>Specifying either the type or an object reference is necessary because the metadata of any given dependency property can vary from the original registration due either to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> calls that can refine the property metadata as it exists on a type.</source>
          <target state="translated">Указание типа или ссылкой на объект является необходимым, поскольку метаданные любое заданное свойство зависимостей может изменяться от исходной регистрации ввиду <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> вызовы, которые можно уточнить метаданные свойства, которое существует в тип.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>When you request property metadata based on an instance, you are really just passing the instance so that its type can be evaluated internally.</source>
          <target state="translated">При запросе метаданных свойства на основе экземпляра это просто передачи экземпляра, его тип может вычисляться внутренним образом.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>Dependency property metadata does not vary per instance; it is always consistent for any given type-property combination.</source>
          <target state="translated">Метаданные свойства зависимостей не зависит от конкретного экземпляра. всегда является согласованным для любой комбинации типа и свойства.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObject)">
          <source>The following example gets metadata for a dependency property based on a specific <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> instance.</source>
          <target state="translated">Следующий пример получает метаданные для свойства зависимостей, в зависимости от конкретного <ph id="ph1">&lt;xref:System.Windows.DependencyObject&gt;</ph> экземпляра.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)">
          <source>A specific object that records the dependency object type from which the dependency property metadata is desired.</source>
          <target state="translated">Специальный объект, который записывает тип объекта зависимости, из которого запрашиваются метаданные свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)">
          <source>Returns the metadata for this dependency property as it exists on a specified type.</source>
          <target state="translated">Возвращает метаданные для этого свойства зависимостей в том виде, в каком они представлены в указанном типе.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)">
          <source>A property metadata object.</source>
          <target state="translated">Объект метаданных свойств.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)">
          <source>Specifying either the type or an object reference is necessary because the metadata of any given dependency property can vary from the original registration due either to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> calls that can refine the property metadata as it exists on a type.</source>
          <target state="translated">Указание типа или ссылкой на объект является необходимым, поскольку метаданные любое заданное свойство зависимостей может изменяться от исходной регистрации ввиду <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> вызовы, которые можно уточнить метаданные свойства, которое существует в тип.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.GetMetadata(System.Windows.DependencyObjectType)">
          <source>The following example gets metadata for a dependency property based on its <ph id="ph1">&lt;xref:System.Windows.DependencyObjectType&gt;</ph>.</source>
          <target state="translated">Следующий пример получает метаданные для свойства зависимостей на основе его <ph id="ph1">&lt;xref:System.Windows.DependencyObjectType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>Gets an internally generated value that uniquely identifies the dependency property.</source>
          <target state="translated">Возвращает внутреннее сгенерированное значение, уникальным образом идентифицирующее свойство зависимостей.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>A unique numeric identifier.</source>
          <target state="translated">Уникальный числовой идентификатор.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>This value is an integer, not a <ph id="ph1">[!INCLUDE[TLA#tla_guid](~/includes/tlasharptla-guid-md.md)]</ph>.</source>
          <target state="translated">Это значение не является целым числом, <ph id="ph1">[!INCLUDE[TLA#tla_guid](~/includes/tlasharptla-guid-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>Generally, using this index value is not required, and there is no index access to tables of all dependency properties.</source>
          <target state="translated">Как правило это значение индекса не требуется и нет индекса доступа к таблицам всех свойств зависимостей.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>Dependency properties should instead be referenced by their identifier fields.</source>
          <target state="translated">Свойства зависимостей вместо этого следует ссылаться их идентификатор поля.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph> is used internally for faster access to data structures that use the <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph> as a zero-based array index.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph> используется внутренним образом для ускорения доступа к структурам данных, использующих <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.GlobalIndex%2A&gt;</ph> как массив, начинающийся с нуля индекс.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.GlobalIndex">
          <source>A similar usage might have applications for designers or tools.</source>
          <target state="translated">Подобное использование может применяться для конструкторов или инструментов.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source>The value to check.</source>
          <target state="translated">Проверяемое значение.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source>Determines whether a specified value is acceptable for this dependency property's type, as checked against the property type provided in the original dependency property registration.</source>
          <target state="translated">Определяет, приемлемо ли указанное значение для типа данного свойства зависимостей, проверяя его по типу свойства, указанного при исходной регистрации свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified value is the registered property type or an acceptable derived type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если указанное значение принадлежит к зарегистрированному типу свойства или приемлемому производному типу; в противном случае — <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source>A value of <ph id="ph1">`null`</ph> is a valid type for reference type dependency properties, or for a <ph id="ph2">&lt;xref:System.Nullable%601&gt;</ph> dependency property, and would return <ph id="ph3">`true`</ph> for these cases.</source>
          <target state="translated">Значение <ph id="ph1">`null`</ph> является допустимым типом для свойств зависимостей ссылочного типа или <ph id="ph2">&lt;xref:System.Nullable%601&gt;</ph> свойства зависимостей и будет возвращать <ph id="ph3">`true`</ph> для таких случаев.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source>In cases where the dependency property is neither a reference nor a <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> type, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> will return <ph id="ph3">`false`</ph> for a null value rather than raise an exception.</source>
          <target state="translated">В случаях, когда свойство зависимостей ни ссылку и не является <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> типа, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> вернет <ph id="ph3">`false`</ph> значение null, а не создавать исключение.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidType(System.Object)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> as a check before calling <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> on the dependency property.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> проверку перед вызовом метода <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> для свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>The value to check.</source>
          <target state="translated">Проверяемое значение.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>Determines whether the provided value is accepted for the type of property through basic type checking, and also potentially if it is within the allowed range of values for that type.</source>
          <target state="translated">Определяет, приемлемо ли указанное значение для типа свойства, путем базовой проверки типа, а также, находится ли оно потенциально в пределах разрешенного диапазона значений для данного типа.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the value is acceptable and is of the correct type or a derived type; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если значение приемлемо и принадлежит к надлежащему или производному типу; в противном случае — <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>For a dependency property, an allowed range of values for that type can be specified through a <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> that is provided in the dependency property registration.</source>
          <target state="translated">Для свойства зависимостей, можно указать разрешенный диапазон значений для этого типа с помощью <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> , предоставляется при регистрации свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>This method calls <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> internally.</source>
          <target state="translated">Этот метод вызывает метод <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> внутренним образом.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>If the dependency property in question has no <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>,then calling this method is effectively equivalent to calling <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph>.</source>
          <target state="translated">Если свойство зависимостей в вопросе не имеет <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>, то вызов этого метода, эффективно аналогичен вызову <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>If the dependency property does have a <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>, and if <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> would have returned <ph id="ph3">`true`</ph>, then the value returned will be as implemented in the callback.</source>
          <target state="translated">Если свойство зависимости имеет <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>и если <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> возвращала бы <ph id="ph3">`true`</ph>, то возвращаемое значение будет иметь реализации обратного вызова.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>A null value is a valid value for reference type dependency properties, or for a <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> dependency property, and would return <ph id="ph2">`true`</ph> for these cases.</source>
          <target state="translated">Значение null является допустимым значением для свойства зависимостей типа ссылки или <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> свойства зависимостей и будет возвращать <ph id="ph2">`true`</ph> для таких случаев.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>In cases where the dependency property is neither a reference nor a <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> type, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> will return <ph id="ph3">`false`</ph> for a null value rather than raise an exception.</source>
          <target state="translated">В случаях, когда свойство зависимостей ни ссылку и не является <ph id="ph1">&lt;xref:System.Nullable%601&gt;</ph> типа, <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.IsValidType%2A&gt;</ph> вернет <ph id="ph3">`false`</ph> значение null, а не создавать исключение.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.IsValidValue(System.Object)">
          <source>The following example uses <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidValue%2A&gt;</ph> as a check before calling <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> on the dependency property.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.IsValidValue%2A&gt;</ph> проверку перед вызовом метода <ph id="ph2">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> для свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.Name">
          <source>Gets the name of the dependency property.</source>
          <target state="translated">Возвращает имя свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>The name of the property.</source>
          <target state="translated">Имя свойства.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>This property gets the name provided as the <ph id="ph1">`name`</ph> parameter during dependency property registration.</source>
          <target state="translated">Это свойство получает имя, указанное как <ph id="ph1">`name`</ph> параметр во время регистрации свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>This name is immutable, and cannot be <ph id="ph1">`null`</ph> or an empty string.</source>
          <target state="translated">Это имя является постоянным и не может быть <ph id="ph1">`null`</ph> или является пустой строкой.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>Duplicate name registrations on the same owner type are not permitted, and will throw an exception when you attempt to register the duplicate.</source>
          <target state="translated">Повторяющееся имя регистрации на том же типе владельца не разрешены и возникает исключение при попытке зарегистрировать дубликат.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph> of a dependency property must follow the convention of matching the name of its dependency property identifier minus the suffix "Property".</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph> Зависимости свойства должны соответствовать соглашению совпадающих имя его идентификатор для свойства зависимостей минус суффикс «Свойство».</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>For details, see <bpt id="p1">[</bpt>Custom Dependency Properties<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Пользовательские свойства зависимостей<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.Name">
          <source>The following example queries various characteristics of a dependency property identifier, including the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph>.</source>
          <target state="translated">В следующем примере запрашивается различные характеристики идентификатор свойства зависимостей, включая <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Supplies alternate metadata for this dependency property when it is present on instances of a specified type, versus the metadata that was provided in the initial dependency property registration.</source>
          <target state="translated">Предоставляет альтернативные метаданные для этого свойства зависимостей, когда оно присутствует в экземплярах указанного типа по сравнению с метаданными, предоставленными регистрацией первоначального свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>The type where this dependency property is inherited and where the provided alternate metadata will be applied.</source>
          <target state="translated">Тип, где это свойство зависимостей наследуется и где будут применены указанные альтернативные метаданные.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>The metadata to apply to the dependency property on the overriding type.</source>
          <target state="translated">Метаданные для применения к свойству зависимостей в переопределяемом типе.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Specifies alternate metadata for this dependency property when it is present on instances of a specified type, overriding the metadata that existed for the dependency property as it was inherited from base types.</source>
          <target state="translated">Задает альтернативные метаданные для этого свойства зависимостей, если оно присутствует в экземплярах указанного типа, переопределяя метаданные, которые существовали для данного свойства зависимостей в том виде, в котором оно было унаследовано от базовых типов.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Dependency property metadata should be overridden before the property system uses the dependency property.</source>
          <target state="translated">В системе свойств использует свойства зависимостей, следует переопределить метаданные свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>This equates to the time that specific instances are created using the class that registers the dependency property.</source>
          <target state="translated">Это соответствует времени, определенные экземпляры создаются с помощью класса, регистрирующего свойство зависимостей.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Calls to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> should only be performed within the static constructors of the type that provides itself as the <ph id="ph2">`forType`</ph> parameter of this method, or through similar instantiation.</source>
          <target state="translated">Вызовы <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> следует выполнять только в статическом конструкторе типа, предоставляющего себя в качестве <ph id="ph2">`forType`</ph> параметр этого метода, или с помощью аналогичные при создании экземпляра.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Attempting to change metadata after instances of the owner type exist will not raise exceptions, but will result in inconsistent behaviors in the property system.</source>
          <target state="translated">Попытка изменить метаданные после экземпляров типа-владельца не возникнет исключения, но приведет к несогласованному поведению в системе свойств.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>After metadata for a particular derived class override is established with this method, subsequent attempts to override metadata on this same derived class will raise an exception.</source>
          <target state="translated">После установки с помощью этого метода метаданные для определенного производного класса переопределения последующие попытки переопределения метаданных на этом же производном классе вызывает исключение.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</source>
          <target state="translated">Предоставленных метаданных объединяется с метаданными для свойства зависимостей, которое существует в базовом владельце.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Any characteristics that were specified in the original base metadata will persist; only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</source>
          <target state="translated">Характеристики, которые были указаны в исходных базовых метаданных будет сохранено; только характеристики, специально измененные в новых метаданных, переопределят характеристики базовых метаданных.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Some characteristics such as <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> are replaced if specified in the new metadata.</source>
          <target state="translated">Некоторые характеристики, такие как <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> заменяются, если он указан в новые метаданные.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Others, such as <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, are combined.</source>
          <target state="translated">Другие, такие как <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, объединяются.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Ultimately, the merge behavior depends on the property metadata type being used for the override, so the behavior described here is for the existing property metadata classes used by <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> dependency properties.</source>
          <target state="translated">В конечном счете, поведение при объединении зависит от типа метаданных свойства используется для переопределения, поэтому для существующих классов метаданных свойств, используемых поведения, описанного здесь <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> свойств зависимостей.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Metadata<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> and <bpt id="p2">[</bpt>Framework Property Metadata<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>метаданные свойства зависимостей<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> и <bpt id="p2">[</bpt>метаданных свойств среды<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>An attempt was made to override metadata on a read-only dependency property (that operation cannot be done using this signature).</source>
          <target state="translated">Была предпринята попытка переопределения метаданных в доступном только для чтения свойстве зависимости (операция не может быть выполнена с помощью данной сигнатуры).</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)">
          <source>Metadata was already established for the dependency property as it exists on the provided type.</source>
          <target state="translated">Метаданные уже были установлены для данного свойства зависимостей в том виде, в котором оно существует в предоставленном типе.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>The type where this dependency property is inherited and where the provided alternate metadata will be applied.</source>
          <target state="translated">Тип, где это свойство зависимостей наследуется и где будут применены указанные альтернативные метаданные.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>The metadata to apply to the dependency property on the overriding type.</source>
          <target state="translated">Метаданные для применения к свойству зависимостей в переопределяемом типе.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>The access key for a read-only dependency property.</source>
          <target state="translated">Ключ доступа для свойства зависимостей, доступного только для чтения.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Supplies alternate metadata for a read-only dependency property when it is present on instances of a specified type, overriding the metadata that was provided in the initial dependency property registration.</source>
          <target state="translated">Предоставляет альтернативные метаданные для свойства зависимостей, доступного только для чтения, когда оно присутствует в экземплярах указанного типа, переопределяя метаданные, предоставленные при первоначальной регистрации свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>You must pass the <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyKey" /&gt;</ph> for the read-only dependency property to avoid raising an exception.</source>
          <target state="translated">Для доступного только для чтения свойства зависимости необходимо передать <ph id="ph1">&lt;see cref="T:System.Windows.DependencyPropertyKey" /&gt;</ph>, чтобы избежать исключения.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>This signature provides underlying implementation for a read-only dependency property identifier (<ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>) method.</source>
          <target state="translated">Эта подпись предоставляет базовую реализацию для идентификатора свойства зависимости только для чтения (<ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>) метод.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>If overriding metadata for a read-write dependency property, use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>.</source>
          <target state="translated">Для переопределения метаданных для свойства зависимостей для чтения и записи, используйте <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%28System.Type%2CSystem.Windows.PropertyMetadata%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Dependency property metadata should be overridden before the property system uses the dependency property.</source>
          <target state="translated">В системе свойств использует свойства зависимостей, следует переопределить метаданные свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>This equates to the time that specific objects are created for the class that registers the dependency property.</source>
          <target state="translated">Это равно времени создания конкретных объектов для класса, который регистрирует свойство зависимости.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Calls to <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> should only be performed within the static constructors of the type that provides itself as the <ph id="ph2">`forType`</ph> parameter of this method, or through similar instantiation.</source>
          <target state="translated">Вызовы <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> следует выполнять только в статическом конструкторе типа, предоставляющего себя в качестве <ph id="ph2">`forType`</ph> параметр этого метода, или с помощью аналогичные при создании экземпляра.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Attempting to change metadata after instances of the owner type exist will not raise exceptions, but will result in inconsistent behaviors in the property system.</source>
          <target state="translated">Попытка изменить метаданные после экземпляров типа-владельца не возникнет исключения, но приведет к несогласованному поведению в системе свойств.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>After metadata for a particular derived class override is established with this method, subsequent attempts to override metadata on this same derived class will raise an exception.</source>
          <target state="translated">После установки с помощью этого метода метаданные для определенного производного класса переопределения последующие попытки переопределения метаданных на этом же производном классе вызывает исключение.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>The supplied metadata is merged with the property metadata for the dependency property as it exists on the base owner.</source>
          <target state="translated">Предоставленных метаданных объединяется с метаданными для свойства зависимостей, которое существует в базовом владельце.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Any characteristics that were specified in the original base metadata will persist; only those characteristics that were specifically changed in the new metadata will override the characteristics of the base metadata.</source>
          <target state="translated">Характеристики, которые были указаны в исходных базовых метаданных будет сохранено; только характеристики, специально измененные в новых метаданных, переопределят характеристики базовых метаданных.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Some characteristics such as <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> are replaced if specified in the new metadata.</source>
          <target state="translated">Некоторые характеристики, такие как <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> заменяются, если он указан в новые метаданные.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>Others, such as <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, are combined.</source>
          <target state="translated">Другие, такие как <ph id="ph1">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph>, объединяются.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>The merge behavior depends on the property metadata type being used for the override.</source>
          <target state="translated">Поведение при объединении зависит от используемого для переопределения типа метаданных свойства.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Metadata<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> and <bpt id="p2">[</bpt>Framework Property Metadata<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>метаданные свойства зависимостей<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-metadata.md)</ept> и <bpt id="p2">[</bpt>метаданных свойств среды<ept id="p2">](~/docs/framework/wpf/advanced/framework-property-metadata.md)</ept>.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>Gets the type of the object that registered the dependency property with the property system, or added itself as owner of the property.</source>
          <target state="translated">Получает тип объекта, зарегистрировавшего свойство зависимостей в системе свойств или добавившего себя в качестве владельца свойства.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>The type of the object that registered the property or added itself as owner of the property.</source>
          <target state="translated">Тип объекта, зарегистрировавшего свойство или добавившего себя в качестве владельца свойства.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>This value was provided during property registration.</source>
          <target state="translated">Данное значение было указано во время регистрации свойства.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>The owner will be either the original registering type in the case of a <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier generated from a <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> call, or the type that added itself as owner in the case of a <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier generated from an <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> call.</source>
          <target state="translated">Владельцем будет либо исходного регистрации типа в случае использования <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> идентификатор, созданный из <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> вызова или тип, добавившего себя в качестве владельца для <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> идентификатор, созданный из <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.AddOwner%2A&gt;</ph> вызова.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>The <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OwnerType%2A&gt;</ph> on any given <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> is immutable, and cannot be <ph id="ph3">`null`</ph> in a valid <ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OwnerType%2A&gt;</ph> С заданным <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> является постоянным и не может быть <ph id="ph3">`null`</ph> в допустимое <ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>The following example gets the owner type based on a dependency property identifier <ph id="ph1">`dp`</ph>, and then gets metadata on the owner type for that same identifier.</source>
          <target state="translated">Следующий пример получает тип владельца, исходя из идентификатора свойства зависимости <ph id="ph1">`dp`</ph>, а затем возвращает метаданные для типа владельца по тому же идентификатору.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.OwnerType">
          <source>This operation is actually equivalent to getting <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph> on <ph id="ph2">`dp`</ph>.</source>
          <target state="translated">Эта операция эквивалентно фактически получению <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph> на <ph id="ph2">`dp`</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>Gets the type that the dependency property uses for its value.</source>
          <target state="translated">Возвращает тип, используемый свойством зависимостей для его значения.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>The <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the property value.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> значения свойства.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>This property reports the type of the property's value as declared by the original property registration, through the <ph id="ph1">`propertyType`</ph> parameter.</source>
          <target state="translated">Это свойство сообщает тип значения свойства, объявленные в исходной регистрации свойства через <ph id="ph1">`propertyType`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>Similar to the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph>, the property type of a dependency property is immutable after registration.</source>
          <target state="translated">Аналогично <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph>, тип свойства для свойства зависимостей нельзя изменить после регистрации.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>The following example queries various characteristics of a dependency property identifier, including the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.PropertyType%2A&gt;</ph>.</source>
          <target state="translated">В следующем примере запрашивается различные характеристики идентификатор свойства зависимостей, включая <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.PropertyType%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.PropertyType">
          <source>The type name string of the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.PropertyType%2A&gt;</ph> is obtained from the returned <ph id="ph2">&lt;xref:System.Type&gt;</ph>.</source>
          <target state="translated">Строка имени типа <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.PropertyType%2A&gt;</ph> получается из возвращенного <ph id="ph2">&lt;xref:System.Type&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>Gets a value that indicates whether the dependency property identified by this <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> instance is a read-only dependency property.</source>
          <target state="translated">Возвращает значение, указывающее, является ли свойство зависимостей, идентифицируемое данным экземпляром <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>, доступным только для чтения.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the dependency property is read-only; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если свойство зависимостей доступно только для чтения; в противном случае — <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>Read-only dependency properties are registered within the property system by calling the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt;</ph> method as opposed to the <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> method.</source>
          <target state="translated">Свойства зависимости только для чтения зарегистрированного в системе свойств путем вызова метода <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterReadOnly%2A&gt;</ph> метода, в отличие от <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>Attached properties can also be registered as read-only; see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt;</ph>.</source>
          <target state="translated">Вложенные свойства также можно зарегистрировать только для чтения; в разделе <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>Read-only dependency properties require a <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> identifier rather than a <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier to perform metadata operations such as overriding the metadata or setting the value.</source>
          <target state="translated">Свойства зависимости только для чтения требуют <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> идентификатор, а не <ph id="ph2">&lt;xref:System.Windows.DependencyProperty&gt;</ph> идентификатор для выполнения операций с метаданными, например переопределения метаданных или установка значения.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>If you obtained a collection of <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifiers through a call to <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;</ph> or another <ph id="ph3">[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]</ph> that exposes identifiers, check the <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> value before attempting to call <ph id="ph5">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> or <ph id="ph6">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> using that dependency property identifier as an input parameter, to verify that the dependency property that the identifier represents is not read-only.</source>
          <target state="translated">Если получить коллекцию <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> идентификаторы посредством вызова <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A&gt;</ph> или другой <ph id="ph3">[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]</ph> , предоставляющий идентификаторов, проверьте <ph id="ph4">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> значение, прежде чем пытаться вызвать <ph id="ph5">&lt;xref:System.Windows.DependencyObject.SetValue%2A&gt;</ph> или <ph id="ph6">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> , использование идентификатор для свойства зависимостей в качестве входного параметра, чтобы убедиться, что свойством зависимостей, которое представляет идентификатор не только для чтения.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>If the value of <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> is <ph id="ph2">`true`</ph> on a dependency property, there is no programmatic way to obtain a reference to the <ph id="ph3">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> identifier of that dependency property, from the metadata or from the <ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph> identifier; the identifier must be available as a static field in order to call <ph id="ph5">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph> against a read-only dependency property.</source>
          <target state="translated">Если значение <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.ReadOnly%2A&gt;</ph> — <ph id="ph2">`true`</ph> для свойства зависимостей, нет возможности для получения ссылки на программный <ph id="ph3">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> идентификатора этого свойства зависимостей, из метаданных или <ph id="ph4">&lt;xref:System.Windows.DependencyProperty&gt;</ph> идентификатор; идентификатор должен быть доступен как статическое поле для вызова <ph id="ph5">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph> для свойства зависимостей только для чтения.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>When you create a custom dependency property, and register it as read-only, you should define only a get accessor for the <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> wrapper property.</source>
          <target state="translated">При создании пользовательского свойства зависимостей и зарегистрируйте его только для чтения, следует определить только метод доступа get для <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> свойство программы-оболочки.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>Otherwise, your class will have a confusing object model for the property wrapper as compared to the access to the backing dependency property.</source>
          <target state="translated">В противном случае ваш класс будет иметь несогласованную объектную модель для обертки свойства, по сравнению с доступом к базовому свойству зависимостей.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>For details, see <bpt id="p1">[</bpt>Custom Dependency Properties<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept> or <bpt id="p2">[</bpt>Read-Only Dependency Properties<ept id="p2">](~/docs/framework/wpf/advanced/read-only-dependency-properties.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>свойств зависимостей<ept id="p1">](~/docs/framework/wpf/advanced/custom-dependency-properties.md)</ept> или <bpt id="p2">[</bpt>свойства зависимости только для чтения<ept id="p2">](~/docs/framework/wpf/advanced/read-only-dependency-properties.md)</ept>.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ReadOnly">
          <source>The following example obtains the default metadata and the dependency property identifier properties from various dependency property fields, and uses the information to populate a table to implement a "metadata browser".</source>
          <target state="translated">В следующем примере получает метаданные по умолчанию и идентификатора свойства зависимостей из различных полей свойства зависимостей и использует сведения для заполнения таблицы и реализации «обозревателя метаданных».</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Registers a dependency property.</source>
          <target state="translated">Регистрирует свойство зависимостей.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Имя регистрируемого свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>The name must be unique within the registration namespace of the owner type.</source>
          <target state="translated">Имя должно быть уникальным в пределах пространства имен регистрации для типа владельца.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>The type of the property.</source>
          <target state="translated">Тип свойства.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Тип владельца, регистрирующий свойство зависимостей.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>Registers a dependency property with the specified property name, property type, and owner type.</source>
          <target state="translated">Регистрирует свойство зависимостей с указанием имени свойства, типа свойства и типа владельца.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Идентификатор свойства зависимостей, который следует использовать для задания значения поля <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> в классе.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о регистрации свойств зависимостей см. в разделе <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Имя регистрируемого свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The type of the property.</source>
          <target state="translated">Тип свойства.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Тип владельца, регистрирующий свойство зависимостей.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Метаданные свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registers a dependency property with the specified property name, property type, owner type, and property metadata.</source>
          <target state="translated">Регистрирует свойство зависимостей с указанным именем свойства, типом свойства, типом владельца и метаданными свойства.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Идентификатор свойства зависимостей, который следует использовать для задания значения поля <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> в классе.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о регистрации свойств зависимостей см. в разделе <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Имя регистрируемого свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The type of the property.</source>
          <target state="translated">Тип свойства.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Тип владельца, регистрирующий свойство зависимостей.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Метаданные свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</source>
          <target state="translated">Ссылка на обратный вызов, который должен выполнить пользовательскую проверку значения свойства зависимостей после обычной проверки типа.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registers a dependency property with the specified property name, property type, owner type, property metadata, and a value validation callback for the property.</source>
          <target state="translated">Регистрирует свойство зависимостей с указанным именем свойства, типом свойства, типом владельца, метаданными свойства и обратным вызовом проверки значения для свойства.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Идентификатор свойства зависимостей, который следует использовать для задания значения поля <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> в классе.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о регистрации свойств зависимостей см. в разделе <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.Register(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The following example registers a dependency property, including a validation callback (the callback definition is not shown; for details on the callback definition, see <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>).</source>
          <target state="translated">В следующем примере регистрируется свойство зависимостей, включая обратный вызов проверки (определение обратного вызова не показано; Дополнительные сведения об определении обратного вызова см. в разделе <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Registers an attached property with the property system.</source>
          <target state="translated">Регистрирует присоединенное свойство в системе свойств.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Имя регистрируемого свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>The type of the property.</source>
          <target state="translated">Тип свойства.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Тип владельца, регистрирующий свойство зависимостей.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>Registers an attached property with the specified property name, property type, and owner type.</source>
          <target state="translated">Регистрирует присоединенное свойство с указанием имени свойства, типа свойства и типа владельца.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Идентификатор свойства зависимостей, который следует использовать для задания значения поля <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> в классе.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>An attached property is a property concept defined by <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Вложенное свойство является свойством понятием <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> implements attached properties as dependency properties.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> реализует вложенные свойства как свойства зависимости.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>Because the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</source>
          <target state="translated">Поскольку <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> вложенные свойства являются свойствами зависимости, они могут быть применены метаданные, который может использоваться для операции, такие как сообщение о характеристиках структуры системой общих свойств.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>For more information, see <bpt id="p1">[</bpt>Attached Properties Overview<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Общие сведения о вложенных свойствах<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о регистрации свойств зависимостей см. в разделе <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type)">
          <source>The following example registers an attached property on an abstract class using this <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> signature.</source>
          <target state="translated">В следующем примере регистрируется вложенное свойство для абстрактного класса с помощью этого <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> подписи.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Имя регистрируемого свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The type of the property.</source>
          <target state="translated">Тип свойства.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Тип владельца, регистрирующий свойство зависимостей.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Метаданные свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>This can include the default value as well as other characteristics.</source>
          <target state="translated">Могут включать значение по умолчанию и другие характеристики.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registers an attached property with the specified property name, property type, owner type, and property metadata.</source>
          <target state="translated">Регистрирует присоединенное свойство с указанным именем и типом свойства, типом владельца и метаданными свойства.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Идентификатор свойства зависимостей, который следует использовать для задания значения поля <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> в классе.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>An attached property is a property concept defined by <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Вложенное свойство является свойством понятием <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> implements attached properties as dependency properties.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> реализует вложенные свойства как свойства зависимости.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Because the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</source>
          <target state="translated">Поскольку <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> вложенные свойства являются свойствами зависимости, они могут быть применены метаданные, который может использоваться для операции, такие как сообщение о характеристиках структуры системой общих свойств.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information, see <bpt id="p1">[</bpt>Attached Properties Overview<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Общие сведения о вложенных свойствах<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о регистрации свойств зависимостей см. в разделе <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Use RegisterAttached for Value-inheriting Dependency Properties</source>
          <target state="translated">Использование RegisterAttached для наследования значения свойств зависимостей</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>One particular scenario for registering a dependency property with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> instead of <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> is to support property value inheritance.</source>
          <target state="translated">Один из сценариев для регистрации свойства зависимостей с <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> вместо <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> предназначен для поддержки наследования значения свойства.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>You should register value-inheriting dependency properties with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set* static methods to provide true attached property support accessors.</source>
          <target state="translated">Необходимо зарегистрировать наследование значения свойства зависимостей с <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> даже если класс определяет оболочку свойствам, которые предоставляют свойство зависимостей, и даже если не требуется предоставлять Get * и набор * статические методы для предоставления присоединенного значение true Поддержка доступа к свойствам.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</source>
          <target state="translated">Несмотря на то, что наследование значения свойства могут быть выполнены для неприсоединенных свойств зависимости, поведение наследования для неприсоединенного свойства в определенных границах элемента в дереве среды выполнения не определено.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</source>
          <target state="translated">Регистрация свойства как вложенного фактически делает вложенное свойство глобальным для системы свойств и гарантирует, что наследование значения свойства работает через все границы в дереве элементов.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Always use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> to register properties where you specify <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in the metadata.</source>
          <target state="translated">Всегда используйте <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> для регистрации свойства, где указываются <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> в метаданных.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Наследование значения свойства<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Имя регистрируемого свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The type of the property.</source>
          <target state="translated">Тип свойства.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Тип владельца, регистрирующий свойство зависимостей.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Метаданные свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>This can include the default value as well as other characteristics.</source>
          <target state="translated">Могут включать значение по умолчанию и другие характеристики.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A reference to a callback that should perform any custom validation of the dependency property value beyond typical type validation.</source>
          <target state="translated">Ссылка на обратный вызов, который должен выполнить пользовательскую проверку значения свойства зависимостей после обычной проверки типа.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registers an attached property with the specified property type, owner type, property metadata, and value validation callback for the property.</source>
          <target state="translated">Регистрирует присоединенное свойство с указанным типом свойства, типом владельца, метаданными свойства и обратным вызовом для проверки значения свойства.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A dependency property identifier that should be used to set the value of a <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> field in your class.</source>
          <target state="translated">Идентификатор свойства зависимостей, который следует использовать для задания значения поля <ph id="ph1">&lt;see langword="public static readonly" /&gt;</ph> в классе.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>That identifier is then used to reference the dependency property later, for operations such as setting its value programmatically or obtaining metadata.</source>
          <target state="translated">Затем этот идентификатор используется для ссылки на свойство зависимостей для операций, например задания значения программным образом или получение метаданных.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>An attached property is a property concept defined by <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Вложенное свойство является свойством понятием <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> implements attached properties as dependency properties.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> реализует вложенные свойства как свойства зависимости.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Because the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> attached properties are dependency properties, they can have metadata applied that can be used by the general property system for operations such as reporting layout characteristics.</source>
          <target state="translated">Поскольку <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> вложенные свойства являются свойствами зависимости, они могут быть применены метаданные, который может использоваться для операции, такие как сообщение о характеристиках структуры системой общих свойств.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information, see <bpt id="p1">[</bpt>Attached Properties Overview<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Общие сведения о вложенных свойствах<ept id="p1">](~/docs/framework/wpf/advanced/attached-properties-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о регистрации свойств зависимостей см. в разделе <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Use RegisterAttached for Value-inheriting Dependency Properties</source>
          <target state="translated">Использование RegisterAttached для наследования значения свойств зависимостей</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>One particular scenario for registering a dependency property with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> instead of <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> is to support property value inheritance.</source>
          <target state="translated">Один из сценариев для регистрации свойства зависимостей с <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> вместо <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> предназначен для поддержки наследования значения свойства.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>You should register value-inheriting dependency properties with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set* static methods to provide true attached property support accessors.</source>
          <target state="translated">Необходимо зарегистрировать наследование значения свойства зависимостей с <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> даже если класс определяет оболочку свойствам, которые предоставляют свойство зависимостей, и даже если не требуется предоставлять Get * и набор * статические методы для предоставления присоединенного значение true Поддержка доступа к свойствам.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</source>
          <target state="translated">Несмотря на то, что наследование значения свойства могут быть выполнены для неприсоединенных свойств зависимости, поведение наследования для неприсоединенного свойства в определенных границах элемента в дереве среды выполнения не определено.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</source>
          <target state="translated">Регистрация свойства как вложенного фактически делает вложенное свойство глобальным для системы свойств и гарантирует, что наследование значения свойства работает через все границы в дереве элементов.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Always use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> to register properties where you specify <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in the metadata.</source>
          <target state="translated">Всегда используйте <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> для регистрации свойства, где указываются <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> в метаданных.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Наследование значения свойства<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The following example registers an attached property on an abstract class using this <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> signature.</source>
          <target state="translated">В следующем примере регистрируется вложенное свойство для абстрактного класса с помощью этого <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> подписи.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttached(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>This attached property is an enumeration type property, and the registration adds a validation callback to verify that the provided value is a value of the enumeration.</source>
          <target state="translated">Это вложенное свойство является свойством типа перечисления и при регистрации добавляется обратный вызов проверки для проверки, предоставленное значение является значением перечисления.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Registers a read-only attached property.</source>
          <target state="translated">Регистрирует присоединенное свойство зависимостей, предназначенное только для чтения.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Имя регистрируемого свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The type of the property.</source>
          <target state="translated">Тип свойства.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Тип владельца, регистрирующий свойство зависимостей.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Метаданные свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registers a read-only attached property, with the specified property type, owner type, and property metadata.</source>
          <target state="translated">Регистрирует доступное только для чтения присоединенное свойство с указанным типом свойства, типом владельца и метаданными свойства.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</source>
          <target state="translated">Ключ свойства зависимостей, который следует использовать для задания значения статического доступного только для чтения поля в вашем классе, которое затем используется для ссылки на свойство зависимостей.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>This method returns the type <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, whereas <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> returns the type <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Этот метод возвращает тип <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, тогда как <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> возвращает тип <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</source>
          <target state="translated">Как правило, ключи, представляющие свойства только для чтения не становятся открытым, поскольку ключи можно использовать для задания значения свойства зависимостей, вызвав <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</source>
          <target state="translated">Структура класса повлияет вашим требованиям, но обычно рекомендуется ограничить доступ и видимость любого <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> для только те части кода, которые необходимы для установки этого свойства зависимостей как часть логики класса или приложения.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> as a <ph id="ph2">`public static readonly`</ph> field on your class.</source>
          <target state="translated">Кроме того, рекомендуется предоставить идентификатор свойства зависимостей для свойства зависимостей только для чтения, обеспечивая значение <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> как <ph id="ph2">`public static readonly`</ph> поля в вашем классе.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Вложенные свойства только для чтения используются редко, так как его использование в основной скрипт для вложенного свойства <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Without a public setter, an attached property cannot be set in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax.</source>
          <target state="translated">Без открытого переключателя невозможно задать присоединенное свойство в <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> синтаксиса.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о регистрации свойств зависимостей см. в разделе <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Use RegisterAttached for Value-inheriting Dependency Properties</source>
          <target state="translated">Использование RegisterAttached для наследования значения свойств зависимостей</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>One particular scenario for registering a dependency property as attached is to support property value inheritance.</source>
          <target state="translated">Один из сценариев регистрации свойств зависимостей как вложенного заключается в поддержке наследования значения свойства.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>You should register value-inheriting dependency properties with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set* static methods to provide true attached property support accessors.</source>
          <target state="translated">Необходимо зарегистрировать наследование значения свойства зависимостей с <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> даже если класс определяет оболочку свойствам, которые предоставляют свойство зависимостей, и даже если не требуется предоставлять Get * и набор * статические методы для предоставления присоединенного значение true Поддержка доступа к свойствам.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</source>
          <target state="translated">Несмотря на то, что наследование значения свойства могут быть выполнены для неприсоединенных свойств зависимости, поведение наследования для неприсоединенного свойства в определенных границах элемента в дереве среды выполнения не определено.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</source>
          <target state="translated">Регистрация свойства как вложенного фактически делает вложенное свойство глобальным для системы свойств и гарантирует, что наследование значения свойства работает через все границы в дереве элементов.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Always use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> to register properties where you specify <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in the metadata.</source>
          <target state="translated">Всегда используйте <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> для регистрации свойства, где указываются <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> в метаданных.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Наследование значения свойства<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Имя регистрируемого свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The type of the property.</source>
          <target state="translated">Тип свойства.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Тип владельца, регистрирующий свойство зависимостей.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Метаданные свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</source>
          <target state="translated">Ссылка на созданный пользователем обратный вызов, который должен выполнить пользовательскую проверку значения свойства зависимостей после обычной проверки типа.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registers a read-only attached property, with the specified property type, owner type, property metadata, and a validation callback.</source>
          <target state="translated">Регистрирует доступное только для чтения присоединенное свойство с указанным типом свойства, типом владельца, метаданными свойства и обратным вызовом для проверки.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</source>
          <target state="translated">Ключ свойства зависимостей, который следует использовать для задания значения статического доступного только для чтения поля в вашем классе, которое затем используется для ссылки на свойство зависимостей.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>This method returns the type <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, whereas <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> returns the type <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Этот метод возвращает тип <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, тогда как <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> возвращает тип <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Typically, the keys that represent the type <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Как правило, ключи, представляющие тип <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</source>
          <target state="translated">Как правило, ключи, представляющие свойства только для чтения не становятся открытым, поскольку ключи можно использовать для задания значения свойства зависимостей, вызвав <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</source>
          <target state="translated">Структура класса повлияет вашим требованиям, но обычно рекомендуется ограничить доступ и видимость любого <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> для только те части кода, которые необходимы для установки этого свойства зависимостей как часть логики класса или приложения.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> as a <ph id="ph2">`public static readonly`</ph> field on your class.</source>
          <target state="translated">Кроме того, рекомендуется предоставить идентификатор свойства зависимостей для свойства зависимостей только для чтения, обеспечивая значение <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> как <ph id="ph2">`public static readonly`</ph> поля в вашем классе.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Read-only attached properties are a rare scenario, because the primary scenario for an attached property is its use in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Вложенные свойства только для чтения используются редко, так как его использование в основной скрипт для вложенного свойства <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Without a public setter, an attached property cannot be set in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax.</source>
          <target state="translated">Без открытого переключателя невозможно задать присоединенное свойство в <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> синтаксиса.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о регистрации свойств зависимостей см. в разделе <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Use RegisterAttached for Value-inheriting Dependency Properties</source>
          <target state="translated">Использование RegisterAttached для наследования значения свойств зависимостей</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>One particular scenario for registering a dependency property as attached instead of <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> is to support property value inheritance.</source>
          <target state="translated">Один из сценариев регистрации свойств зависимостей как подключенные вместо <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Register%2A&gt;</ph> предназначен для поддержки наследования значения свойства.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>You should register value-inheriting dependency properties with <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> even if the class defines property wrapper accessors that expose the dependency property, and even if you do not intend to expose Get* and Set* static methods to provide true attached property support accessors.</source>
          <target state="translated">Необходимо зарегистрировать наследование значения свойства зависимостей с <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> даже если класс определяет оболочку свойствам, которые предоставляют свойство зависимостей, и даже если не требуется предоставлять Get * и набор * статические методы для предоставления присоединенного значение true Поддержка доступа к свойствам.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Although property value inheritance might appear to work for nonattached dependency properties, the inheritance behavior for a nonattached property through certain element boundaries in the runtime tree is undefined.</source>
          <target state="translated">Несмотря на то, что наследование значения свойства могут быть выполнены для неприсоединенных свойств зависимости, поведение наследования для неприсоединенного свойства в определенных границах элемента в дереве среды выполнения не определено.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registering the property as attached effectively makes the attached property a global property to the property system, and assures that property value inheritance works across all boundaries in an element tree.</source>
          <target state="translated">Регистрация свойства как вложенного фактически делает вложенное свойство глобальным для системы свойств и гарантирует, что наследование значения свойства работает через все границы в дереве элементов.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Always use <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> to register properties where you specify <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> in the metadata.</source>
          <target state="translated">Всегда используйте <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> для регистрации свойства, где указываются <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph> в метаданных.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterAttachedReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information, see <bpt id="p1">[</bpt>Property Value Inheritance<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Наследование значения свойства<ept id="p1">](~/docs/framework/wpf/advanced/property-value-inheritance.md)</ept>.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" uid="T:System.Windows.DependencyProperty">
          <source>Registers a dependency property as a read-only dependency property.</source>
          <target state="translated">Регистрирует свойство зависимостей как свойство зависимостей только для чтения.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Имя регистрируемого свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The type of the property.</source>
          <target state="translated">Тип свойства.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Тип владельца, регистрирующий свойство зависимостей.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Метаданные свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Registers a read-only dependency property, with the specified property type, owner type, and property metadata.</source>
          <target state="translated">Регистрирует доступное только для чтения свойство зависимостей с указанным типом свойства, типом владельца и метаданными свойства.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property.</source>
          <target state="translated">Ключ свойства зависимостей, который следует использовать для задания значения статического доступного только для чтения поля в вашем классе, которое затем используется для ссылки на свойство зависимостей.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>This method returns the type <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, whereas <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> returns the type <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Этот метод возвращает тип <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, тогда как <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> возвращает тип <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</source>
          <target state="translated">Как правило, ключи, представляющие свойства только для чтения не становятся открытым, поскольку ключи можно использовать для задания значения свойства зависимостей, вызвав <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</source>
          <target state="translated">Структура класса повлияет вашим требованиям, но обычно рекомендуется ограничить доступ и видимость любого <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> для только те части кода, которые необходимы для установки этого свойства зависимостей как часть логики класса или приложения.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> as a <ph id="ph2">`public static readonly`</ph> field on your class.</source>
          <target state="translated">Кроме того, рекомендуется предоставить идентификатор свойства зависимостей для свойства зависимостей только для чтения, обеспечивая значение <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> как <ph id="ph2">`public static readonly`</ph> поля в вашем классе.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Read-only dependency properties are a fairly typical scenario both in the existing <ph id="ph1">[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]</ph> and for customization scenarios, because other <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> features might require a dependency property even if that property is not intended to be settable by callers.</source>
          <target state="translated">Свойства зависимости только для чтения, это весьма распространенный сценарий как в существующем <ph id="ph1">[!INCLUDE[TLA2#tla_api](~/includes/tla2sharptla-api-md.md)]</ph> и сценарии настройки, так как другие <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> функциям может требоваться свойство зависимостей, даже если это свойство не планируется сделать доступным для установки по вызывающие объекты.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>You can use the value of a read-only dependency property as the basis for other property system operations that take a dependency property, such as basing a <ph id="ph1">&lt;xref:System.Windows.Trigger&gt;</ph> on the dependency property in a style.</source>
          <target state="translated">Значение свойства зависимости только для чтения можно использовать как основу для других операций системы свойств, принимающих свойство зависимостей, например основан <ph id="ph1">&lt;xref:System.Windows.Trigger&gt;</ph> для свойства зависимостей в стиле.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о регистрации свойств зависимостей см. в разделе <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The following example registers an <ph id="ph1">`AquariumSize`</ph> dependency property as read-only.</source>
          <target state="translated">В следующем примере регистрируется <ph id="ph1">`AquariumSize`</ph> свойство зависимостей только для чтения.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>The example defines <ph id="ph1">`AquariumSizeKey`</ph> as an internal key (so that other classes in the assembly could override metadata) and exposes the dependency property identifier based on that key as <ph id="ph2">`AquariumSizeProperty`</ph>.</source>
          <target state="translated">В примере определяется <ph id="ph1">`AquariumSizeKey`</ph> как внутренний ключ (, чтобы другие классы в сборке могли переопределять метаданные) и предоставляет идентификатор свойства зависимостей на основе такого ключа как <ph id="ph2">`AquariumSizeProperty`</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata)">
          <source>Also, a wrapper is created for <ph id="ph1">`AquariumSize`</ph>, with only a get accessor.</source>
          <target state="translated">Кроме того, создается программа-оболочка для <ph id="ph1">`AquariumSize`</ph>, с помощью только метод доступа get.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The name of the dependency property to register.</source>
          <target state="translated">Имя регистрируемого свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The type of the property.</source>
          <target state="translated">Тип свойства.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The owner type that is registering the dependency property.</source>
          <target state="translated">Тип владельца, регистрирующий свойство зависимостей.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Property metadata for the dependency property.</source>
          <target state="translated">Метаданные свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A reference to a user-created callback that should perform any custom validation of the dependency property value beyond typical type validation.</source>
          <target state="translated">Ссылка на созданный пользователем обратный вызов, который должен выполнить пользовательскую проверку значения свойства зависимостей после обычной проверки типа.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Registers a read-only dependency property, with the specified property type, owner type, property metadata, and a validation callback.</source>
          <target state="translated">Регистрирует доступное только для чтения свойство зависимостей с указанным типом свойства, типом владельца, метаданными свойства и обратным вызовом для проверки.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>A dependency property key that should be used to set the value of a static read-only field in your class, which is then used to reference the dependency property later.</source>
          <target state="translated">Ключ свойства зависимостей, который следует использовать для задания значения статического доступного только для чтения поля в вашем классе, которое затем используется для ссылки на свойство зависимостей.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>This method returns the type <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, whereas <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> returns the type <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Этот метод возвращает тип <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph>, тогда как <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.RegisterAttached%2A&gt;</ph> возвращает тип <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Typically, the keys that represent read-only properties are not made public, because the keys can be used to set the dependency property value by calling <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</source>
          <target state="translated">Как правило, ключи, представляющие свойства только для чтения не становятся открытым, поскольку ключи можно использовать для задания значения свойства зависимостей, вызвав <ph id="ph1">&lt;xref:System.Windows.DependencyObject.SetValue%28System.Windows.DependencyPropertyKey%2CSystem.Object%29&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Your class design will affect your requirements, but it is generally recommended to limit the access and visibility of any <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> to only those parts of your code that are necessary to set that dependency property as part of class or application logic.</source>
          <target state="translated">Структура класса повлияет вашим требованиям, но обычно рекомендуется ограничить доступ и видимость любого <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey&gt;</ph> для только те части кода, которые необходимы для установки этого свойства зависимостей как часть логики класса или приложения.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>It is also recommended that you expose a dependency property identifier for the read-only dependency property, by exposing the value of <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> as a <ph id="ph2">`public static readonly`</ph> field on your class.</source>
          <target state="translated">Кроме того, рекомендуется предоставить идентификатор свойства зависимостей для свойства зависимостей только для чтения, обеспечивая значение <ph id="ph1">&lt;xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A?displayProperty=nameWithType&gt;</ph> как <ph id="ph2">`public static readonly`</ph> поля в вашем классе.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Read-only dependency properties are a fairly typical scenario.</source>
          <target state="translated">Свойства зависимости только для чтения — это весьма распространенный сценарий.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>You can use the value of a read-only dependency property as the basis for other property system operations that take a dependency property, such as basing a <ph id="ph1">&lt;xref:System.Windows.Trigger&gt;</ph> on the dependency property in a style.</source>
          <target state="translated">Значение свойства зависимости только для чтения можно использовать как основу для других операций системы свойств, принимающих свойство зависимостей, например основан <ph id="ph1">&lt;xref:System.Windows.Trigger&gt;</ph> для свойства зависимостей в стиле.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>For more information on dependency property registration, see <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о регистрации свойств зависимостей см. в разделе <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>Validation on a read-only dependency property might be less important.</source>
          <target state="translated">Проверка на доступное только для чтения свойство зависимостей может быть менее важна.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.RegisterReadOnly(System.String,System.Type,System.Type,System.Windows.PropertyMetadata,System.Windows.ValidateValueCallback)">
          <source>The nonpublic access level you specify for the key reduces the likelihood for arbitrary invalid input.</source>
          <target state="translated">Уровень доступа к закрытым, заданный для ключа снижает вероятность произвольного недопустимого ввода.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.ToString">
          <source>Returns the string representation of the dependency property.</source>
          <target state="translated">Возвращает строковое представление свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Windows.DependencyProperty.ToString">
          <source>The string representation of the dependency property.</source>
          <target state="translated">Строковое представление свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.DependencyProperty.ToString">
          <source>This implementation returns the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph> property value.</source>
          <target state="translated">Эта реализация возвращает <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.Name%2A&gt;</ph> значение свойства.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>Specifies a static value that is used by the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> property system rather than <ph id="ph2">&lt;see langword="null" /&gt;</ph> to indicate that the property exists, but does not have its value set by the property system.</source>
          <target state="translated">Задает статическое значение, используемое системой свойств <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> вместо <ph id="ph2">&lt;see langword="null" /&gt;</ph> для указания того, что свойство существует, но его значение не задано системой свойств.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> is a sentinel value that is used for scenarios where the <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> property system is unable to determine a requested <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> value.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> имеет значение-метку, который используется для сценариев, где <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> системы свойств не может определить запрошенный <ph id="ph3">&lt;xref:System.Windows.DependencyProperty&gt;</ph> значение.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> is used rather than <ph id="ph2">`null`</ph>, because <ph id="ph3">`null`</ph> could be a valid property value, as well as a valid (and frequently used) <ph id="ph4">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> используется вместо <ph id="ph2">`null`</ph>, так как <ph id="ph3">`null`</ph> может быть является допустимым значением свойства, а также является допустимым (и часто используемые) <ph id="ph4">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> is never returned out of <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> никогда не возвращается из <ph id="ph2">&lt;xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>When you call <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType&gt;</ph> on a dependency property on a <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> instance, one of the following applies:</source>
          <target state="translated">При вызове <ph id="ph1">&lt;xref:System.Windows.DependencyObject.GetValue%2A?displayProperty=nameWithType&gt;</ph> для свойства зависимостей на <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph> применяется экземпляр, одно из следующих:</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>A dependency property has a default value established in metadata and that value is returned.</source>
          <target state="translated">Свойство зависимости имеет значение по умолчанию, установленное в метаданных и возвращается это значение.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>This value might come from <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</source>
          <target state="translated">Это значение может быть получено из <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.DefaultMetadata%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>Some other value was established by the property system, and the default value is no longer relevant.</source>
          <target state="translated">Системой свойств установлено другое значение и значение по умолчанию больше не нужны.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Value Precedence<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Приоритет значений свойств зависимостей<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>Setting a <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> of <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> is specifically disallowed.</source>
          <target state="translated">Установка <ph id="ph1">&lt;xref:System.Windows.PropertyMetadata.DefaultValue%2A&gt;</ph> из <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> специально не разрешено.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType&gt;</ph> returns <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> when the requested property has not been locally set.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyObject.ReadLocalValue%2A?displayProperty=nameWithType&gt;</ph> Возвращает <ph id="ph2">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> Если запрошенное свойство не задано локально.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> has a special meaning when used as the return value of a <ph id="ph2">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> имеет особое значение при использовании в качестве возвращаемого значения <ph id="ph2">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Callbacks and Validation<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>обратных вызовах свойства зависимости и проверки<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.DependencyProperty.UnsetValue">
          <source>If you are binding to a database, note that <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> is not equivalent to <ph id="ph2">&lt;xref:System.DBNull.Value&gt;</ph>, in a similar way to how <ph id="ph3">&lt;xref:System.DBNull.Value&gt;</ph> is not equivalent to a true null.</source>
          <target state="translated">При привязке к базе данных, обратите внимание, что <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.UnsetValue&gt;</ph> не эквивалентен <ph id="ph2">&lt;xref:System.DBNull.Value&gt;</ph>, аналогично тому, как <ph id="ph3">&lt;xref:System.DBNull.Value&gt;</ph> не соответствует параметру значение true, значение null.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>Gets the value validation callback for the dependency property.</source>
          <target state="translated">Возвращает обратный вызов для проверки значения свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>The value validation callback for this dependency property, as provided for the <ph id="ph1">&lt;paramref name="validateValueCallback" /&gt;</ph> parameter in the original dependency property registration.</source>
          <target state="translated">Обратный вызов для проверки значения данного свойства зависимостей, указанный параметром <ph id="ph1">&lt;paramref name="validateValueCallback" /&gt;</ph> при изначальной регистрации свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>This property will contain <ph id="ph1">`null`</ph> for any dependency property with no registered validation callback.</source>
          <target state="translated">Это свойство будет содержать <ph id="ph1">`null`</ph> для любого свойства зависимостей без зарегистрированного обратного вызова проверки.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>Validate value callbacks must act in a static sense: validation applied through the <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> cannot determine whether the provided value is valid for any particular instance.</source>
          <target state="translated">Проверить значение обратные вызовы должны действовать статически: проверка, применяемая через <ph id="ph1">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> не может определить, является ли указанное значение допустимым для какой-либо экземпляр.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>The callback can only determine whether all objects that possess the dependency property should or should not accept the provided value as valid.</source>
          <target state="translated">Обратный вызов может только определить, следует ли все объекты, которые обладают свойством зависимостей, или не должен принимать указанное значение как допустимое.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>If you need to perform validation that relies on knowing the values of other dependency properties on a particular instance, use a <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> instead.</source>
          <target state="translated">Если необходимо выполнять проверку, полагаясь на знание значений других свойств зависимостей в определенном экземпляре, используйте <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> вместо него.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>The <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> is registered as part of dependency property metadata, rather than directly within the dependency property identifier.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> Зарегистрирован как часть метаданных свойства зависимостей, а не непосредственно в идентификатор свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.DependencyProperty.ValidateValueCallback">
          <source>For details, see <bpt id="p1">[</bpt>Dependency Property Callbacks and Validation<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>обратных вызовах свойства зависимости и проверки<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-callbacks-and-validation.md)</ept>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>