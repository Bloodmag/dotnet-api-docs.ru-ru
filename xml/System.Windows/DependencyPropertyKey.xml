<Type Name="DependencyPropertyKey" FullName="System.Windows.DependencyPropertyKey">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9a12e407bc5345e416145c390f8fcd6f8262c445" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30676978" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class DependencyPropertyKey" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit DependencyPropertyKey extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.DependencyPropertyKey" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class DependencyPropertyKey" />
  <TypeSignature Language="C++ CLI" Value="public ref class DependencyPropertyKey sealed" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Предоставляет идентификатор свойства зависимостей для ограниченного доступа на запись к доступному только для чтения свойству зависимостей.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyPropertyKey> экземпляры получаются как возвращаемое значение вызова регистрации свойства зависимостей, с помощью методов <xref:System.Windows.DependencyProperty.RegisterReadOnly%2A> или <xref:System.Windows.DependencyProperty.RegisterAttachedReadOnly%2A>.  
  
 Типы, которые регистрации свойства зависимостей можно использовать <xref:System.Windows.DependencyPropertyKey> в вызовах <xref:System.Windows.DependencyObject.SetValue%2A> и <xref:System.Windows.DependencyObject.ClearValue%2A> как часть логики класса, измените значение свойства. Если разрешено уровнем доступа ключа, связанные классы можно также использовать ключ и свойства зависимостей. Например можно объявить ключ внутренним и других типов в этой сборке можно также задать это свойство зависимостей.  
  
 <xref:System.Windows.DependencyPropertyKey> Возвращается по зависимости только для чтения регистрации свойства, не следует делать открытым, так как открытие ключа делает свойство можно задать таким образом, игнорируя точке его регистрации в качестве свойства зависимости только для чтения. Кроме того, открытие ключа вызывает несоответствие между доступными зависимостей поведения свойства и его [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] реализации свойства программы-оболочки, которые имеет недопустимый класс конструирования.  
  
 Вместо предоставления самого ключа, вместо этого следует предоставлять <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> значение <xref:System.Windows.DependencyPropertyKey> как `public static readonly` <xref:System.Windows.DependencyProperty> в вашем классе. Это позволяет возвращать допустимый идентификатор свойства зависимостей для определенных операций системы свойств, например перечисления локально заданных значений свойства. Однако идентификатор таким образом получить не все возможности <xref:System.Windows.DependencyProperty> для многих операций системы свойств.  
  
   
  
## Examples  
 Следующий пример регистрирует свойство зависимости только для чтения, а также использует ключ для двух целей в других членах класса: обеспечение get «оболочку», а также как идентификатор для защищенной операции определения, задающее значение на основе вычисления значений других свойств.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyProperty" />
  </Docs>
  <Members>
    <Member MemberName="DependencyProperty">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyProperty DependencyProperty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyProperty DependencyProperty" />
      <MemberSignature Language="DocId" Value="P:System.Windows.DependencyPropertyKey.DependencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DependencyProperty As DependencyProperty" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyProperty ^ DependencyProperty { System::Windows::DependencyProperty ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает идентификатор свойства зависимостей, связанный с данным специализированным идентификатором доступного только для чтения свойства зависимостей.</summary>
        <value>Соответствующий идентификатор свойства зависимостей.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> Значение включает идентификатор только для чтения свойства участвовать в стандартных операций системы свойств, с помощью некоторых тех же интерфейсов, которые заданы для свойства зависимости для чтения и записи.  
  
 Чтобы реализовать метод доступа get свойства для свойства зависимостей только для чтения, следует создать и представить <xref:System.Windows.DependencyProperty> идентификатор класса. Это служит двум целям.  
  
-   Потребностями класс <xref:System.Windows.DependencyProperty> идентификатор для реализации метода доступа get для свойства оболочки. Вы используете <xref:System.Windows.DependencyProperty> как параметр для <xref:System.Windows.DependencyObject.GetValue%2A> вызова, который реализует метод доступа get.  
  
-   <xref:System.Windows.DependencyProperty> Идентификаторы предоставляют свойство зависимостей в системе свойств таким образом, что другие методы, основанные на метаданных к нему возможен доступ к стандартной форме. Для экземпляра Если вызван <xref:System.Windows.DependencyObject.GetLocalValueEnumerator%2A> на некоторых <xref:System.Windows.DependencyObject> и получить идентификатор перечисление локально набора свойств (значения и идентификаторы) вернул для свойства зависимостей только для чтения будет вашей <xref:System.Windows.DependencyProperty> преимущества, а не ключ. Предоставление доступа к не <xref:System.Windows.DependencyProperty> идентификатор повышает безопасность свойства зависимости только для чтения любым способом, он только выполняет операции, затрагивающие свойство более удобны для последующих производных классов и экземпляров классов.  
  
 Для предоставления <xref:System.Windows.DependencyProperty> вызывать идентификатор класса <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> непосредственно на ваш ключ. Это значение используется для создания `public static readonly` <xref:System.Windows.DependencyProperty> идентификатор класса, который соответствует <xref:System.Windows.DependencyPropertyKey>.  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Windows.DependencyPropertyKey.DependencyProperty%2A> для предоставления <xref:System.Windows.DependencyProperty> идентификатор (`AquariumGraphicProperty`) для `AquariumGraphic` зависимости только для чтения свойство в классе. В примере также показано <xref:System.Windows.DependencyPropertyKey> созданием (как внутренний член) и метод доступа get для `AquariumGraphic`.  
  
 [!code-csharp[WPFAquariumSln#RODP](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodp)]
 [!code-vb[WPFAquariumSln#RODP](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodp)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.DependencyProperty" />
      </Docs>
    </Member>
    <Member MemberName="OverrideMetadata">
      <MemberSignature Language="C#" Value="public void OverrideMetadata (Type forType, System.Windows.PropertyMetadata typeMetadata);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void OverrideMetadata(class System.Type forType, class System.Windows.PropertyMetadata typeMetadata) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.DependencyPropertyKey.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />
      <MemberSignature Language="VB.NET" Value="Public Sub OverrideMetadata (forType As Type, typeMetadata As PropertyMetadata)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void OverrideMetadata(Type ^ forType, System::Windows::PropertyMetadata ^ typeMetadata);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forType" Type="System.Type" />
        <Parameter Name="typeMetadata" Type="System.Windows.PropertyMetadata" />
      </Parameters>
      <Docs>
        <param name="forType">Тип, в котором существует данное свойство зависимостей и следует переопределить метаданные.</param>
        <param name="typeMetadata">Метаданные, переданные для этого типа.</param>
        <summary>Переопределяет метаданные доступного только для чтения свойства зависимостей, представленного данным идентификатором свойства зависимостей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Переопределение метаданных в свойстве зависимости только для чтения выполняется по тем же причинам с переопределением метаданных для свойства зависимостей для чтения и записи и ограничен доступ на уровне ключа, так как поведения, заданные в метаданных можно изменить установленное поведение ( значение по умолчанию, например).  
  
 Как со свойствами зависимости для чтения и записи, переопределение метаданных в свойстве зависимости только для чтения должна выполняться только до этого свойства, используемые системой свойств (это соответствует времени, конкретные экземпляры объектов, которые регистрируют Свойство создаются экземпляры). Вызовы <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> следует выполнять только в статическом конструкторе типа, предоставляющего себя в качестве `forType` параметра этого метода или эквивалентные инициализации для этого класса.  
  
 Этот метод фактически пересылает <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> метод, передавая <xref:System.Windows.DependencyPropertyKey> экземпляр в качестве параметра ключа.  
  
   
  
## Examples  
 В следующем примере переопределяется метаданные для существующего свойства зависимости только для чтения, наследующий класс. В этом случае целью сценария было Добавление принудительного обратного вызова значения, но не имеют метаданных базового свойства. Можно также переопределить метаданные для любых других причин, по которой обычно является переопределения метаданных соответствующие (изменение значения по умолчанию, добавив <xref:System.Windows.FrameworkPropertyMetadataOptions> значения и т. д.)  
  
 [!code-csharp[WPFAquariumSln#RODPOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/WPFAquariumSln/CSharp/WPFAquariumObjects/Class1.cs#rodpoverride)]
 [!code-vb[WPFAquariumSln#RODPOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WPFAquariumSln/visualbasic/wpfaquariumobjects/class1.vb#rodpoverride)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Попытка переопределения метаданных в доступном для чтения и записи свойстве зависимостей (не может быть осуществлена с помощью данной сигнатуры).</exception>
        <exception cref="T:System.ArgumentException">Метаданные уже были установлены для свойства, так как они существуют в указанном типе.</exception>
        <altmember cref="T:System.Windows.DependencyProperty" />
        <altmember cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata,System.Windows.DependencyPropertyKey)" />
      </Docs>
    </Member>
  </Members>
</Type>