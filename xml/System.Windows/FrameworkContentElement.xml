<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="FrameworkContentElement.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac51c90a9ddef163b0e59dd29a8a1fb7b48cd8dbb6c.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1c90a9ddef163b0e59dd29a8a1fb7b48cd8dbb6c</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkContentElement">
          <source><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> is the WPF framework-level implementation and expansion of the <ph id="ph2">&lt;see cref="T:System.Windows.ContentElement" /&gt;</ph> base class.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> является реализацией уровня платформы WPF и расширением базового класса <ph id="ph2">&lt;see cref="T:System.Windows.ContentElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkContentElement">
          <source><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> adds support for additional input APIs (including tooltips and context menus), storyboards, data context for data binding, styles support, and logical tree helper APIs.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> добавляет поддержку дополнительных API входных данных (включая подсказки и контекстные меню), раскадровки, контексты данных для привязки, поддержку стилей и вспомогательные API логического дерева.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> does not yet define its own rendering behavior; instantiating an actual <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> class instance in code or markup is possible but displays nothing in a <ph id="ph3">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> application <ph id="ph4">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> еще не определяет свое поведение отрисовки; При создании экземпляра фактический <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> экземпляров классов в код или разметку возможна, но не отображает ничего в <ph id="ph3">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> приложения <ph id="ph4">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>Rendering logic must be provided by classes that take <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> child elements as part of their content model, or in <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived classes.</source>
          <target state="translated">Логика обработки должны предоставляться классы, которые принимают <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> дочерние элементы как часть своей модели содержимого, или в <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> производных классов.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> deliberately parallels many of the same <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> as <ph id="ph3">&lt;xref:System.Windows.FrameworkElement&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> Многие из перечисленных намеренно параллельно <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> как <ph id="ph3">&lt;xref:System.Windows.FrameworkElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>Note that certain <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> found on <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> will not have a <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> equivalent.</source>
          <target state="translated">Обратите внимание что некоторые <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> на <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> не будет иметь <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> эквивалент.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>Several of the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> are for functionality such as geometry representation or layout, which are not relevant for a <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>.</source>
          <target state="translated">Некоторые <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> <ph id="ph2">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph> предназначены для функции, такие как представление geometry или макета, которые не относятся к <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>The majority of existing <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived classes will be found in the <ph id="ph2">&lt;xref:System.Windows.Documents&gt;</ph> namespace.</source>
          <target state="translated">Большинство существующих <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> производные классы, которые будут находиться в <ph id="ph2">&lt;xref:System.Windows.Documents&gt;</ph> пространства имен.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>Many of these derived classes implement elements for the flow document model.</source>
          <target state="translated">Многие из этих производных классов реализуют элементы для модели потокового документа.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkContentElement">
          <source>Certain derived classes such as <ph id="ph1">&lt;xref:System.Windows.Documents.Hyperlink&gt;</ph> have some control-like functionality, but are derived from <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> such that the control-like elements can still participate in the flow document model.</source>
          <target state="translated">Определенные производные классы, такие как <ph id="ph1">&lt;xref:System.Windows.Documents.Hyperlink&gt;</ph> имеют некоторые функции типа элемента управления, но являются производными от <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> таким образом, что элементы управления по принципу по-прежнему могут участвовать в модели потокового документа.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> class.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>The child element to be added.</source>
          <target state="translated">Добавляемый дочерний элемент.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>Adds the provided element as a child of this element.</source>
          <target state="translated">Добавляет указанный элемент в качестве дочернего для данного элемента.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>This method can throw an exception if called at a time when the logical tree is being iterated by another process.</source>
          <target state="translated">Этот метод может создать исключение, если вызывается в момент, когда выполняется итерация логического дерева с помощью другого процесса.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>Most <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived classes expose dedicated collections that are responsible for containment (for example, <ph id="ph2">&lt;xref:System.Windows.Documents.Span.Inlines%2A&gt;</ph> on the <ph id="ph3">&lt;xref:System.Windows.Documents.Span&gt;</ph> class; <ph id="ph4">&lt;xref:System.Windows.Documents.Section.Blocks%2A&gt;</ph> on the <ph id="ph5">&lt;xref:System.Windows.Documents.Section&gt;</ph> class).</source>
          <target state="translated">Большинство <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> производные классы предоставляют выделенный коллекций, которые отвечают за вложения (например, <ph id="ph2">&lt;xref:System.Windows.Documents.Span.Inlines%2A&gt;</ph> на <ph id="ph3">&lt;xref:System.Windows.Documents.Span&gt;</ph> класса; <ph id="ph4">&lt;xref:System.Windows.Documents.Section.Blocks%2A&gt;</ph> на <ph id="ph5">&lt;xref:System.Windows.Documents.Section&gt;</ph> класса).</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>You can typically avoid any need to manipulate the logical tree directly if you derive from these classes instead.</source>
          <target state="translated">Обычно необходимость управления логического дерева напрямую, если наследование от этих классов, вместо этого можно избежать.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>Working with the logical tree for content elements is an advanced scenario that may require a specialized parser or a specialized <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> that acts as the parent rendering element (content host).</source>
          <target state="translated">Работа с логического дерева для элементов содержимого — расширенный сценарий, который может потребовать специализированное средство синтаксического анализа или специализированный <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> , действует как родительский элемент отрисовки (хранилище содержимого).</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.AddLogicalChild(System.Object)">
          <source>For more information about how to use <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.LogicalChildren%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A&gt;</ph>, see <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об использовании <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.LogicalChildren%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A&gt;</ph>, в разделе <bpt id="p1">[</bpt>деревьев в WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginInit">
          <source>Called before an element is initialized.</source>
          <target state="translated">Вызывается перед инициализацией элемента.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginInit">
          <source>Override this method to provide special handling that should occur before your element is initialized during the element loading process.</source>
          <target state="translated">Переопределите этот метод, чтобы обеспечить специальную обработку, которая будет выполняться перед инициализацией элемента в процессе его загрузки.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginInit">
          <source>Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</source>
          <target state="translated">Реализация должна вызывать базовую реализацию, поскольку реализация base (по умолчанию) устанавливает внутренние флаги для отслеживания инициализации.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginInit">
          <source>The base implementation will throw an exception if <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkContentElement.BeginInit" /&gt;</ph> is called more than one time on the same element prior to reaching <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.EndInit" /&gt;</ph>.</source>
          <target state="translated">Базовая реализация будет вызывать исключение, если <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkContentElement.BeginInit" /&gt;</ph> вызывается более одного раза в один и тот же элемент до достижения <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.EndInit" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkContentElement">
          <source>Begins the sequence of actions that are contained in the provided storyboard.</source>
          <target state="translated">Начинает последовательность действий, содержащихся в предоставленной раскадровке.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>The storyboard to begin.</source>
          <target state="translated">Раскадровка, которая будет начата.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>Begins the sequence of actions that are contained in the provided storyboard.</source>
          <target state="translated">Начинает последовательность действий, содержащихся в предоставленной раскадровке.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>For the signatures that do not use the <ph id="ph1">`isControllable`</ph>, parameter, or when that parameter is specified <ph id="ph2">`false`</ph>, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</source>
          <target state="translated">Для подписи, которые не используют <ph id="ph1">`isControllable`</ph>, параметра, или при указании этого параметра <ph id="ph2">`false`</ph>, связанные с анимацией часы шкалы времени удаляются сразу же после достижения периода «Заливка».</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>Therefore the animation cannot be restarted after being run once.</source>
          <target state="translated">Поэтому анимация не будет перезапущена после однократного запуска.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</source>
          <target state="translated">Обратите внимание, что управление анимацией также требует раскадровки или доступа к ней как экземпляр в коде.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>The storyboard to begin.</source>
          <target state="translated">Раскадровка, которая будет начата.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>A value of the enumeration that describes behavior to use if a property described in the storyboard is already animated.</source>
          <target state="translated">Значение перечисления, описывающего поведение в случае, если описанное в раскадровке свойство уже анимировано.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Begins the sequence of actions that are contained in the provided storyboard, with options specified for what should occur if the property is already animated.</source>
          <target state="translated">Начинает последовательность действий, содержащихся в предоставленной раскадровке, с указанием действий, которые следует выполнить в случае уже анимированного свойства.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>For the signatures that do not use the <ph id="ph1">`isControllable`</ph>, parameter, or when that parameter is specified <ph id="ph2">`false`</ph>, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</source>
          <target state="translated">Для подписи, которые не используют <ph id="ph1">`isControllable`</ph>, параметра, или при указании этого параметра <ph id="ph2">`false`</ph>, связанные с анимацией часы шкалы времени удаляются сразу же после достижения периода «Заливка».</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Therefore the animation cannot be restarted after being run once.</source>
          <target state="translated">Поэтому анимация не будет перезапущена после однократного запуска.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</source>
          <target state="translated">Обратите внимание, что управление анимацией также требует раскадровки или доступа к ней как экземпляр в коде.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Using the Compose HandoffBehavior</source>
          <target state="translated">Использование составлять руководство.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>When you apply a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.Animation.AnimationTimeline&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> to a property by using the <ph id="ph4">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph> <ph id="ph5">&lt;xref:System.Windows.Media.Animation.HandoffBehavior&gt;</ph>, any <ph id="ph6">&lt;xref:System.Windows.Media.Animation.Clock&gt;</ph> objects previously associated with that property continue to consume system resources; the timing system does not remove the clocks automatically.</source>
          <target state="translated">При применении <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.Animation.AnimationTimeline&gt;</ph>, или <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> к свойству с помощью <ph id="ph4">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph> <ph id="ph5">&lt;xref:System.Windows.Media.Animation.HandoffBehavior&gt;</ph>, любые <ph id="ph6">&lt;xref:System.Windows.Media.Animation.Clock&gt;</ph> ранее связанную с ним объекты по-прежнему потребление системных ресурсов; в случае система времени не удаляет эти часы автоматически.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>To avoid performance issues when you apply a large number of clocks by using <ph id="ph1">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph>, you should remove composing clocks from the animated property after they complete.</source>
          <target state="translated">Чтобы избежать проблем с производительностью при применении большое число часов с помощью <ph id="ph1">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph>, необходимо удалить составляющую часами анимированное свойство после их завершения.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>There are several ways to remove a clock:</source>
          <target state="translated">Существует несколько способов удаления часов:</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>To remove all clocks from a property, use the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29&gt;</ph> method of the animated object.</source>
          <target state="translated">Чтобы удалить все часы из свойства, используйте <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29&gt;</ph> или <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29&gt;</ph> метод анимированного объекта.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Specify the property being animated as the first parameter, and <ph id="ph1">`null`</ph> as the second.</source>
          <target state="translated">Укажите в качестве первого параметра, анимируемого свойства и <ph id="ph1">`null`</ph> вторым.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>This removes all animation clocks from the property.</source>
          <target state="translated">При этом удаляются все часы анимации из свойства.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>To remove a specific <ph id="ph1">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> from a list of clocks, use the <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> property of the <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> to retrieve a <ph id="ph4">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>, then call the <ph id="ph5">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph> method of the <ph id="ph6">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>.</source>
          <target state="translated">Для удаления определенных <ph id="ph1">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> из списка часов используйте <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> свойство <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> для получения <ph id="ph4">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>, затем вызовите <ph id="ph5">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph> метод <ph id="ph6">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>This is typically done in the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> event handler for a clock.</source>
          <target state="translated">Обычно это делается <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> обработчика событий для часов.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Note that only root clocks can be controlled by a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>; the <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> property of a child clock returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Обратите внимание, что только корневые часы могут управляться <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>; <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> свойство дочерних часов возвращает <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Note also that the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> event is not raised if the effective duration of the clock is forever.</source>
          <target state="translated">Обратите внимание, что <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> событие не происходит, если эффективная продолжительность часов является бесконечностью.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>In that case, the user must determine when to call <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph>.</source>
          <target state="translated">В этом случае пользователь должен определить, когда вызывать <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>This is primarily an issue for animations on objects that have a long lifetime.</source>
          <target state="translated">В основном это проблема для анимации объектов, имеющих длинное время жизни.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>When an object is garbage collected, its clocks are also disconnected and garbage collected.</source>
          <target state="translated">При обнаружении объектов сбора мусора, его часы также будут отключены и собраны как мусор.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>For more information about clock objects, see <bpt id="p1">[</bpt>Animation and Timing System Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об объектах часов см. в разделе <bpt id="p1">[</bpt>анимации и общие сведения о синхронизации системы<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>The storyboard to begin.</source>
          <target state="translated">Раскадровка, которая будет начата.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>A value of the enumeration that describes behavior to use if a  property described in the storyboard is already animated.</source>
          <target state="translated">Значение перечисления, описывающего поведение в случае, если описанное в раскадровке свойство уже анимировано.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Declares whether the animation is controllable (can be paused) after it is started.</source>
          <target state="translated">Объявляет, является ли анимация управляемой после запуска (можно ли ее приостановить).</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Begins the sequence of actions that are contained in the provided storyboard, with specified state for control of the animation after it is started.</source>
          <target state="translated">Начинает последовательность действий, содержащихся в предоставленной раскадровке, с указанным состоянием управления анимацией после ее запуска.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>For the signatures that do not use the <ph id="ph1">`isControllable`</ph>, parameter, or when that parameter is specified <ph id="ph2">`false`</ph>, the timeline clocks associated with the animation are removed as soon as it reaches the "Fill" period.</source>
          <target state="translated">Для подписи, которые не используют <ph id="ph1">`isControllable`</ph>, параметра, или при указании этого параметра <ph id="ph2">`false`</ph>, связанные с анимацией часы шкалы времени удаляются сразу же после достижения периода «Заливка».</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Therefore the animation cannot be restarted after being run once.</source>
          <target state="translated">Поэтому анимация не будет перезапущена после однократного запуска.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Note that controlling an animation also requires that the storyboard be named or accessible as an instance in code.</source>
          <target state="translated">Обратите внимание, что управление анимацией также требует раскадровки или доступа к ней как экземпляр в коде.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Using the Compose HandoffBehavior</source>
          <target state="translated">Использование составлять руководство.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>When you apply a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.Animation.AnimationTimeline&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> to a property by using the <ph id="ph4">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph> <ph id="ph5">&lt;xref:System.Windows.Media.Animation.HandoffBehavior&gt;</ph>, any <ph id="ph6">&lt;xref:System.Windows.Media.Animation.Clock&gt;</ph> objects previously associated with that property continue to consume system resources; the timing system does not remove these clocks automatically.</source>
          <target state="translated">При применении <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.Animation.AnimationTimeline&gt;</ph>, или <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> к свойству с помощью <ph id="ph4">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph> <ph id="ph5">&lt;xref:System.Windows.Media.Animation.HandoffBehavior&gt;</ph>, любые <ph id="ph6">&lt;xref:System.Windows.Media.Animation.Clock&gt;</ph> ранее связанную с ним объекты по-прежнему потребление системных ресурсов; в случае система времени не удаляет эти часы автоматически.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>To avoid performance issues when you apply a large number of clocks by using <ph id="ph1">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph>, you should remove composing clocks from the animated property after they complete.</source>
          <target state="translated">Чтобы избежать проблем с производительностью при применении большое число часов с помощью <ph id="ph1">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph>, необходимо удалить составляющую часами анимированное свойство после их завершения.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>There are several ways to remove a clock:</source>
          <target state="translated">Существует несколько способов удаления часов:</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>To remove all clocks from a property, use the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29&gt;</ph> method of the animated object.</source>
          <target state="translated">Чтобы удалить все часы из свойства, используйте <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29&gt;</ph> или <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29&gt;</ph> метод анимированного объекта.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Specify the property being animated as the first parameter, and <ph id="ph1">`null`</ph> as the second.</source>
          <target state="translated">Укажите в качестве первого параметра, анимируемого свойства и <ph id="ph1">`null`</ph> вторым.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>This removes all animation clocks from the property.</source>
          <target state="translated">При этом удаляются все часы анимации из свойства.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>To remove a specific <ph id="ph1">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> from a list of clocks, use the <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> property of the <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> to retrieve a <ph id="ph4">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>, then call the <ph id="ph5">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph> method of the <ph id="ph6">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>.</source>
          <target state="translated">Для удаления определенных <ph id="ph1">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> из списка часов используйте <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> свойство <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> для получения <ph id="ph4">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>, затем вызовите <ph id="ph5">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph> метод <ph id="ph6">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>This is typically done in the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> event handler for a clock.</source>
          <target state="translated">Обычно это делается <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> обработчика событий для часов.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Note that only root clocks can be controlled by a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>; the <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> property of a child clock returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Обратите внимание, что только корневые часы могут управляться <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>; <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> свойство дочерних часов возвращает <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Note also that the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> event is not raised if the effective duration of the clock is forever.</source>
          <target state="translated">Обратите внимание, что <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> событие не происходит, если эффективная продолжительность часов является бесконечностью.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>In that case, the user must determine when to call <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph>.</source>
          <target state="translated">В этом случае пользователь должен определить, когда вызывать <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>This is primarily an issue for animations on objects that have a long lifetime.</source>
          <target state="translated">В основном это проблема для анимации объектов, имеющих длинное время жизни.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>When an object is garbage collected, its clocks are also disconnected and garbage collected.</source>
          <target state="translated">При обнаружении объектов сбора мусора, его часы также будут отключены и собраны как мусор.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>For more information about clock objects, see <bpt id="p1">[</bpt>Animation and Timing System Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об объектах часов см. в разделе <bpt id="p1">[</bpt>анимации и общие сведения о синхронизации системы<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>Gets or sets the <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph> that is used for the element.</source>
          <target state="translated">Возвращает или задает группу <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph>,  которая используется для элемента.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph> that is used for the element.</source>
          <target state="translated">Группа <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph>, используемая для элемента.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>A <ph id="ph1">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> can be used to validate the values of multiple properties of an object.</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> можно использовать для проверки значений нескольких свойств объекта.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>For example, suppose that an application prompts the user to enter an address and then populates an object of type <ph id="ph1">`Address`</ph>, which has the properties <ph id="ph2">`Street`</ph>, <ph id="ph3">`City`</ph>, <ph id="ph4">`ZipCode`</ph>, and <ph id="ph5">`Country`</ph>, with the values that the user provided.</source>
          <target state="translated">Предположим, что приложение предлагает пользователю ввести адрес и заполняет объект типа <ph id="ph1">`Address`</ph>, который имеет свойства <ph id="ph2">`Street`</ph>, <ph id="ph3">`City`</ph>, <ph id="ph4">`ZipCode`</ph>, и <ph id="ph5">`Country`</ph>, со значениями, пользователь предоставлен.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>The application has a panel that contains four <ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> controls, each of which is bound to one of the object’s properties.</source>
          <target state="translated">Приложение имеет панель, которая содержит четыре <ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> элементов управления, привязанных к одному из свойств объекта.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>You can use a <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph> in a <ph id="ph2">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> to validate the <ph id="ph3">`Address`</ph> object.</source>
          <target state="translated">Можно использовать <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph> в <ph id="ph2">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> для проверки <ph id="ph3">`Address`</ph> объекта.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>For example, the <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph> can ensure that the zip code is valid for the country of the address.</source>
          <target state="translated">Например <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph> можно обеспечить допустимость ZIP-код страны адреса.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>Child elements inherit the <ph id="ph1">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> from their parent elements, just as with any other inheritable property.</source>
          <target state="translated">Дочерние элементы наследуют <ph id="ph1">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> от своих родительских элементов, как и в случае любого другого наследуемые свойства.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.BindingGroup">
          <source>Metadata properties set to <bpt id="p1">**</bpt>true<ept id="p1">**</ept></source>
          <target state="translated">Значение свойства метаданных <bpt id="p1">**</bpt>true<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.BindingGroupProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.BindingGroup" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.BringIntoView">
          <source>Attempts to bring this element into view, within any scrollable regions it is contained within.</source>
          <target state="translated">Пытается отобразить данный элемент вместе с содержащимися в нем прокручиваемыми областями.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BringIntoView">
          <source>By calling this method, you effectively will call <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A&gt;</ph> on any parent scrollable area that contains the element (the parent may very well be a <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, not a <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>).</source>
          <target state="translated">Путем вызова данного метода, фактически будет вызываться <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A&gt;</ph> на все родительские прокручиваемую область, которая содержит элемент (родительский могут оказаться очень <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, а не <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.BringIntoView">
          <source>If this element is not contained in a scrollable area, the event is still raised, but there will be no effect.</source>
          <target state="translated">Если этот элемент не содержится в прокручиваемую область, по-прежнему вызывается событие, но будет иметь никакого влияния.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>Gets or sets the context menu element that should appear whenever the context menu is requested via <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> from within this element.</source>
          <target state="translated">Возвращает или задает элемент контекстного меню, который должен отображаться каждый раз при запросе контекстного меню через <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> из данного элемента.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>The context menu that this element uses.</source>
          <target state="translated">Контекстное меню, используемое данным элементом.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>None</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ContextMenu">
          <source>The following example places a <ph id="ph1">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> on a <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph>.</source>
          <target state="translated">В следующих местах пример <ph id="ph1">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> на <ph id="ph2">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Occurs just before any context menu on the element is closed.</source>
          <target state="translated">Происходит непосредственно перед закрытием какого-либо контекстного меню в элементе.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>To suppress closing context menus, handlers of the event should mark it as handled.</source>
          <target state="translated">Для подавления закрытия контекстных меню обработчики события следует пометить как обработанное.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>To use this event as an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style, you must reference the underlying service event identifier:</source>
          <target state="translated">Чтобы использовать это событие как <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> в стиле, необходимо сослаться на идентификатор события базовой службы:</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>(This usage is required because the event implementation on <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> that exposes the underlying service event does not correctly map the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuClosing&gt;</ph> identifier for use in triggers).</source>
          <target state="translated">(Такое использование является обязательным, поскольку реализация событий в <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> , предоставляет базовое событие службы не сопоставляют правильно <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuClosing&gt;</ph> идентификатор для использования в триггерах).</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Routed Event Information</source>
          <target state="translated">Сведения о маршрутизируемом событии</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Routing strategy</source>
          <target state="translated">Стратегия маршрутизации</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Bubbling</source>
          <target state="translated">Вверх</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>Delegate</source>
          <target state="translated">делегат</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>The following example implements a handler that changes the cursor over a named region <ph id="ph1">`DisplayArea`</ph> (not shown).</source>
          <target state="translated">В следующем примере реализуется обработчик, изменяющий курсор над именованной областью <ph id="ph1">`DisplayArea`</ph> (не показано).</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuClosing">
          <source>The comment hints at a <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> usage, but in fact this sample would be identical if <ph id="ph2">`DisplayArea`</ph> were a <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>.</source>
          <target state="translated">Указывает комментарий на <ph id="ph1">&lt;xref:System.Windows.UIElement&gt;</ph> использование ",", но в действительности будет совпадать в этом примере если <ph id="ph2">`DisplayArea`</ph> были <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated">Идентифицирует <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /&gt;</ph> <bpt id="p1">[</bpt>Обзор маршрутизированных событий<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">Объекты идентификатор события, создаваемые при их регистрации (см. <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) и затем могут использоваться для добавления обработчиков класса (см. <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ContextMenuClosingEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">Идентификатор объекты содержат идентифицирующее имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Occurs when any context menu on the element is opened.</source>
          <target state="translated">Происходит при открытии какого-либо контекстного меню в элементе.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>To manually open context menus, handlers of the events should mark the relevant event as handled.</source>
          <target state="translated">Для открытия контекстных меню вручную обработчики событий должны помечать соответствующее событие как обработанное.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Otherwise, the existing value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenu%2A&gt;</ph> property will be used to automatically open a context menu.</source>
          <target state="translated">В противном случае — значение существующего <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenu%2A&gt;</ph> свойство будет использоваться для автоматического открытия контекстного меню.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenu%2A&gt;</ph> property and then open the new <ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph>.</source>
          <target state="translated">Маркировка обрабатываемого события эффективно отменит действие по умолчанию и может быть возможность сбросить значение <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenu%2A&gt;</ph> свойства и откройте новый <ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>However, there is a timing issue you should be aware of.</source>
          <target state="translated">Однако есть ошибки синхронизации, которые следует иметь в виду.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>In order to completely replace the context menu through a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuOpening&gt;</ph> handler, the initial context menu must not be null / empty.</source>
          <target state="translated">Чтобы полностью заменить контекстного меню через <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuOpening&gt;</ph> обработчик, меню исходного контекста не должно быть null или пустым.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Alternatively, you might need to handle the event and then manually open a new context menu.</source>
          <target state="translated">Кроме того может потребоваться обработать событие и затем вручную открыть новое контекстное меню.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>For details, see <bpt id="p1">[</bpt>How to: Handle the ContextMenuOpening Event<ept id="p1">](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>как: руководство<ept id="p1">](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)</ept>.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>To use this event as an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style, you must reference the underlying service event identifier:</source>
          <target state="translated">Чтобы использовать это событие как <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> в стиле, необходимо сослаться на идентификатор события базовой службы:</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>(This usage is required because the event implementation on <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> that exposes the underlying service event does not correctly map the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuOpening&gt;</ph> identifier for use in triggers).</source>
          <target state="translated">(Такое использование является обязательным, поскольку реализация событий в <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> , предоставляет базовое событие службы не сопоставляют правильно <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ContextMenuOpening&gt;</ph> идентификатор для использования в триггерах).</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Routed Event Information</source>
          <target state="translated">Сведения о маршрутизируемом событии</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Routing strategy</source>
          <target state="translated">Стратегия маршрутизации</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Bubbling</source>
          <target state="translated">Вверх</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ContextMenuOpening">
          <source>Delegate</source>
          <target state="translated">делегат</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated">Идентифицирует <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /&gt;</ph> <bpt id="p1">[</bpt>Обзор маршрутизированных событий<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">Объекты идентификатор события, создаваемые при их регистрации (см. <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) и затем могут использоваться для добавления обработчиков класса (см. <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ContextMenuOpeningEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">Идентификатор объекты содержат идентифицирующее имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ContextMenuProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ContextMenu" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Gets or sets the cursor that displays when the mouse pointer is over this element.</source>
          <target state="translated">Получение или установка курсора, который отображается при наведении указателя мыши на этот элемент.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The cursor to display.</source>
          <target state="translated">Отображаемый курсор.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The default value is defined as <ph id="ph1">&lt;see langword="null" /&gt;</ph> per this dependency property.</source>
          <target state="translated">Значение по умолчанию определяется как <ph id="ph1">&lt;see langword="null" /&gt;</ph> для данного свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>However, the practical default at run time will come from a variety of factors.</source>
          <target state="translated">Однако на практике значение по умолчанию во время выполнения зависит от множества факторов.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>When setting this property in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, the <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> processor relies on type conversion for the <ph id="ph3">&lt;xref:System.Windows.Input.Cursor&gt;</ph> class to evaluate the string.</source>
          <target state="translated">При задании этого свойства <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> процессора основывается на преобразование типа для <ph id="ph3">&lt;xref:System.Windows.Input.Cursor&gt;</ph> класса для вычисления строки.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The provided string should evaluate to a <ph id="ph1">&lt;xref:System.Windows.Input.CursorType&gt;</ph> value.</source>
          <target state="translated">Предоставленная строка должно выражаться <ph id="ph1">&lt;xref:System.Windows.Input.CursorType&gt;</ph> значение.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph> for details.</source>
          <target state="translated">Подробные сведения см. в разделе <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Whether the cursor as established by this property will or will not display when the mouse pointer is over this element is also dependent on the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ForceCursor%2A&gt;</ph> property.</source>
          <target state="translated">Ли курсор в соответствии с параметром этого свойства будет или не будет отображаться, когда указатель мыши находится над данным элементом зависит от значения <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ForceCursor%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Also, event-related considerations such as an active drag, mouse capture, text editing modes within controls, and so on, will also affect the cursor with higher priority than the value you specify in this property.</source>
          <target state="translated">Кроме того вопросы, связанные с событиями, как активное перетаскивание, захват мыши, режимы редактирования текста в элементы управления и т. д., также влияет на курсор с более высоким приоритетом, чем значение, указанное в данном свойстве.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>To revert the behavior of setting this property to the eventual default, set it to <ph id="ph1">`null`</ph> again.</source>
          <target state="translated">Чтобы отменить поведение этого свойства к стандартному, задайте для него значение <ph id="ph1">`null`</ph> еще раз.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The <ph id="ph1">`null`</ph> default really means that determination of the practical cursor value is deferred here and should be obtained from elsewhere.</source>
          <target state="translated"><ph id="ph1">`null`</ph> По умолчанию реально означает, что определение практического значения курсора здесь, откладывается и должны быть получены из другого источника.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>If presented with no programmatic values from any source, the default cursor over a <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> application will be an arrow.</source>
          <target state="translated">Если отображается без программный значений из любого источника, курсор по умолчанию над <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> приложения будет стрелкой.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Each movement of the mouse over a <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> application raises a <ph id="ph2">&lt;xref:System.Windows.ContentElement.QueryCursor&gt;</ph> event.</source>
          <target state="translated">Каждый движения мыши над <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> приложение создает событие <ph id="ph2">&lt;xref:System.Windows.ContentElement.QueryCursor&gt;</ph> событий.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The event bubbles, and any element along the route has the opportunity to handle the event and to set the value of the cursor via the arguments of this event.</source>
          <target state="translated">Событие может передаваться и любой элемент на маршруте имеет возможность обработать событие и задать значение для курсора через аргументов этого события.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>If that happens, the fact that the event is handled and has a changed value in the arguments takes precedence over the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Cursor%2A&gt;</ph> property at any level, unless <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ForceCursor%2A&gt;</ph> is set.</source>
          <target state="translated">В этом случае тот факт, что событие обработано и имеет измененное значение в аргументах имеет приоритет над значением <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Cursor%2A&gt;</ph> свойство на любом уровне, если <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ForceCursor%2A&gt;</ph> имеет значение.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>If not creating a custom cursor, typically you set this property to a static property value of the <ph id="ph1">&lt;xref:System.Windows.Input.Cursors&gt;</ph> class.</source>
          <target state="translated">Если не создается специальный курсор, обычно можно установить это свойство в значение статического свойства <ph id="ph1">&lt;xref:System.Windows.Input.Cursors&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Setting the <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph> to a custom value is not enabled in partial trust.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph> пользовательское значение не включен в режиме частичного доверия.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>For more information on custom cursors, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о специальных курсорах см. в разделе <bpt id="p1">[</bpt>фокусе<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>None</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Cursor">
          <source>The following example sets the cursor to a custom value.</source>
          <target state="translated">Следующий пример устанавливает курсор пользовательское значение.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.CursorProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Cursor" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Cursor" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Gets or sets the data context for an element when it participates in data binding.</source>
          <target state="translated">Получает или задает контекст данных для элемента, участвующего в привязке данных.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>The object to use as data context.</source>
          <target state="translated">Объект, используемый в качестве контекста данных.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source><bpt id="p1">*</bpt>Data context<ept id="p1">*</ept> is a concept that allows elements to inherit information from their parent elements about the binding source that is used for binding, as well as other characteristics of the binding such as the path.</source>
          <target state="translated"><bpt id="p1">*</bpt>Контекст данных<ept id="p1">*</ept> — концепция, которая позволяет элементам наследовать от своих родительских элементов об источнике привязки, который используется для привязки, а также другие характеристики привязки, например путь информацию.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Data context can be set directly to a <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> object, with the bindings evaluating to properties of that object.</source>
          <target state="translated">Контекст данных можно задать непосредственно в <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> объекта с привязками, вычисляемыми в свойства этого объекта.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Alternatively, you can set the data context to a <ph id="ph1">&lt;xref:System.Windows.Data.DataSourceProvider&gt;</ph> object.</source>
          <target state="translated">Кроме того, можно задать контекст данных <ph id="ph1">&lt;xref:System.Windows.Data.DataSourceProvider&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>This dependency property inherits property values.</source>
          <target state="translated">Это свойство зависимостей наследуется значений свойств.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>If there are child elements with no other value for <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> established through local values or styles, the property system will set the value to be the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> value of the nearest parent element with this value assigned.</source>
          <target state="translated">Если имеются дочерние элементы и не имеет значения для <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> установленное с помощью локальных значений или стилей, в системе свойств будет задать это значение должно быть <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> значение ближайшего родительского элемента с назначенным данным значением.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Alternatively, you can use one of the following properties of the <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> class to specify the binding source explicitly: <ph id="ph2">&lt;xref:System.Windows.Data.Binding.ElementName%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Data.Binding.Source%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.Windows.Data.Binding.RelativeSource%2A&gt;</ph>.</source>
          <target state="translated">Кроме того, можно использовать один из следующих свойств <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> класс, чтобы явно указать источник привязки: <ph id="ph2">&lt;xref:System.Windows.Data.Binding.ElementName%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Data.Binding.Source%2A&gt;</ph>, или <ph id="ph4">&lt;xref:System.Windows.Data.Binding.RelativeSource%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Specify the Binding Source<ept id="p1">](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>как: Укажите источник привязки<ept id="p1">](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)</ept>.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>In <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> is most commonly set to as a <ph id="ph3">&lt;xref:System.Windows.Data.Binding&gt;</ph> declaration.</source>
          <target state="translated">В <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> чаще всего значение как <ph id="ph3">&lt;xref:System.Windows.Data.Binding&gt;</ph> объявления.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>You can use either property element syntax or attribute syntax.</source>
          <target state="translated">Можно использовать синтаксис элемента свойства или синтаксис атрибутов.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Attribute syntax is shown in the example on this page.</source>
          <target state="translated">Синтаксис атрибутов показан в примере на этой странице.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>You can also set <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> in code.</source>
          <target state="translated">Можно также задать <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> в коде.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>XAML Property Element Usage</source>
          <target state="translated">Использование элемента свойства XAML</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>XAML Attribute Usage</source>
          <target state="translated">Использование атрибута XAML</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>XAML Values</source>
          <target state="translated">Значения XAML</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source><bpt id="p1">*</bpt>dataContextObject<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>dataContextObject<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>A directly embedded object that serves as data context for any bindings within the parent element.</source>
          <target state="translated">Непосредственно внедренный объект, который служит в качестве контекста данных для любых привязок внутри родительского элемента.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Typically, this object is a <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> or another <ph id="ph2">&lt;xref:System.Windows.Data.BindingBase&gt;</ph> subclass.</source>
          <target state="translated">Как правило, этот объект является <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> или другой <ph id="ph2">&lt;xref:System.Windows.Data.BindingBase&gt;</ph> подкласс.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Alternatively, raw data of any <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> object type intended for binding may be placed here, with the actual bindings defined later.</source>
          <target state="translated">Кроме того необработанные данные любого <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> предназначен для привязки могут быть помещены с фактические привязки определить позже, тип объекта.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source><bpt id="p1">*</bpt>bindingUsage<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>bindingUsage<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>A binding usage that evaluates to an appropriate data context.</source>
          <target state="translated">Использование привязки, результатом вычисления которого в соответствующий контекст данных.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>For details, see <bpt id="p1">[</bpt>Binding Markup Extension<ept id="p1">](~/docs/framework/wpf/advanced/binding-markup-extension.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Привязка расширения разметки<ept id="p1">](~/docs/framework/wpf/advanced/binding-markup-extension.md)</ept>.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>One of the following: <ph id="ph1">`StaticResource`</ph>, or <ph id="ph2">`DynamicResource`</ph>.</source>
          <target state="translated">Одно из следующих: <ph id="ph1">`StaticResource`</ph>, или <ph id="ph2">`DynamicResource`</ph>.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>This usage is used when referring to raw data defined as an object in resources.</source>
          <target state="translated">Данный подход используется при обращении к необработанным данным объектом, в ресурсах.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>See <bpt id="p1">[</bpt>XAML Resources<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</source>
          <target state="translated">В разделе <bpt id="p1">[</bpt>ресурсов XAML<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source><bpt id="p1">*</bpt>contextResourceKey<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>contextResourceKey<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>The key identifier for the object being requested from within a <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">Идентификатор ключа для запрашиваемого внутри объекта <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DataContext">
          <source>The following example sets a binding on a <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> element, by creating a new custom data object, establishing that object as <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph>, and setting the binding path to a property within it.</source>
          <target state="translated">В следующем примере задается привязка на <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> элемент путем создания нового объекта пользовательские данные, установление объект в качестве <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph>и указав путь привязки к свойству в ней.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>Occurs when this element's data context changes.</source>
          <target state="translated">Происходит при изменении контекста данных настоящего элемента.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>For an explanation of data contexts and data binding, see <bpt id="p1">[</bpt>Data Binding Overview<ept id="p1">](~/docs/framework/wpf/data/data-binding-overview.md)</ept>.</source>
          <target state="translated">Объяснение контекстов данных и привязки данных см. в разделе <bpt id="p1">[</bpt>Общие сведения о привязке данных<ept id="p1">](~/docs/framework/wpf/data/data-binding-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>When an element's <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> changes, all data-bound properties on this element are potentially affected.</source>
          <target state="translated">Если элемент <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> потенциально влияет изменения, все свойства с привязкой к данным для этого элемента.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>This applies to any elements that are descendant elements of the current element, which inherit the data context, and also the current element itself.</source>
          <target state="translated">Это применяется к любым элементам, являющимся элементов-потомков текущего элемента, наследующим контекст данных, а также сам элемент.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>All such bindings re-interpret the new <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> to reflect the new value in bindings.</source>
          <target state="translated">Все привязки повторно интерпретировать новый <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> в соответствии с новым значением привязки.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>There is no guarantee made about the order of these changes relative to the raising of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContextChanged&gt;</ph> event.</source>
          <target state="translated">Нет никакой гарантии, о порядок этих изменениях, касающихся формирование <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContextChanged&gt;</ph> событий.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.DataContextChanged">
          <source>The changes can occur before the event, after the event, or in any mixture.</source>
          <target state="translated">Изменения могут происходить перед событием, после события или в любом сочетании.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.DataContextProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.DataContext" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.DataContext" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>Gets or sets the key to use to find the style template for this control in themes.</source>
          <target state="translated">Возвращает или задает ключ, используемый для поиска шаблона стиля данного элемента управления в темах.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>The style key.</source>
          <target state="translated">Ключ стиля.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>To work correctly as part of theme style lookup, this value is expected to be the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the element being styled.</source>
          <target state="translated">Для корректной работы этого значения в ходе поиска тематического стиля ожидается, что оно принадлежит к типу <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> элемента, к которому применяется стиль.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source><ph id="ph1">&lt;see langword="null" /&gt;</ph> is an accepted value for a certain case.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="null" /&gt;</ph> Утвержденное значение в некоторых случаях.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>This property is typically not set through any of its direct setters.</source>
          <target state="translated">Это свойство обычно не задается через какой-либо из его прямых переключателей.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>Instead, you override the type-specific metadata of this dependency property every time you create a new subclass.</source>
          <target state="translated">Вместо этого каждый раз при создании нового подкласса переопределения метаданных определенного типа этого свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>When you subclass, call the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> method against the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty&gt;</ph> identifier, within the static constructor of the control subclass.</source>
          <target state="translated">Когда вы подкласс, вызовите <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> метода для <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty&gt;</ph> идентификатор в статическом конструкторе подкласса элемента управления.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>For instance, an inline class such as <ph id="ph1">&lt;xref:System.Windows.Documents.Bold&gt;</ph> actually has very little implementation beyond overriding the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A&gt;</ph> metadata in its static constructor, and exposing several instance constructors.</source>
          <target state="translated">Для экземпляра класса встроенной, например <ph id="ph1">&lt;xref:System.Windows.Documents.Bold&gt;</ph> фактически имеет очень мало реализацию помимо переопределения <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A&gt;</ph> метаданные статического конструктора и предоставляет несколько конструкторов экземпляров.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>The fact that elements surrounded by the <ph id="ph1">&lt;xref:System.Windows.Documents.Bold&gt;</ph> tag gain a <ph id="ph2">&lt;xref:System.Windows.Documents.TextElement.FontWeight%2A&gt;</ph> property of <ph id="ph3">&lt;xref:System.Windows.FontWeights.Bold%2A&gt;</ph> is implemented within the theme style that was referenced by setting the default value of <ph id="ph4">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A&gt;</ph> to <ph id="ph5">`typeof(Bold)`</ph>.</source>
          <target state="translated">Тот факт, что элементы окружена <ph id="ph1">&lt;xref:System.Windows.Documents.Bold&gt;</ph> тег рост <ph id="ph2">&lt;xref:System.Windows.Documents.TextElement.FontWeight%2A&gt;</ph> свойство <ph id="ph3">&lt;xref:System.Windows.FontWeights.Bold%2A&gt;</ph> реализованы в стиле темы, который указывает ссылка, задав значение по умолчанию <ph id="ph4">&lt;xref:System.Windows.FrameworkContentElement.DefaultStyleKey%2A&gt;</ph> для <ph id="ph5">`typeof(Bold)`</ph>.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>If you want your element or control to deliberately not use theme styles, set the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A&gt;</ph> property to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Элемент или элемент управления, намеренно не используемый тематических стилей, установите <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.OverridesDefaultStyle%2A&gt;</ph> свойства <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.DefaultStyleKey">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.DefaultStyleKeyProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.DefaultStyleKey" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.EndInit">
          <source>Called immediately after an element is initialized.</source>
          <target state="translated">Вызывается сразу после инициализации элемента.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.EndInit">
          <source>Implement this method to provide special handling that should occur when your element is initialized during the element loading process.</source>
          <target state="translated">Реализация этого метода для обеспечения специальной обработки, которое должно происходить при инициализации во время процесса загрузки элемента.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.EndInit">
          <source>Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</source>
          <target state="translated">Реализация должна вызывать базовую реализацию, поскольку реализация base (по умолчанию) устанавливает внутренние флаги для отслеживания инициализации.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.EndInit">
          <source>If <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph> was previously called, the base implementation will raise the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Initialized&gt;</ph> event.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph> был вызван ранее, базовый вызывает реализацию <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Initialized&gt;</ph> событий.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.EndInit">
          <source>Otherwise, if <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph> was not called or it could not be determined whether <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph> was called, the event is not raised.</source>
          <target state="translated">В противном случае, если <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph> не был вызван или не удалось определить, является ли <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.BeginInit%2A&gt;</ph> был вызван, событие не происходит.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>Name of the element to search for.</source>
          <target state="translated">Имя искомого элемента.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>Finds an element that has the provided identifier name.</source>
          <target state="translated">Находит элемент по указанному имени идентификатора.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>The requested element.</source>
          <target state="translated">Запрошенный элемент.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>May be <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no matching element was found.</source>
          <target state="translated">Может быть равен <ph id="ph1">&lt;see langword="null" /&gt;</ph>, если соответствующий элемент не найден.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>If this element has child elements, these child elements are all searched recursively for the requested named element.</source>
          <target state="translated">Если этот элемент содержит дочерние элементы, эти дочерние элементы являются все выполняется рекурсивный поиск запрошенного именованного элемента.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindName(System.String)">
          <source>The following example sets a property on an element found by name within a referenced <ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> on a page.</source>
          <target state="translated">В следующем примере задается свойство на элементе найден по имени в указанный <ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> на странице.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>Key identifier of the resource to be found.</source>
          <target state="translated">Идентификатор ключа искомого ресурса.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>Searches for a resource with the specified key, and will throw an exception if the requested resource is not found.</source>
          <target state="translated">Ищет ресурс с указанным ключом и вызывает исключение, если запрошенный ресурс не удается найти.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>The found resource, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no matching resource was found (but will also throw an exception if <ph id="ph2">&lt;see langword="null" /&gt;</ph>).</source>
          <target state="translated">Найденный ресурс или значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>, если соответствующий ресурс не найден (но также вызовет исключение в случае значения <ph id="ph2">&lt;see langword="null" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>If you call this method for a key that cannot be found, an exception is thrown.</source>
          <target state="translated">Если этот метод вызывается для ключа, который не удается найти, создается исключение.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>If you do not want to handle exceptions for this case, you should instead call <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TryFindResource%2A&gt;</ph>.</source>
          <target state="translated">Если вы не хотите обрабатывать исключения для этого случая, вместо этого следует вызывать <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TryFindResource%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TryFindResource%2A&gt;</ph> returns <ph id="ph2">`null`</ph> when no resource is found, and does not throw an exception.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TryFindResource%2A&gt;</ph> Возвращает <ph id="ph2">`null`</ph> Если ресурс не найден и не вызывает исключение.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a resource were requested by key at run-time.</source>
          <target state="translated">Если ресурс не найден в вызывающем элементе, поиск в родительском дереве с помощью логического дерева, таким же образом, что было бы дерева поисковое ли ресурс, запрошенного по ключу во время выполнения.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</source>
          <target state="translated">Обычно вы сразу же привести возвращаемое значение к типу свойства, которое вы пытаетесь набор с возвращенным значением ресурса.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</source>
          <target state="translated">В следующем примере найти ресурс, определенный в разметке и применяет его к определенному свойству элемента в ответ на перенаправленное событие.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source>The requested resource key was not found.</source>
          <target state="translated">Запрошенный ключ ресурса не найден.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.FindResource(System.Object)">
          <source><ph id="ph1">&lt;paramref name="resourceKey" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="resourceKey" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Gets or sets an object that enables customization of appearance, effects, or other style characteristics that will apply to this element when it captures keyboard focus.</source>
          <target state="translated">Получает или задает объект, позволяющий настройку внешнего вида, эффектов или других характеристик стиля, применяемых к данному элементу, когда он получает фокус клавиатуры.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>The desired style to apply on focus.</source>
          <target state="translated">Требуемый стиль для применения при получении фокуса.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>The default value as declared in the dependency property is an empty static <ph id="ph1">&lt;see cref="T:System.Windows.Style" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию, объявленное в свойстве зависимостей, представляет собой пустой статический <ph id="ph1">&lt;see cref="T:System.Windows.Style" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>However, the effective value at run time is often (but not always) a style as supplied by theme support for controls.</source>
          <target state="translated">Тем не менее, действительным значением во время выполнения часто (но не всегда) является стиль, представленный поддержкой тем для элементов управления.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>When setting this property in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, styles are almost always defined as a resource, rather than inline as an element, and that resource is usually referenced as a <ph id="ph2">&lt;xref:System.Windows.StaticResourceExtension&gt;</ph>.</source>
          <target state="translated">При задании этого свойства <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, стили, почти всегда определяются как ресурс, а не встроенными как элемент, и что ресурсов обычно указывается как <ph id="ph2">&lt;xref:System.Windows.StaticResourceExtension&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Note that this property affects visual appearance but does not report so in metadata.</source>
          <target state="translated">Обратите внимание, что это свойство влияет на внешний вид, но не сообщает это в метаданных.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>This is because the visual appearance change is event-driven and may not apply at all times, and thus should not generally report any visual or layout information in metadata.</source>
          <target state="translated">Это так, как изменение внешнего вида управляется событиями и могут применяться не все время, таким образом не следует сообщать обычно любые сведения о visual или макета в метаданных.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Conceptually, the visual behavior of focus applied to a control should be coherent from element to element.</source>
          <target state="translated">По существу visual поведение фокуса, примененного к элементу управления, должно быть согласовано от элемента к элементу.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>The most sensible way to enforce coherence is to only change the focus visual style if you are composing an entire theme.</source>
          <target state="translated">Наиболее понятным способом применения согласованности является изменение стиля визуального отображения фокуса только при составлении целой темы.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Setting this property on individual styles and not as part of a theme is not the intended usage of this property, because it may lead to a confusing user experience regarding keyboard focus.</source>
          <target state="translated">Задание этого свойства отдельных стилей, не являющийся частью темы не предполагаемое использование этого свойства, так как это может привести к путанице при использовании фокуса клавиатуры.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>If you are intending element-specific behavior that is deliberately not coherent across a theme, a much better approach is to use triggers in styles for individual input state properties, such as <ph id="ph1">&lt;xref:System.Windows.UIElement.IsFocused%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A&gt;</ph>, and to do so in a way that does not visually interfere with any existing focus visual style.</source>
          <target state="translated">Если планируется поведение отдельных элементов, которое намеренно не согласовано в в теме гораздо лучшим подходом является использование триггеров в стилях для отдельных свойств состояния ввода, такие как <ph id="ph1">&lt;xref:System.Windows.UIElement.IsFocused%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A&gt;</ph>и таким образом, в результате которого не визуально мешать любой существующий стиль визуального отображения фокуса.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>For more information on the design intention of <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A&gt;</ph> and alternative focus properties, see <bpt id="p1">[</bpt>Styling for Focus in Controls, and FocusVisualStyle<ept id="p1">](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о необходимым <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FocusVisualStyle%2A&gt;</ph> и альтернативное сосредоточиться свойств см. в разделе <bpt id="p1">[</bpt>стиля фокуса в элементах управления и стиля визуального отображения фокуса<ept id="p1">](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md)</ept>.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>XAML Attribute Usage</source>
          <target state="translated">Использование атрибута XAML</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>XAML Property Element Usage</source>
          <target state="translated">Использование элемента свойства XAML</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>XAML Values</source>
          <target state="translated">Значения XAML</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>One of the following: , or .</source>
          <target state="translated">Одно из следующих:, или.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>See <bpt id="p1">[</bpt>XAML Resources<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</source>
          <target state="translated">В разделе <bpt id="p1">[</bpt>ресурсов XAML<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source><bpt id="p1">*</bpt>styleResourceKey<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>styleResourceKey<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>The key that identifies the style being requested.</source>
          <target state="translated">Ключ, идентифицирующий запрашиваемый стиль.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>The key refers to an existing resource in a <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">Ключ ссылается на существующий ресурс в <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Property element syntax is technically possible, but not recommended.</source>
          <target state="translated">Синтаксис элемента свойства технически возможно, но не рекомендуется.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>See <bpt id="p1">[</bpt>Inline Styles and Templates<ept id="p1">](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)</ept>.</source>
          <target state="translated">В разделе <bpt id="p1">[</bpt>встроенные стили и шаблоны<ept id="p1">](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)</ept>.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>A binding reference using  or <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> is also possible, but uncommon.</source>
          <target state="translated">Ссылка привязки с помощью или <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> также является, возможно, но встречается редко.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.FocusVisualStyle">
          <source>None</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.FocusVisualStyleProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.FocusVisualStyle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Gets or sets a value indicating whether this <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> should force the <ph id="ph2">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> to render the cursor as declared by this instance's <ph id="ph3">&lt;see cref="P:System.Windows.FrameworkContentElement.Cursor" /&gt;</ph> property.</source>
          <target state="translated">Возвращает или задает значение, указывающее, должен ли данный <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> заставлять <ph id="ph2">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> визуализировать курсор, как объявлено свойством <ph id="ph3">&lt;see cref="P:System.Windows.FrameworkContentElement.Cursor" /&gt;</ph> данного экземпляра.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to force cursor presentation while over this element to use this instance's setting for the cursor (including on all child elements); otherwise <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph> означает принудительное использование настройки данного экземпляра для презентации курсора, когда он находится над данным элементом (включая все дочерние); в противном случае — <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>The default value is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию — <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Setting this property to <ph id="ph1">`true`</ph> will override the cursor preferences established by child elements.</source>
          <target state="translated">Присвоение этому свойству <ph id="ph1">`true`</ph> переопределяют настройки курсора, установленные дочерними элементами.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Doing so in general application <ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph> might be confusing for the user, particularly if child elements are attempting to specify cursors.</source>
          <target state="translated">Поэтому в общем приложения это <ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph> может сбить с толку для пользователей, особенно в том случае, если дочерние элементы пытаются задавать курсоры.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Setting <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ForceCursor%2A&gt;</ph> is more appropriate in control subclassing or compositing scenarios.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ForceCursor%2A&gt;</ph> больше подходит в сценариях управления подклассы или композиции.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>None</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ForceCursor">
          <source>The following example forces the cursor while over the element.</source>
          <target state="translated">Следующий пример принудительно курсор над элементом.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ForceCursorProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ForceCursor" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)">
          <source>The target <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> from which to get the binding.</source>
          <target state="translated">Целевое <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>, из которого следует получить привязку.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)">
          <source>Gets the <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph> for the specified property's binding.</source>
          <target state="translated">Возвращает <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph> для привязки указанного свойства.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)">
          <source>Returns a <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph> if the target is data bound; otherwise, <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Возвращает <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph>, если цель привязана к данным; в противном случае — <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.GetBindingExpression(System.Windows.DependencyProperty)">
          <source>The following example retrieves a binding by querying a property.</source>
          <target state="translated">Следующий пример возвращает привязку по запросу свойства.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetUIParentCore">
          <source>Returns an alternative logical parent for this element if there is no visual parent.</source>
          <target state="translated">Возвращает альтернативный логический родительский объект для этого элемента при отсутствии визуального родительского объекта.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetUIParentCore">
          <source>In this case, a <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> parent is always the same value as the <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Parent" /&gt;</ph> property.</source>
          <target state="translated">В данном случае родительский объект <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> всегда имеет то же значение, что и свойство <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Parent" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.GetUIParentCore">
          <source>Returns something other than <ph id="ph1">&lt;see langword="null" /&gt;</ph> whenever a WPF framework-level implementation of this method has a non-visual parent connection.</source>
          <target state="translated">Возвращает нечто, отличное от <ph id="ph1">&lt;see langword="null" /&gt;</ph>, каждый раз, когда реализация уровня инфраструктуры WPF этого метода имеет подключение без визуального родительского объекта.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.GetUIParentCore">
          <source>The default implementation returns the expected single visual parent.</source>
          <target state="translated">Реализация по умолчанию возвращает ожидаемый единый визуальный родитель.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.GetUIParentCore">
          <source>Custom implementations might return alternate parent relationships.</source>
          <target state="translated">Пользовательские реализации могут возвращать альтернативные родительские связи.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.Initialized">
          <source>Occurs when this <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> is initialized.</source>
          <target state="translated">Происходит во время инициализации данного <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.Initialized">
          <source>This coincides with cases where the value of the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /&gt;</ph> property changes from <ph id="ph2">&lt;see langword="false" /&gt;</ph> (or undefined) to <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Это совпадает со случаями, когда значение свойства <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /&gt;</ph> меняется с <ph id="ph2">&lt;see langword="false" /&gt;</ph> (или неопределенного) на <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Initialized">
          <source>This event will be raised whenever the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.EndInit%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.OnInitialized%2A&gt;</ph> methods are called.</source>
          <target state="translated">Это событие будет каждый раз, когда возникает <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.EndInit%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.OnInitialized%2A&gt;</ph> вызываются методы.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Initialized">
          <source>Calls to these methods could have been made by deliberate code, or by the <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> loading process.</source>
          <target state="translated">Вызовы этих методов могут выполняться из произвольного кода, либо by <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> процесса загрузки.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>Gets or sets the context for input used by this <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>.</source>
          <target state="translated">Получает или задает контекст для ввода, используемый данным <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>The input scope, which modifies how input from alternative input methods is interpreted.</source>
          <target state="translated">Область ввода, которая изменяет интерпретацию ввода с помощью альтернативных методов.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>The default value is <ph id="ph1">&lt;see langword="null" /&gt;</ph> (which results in a default handling of commands).</source>
          <target state="translated">Значение по умолчанию равно <ph id="ph1">&lt;see langword="null" /&gt;</ph> (что приводит к обработке команд по умолчанию).</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>This dependency property inherits property values.</source>
          <target state="translated">Это свойство зависимостей наследуется значений свойств.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>If there are child elements with no other value for <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.InputScope%2A&gt;</ph> established through local values or styles, the property system will set the value to be the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.InputScope%2A&gt;</ph> value of the nearest parent element with this value assigned.</source>
          <target state="translated">Если имеются дочерние элементы и не имеет значения для <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.InputScope%2A&gt;</ph> установленное с помощью локальных значений или стилей, в системе свойств будет задать это значение должно быть <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.InputScope%2A&gt;</ph> значение ближайшего родительского элемента с назначенным данным значением.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>Although a <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax usage is listed and is syntactically allowed, setting this property in <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> is not common.</source>
          <target state="translated">Несмотря на то что <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> использование синтаксиса указано и синтаксически разрешено, задание этого свойства <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> не так часто.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.InputScope">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.InputScopeProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.InputScope" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.InputScope" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.IsInitialized">
          <source>Gets a value indicating whether this element has been initialized, either by being loaded as <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>, or by explicitly having its <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.EndInit" /&gt;</ph> method called.</source>
          <target state="translated">Возвращает значение, указывающее, был ли инициализирован данный элемент, либо путем загрузки в качестве <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>, либо путем явного вызова своего метода <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.EndInit" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsInitialized">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the element is initialized per the aforementioned loading or method calls; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если элемент инициализирован путем вышеупомянутой загрузки или вызовов метода; в противном случае — <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsInitialized">
          <source>This property may also be <ph id="ph1">`true`</ph> if this element has been moved within the element tree such that it has a new parent element, and therefore becomes reloaded again.</source>
          <target state="translated">Это свойство также может быть <ph id="ph1">`true`</ph> Если этот элемент был перемещен в пределах дерева элементов таким образом, что он имеет новый родительский элемент и снова станет перегруженным.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.IsLoaded">
          <source>Gets a value indicating whether this element has been loaded for presentation.</source>
          <target state="translated">Возвращает значение, указывающее, загружен ли данный элемент для презентации.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsLoaded">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current element is attached to an element tree and has been rendered; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the element has never been attached to a loaded element tree.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если текущий элемент прикреплен к дереву элементов и визуализирован; <ph id="ph2">&lt;see langword="false" /&gt;</ph> — если элемент никогда не был присоединен к загруженному дереву элементов.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsLoaded">
          <source>From a newly constructed instance, this property starts off <ph id="ph1">`false`</ph>, and remains <ph id="ph2">`true`</ph> once it is set to <ph id="ph3">`true`</ph>, even if subsequently removed by  code.</source>
          <target state="translated">Вновь созданного экземпляра это свойство начинается <ph id="ph1">`false`</ph>и остается <ph id="ph2">`true`</ph> после ее установки <ph id="ph3">`true`</ph>, даже если затем удаляется из кода.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsLoaded">
          <source>The following example code uses <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.IsLoaded%2A&gt;</ph> as a conditional check to assure that a function <ph id="ph2">`displayData`</ph> (not shown) will have valid elements loaded on the page to work against, as part of an on-demand handler.</source>
          <target state="translated">В следующем примере кода используется <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.IsLoaded%2A&gt;</ph> как условную проверку, чтобы убедиться, что функция <ph id="ph2">`displayData`</ph> (не показано) будет допустимые элементы загрузки на странице будет работать, как часть обработчик по требованию.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.IsLoaded">
          <source>That same logic is run as an event handler for <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph>.</source>
          <target state="translated">Выполнение логики обработчик событий для <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>Gets or sets localization/globalization language information that applies to an individual element.</source>
          <target state="translated">Возвращает или задает сведения о языке локализации и глобализации, который применяется к отдельному элементу.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>The culture information for this element.</source>
          <target state="translated">Сведения о языке и региональных параметрах для этого элемента.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>The default value is an <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XmlLanguage" /&gt;</ph> instance with its <ph id="ph2">&lt;see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /&gt;</ph> value set to the string "en-US".</source>
          <target state="translated">Значение по умолчанию представляет собой экземпляр <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XmlLanguage" /&gt;</ph> со значением свойства <ph id="ph2">&lt;see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /&gt;</ph>, равным строке "en-US".</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>The string formats follow the RFC 3066 standard.</source>
          <target state="translated">Строковые форматы соответствуют стандарту RFC 3066.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>For example, U.S. English is "en-US".</source>
          <target state="translated">К примеру США Английский — «en US».</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Markup.XmlLanguage&gt;</ph> for more information on the values and format.</source>
          <target state="translated">В разделе <ph id="ph1">&lt;xref:System.Windows.Markup.XmlLanguage&gt;</ph> Дополнительные сведения о значениях и формате.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>This dependency property inherits property values.</source>
          <target state="translated">Это свойство зависимостей наследуется значений свойств.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>If there are child elements with no other value for <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph> established through local values or styles, the property system will set the value to be the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph> value of the nearest parent element with this value assigned.</source>
          <target state="translated">Если имеются дочерние элементы и не имеет значения для <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph> установленное с помощью локальных значений или стилей, в системе свойств будет задать это значение должно быть <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph> значение ближайшего родительского элемента с назначенным данным значением.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Language">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.LanguageProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Language" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Language" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Occurs when the element is laid out, rendered, and ready for interaction.</source>
          <target state="translated">Происходит, если элемент размещен, отрисован и готов к взаимодействию.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</source>
          <target state="translated">События с прямой маршрутизацией не следуют по маршруту, они обрабатываются только внутри элемента, на котором они вызываются.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style.</source>
          <target state="translated">Прямые перенаправленные события поддерживают другое поведение перенаправленных событий: они поддерживают коллекцию доступных обработчиков и могут использоваться как <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> в стиле.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Routed Event Information</source>
          <target state="translated">Сведения о маршрутизируемом событии</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Routing strategy</source>
          <target state="translated">Стратегия маршрутизации</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Direct</source>
          <target state="translated">Direct</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Loaded">
          <source>Delegate</source>
          <target state="translated">делегат</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.LoadedEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Loaded" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated">Идентифицирует <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Loaded" /&gt;</ph> <bpt id="p1">[</bpt>Обзор маршрутизированных событий<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.LoadedEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">Объекты идентификатор события, создаваемые при их регистрации (см. <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) и затем могут использоваться для добавления обработчиков класса (см. <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.LoadedEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">Идентификатор объекты содержат идентифицирующее имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.LogicalChildren">
          <source>Gets an enumerator for the logical child elements of this element.</source>
          <target state="translated">Возвращает перечислитель для логических дочерних элементов данного элемента.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.LogicalChildren">
          <source>An enumerator for logical child elements of this element.</source>
          <target state="translated">Перечислитель для логических дочерних элементов данного элемента.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.LogicalChildren">
          <source>For more information on how to use <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.LogicalChildren%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A&gt;</ph>, see <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об использовании <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.LogicalChildren%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.AddLogicalChild%2A&gt;</ph>, в разделе <bpt id="p1">[</bpt>деревьев в WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source>The direction that focus is to be moved, as a value of the enumeration.</source>
          <target state="translated">Направление, в котором перемещается фокус, в виде значения перечисления.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source>Moves the keyboard focus from this element to another element.</source>
          <target state="translated">Перемещает клавиатурный фокус с данного элемента на другой.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if focus is moved successfully; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the target element in direction as specified does not exist.</source>
          <target state="translated">Возвращает <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если фокус перемещен успешно; <ph id="ph2">&lt;see langword="false" /&gt;</ph>, если целевого элемента в указанном направлении не существует.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Gets or sets the identifying name of the element.</source>
          <target state="translated">Возвращает или задает имя, обозначающее элемент.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>The name provides an instance reference so that programmatic code-behind, such as event handler code, can refer to an element once it is constructed during parsing of <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">Имя предоставляет ссылку на экземпляр, что позволяет коду программной части, например коду обработчика событий, обращаться к элементу сразу после его создания в процессе синтаксического анализа <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>The name of the element.</source>
          <target state="translated">Имя элемента.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>The most common usage of this property is when specifying a <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> element name in markup.</source>
          <target state="translated">Наиболее распространенное использование этого свойства является при задании <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> имя элемента в разметке.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>This property essentially provides a WPF framework-level convenience property to set the <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> <bpt id="p1">[</bpt>x:Name Directive<ept id="p1">](~/docs/framework/xaml-services/x-name-directive.md)</ept>.</source>
          <target state="translated">По сути, это свойство предоставляет свойство удобства уровня платформы WPF для задания <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> <bpt id="p1">[</bpt>директива x: Name<ept id="p1">](~/docs/framework/xaml-services/x-name-directive.md)</ept>.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Getting a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> from code is not common, because if you have the appropriate reference in code already, you can just call methods and properties on the element reference and do not generally need the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph>.</source>
          <target state="translated">Получение <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> из кода не так часто, потому что если в коде уже присутствует соответствующая ссылка, может просто вызвать методы и свойства в элементе ссылки и они не обычно необходимость <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>An exception is if the string has some overloaded meaning, for instance if it is useful to display that name in <ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>.</source>
          <target state="translated">Исключение — если строка имеет несколько перегруженных значение, например если полезно отображать это имя в <ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Setting a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> from code if the original <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> was set from markup is also not recommended, and changing the property will not change the object reference.</source>
          <target state="translated">Установка <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> из кода если исходное <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> был набор из разметки также не рекомендуется, и изменения свойства в ссылку на объект не меняется.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Such object references are created only when the underlying namescopes are explicitly created during <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> loading.</source>
          <target state="translated">Ссылки на такие объекты создаются только в том случае, если основной области видимости имен явно создаются во время <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> загрузки.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>You must specifically call <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.RegisterName%2A&gt;</ph> to make an effective change on the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> property of an already loaded element.</source>
          <target state="translated">Необходимо явно вызывать <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.RegisterName%2A&gt;</ph> действующие сделать на <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> свойства элемента уже загружен.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>One notable case where setting <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> from  code is important is for naming elements that storyboards will run against.</source>
          <target state="translated">Важные один вариант, где параметр <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> из кода важно для именования элементов, которые раскадровки будет выполняться.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Before you can register a name, might also need to instantiate and assign a <ph id="ph1">&lt;xref:System.Windows.NameScope&gt;</ph> instance.</source>
          <target state="translated">Прежде чем выполнять регистрацию имени, может потребоваться создать и назначить <ph id="ph1">&lt;xref:System.Windows.NameScope&gt;</ph> экземпляра.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>See the Example section, or <bpt id="p1">[</bpt>Storyboards Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept>.</source>
          <target state="translated">См. в разделе, или <bpt id="p1">[</bpt>Общие<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Setting <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> from code has limited applications, but looking up an element by name is more common, particularly if you are employing a navigation model where pages reload into the application and the run-time code is not necessarily the code-behind of that respective page.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> из кода имеет ограниченную приложений, но поиск элемента по имени чаще, особенно если задействуется модель навигации перезагрузкой страниц в приложение и код времени выполнения не обязательно является кодом программной части, соответствующую страницу.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>The utility method <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FindName%2A&gt;</ph>, which is available from any <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>, can find any element by <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> in that element's logical tree recursively.</source>
          <target state="translated">Вспомогательный метод <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FindName%2A&gt;</ph>, которое доступно из любого <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph>, можно найти любой элемент, <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> в рекурсивно логического дерева этого элемента.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Or you can use the <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A&gt;</ph> static method of <ph id="ph2">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>, which also takes the <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> string as an argument.</source>
          <target state="translated">Или можно использовать <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A&gt;</ph> статический метод <ph id="ph2">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>, которая также принимает <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.Name%2A&gt;</ph> строку в качестве аргумента.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Commonly used root elements (<ph id="ph1">&lt;xref:System.Windows.Window&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Controls.Page&gt;</ph> for example) implement the interface <ph id="ph3">&lt;xref:System.Windows.Markup.INameScope&gt;</ph>.</source>
          <target state="translated">Часто используемые корневые элементы (<ph id="ph1">&lt;xref:System.Windows.Window&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Controls.Page&gt;</ph> например) реализуют интерфейс <ph id="ph3">&lt;xref:System.Windows.Markup.INameScope&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Implementations of this interface are expected to enforce that names be unambiguous within their scope.</source>
          <target state="translated">Реализации этого интерфейса ожидается обеспечение однозначности имен в пределах их области.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Name">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.NameProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Name" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Name" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Provides data about the event.</source>
          <target state="translated">Предоставляет данные о событии.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Invoked whenever the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /&gt;</ph> routed event reaches this class in its route.</source>
          <target state="translated">Вызывается, когда перенаправленное событие <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuClosing" /&gt;</ph> достигает этого класса на своем пути.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">У этого метода нет реализации по умолчанию.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.</source>
          <target state="translated">По-прежнему должен вызвать базовую реализацию, если промежуточный класс в цепочке наследования реализует данный метод.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>The purpose of this method is somewhat similar to <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</source>
          <target state="translated">Этот метод похож на <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> шаблона On * методы: она предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">В этом случае соответствующее событие является маршрутизируемым.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers.</source>
          <target state="translated">Шаблон реализации методов On * отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, не обязательно является элементом, который будет вызывать обработчики.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Therefore, your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</source>
          <target state="translated">Таким образом реализация придется учитывать исходных свойств аргументов события (и не пытаться повторно вызвать событие в большинстве случаев).</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Subclasses of <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> could choose to call private class handler methods when the event is received along the route.</source>
          <target state="translated">Подклассы <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> может выбрать для вызова методов обработчика закрытый класс при получении события в маршруте.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</source>
          <target state="translated">Одним из потенциальных сценариев является получение аргументов события и пометка его как обработанного для сокращения маршрута.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Event data for the event.</source>
          <target state="translated">Данные для события.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Invoked whenever the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /&gt;</ph> routed event reaches this class in its route.</source>
          <target state="translated">Вызывается, когда перенаправленное событие <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ContextMenuOpening" /&gt;</ph> достигает этого класса на своем пути.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">У этого метода нет реализации по умолчанию.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>You should still call base() in case an intermediate class in the inheritance has implemented this method.</source>
          <target state="translated">Рекомендуется вызывать base() в случае, если промежуточный класс в цепочке наследования реализует данный метод.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>The purpose of this method is somewhat similar to <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</source>
          <target state="translated">Этот метод похож на <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> шаблона On * методы: она предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">В этом случае соответствующее событие является маршрутизируемым.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</source>
          <target state="translated">Шаблон реализации методов On * отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, не обязательно является элементом, вызывающим обработчики, так что вашей реализации нужно будет принимать источника аргументов события свойства в учетной записи (и не пытаться повторно вызвать событие в большинстве случаев).</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Subclasses of <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> could choose to call private class handler methods when the event is received along the route.</source>
          <target state="translated">Подклассы <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> может выбрать для вызова методов обработчика закрытый класс при получении события в маршруте.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</source>
          <target state="translated">Одним из потенциальных сценариев является получение аргументов события и пометка его как обработанного для сокращения маршрута.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>Event data for the event.</source>
          <target state="translated">Данные для события.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>Class handler for the <ph id="ph1">&lt;see cref="E:System.Windows.ContentElement.GotFocus" /&gt;</ph> event.</source>
          <target state="translated">Обработчик класса для события <ph id="ph1">&lt;see cref="E:System.Windows.ContentElement.GotFocus" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>This class handler sets appropriate focus behavior on this element if the event originated from this element.</source>
          <target state="translated">Этот обработчик класса задает соответствующее поведение фокуса на этот элемент, если событие происходит из этого элемента.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>If the event's source was another element in the tree, the handler does nothing.</source>
          <target state="translated">Если источником события был другой элемент дерева, обработчик не выполняет никаких действий.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>Override this method in order to change these default focusing behavior on your element.</source>
          <target state="translated">Переопределите этот метод, чтобы изменить фокусировки на вашем элементе поведение по умолчанию.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Event data for the event.</source>
          <target state="translated">Данные для события.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Raises the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Initialized" /&gt;</ph> event.</source>
          <target state="translated">Вызывает событие <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Initialized" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>This method is invoked whenever <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /&gt;</ph> is set to <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Этот метод вызывается при каждой установке для свойства <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.IsInitialized" /&gt;</ph> значения <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>The default implementation of this virtual method raises the event as described earlier in this topic.</source>
          <target state="translated">Реализация по умолчанию данного виртуального метода вызывает событие, как описано ранее в этом разделе.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Overrides should call base() to preserve this behavior.</source>
          <target state="translated">Переопределение должно вызывать base() для сохранения этого поведения.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Note that the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.IsInitialized%2A&gt;</ph> property is read-only.</source>
          <target state="translated">Обратите внимание, что <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.IsInitialized%2A&gt;</ph> свойство доступно только для чтения.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Therefore, you cannot set it to force initialization behavior that way.</source>
          <target state="translated">Таким образом нельзя задать для него принудительную инициализацию таким образом.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnInitialized(System.EventArgs)">
          <source>Initialization setting is intended to be done only by the <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> framework.</source>
          <target state="translated">Параметр инициализации должен выполняться только <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> framework.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The event data that describes the property that changed, including the old and new values.</source>
          <target state="translated">Данные события, описывающие измененное свойство, а также старое и новое значения.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Invoked whenever the effective value of any dependency property on this <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> has been updated.</source>
          <target state="translated">Вызывается всякий раз при обновлении действующего значения какого-либо свойства зависимостей относительно данного элемента <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The specific dependency property that changed is reported in the arguments parameter.</source>
          <target state="translated">Конкретное измененное свойство зависимостей сообщается в параметре аргументов.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Overrides <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /&gt;</ph>.</source>
          <target state="translated">Переопределяет свойство <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This method is not intended to generally detect property changes or invalidations.</source>
          <target state="translated">Этот метод не предназначен для общего выявления изменений свойств или их недействительности.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>It is instead intended for modifications of the general invalidation pattern if certain information is known about wide classifications of properties.</source>
          <target state="translated">Он предназначен для изменения общего шаблона недействительности, если известна определенная информация о широких классификациях свойств.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This method is potentially invoked many times during the life of an object.</source>
          <target state="translated">Этот метод потенциально вызывается несколько раз за время существования объекта.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Therefore, you can achieve better performance if you override the metadata of specific properties and then attach <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph> functions for individual properties.</source>
          <target state="translated">Таким образом, можно улучшить производительность, если переопределения метаданных свойств, а затем подключите <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> или <ph id="ph2">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph> функции для отдельных свойств.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>However, you would use this method if a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> includes a significant number of value-interrelated dependency properties, or if it includes logic such as rendering behavior that must be rerun for several related cases of property invalidations.</source>
          <target state="translated">Тем не менее, будет использовать этот метод, если <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> включает значительное количество свойств зависимостей с взаимосвязанными значениями, или если он содержит логику, например поведение отрисовки, необходимо повторно для нескольких связанных случаев недействительности свойств.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Note that there is an identically named <ph id="ph1">`OnPropertyChanged`</ph> method with a different signature (the parameter type is <ph id="ph2">&lt;xref:System.ComponentModel.PropertyChangedEventArgs&gt;</ph>) that can appear on a number of classes.</source>
          <target state="translated">Обратите внимание, что таким же именем <ph id="ph1">`OnPropertyChanged`</ph> метод с другой сигнатурой (тип параметра является <ph id="ph2">&lt;xref:System.ComponentModel.PropertyChangedEventArgs&gt;</ph>), которые могут возникнуть на несколько классов.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>That <ph id="ph1">`OnPropertyChanged`</ph> is used for data object notifications, and is part of the contract for <ph id="ph2">&lt;xref:System.ComponentModel.INotifyPropertyChanged&gt;</ph>.</source>
          <target state="translated">Что <ph id="ph1">`OnPropertyChanged`</ph> используется для уведомления объекта данных и является частью контракта для <ph id="ph2">&lt;xref:System.ComponentModel.INotifyPropertyChanged&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Always call the base implementation, as the first operation in your implementation.</source>
          <target state="translated">Всегда вызовите базовую реализацию в качестве первой операции в вашей реализации.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Failure to do this will significantly disable the entire <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> property system, which causes incorrect values to be reported.</source>
          <target state="translated">В противном случае значительно отключит всего <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> системы свойств, вследствие чего будут сообщены неверные значения.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>The old style.</source>
          <target state="translated">Старый стиль.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>The new style.</source>
          <target state="translated">Новый стиль.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>Invoked when the style that is in use on this element changes.</source>
          <target state="translated">Вызывается при изменении стиля, используемого для данного элемента.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>This method has a default implementation that sets an internal flag noting the style changed condition.</source>
          <target state="translated">Этот метод имеет реализацию по умолчанию, которая задает внутренний флаг, уведомляя об измененном состоянии стиля.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>Always call the base implementation, otherwise styles cannot be applied.</source>
          <target state="translated">Всегда вызывать базовую реализацию, в противном случае нельзя применить стили.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>Scenarios for overriding this method might include if your derived class has a specialized style selector, or caches style values.</source>
          <target state="translated">Сценарии переопределения данного метода могут включать случай производного класса имеется селектор специализированного стиля или кэшированные значения стилей.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>Theme changes will potentially invoke this method.</source>
          <target state="translated">Изменения темы потенциально будет вызывать этот метод.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>Provides data about the event.</source>
          <target state="translated">Предоставляет данные о событии.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>Invoked whenever the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /&gt;</ph> routed event reaches this class in its route.</source>
          <target state="translated">Вызывается, когда перенаправленное событие <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /&gt;</ph> достигает этого класса на своем пути.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">У этого метода нет реализации по умолчанию.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>You should still call base() in case an intermediate class in the inheritance has implemented this method.</source>
          <target state="translated">Рекомендуется вызывать base() в случае, если промежуточный класс в цепочке наследования реализует данный метод.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>The purpose of this method is somewhat similar to <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</source>
          <target state="translated">Этот метод похож на <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> шаблона On * методы: она предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">В этом случае соответствующее событие является маршрутизируемым.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will have to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</source>
          <target state="translated">Шаблон реализации методов On * отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, не обязательно является элементом, вызывающим обработчики, так что вашей реализации нужно будет принимать источника аргументов события свойства в учетной записи (и не пытаться повторно вызвать событие в большинстве случаев).</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>Subclasses of <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> could choose to call private class handler methods when the event is received along the route.</source>
          <target state="translated">Подклассы <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> может выбрать для вызова методов обработчика закрытый класс при получении события в маршруте.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</source>
          <target state="translated">Одним из потенциальных сценариев является получение аргументов события и пометка его как обработанного для сокращения маршрута.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>Provides data about the event.</source>
          <target state="translated">Предоставляет данные о событии.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>Invoked whenever the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /&gt;</ph> routed event reaches this class in its route.</source>
          <target state="translated">Вызывается, когда перенаправленное событие <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /&gt;</ph> достигает этого класса на своем пути.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">У этого метода нет реализации по умолчанию.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>You should still call base() in case an intermediate class in the inheritance has implemented this method.</source>
          <target state="translated">Рекомендуется вызывать base() в случае, если промежуточный класс в цепочке наследования реализует данный метод.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>The purpose of this method is somewhat similar to <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</source>
          <target state="translated">Этот метод похож на <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> шаблона On * методы: она предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">В этом случае соответствующее событие является маршрутизируемым.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</source>
          <target state="translated">Шаблон реализации методов On * отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, не обязательно является элементом, вызывающим обработчики, так что реализации требуется выполнять источника аргументов события свойства в учетной записи (и не пытаться повторно вызвать событие в большинстве случаев).</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>Subclasses of <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> could choose to call private class handler methods when the event is received along the route.</source>
          <target state="translated">Подклассы <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> может выбрать для вызова методов обработчика закрытый класс при получении события в маршруте.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</source>
          <target state="translated">Одним из потенциальных сценариев является получение аргументов события и пометка его как обработанного для сокращения маршрута.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source>Gets or sets a value indicating whether this element incorporates style properties from theme styles.</source>
          <target state="translated">Возвращает или задает значение, указывающее, содержит ли данный элемент свойства стиля из тематических стилей.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this element does not use theme style properties; all style-originating properties come from local application styles, and theme style properties do not apply.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если этот элемент не использует свойства стиля темы; все свойства, определяющие стиль, получаются из локальных стилей приложения, а свойства стиля темы не применяются.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if application styles apply first, and then theme styles apply for properties that were not specifically set in application styles.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="false" /&gt;</ph>, если сначала применяются стили приложения, а затем стили тем для свойств, которые не были явным образом заданы в стилях приложения.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source>The most common usage of this property is an indirect usage within the setter of a style that is supplying a themed style.</source>
          <target state="translated">Наиболее распространенное использование этого свойства является непрямое использование в переключателе стиля, который передает тематический стиль.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.OverridesDefaultStyleProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.OverridesDefaultStyle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>Gets the parent in the logical tree for this element.</source>
          <target state="translated">Возвращает родительский объект в логическом дереве для этого элемента.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>The logical parent for this element.</source>
          <target state="translated">Логический родительский объект для этого элемента.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>Note that the logical parent of an element can potentially change depending on your application functionality, and keeping the value of this property will not reflect that change.</source>
          <target state="translated">Обратите внимание, что логический родительский элемент может измениться в зависимости от функциональности приложения, и сохранение значения этого свойства не отражает такое изменение.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>You typically should get the value immediately before you need it.</source>
          <target state="translated">Обычно следует получать значение, непосредственно перед он нужен.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>See <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept> for more information about traversing logical trees, and the scenarios where taking this approach towards element discovery is appropriate.</source>
          <target state="translated">В разделе <bpt id="p1">[</bpt>деревьев в WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept> Дополнительные сведения о просмотре логические деревья и сценарии, когда этот подход к обнаружения элемента не соответствует.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>The property system will potentially recalculate all property values of an element when it is reparented, because some properties inherit values through the logical tree.</source>
          <target state="translated">В системе свойств потенциально пересчитает все значения свойств элемента при изменении его родителя, так как некоторые свойства наследуют значения через логическое дерево.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> that applies for bindings can also change when elements are reparented.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph> , Применяемый для привязки также можно изменить при изменении элементов родителя.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>Changing an element's parent is typically only done through manipulation of collections, by using dedicated add or remove methods, or through setting content properties of elements.</source>
          <target state="translated">Изменение родителя элемента обычно выполняется только через управление коллекциями, с использованием выделенных методов добавления и удаления, или путем задания свойств содержимого элементов.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>The most typical scenario for using the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph> property is to obtain a reference and then get various <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> property values from the parent.</source>
          <target state="translated">Наиболее типичный сценарий использования <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph> свойство является получить ссылку, а затем получить различные <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> значения свойств из родительского элемента.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>For templates, the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph> of the template eventually will be <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Для шаблонов <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph> шаблона в конечном итоге будет <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>To get past this point and extend into the logical tree where the template is actually applied, use <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph>.</source>
          <target state="translated">Чтобы получить на этом этапе и расширить в логическом дереве, где фактически применяется шаблон, используйте <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Parent">
          <source>The following example checks to see whether the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph> of a <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> is of a particular type.</source>
          <target state="translated">Следующий пример проверяет, является ли <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Parent%2A&gt;</ph> из <ph id="ph2">&lt;xref:System.Windows.Documents.TextPointer&gt;</ph> — определенного типа.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>The direction for which a prospective focus change should be determined.</source>
          <target state="translated">Направление, в котором следует определить перспективное изменение фокуса.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>Determines the next element that would receive focus relative to this element for a provided focus movement direction, but does not actually move the focus.</source>
          <target state="translated">Определяет следующий элемент, который получит фокус, относительно данного элемента для указанного направления движения фокуса, но реально фокус не перемещает.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>This method is sealed and cannot be overridden.</source>
          <target state="translated">Данный метод запечатан и не может быть переопределен.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>The next element that focus would move to if focus were actually traversed.</source>
          <target state="translated">Следующий элемент, на который будет перемещен фокус в случае фактического обхода фокуса.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>May return <ph id="ph1">&lt;see langword="null" /&gt;</ph> if focus cannot be moved relative to this element for the provided direction.</source>
          <target state="translated">Может возвращать значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>, если фокус нельзя переместить относительно данного элемента в указанном направлении.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.MoveFocus%2A&gt;</ph> is the related method that actually does move focus.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.MoveFocus%2A&gt;</ph> имеет связанный метод, который фактически перемещения фокуса.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>Specified one of the following directions in the <ph id="ph1">&lt;see cref="T:System.Windows.Input.TraversalRequest" /&gt;</ph>: <ph id="ph2">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Next" /&gt;</ph>, <ph id="ph3">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" /&gt;</ph>, <ph id="ph4">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.First" /&gt;</ph>, <ph id="ph5">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Last" /&gt;</ph>.</source>
          <target state="translated">Одно из следующих направлений, указанное в <ph id="ph1">&lt;see cref="T:System.Windows.Input.TraversalRequest" /&gt;</ph>: <ph id="ph2">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Next" /&gt;</ph>, <ph id="ph3">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" /&gt;</ph>, <ph id="ph4">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.First" /&gt;</ph>, <ph id="ph5">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Last" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>These directions are not legal for <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /&gt;</ph> (but they are legal for <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /&gt;</ph>).</source>
          <target state="translated">Эти направления недопустимы для метода <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkContentElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /&gt;</ph> (однако допустимы для метода <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkContentElement.MoveFocus(System.Windows.Input.TraversalRequest)" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>Name to use for the specified name-object mapping.</source>
          <target state="translated">Имя, используемое для сопоставления указанного имени с объектом.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>Object for the mapping.</source>
          <target state="translated">Объект для сопоставления.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>Provides an accessor that simplifies access to the <ph id="ph1">&lt;see cref="T:System.Windows.NameScope" /&gt;</ph> registration method.</source>
          <target state="translated">Предоставляет метод доступа, упрощающий доступ к методу регистрации <ph id="ph1">&lt;see cref="T:System.Windows.NameScope" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>This method is a convenience method for calling <ph id="ph1">&lt;xref:System.Windows.NameScope.RegisterName%2A&gt;</ph>.</source>
          <target state="translated">Этот метод является самым удобным для вызова <ph id="ph1">&lt;xref:System.Windows.NameScope.RegisterName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>The implementation will check successive parent elements until it finds the applicable <ph id="ph1">&lt;xref:System.Windows.NameScope&gt;</ph> implementation, which is found by finding an element that implements <ph id="ph2">&lt;xref:System.Windows.Markup.INameScope&gt;</ph>.</source>
          <target state="translated">Реализация будет проверять последовательных родительских элементов, пока не найдет применимый <ph id="ph1">&lt;xref:System.Windows.NameScope&gt;</ph> реализации, в которой находится с помощью поиск элемента, который реализует <ph id="ph2">&lt;xref:System.Windows.Markup.INameScope&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>For more information about namescopes, see <bpt id="p1">[</bpt>WPF XAML Namescopes<ept id="p1">](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об области видимости имен см. в разделе <bpt id="p1">[</bpt>области имен XAML WPF<ept id="p1">](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>Calling <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.RegisterName%2A&gt;</ph> is necessary in order to correctly hook up animation storyboards for applications when created in code.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.RegisterName%2A&gt;</ph> необходим, чтобы правильно подключать анимации раскадровки для приложений, созданных в коде.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>This is because one of the key storyboard properties, <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard.TargetName%2A&gt;</ph>, uses a run-time name lookup instead of being able to take a reference to a target element.</source>
          <target state="translated">Это вызвано одно из ключевых раскадровки свойства, <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard.TargetName%2A&gt;</ph>, выполняет поиск имени во время выполнения не предоставляется возможность указать ссылку на целевой элемент.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>This is true even if that element is accessible by reference from the code.</source>
          <target state="translated">Это верно, даже если этому элементу осуществляется по ссылке из кода.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>For more information on why you need to register names for storyboard targets, see <bpt id="p1">[</bpt>Storyboards Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о том, почему необходимо зарегистрировать имена целей раскадровки см. в разделе <bpt id="p1">[</bpt>Общие<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RegisterName(System.String,System.Object)">
          <source>Animations for content elements are less common than animations on controls, the <bpt id="p1">[</bpt>Storyboards Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept> concentrates on control scenarios.</source>
          <target state="translated">Анимация элементов содержимого реже, чем анимация элементов, <bpt id="p1">[</bpt>Общие<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept> управления.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)">
          <source>The element to remove.</source>
          <target state="translated">Подлежащий удалению элемент.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)">
          <source>Removes the specified element from the logical tree for this element.</source>
          <target state="translated">Удаляет указанный элемент из логического дерева данного элемента.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)">
          <source>This <ph id="ph1">[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]</ph> is mainly relevant for class deriving scenarios, when adding support for child collections.</source>
          <target state="translated">Это <ph id="ph1">[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]</ph> основном относится к классу, производные сценариев, при добавлении поддержки дочерних коллекций.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)">
          <source>Most <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> derived classes expose dedicated collections that are responsible for containment (for example, <ph id="ph2">&lt;xref:System.Windows.Documents.Span.Inlines%2A&gt;</ph> on the <ph id="ph3">&lt;xref:System.Windows.Documents.Span&gt;</ph> class; <ph id="ph4">&lt;xref:System.Windows.Documents.Section.Blocks%2A&gt;</ph> on the <ph id="ph5">&lt;xref:System.Windows.Documents.Section&gt;</ph> class).</source>
          <target state="translated">Большинство <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> производные классы предоставляют выделенный коллекций, которые отвечают за вложения (например, <ph id="ph2">&lt;xref:System.Windows.Documents.Span.Inlines%2A&gt;</ph> на <ph id="ph3">&lt;xref:System.Windows.Documents.Span&gt;</ph> класса; <ph id="ph4">&lt;xref:System.Windows.Documents.Section.Blocks%2A&gt;</ph> на <ph id="ph5">&lt;xref:System.Windows.Documents.Section&gt;</ph> класса).</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.RemoveLogicalChild(System.Object)">
          <source>Deriving from such classes typically can avoid any need to manipulate the logical tree directly.</source>
          <target state="translated">Наследование из таких классов обычно можно избежать необходимости напрямую управлять логического дерева.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Gets or sets the current locally-defined resource dictionary.</source>
          <target state="translated">Возвращает или задает текущий локально определенный словарь ресурсов.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>The current locally-defined resources.</source>
          <target state="translated">Текущие локально определенные ресурсы.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>This is a dictionary of resources, where resources within the dictionary are accessed by key.</source>
          <target state="translated">Это словарь ресурсов, доступ к ресурсам которого можно получить по ключу.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Resource dictionaries that can be defined completely or partially in <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> are typically created as a property element, and are typically on the root element for any individual page or for the application.</source>
          <target state="translated">Словари ресурсов, которые могут быть определены полностью или частично в <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> обычно создаются как элемент свойства и обычно представляют собой в корневом элементе любой отдельной страницы или приложения.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Placing the resource dictionary at this level makes it easier to find from individual child elements in the page (or from any page, in the application case).</source>
          <target state="translated">Размещение словаря ресурсов на этом уровне облегчает поиск из отдельных дочерних элементов на странице (или на любой странице, в случае приложения).</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>In most application scenarios, we recommend that styles be defined as object elements within a resource dictionary, or be defined as external resources so that the entire style resource can be self-contained (this approach helps separate designer responsibilities from developer responsibilities by separating the physical files that need to be edited).</source>
          <target state="translated">В большинстве сценариев приложений, рекомендуется определить эти стили как элементы-объекты в словаре ресурсов или как внешние ресурсы, чтобы весь ресурс стиля мог быть автономным (этот подход помогает отдельный конструктор Ответственность от ответственности разработчика путем разделения физических файлов, которые нужно редактировать).</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Note that this property returns only the resource dictionary declared directly within that element.</source>
          <target state="translated">Обратите внимание, что это свойство возвращает только словарь ресурсов, объявленный непосредственно внутри этого элемента.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>This is different than the actual resource lookup process, where a child element can access any of the resources defined in each parent element, searching recursively upwards.</source>
          <target state="translated">Это отличается от фактического процесса поиска ресурсов, где дочерний элемент можно использовать все ресурсы, определенные в каждом родительском элементе, выполняя рекурсивный восходящий поиск.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Resources can also be referenced by code from within the collection, but be aware that resources created in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> will definitely not be accessible until after <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph> is raised by the element that declares the dictionary.</source>
          <target state="translated">Ресурсы также могут ссылаться с помощью кода из коллекции, но имейте в виду, что ресурсы, созданные в <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> определенно будут недоступны до после <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph> возникает для элемента, который объявляет словаря.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>In fact, resources are parsed asynchronously, and not even the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph> event is an assurance that you can reference a <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> defined resource.</source>
          <target state="translated">На самом деле ресурсы анализируется асинхронно и даже <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Loaded&gt;</ph> событий является гарантией того, можно ссылаться <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> определенных ресурсов.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>For this reason you should generally only access <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> defined resources as part of run-time code, or through other <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> techniques such as styles or resource extension references for attribute values.</source>
          <target state="translated">По этой причине следует обычно только обращаться к <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> определены ресурсы в рамках кода во время выполнения, или с помощью других <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> методы, такие как ссылки на расширение ресурса для значений атрибутов или стилей.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>When you access resources through code, it is essentially equivalent to a  reference made from <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">При доступе к ресурсам через код, он фактически эквивалентна ссылку из <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>The underlying <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> supports the methods required to add, remove, or query resources from within the collection by using code.</source>
          <target state="translated">Базовый <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> поддерживает методы, необходимые для добавления, удаления или запроса ресурсов из коллекции с помощью кода.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph> property is settable to support the scenario of completely replacing the resources collection of an element to be a new or different <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph> Свойства можно настроить для поддержки полной замены коллекции ресурсов элемента как новый или другой сценарий <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Notice that the <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax shown does not include an element for the <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">Обратите внимание, что <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> синтаксис, показанный отсутствует элемент для <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>This is an example of implicit collection syntax; a tag representing the collection element can be omitted.</source>
          <target state="translated">Это пример неявного синтаксиса коллекции; можно опустить тег представляет элемент коллекции.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>The elements that are added as items to the collection are specified instead.</source>
          <target state="translated">Вместо этого указаны элементы, которые будут добавлены как элементы в коллекцию.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>For more information about implicit collections and <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, see <bpt id="p1">[</bpt>XAML Syntax In Detail<ept id="p1">](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о неявных коллекциях и <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, в разделе <bpt id="p1">[</bpt>XAML Syntax In Detail<ept id="p1">](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)</ept>.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>One case where a <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> is still specified explicitly as an element is if you are introducing a merged dictionary, in which case there are typically no child elements for that <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">Один вариант где <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> по-прежнему задается явным образом как элемент есть ли вы ввели объединенный словарь, в этом случае обычно нет дочерних элементов для этого <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>For details, see <bpt id="p1">[</bpt>Merged Resource Dictionaries<ept id="p1">](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>слияние словари ресурсов<ept id="p1">](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md)</ept>.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>XAML Property Element Usage</source>
          <target state="translated">Использование элемента свойства XAML</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>XAML Values</source>
          <target state="translated">Значения XAML</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source><bpt id="p1">*</bpt>oneOrMoreResourceElements<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>oneOrMoreResourceElements<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>One or more object elements, each of which defines a resource.</source>
          <target state="translated">Один или несколько объектов элементов, каждый из которых определяет ресурс.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>Each resource property element within each <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> must have a unique value for the <bpt id="p1">[</bpt>x:Key Directive<ept id="p1">](~/docs/framework/xaml-services/x-key-directive.md)</ept>, which serves as the unique key when values are retrieved from the <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">Каждого элемента property ресурсов в каждом <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> должен иметь уникальное значение для <bpt id="p1">[</bpt>директива x: Key<ept id="p1">](~/docs/framework/xaml-services/x-key-directive.md)</ept>, который используется в качестве уникального ключа при извлечении значений из <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source>The following example establishes a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph> collection on a <ph id="ph2">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> root element.</source>
          <target state="translated">Следующий пример устанавливает <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph> коллекции <ph id="ph2">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> корневого элемента.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Resources">
          <source><ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> is a typical choice because it is one of the few <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> classes that make sense as a root element, and resources are generally stored at the page root or at even higher levels such as in the application.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> Типичный вариант, так как он является одним из нескольких <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> классы назвать корневой элемент и ресурсы обычно хранятся в корне страницы или на даже более высоких уровнях, например, в приложение.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkContentElement">
          <source>Attaches a binding to this element for the specified dependency property.</source>
          <target state="translated">Присоединяет привязку к этому элементу для указанного свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>Identifies the bound property.</source>
          <target state="translated">Идентифицирует привязанное свойство.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>The source property name or the path to the property used for the binding.</source>
          <target state="translated">Имя исходного свойства или путь к свойству, используемому для привязки.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>Attaches a binding to this element, based on the provided source property name as a path qualification to the data source.</source>
          <target state="translated">Прикрепляет привязку к данному элементу на основе указанного имени исходного свойства в виде классификационного пути к источнику данных.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>Records the conditions of the binding.</source>
          <target state="translated">Фиксирует состояния привязки.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>This return value can be useful for error checking.</source>
          <target state="translated">Это возвращаемое значение можно использовать для проверки ошибок.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>This method is a convenience method for calling <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType&gt;</ph>, which passes the current instance as the <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>, and creates a new <ph id="ph3">&lt;xref:System.Windows.Data.Binding&gt;</ph> based on the provided <ph id="ph4">`path`</ph> parameter.</source>
          <target state="translated">Этот метод является самым удобным для вызова <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType&gt;</ph>, который передает текущего экземпляра в качестве <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>и создает новый <ph id="ph3">&lt;xref:System.Windows.Data.Binding&gt;</ph> на основе предоставленной <ph id="ph4">`path`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>This signature is more convenient if you are establishing a simple default binding.</source>
          <target state="translated">Эта подпись является более удобным в том случае, если устанавливается простой привязки по умолчанию.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>If you need to specify any binding properties to non-default conditions, or want to use a <ph id="ph1">&lt;xref:System.Windows.Data.MultiBinding&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.Data.PriorityBinding&gt;</ph>,you should use the <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29&gt;</ph> signature.</source>
          <target state="translated">Если вам нужно указать любые свойства привязки для нестандартных условий, или использовать <ph id="ph1">&lt;xref:System.Windows.Data.MultiBinding&gt;</ph> или <ph id="ph2">&lt;xref:System.Windows.Data.PriorityBinding&gt;</ph>, следует использовать <ph id="ph3">&lt;xref:System.Windows.FrameworkContentElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29&gt;</ph> подписи.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>The following example sets a binding on a <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> element, by creating a new custom data object, establishing that object as <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph>, and setting the binding path to a property within it.</source>
          <target state="translated">В следующем примере задается привязка на <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> элемент путем создания нового объекта пользовательские данные, установление объект в качестве <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.DataContext%2A&gt;</ph>и указав путь привязки к свойству в ней.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>Identifies the bound property.</source>
          <target state="translated">Идентифицирует привязанное свойство.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>Represents a data binding.</source>
          <target state="translated">Представляет привязку данных.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>Attaches a binding to this element, based on the provided binding object.</source>
          <target state="translated">Прикрепляет привязку к данному элементу на основе предоставленной привязки объекта.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>Records the conditions of the binding.</source>
          <target state="translated">Фиксирует состояния привязки.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>This return value can be useful for error checking.</source>
          <target state="translated">Это возвращаемое значение можно использовать для проверки ошибок.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>This method is a convenience method for calling <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType&gt;</ph>, which passes the current instance as the <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>.</source>
          <target state="translated">Этот метод является самым удобным для вызова <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType&gt;</ph>, который передает текущего экземпляра в качестве <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>The following example sets a binding on a <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> element, by creating a new <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> and setting the source to a newly built <ph id="ph3">`DateTime`</ph> object.</source>
          <target state="translated">В следующем примере задается привязка на <ph id="ph1">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph> элемент, создавая новый <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> и установив для источника новая построенная <ph id="ph3">`DateTime`</ph> объекта.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>The property to which the resource is bound.</source>
          <target state="translated">Свойство, к которому привязан ресурс.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>The name of the resource.</source>
          <target state="translated">Имя ресурса.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>Searches for a resource with the specified name and sets up a resource reference to it for the specified property.</source>
          <target state="translated">Выполняет поиск ресурса по указанному имени и устанавливает ссылку на этот ресурс для указанного свойства.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>A resource reference is similar to the use of a <bpt id="p1">[</bpt>DynamicResource Markup Extension<ept id="p1">](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)</ept> in markup.</source>
          <target state="translated">Ссылка на ресурс похож на использование <bpt id="p1">[</bpt>DynamicResource Markup Extension<ept id="p1">](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)</ept> в разметке.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>The resource reference creates an internal expression that supplies the value of the specified property on a run-time deferred basis.</source>
          <target state="translated">Ссылка на ресурс создает внутреннее выражение, содержащий значение заданного свойства на основе отложенного выполнения.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>The expression will be re-evaluated whenever the resource dictionary indicates a changed value through internal events, or whenever the current element is reparented (a parent change would change the dictionary lookup path).</source>
          <target state="translated">Выражение будет повторно вычисляться каждый раз, когда словарем ресурсов измененного значения через внутренние события или при изменении родителя текущего элемента (родителя изменяется путь для поиска словаря).</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeResources">
          <source>Returns whether serialization processes should serialize the contents of the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Resources" /&gt;</ph> property on instances of this class.</source>
          <target state="translated">Возвращает логическое значение, указывающее, следует ли процессам сериализации сериализировать содержимое свойства <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Resources" /&gt;</ph> в экземплярах данного класса.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeResources">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Resources" /&gt;</ph> property value should be serialized; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если значение свойства <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Resources" /&gt;</ph> подлежит сериализации, в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeResources">
          <source>This will return <ph id="ph1">`true`</ph> so long as there is at least one keyed resource in the local <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph>.</source>
          <target state="translated">Будет возвращен <ph id="ph1">`true`</ph> при условии, что имеется по крайней мере один ресурс с ключом в локальной <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle">
          <source>Returns whether serialization processes should serialize the contents of the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph> property on instances of this class.</source>
          <target state="translated">Возвращает логическое значение, указывающее, следует ли процессам сериализации сериализировать содержимое свойства <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph> в экземплярах данного класса.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph> property value should be serialized; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если значение свойства <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph> подлежит сериализации, в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.ShouldSerializeStyle">
          <source>This will return <ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph> is locally set.</source>
          <target state="translated">Будет возвращен <ph id="ph1">`true`</ph> Если <ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph> установлено локально.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.SourceUpdated">
          <source>Occurs when any associated data source participating in a binding on this element changes.</source>
          <target state="translated">Происходит при изменении какого-либо связанного источника данных, участвующего в привязке к данному элементу.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.SourceUpdated">
          <source>This event surfaces the <ph id="ph1">&lt;xref:System.Windows.Data.Binding.SourceUpdated&gt;</ph> event that is raised by any <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> associated with this element.</source>
          <target state="translated">Это событие поверхности <ph id="ph1">&lt;xref:System.Windows.Data.Binding.SourceUpdated&gt;</ph> событие, возникающее по любому <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> связанные с данным элементом.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.SourceUpdated">
          <source>XAML Attribute Usage</source>
          <target state="translated">Использование атрибута XAML</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Gets or sets the style to be used by this element.</source>
          <target state="translated">Получает или задает стиль, который должен использоваться этим элементом.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The applied, nondefault style for the element, if present.</source>
          <target state="translated">Примененный стиль элемента, отличающийся от стиля по умолчанию, если присутствует.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">В противном случае — значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The default for a default-constructed <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию для созданного по умолчанию объекта <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph> — <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The current style is often provided by a default style from theming, or from styles generally applied to objects of that type by resources at page or application level (an implicit style).</source>
          <target state="translated">Текущий стиль часто обеспечивается стилем по умолчанию из темы или из стилей, обычно применяется к объектам этого типа по ресурсам на уровне страницы или приложения (неявный стиль).</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>This property does not set or return default (theme) styles, but it does return the implicit style or an explicit style.</source>
          <target state="translated">Данное свойство не устанавливает и не возвращает по умолчанию стили (тема), но возвращает неявный или явный стиль.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>In the case of implicit or explicit styles, it does not matter whether the style is accessed as a resource or defined locally.</source>
          <target state="translated">В случае неявных или явных стилей не проверяются ли стиль доступен как ресурс или определен локально.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Setting the styles has some restrictions.</source>
          <target state="translated">Задание стилей имеет некоторые ограничения.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>You can reset the entire <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> property to a new <ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph> at any time, which will force a layout recomposition.</source>
          <target state="translated">Вы можете сбросить всего <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> для нового <ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph> в любое время, который выполняет принудительное рекомпозиции макета.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>However, as soon as that style is placed in use by a loaded element, the <ph id="ph1">&lt;xref:System.Windows.Style&gt;</ph> should be considered sealed.</source>
          <target state="translated">Тем не менее, как можно раньше этим стилем помещается используется загруженным элементом <ph id="ph1">&lt;xref:System.Windows.Style&gt;</ph> следует учитывать sealed.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Attempting to make a change to any individual property of an in-use style (such as anything within the collection of <ph id="ph1">&lt;xref:System.Windows.Style.Setters%2A&gt;</ph>) causes an exception to be thrown.</source>
          <target state="translated">Попытка внести изменение любое отдельное свойство для используемого стиля (такие как что-либо из коллекции <ph id="ph1">&lt;xref:System.Windows.Style.Setters%2A&gt;</ph>) приводит к созданию исключения.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>A style that is defined in markup is considered to be in use as soon as it is loaded from a resource dictionary (for resources), or the page it is contained within is loaded (for inline styles).</source>
          <target state="translated">Стиль, определенный в разметке считается используется сразу после ее загрузки из словаря ресурсов (для ресурсов) или загрузки страницы, в которой он содержится в (для встроенные стили).</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> is a dependency property with special precedence.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> — Это свойство зависимостей с специальные приоритетом.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The locally set style generally operates at the highest precedence in the property system.</source>
          <target state="translated">Локально заданное стиль обычно действует с более высоким приоритетом в системе свойств.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>If the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> is null at this point, during loading the property system checks for implicit styles as defined resources that specify that type.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> имеет значение null в этот момент во время загрузки в системе свойств проверяет наличие неявных стилей как определенных ресурсов этого типа.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>If the style is still null after this step, then the style comes from the default (theme) style, but the default style is not returned in the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> property value.</source>
          <target state="translated">Если стиль равен null после выполнения этого шага, то стиль поступает из стиля по умолчанию (тема), но стиль по умолчанию не возвращается в <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Style%2A&gt;</ph> значение свойства.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>See <bpt id="p1">[</bpt>Dependency Property Value Precedence<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>.</source>
          <target state="translated">В разделе <bpt id="p1">[</bpt>приоритет значения свойства зависимости<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept>.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>XAML Attribute Usage</source>
          <target state="translated">Использование атрибута XAML</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>XAML Values</source>
          <target state="translated">Значения XAML</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>One of the following: , or .</source>
          <target state="translated">Одно из следующих:, или.</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>See <bpt id="p1">[</bpt>XAML Resources<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</source>
          <target state="translated">В разделе <bpt id="p1">[</bpt>ресурсов XAML<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source><bpt id="p1">*</bpt>styleResourceKey<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>styleResourceKey<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The key that identifies the style being requested.</source>
          <target state="translated">Ключ, идентифицирующий запрашиваемый стиль.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The key refers to an existing resource in a <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">Ключ ссылается на существующий ресурс в <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Property element syntax is technically possible, but not recommended.</source>
          <target state="translated">Синтаксис элемента свойства технически возможно, но не рекомендуется.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>See <bpt id="p1">[</bpt>Inline Styles and Templates<ept id="p1">](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)</ept>.</source>
          <target state="translated">В разделе <bpt id="p1">[</bpt>встроенные стили и шаблоны<ept id="p1">](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)</ept>.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>A binding reference using  or <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> is also possible, but uncommon.</source>
          <target state="translated">Ссылка привязки с помощью или <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> также является, возможно, но встречается редко.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Style">
          <source>The following example establishes a <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph> collection on a <ph id="ph2">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> root element and then references it as a resource as a specific style for a <ph id="ph3">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph>.</source>
          <target state="translated">Следующий пример устанавливает <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Resources%2A&gt;</ph> коллекции на <ph id="ph2">&lt;xref:System.Windows.Documents.FlowDocument&gt;</ph> корневой элемент и затем ссылается на него как ресурс как определенный стиль для <ph id="ph3">&lt;xref:System.Windows.Documents.Paragraph&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.StyleProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Style" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source>The name of the requested ambient property.</source>
          <target state="translated">Имя запрошенного внешнего свойства.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source>For a description of this member, see the <ph id="ph1">&lt;see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /&gt;</ph> method.</source>
          <target state="translated">Описание этого элемента содержится в методе <ph id="ph1">&lt;see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="propertyName" /&gt;</ph> is available; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если свойство с именем в параметре <ph id="ph2">&lt;paramref name="propertyName" /&gt;</ph> доступно; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Windows.Markup.IQueryAmbient&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.Windows.Markup.IQueryAmbient&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Gets or sets an arbitrary object value that can be used to store custom information about this element.</source>
          <target state="translated">Получение или установка произвольного значения объекта, которое может использоваться для хранения особых сведений об этом элементе.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>The intended value.</source>
          <target state="translated">Целевое значение.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>This property has no default value.</source>
          <target state="translated">Это свойство не имеет значения по умолчанию.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>This property is analogous to Tag properties in other <ph id="ph1">[!INCLUDE[TLA#tla_ms](~/includes/tlasharptla-ms-md.md)]</ph> programming models, such as <ph id="ph2">[!INCLUDE[TLA#tla_vba](~/includes/tlasharptla-vba-md.md)]</ph> or <ph id="ph3">[!INCLUDE[TLA#tla_winforms](~/includes/tlasharptla-winforms-md.md)]</ph>.</source>
          <target state="translated">Это свойство является аналогом тег свойства в других <ph id="ph1">[!INCLUDE[TLA#tla_ms](~/includes/tlasharptla-ms-md.md)]</ph> моделях программирования, таких как <ph id="ph2">[!INCLUDE[TLA#tla_vba](~/includes/tlasharptla-vba-md.md)]</ph> или <ph id="ph3">[!INCLUDE[TLA#tla_winforms](~/includes/tlasharptla-winforms-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>It is intended to provide a pre-existing place to store some basic custom information about any element without forcing application developers to subclass.</source>
          <target state="translated">Он предназначен для предоставления уже существующее место для хранения базовой пользовательской информации о любом элементе без перезагрузки разработчикам приложений подкласс.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>XAML Values</source>
          <target state="translated">Значения XAML</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Because this property takes an object, you would need to use the property element usage in order to set the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Tag%2A&gt;</ph> property in <ph id="ph2">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> to anything other than an object with a known and built-in type converter, such as a string.</source>
          <target state="translated">Так как это свойство принимает объект, необходимо использовать использование элемента свойства, чтобы задать <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.Tag%2A&gt;</ph> свойство в <ph id="ph2">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> только на объект с известным и встроенным преобразователя, такие как строка.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Objects used in this way are typically not within the standard <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> namespaces and therefore may require namespace mapping to the external namespace in order to be introduced as <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> elements.</source>
          <target state="translated">Объекты, используемые таким образом, обычно не входят в стандартные <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> пространства имен и поэтому может потребоваться сопоставление пространства имен с внешним пространством имен для новых <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> элементов.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.Tag">
          <source>None</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.TagProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Tag" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.Tag" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.TargetUpdated">
          <source>Occurs when any associated target property participating in a binding on this element changes.</source>
          <target state="translated">Происходит при изменении любого связанного целевого свойства, участвующего в привязке в этом элементе.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.TargetUpdated">
          <source>This event surfaces the <ph id="ph1">&lt;xref:System.Windows.Data.Binding.TargetUpdated&gt;</ph> event that is raised by any <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> associated with this element.</source>
          <target state="translated">Это событие поверхности <ph id="ph1">&lt;xref:System.Windows.Data.Binding.TargetUpdated&gt;</ph> событие, возникающее по любому <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> связанные с данным элементом.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.TargetUpdated">
          <source>This usually means that the binding in question is a two-way binding, and that the bound  dependency property affirms an invalidation of the previous property value per any validation or caching scheme that the property supports.</source>
          <target state="translated">Обычно это означает, что рассматриваемая двустороннюю привязку, и что свойства привязанного зависимостей подтверждает недействительность предыдущее значение свойства в любой схеме проверки или кэширования, поддерживает свойство.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.TargetUpdated">
          <source>The event arguments of this event will inform you which bound property was changed.</source>
          <target state="translated">Аргументы события данного события будет информировать того, какие свойства, привязанного к была изменена.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.TargetUpdated">
          <source>XAML Attribute Usage</source>
          <target state="translated">Использование атрибута XAML</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>Gets a reference to the template parent of this element.</source>
          <target state="translated">Получает ссылку на родительский объект шаблона данного элемента.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>This property is not relevant if the element was not created through a template.</source>
          <target state="translated">Это свойство не актуально, если элемент не был создан с помощью шаблона.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>The element whose <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkTemplate" /&gt;</ph><ph id="ph2">&lt;see cref="P:System.Windows.FrameworkTemplate.VisualTree" /&gt;</ph> caused this element to be created.</source>
          <target state="translated">Элемент, свойство <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkTemplate" /&gt;</ph> шаблона <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkTemplate.VisualTree" /&gt;</ph>  которого вызвало создание данного элемента.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>This value is frequently <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Это значение часто равно <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>Templates are actually shared objects, where the contents of the template are created only once.</source>
          <target state="translated">Шаблоны являются фактически общие объекты, в котором содержимое шаблона создаются только один раз.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>Therefore, if you obtain an object reference to an element that came from a template, you may find that the apparent logical tree does not reach to the page root.</source>
          <target state="translated">Таким образом Если получить ссылку на элемент, поступивший из шаблона, может оказаться очевидной логического дерева не достигает корня страницы.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>In order to connect such a template reference to the page's logical tree, you should get the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> value and continue to navigate that element tree as desired.</source>
          <target state="translated">Чтобы подключить такая ссылка шаблона в дереве логической страницы, вы должны получить <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> значения и продолжить для перемещения этого элемента дерева в случае необходимости.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> will frequently be <ph id="ph2">`null`</ph> for common objects, because if you have obtained an object reference from out of a page in your application through typical means, that element probably was not created from a template.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> часто оказываются <ph id="ph2">`null`</ph> для общих объектов, поскольку если приобретается ссылку на объект из линейных страницы в приложении через стандартные средства этот элемент, скорее всего, не был создан из шаблона.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.TemplatedParent">
          <source>Cases where <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> might not be <ph id="ph2">`null`</ph> would include operations such as hit-testing, event handling for certain low-level input events, or working with enumerators, which may have returned elements that came from templates.</source>
          <target state="translated">Ситуации, когда <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.TemplatedParent%2A&gt;</ph> не может быть <ph id="ph2">`null`</ph> включает операции, например события нажатия, обработки для определенных низкоуровневых событий ввода или работа с перечислителями, которые могут возвращать элементы, полученные из шаблонов.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Gets or sets the tool-tip object that is displayed for this element in the <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.</source>
          <target state="translated">Получает или задает объект подсказки, отображаемый для данного элемента в <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>The tooltip object.</source>
          <target state="translated">Объект подсказки.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>If the value of this property is of type <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>, then that is the tool-tip that will be used in the <ph id="ph2">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>.</source>
          <target state="translated">Если значение этого свойства имеет тип <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>, то, является всплывающей подсказки, будет использоваться в <ph id="ph2">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>If the value is of any other type, then that value will be used as the <bpt id="p1">*</bpt>content<ept id="p1">*</ept> for a <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph> provided (constructed) by the system.</source>
          <target state="translated">Если значение любого другого типа, то это значение будет использоваться в качестве <bpt id="p1">*</bpt>содержимого<ept id="p1">*</ept> для <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph> указано (создан) системой.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>For more information see <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTipService&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTipService&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>The service class provides attached properties that can be used to further customize a tool-tip.</source>
          <target state="translated">Служебный класс предоставляет вложенные свойства, которые могут использоваться для дальнейшей настройки подсказки.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>XAML Attribute Usage</source>
          <target state="translated">Использование атрибута XAML</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>XAML Property Element Usage</source>
          <target state="translated">Использование элемента свойства XAML</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>XAML Values</source>
          <target state="translated">Значения XAML</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source><bpt id="p1">*</bpt>toolTipContent<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>toolTipContent<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>A string that becomes the display text for the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph>.</source>
          <target state="translated">Строка, которая становится отображаемый текст для <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source><bpt id="p1">*</bpt>toolTipObjectContent<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>toolTipObjectContent<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Some object, provided in object element form, that should be used as the content for the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> .</source>
          <target state="translated">Некоторые объектом, указанным в форме элемента объекта, который должен использоваться в качестве содержимого для <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> .</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Typically this would be a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> or some other element that creates layout compositing for the <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph>, eventually containing text content within the compositing.</source>
          <target state="translated">Обычно это было бы <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> или другой элемент, создающий композиции макета для <ph id="ph2">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph>, в конечном итоге содержащий текстового содержимого в композиции.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>In this usage, the <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph> element is created implicitly from the parsed <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, and the <bpt id="p1">*</bpt>toolTipObjectContent<ept id="p1">*</ept> content is set as its <ph id="ph3">&lt;xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">При таком использовании <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph> создается элемент неявно из проанализированный <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>и <bpt id="p1">*</bpt>toolTipObjectContent<ept id="p1">*</ept> содержимое задано как его <ph id="ph3">&lt;xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source><ph id="ph1">&lt;</ph><ph id="ph2">`ToolTip`</ph> .../&gt;</source>
          <target state="translated"><ph id="ph1">&lt;</ph><ph id="ph2">`ToolTip`</ph> .../&gt;</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>.</source>
          <target state="translated">См. раздел <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>None</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkContentElement.ToolTip">
          <source>The following example sets the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ToolTip%2A&gt;</ph> property directly to a string.</source>
          <target state="translated">В следующем примере задается значение <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ToolTip%2A&gt;</ph> свойства непосредственно в строку.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Occurs just before any tooltip on the element is closed.</source>
          <target state="translated">Происходит непосредственно перед закрытием какой-либо подсказки в элементе.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>To suppress closing the tooltip, handlers of the event should mark it as handled.</source>
          <target state="translated">Чтобы подавить закрытие подсказки, обработчики события должны его нужно пометить как обработанное.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>This event cannot be an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style.</source>
          <target state="translated">Это событие не может быть <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> в стиле.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</source>
          <target state="translated">Это потому, что поле идентификатора данного события повторно использует реализацию из службы, которая не открывает методы добавления и удаления события.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Routed Event Information</source>
          <target state="translated">Сведения о маршрутизируемом событии</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Routing strategy</source>
          <target state="translated">Стратегия маршрутизации</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Direct</source>
          <target state="translated">Direct</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipClosing">
          <source>Delegate</source>
          <target state="translated">делегат</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated">Идентифицирует <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipClosing" /&gt;</ph> <bpt id="p1">[</bpt>Обзор маршрутизированных событий<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">Объекты идентификатор события, создаваемые при их регистрации (см. <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) и затем могут использоваться для добавления обработчиков класса (см. <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ToolTipClosingEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">Идентификатор объекты содержат идентифицирующее имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Occurs when any tooltip on the element is opened.</source>
          <target state="translated">Происходит при открытии любой всплывающей подсказки к элементу.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>To manually open tooltips, handlers of the events should mark the relevant event as handled.</source>
          <target state="translated">Для открытия подсказок вручную обработчики событий должны помечать соответствующее событие как обработанное.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Otherwise, the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph> property will be used to automatically open a context menu.</source>
          <target state="translated">В противном случае — значение <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph> будет использоваться свойство, чтобы автоматически открыть контекстное меню.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph> property and then open the new <ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph>.</source>
          <target state="translated">Маркировка обрабатываемого события эффективно отменит действие по умолчанию и может быть возможность сбросить значение <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph> свойства и откройте новый <ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Note that this event will not be raised if <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph> is a null reference or otherwise unset.</source>
          <target state="translated">Обратите внимание, что это событие не будет вызываться, если <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.ToolTip%2A&gt;</ph> является пустой ссылкой или в противном случае значение не задано.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>This event cannot be an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style.</source>
          <target state="translated">Это событие не может быть <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> в стиле.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove methods on the event.</source>
          <target state="translated">Это потому, что поле идентификатора данного события повторно использует реализацию из службы, которая не открывает методы добавления и удаления события.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Routed Event Information</source>
          <target state="translated">Сведения о маршрутизируемом событии</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Routing strategy</source>
          <target state="translated">Стратегия маршрутизации</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Direct</source>
          <target state="translated">Direct</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.ToolTipOpening">
          <source>Delegate</source>
          <target state="translated">делегат</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated">Идентифицирует <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.ToolTipOpening" /&gt;</ph> <bpt id="p1">[</bpt>Обзор маршрутизированных событий<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">Объекты идентификатор события, создаваемые при их регистрации (см. <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) и затем могут использоваться для добавления обработчиков класса (см. <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.ToolTipOpeningEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">Идентификатор объекты содержат идентифицирующее имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.ToolTipProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ToolTip" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkContentElement.ToolTip" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>Key identifier of the resource to be found.</source>
          <target state="translated">Идентификатор ключа искомого ресурса.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>Searches for a resource with the specified key, and returns that resource if found.</source>
          <target state="translated">Ищет ресурс с указанным ключом и возвращает его, если он найден.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>The found resource.</source>
          <target state="translated">Найденный ресурс.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>If no resource was found, <ph id="ph1">&lt;see langword="null" /&gt;</ph> is returned.</source>
          <target state="translated">Если ресурс не найден, возвращается значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>If the resource is not found on the calling element, the parent tree is searched using the logical tree, in the same way that the tree would be searched if a dynamic resource reference were requested by key at run-time.</source>
          <target state="translated">Если ресурс не найден в вызывающем элементе, родительского дерева осуществляется с помощью логического дерева таким же образом, который бы выполнялся поиск, если ссылка на динамический ресурс был запрошен по ключу во время выполнения.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</source>
          <target state="translated">Обычно вы сразу же привести возвращаемое значение к типу свойства, которое вы пытаетесь набор с возвращенным значением ресурса.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FindResource%2A&gt;</ph> method has similar behavior, except that it will throw an exception in the case of not finding a resource with the provided key.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.FindResource%2A&gt;</ph> Метод имеет аналогичное поведение, за исключением того, что он будет вызывать исключение в случае не найден ресурс с указанным ключом.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.TryFindResource(System.Object)">
          <source>The following example finds a resource as defined in markup and applies it to a certain property of an element in response to a routed event.</source>
          <target state="translated">В следующем примере найти ресурс, определенный в разметке и применяет его к определенному свойству элемента в ответ на перенаправленное событие.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Occurs when the element is removed from an element tree of loaded elements.</source>
          <target state="translated">Происходит при удалении элемента из дерева загруженных элементов.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</source>
          <target state="translated">События с прямой маршрутизацией не следуют по маршруту, они обрабатываются только внутри элемента, на котором они вызываются.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style.</source>
          <target state="translated">Прямые перенаправленные события поддерживают другое поведение перенаправленных событий: они поддерживают коллекцию доступных обработчиков и могут использоваться как <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> в стиле.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Routed Event Information</source>
          <target state="translated">Сведения о маршрутизируемом событии</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Routing strategy</source>
          <target state="translated">Стратегия маршрутизации</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Direct</source>
          <target state="translated">Direct</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkContentElement.Unloaded">
          <source>Delegate</source>
          <target state="translated">делегат</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkContentElement.UnloadedEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Unloaded" /&gt;</ph> <bpt id="p1">[</bpt>Routed Events Overview<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</source>
          <target state="translated">Идентифицирует <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkContentElement.Unloaded" /&gt;</ph> <bpt id="p1">[</bpt>Обзор маршрутизированных событий<ept id="p1">](~/docs/framework/wpf/advanced/routed-events-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.UnloadedEvent">
          <source>Event identifier objects are created when routed events are registered (see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) and can then be used to add class handlers (see <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</source>
          <target state="translated">Объекты идентификатор события, создаваемые при их регистрации (см. <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>) и затем могут использоваться для добавления обработчиков класса (см. <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkContentElement.UnloadedEvent">
          <source>Identifier objects contain an identifying name, owner type, handler type, routing strategy, and a utility method for adding owners for the event.</source>
          <target state="translated">Идентификатор объекты содержат идентифицирующее имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)">
          <source>Name of the name-object pair to remove from the current scope.</source>
          <target state="translated">Имя пары имя-объект, которую необходимо удалить из текущей области видимости.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)">
          <source>Simplifies access to the <ph id="ph1">&lt;see cref="T:System.Windows.NameScope" /&gt;</ph> de-registration method.</source>
          <target state="translated">Упрощает доступ к методу отмены регистрации <ph id="ph1">&lt;see cref="T:System.Windows.NameScope" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkContentElement.UnregisterName(System.String)">
          <source>You only need to un-register names if you intend to re-register another element with that same name.</source>
          <target state="translated">Только необходимо отменить регистрацию имен Если предполагается повторно зарегистрировать другой элемент с таким же именем.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkContentElement.UpdateDefaultStyle">
          <source>Reapplies the default style to the current <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>.</source>
          <target state="translated">Повторно применяет стиль по умолчанию к текущему объекту <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkContentElement" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>