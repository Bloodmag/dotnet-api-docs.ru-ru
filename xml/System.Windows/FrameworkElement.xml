<Type Name="FrameworkElement" FullName="System.Windows.FrameworkElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="52bb34d9daddff99314e23014e5d61909a488206" />
    <Meta Name="ms.sourcegitcommit" Value="058bfa0b75b777d3171411d35da8f11617fc06b0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="05/04/2018" />
    <Meta Name="ms.locfileid" Value="33660154" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkElement : System.Windows.UIElement, System.ComponentModel.ISupportInitialize, System.Windows.IFrameworkInputElement, System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi FrameworkElement extends System.Windows.UIElement implements class System.ComponentModel.ISupportInitialize, class System.Windows.IFrameworkInputElement, class System.Windows.IInputElement, class System.Windows.Markup.IQueryAmbient" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkElement" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkElement&#xA;Inherits UIElement&#xA;Implements IFrameworkInputElement, IQueryAmbient, ISupportInitialize" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkElement : System::Windows::UIElement, System::ComponentModel::ISupportInitialize, System::Windows::IFrameworkInputElement, System::Windows::Markup::IQueryAmbient" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIElement</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.ISupportInitialize</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.IFrameworkInputElement</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Windows.Markup.IQueryAmbient</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Markup.RuntimeNameProperty("Name")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.UsableDuringInitialization(true)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.Markup.XmlLangProperty("Language")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Windows.StyleTypedProperty(Property="FocusVisualStyle", StyleTargetType=typeof(System.Windows.Controls.Control))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет набор свойств, событий и методов уровня платформы WPF для элементов Windows Presentation Foundation (WPF). Этот класс представляет предоставленную реализацию уровня платформы WPF, созданную на базе API уровня ядра WPF, которые определяются <see cref="T:System.Windows.UIElement" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> Представляет точку соединения между классами элементов уровня платформы WPF и набора уровня ядра WPF <xref:System.Windows.UIElement> службами презентации. Дополнительные сведения об этих понятиях см. в разделе [архитектура WPF](~/docs/framework/wpf/advanced/wpf-architecture.md).  
  
 <xref:System.Windows.FrameworkElement> расширяет <xref:System.Windows.UIElement> и добавляет следующие возможности:  
  
-   **Определение системы макета**: <xref:System.Windows.FrameworkElement> предоставляет определенные реализации уровня платформы WPF для некоторых методов, которые были определены как виртуальные члены в <xref:System.Windows.UIElement>. Прежде всего <xref:System.Windows.FrameworkElement> запечатывает некоторые переопределения макета уровня ядра WPF, а вместо этого предоставляет эквивалента уровня инфраструктуры WPF, которые производные классы должны переопределять вместо. Например <xref:System.Windows.FrameworkElement> печати <xref:System.Windows.UIElement.ArrangeCore%2A> , но предоставляет <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>. Эти изменения отражают тот факт, на уровня платформы WPF это полная система структуры на месте, который может преобразовать любой <xref:System.Windows.FrameworkElement> производного класса. В WPF основы уровня, некоторые элементы, которые будут структуры общая [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] решения на основе макета в месте, но фактические ядра системы макета не определен. Дополнительные сведения см. в разделе [макета](~/docs/framework/wpf/advanced/layout.md).  
  
-   **Логическое дерево:** Общие [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] модели программирования обычно выражается в терминах выполняется дерево элементов. Поддержка выражения дерева элементов в логическом дереве и сопутствующие поддержки для определения этого дерева в разметке реализуется на <xref:System.Windows.FrameworkElement> уровне. Примечание тем не менее, <xref:System.Windows.FrameworkElement> намеренно не определяет модель содержимого и оставляя эту ответственность производным классам. Дополнительные сведения см. в разделе [Деревья в WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
-   **Объект события времени жизни:** часто бывает полезно знать, когда инициализируется элемент (конструктор вызывается) или при первой загрузке элемента в логическом дереве. <xref:System.Windows.FrameworkElement> определяет несколько событий, связанных с временем жизни объекта, которые предоставляют полезные обработчики для кода операции, которые включают элементы, такие как добавление нескольких дочерних элементов. Дополнительные сведения см. в разделе [события времени жизни объектов](~/docs/framework/wpf/advanced/object-lifetime-events.md).  
  
-   **Поддержка привязки данных и ссылки на динамический ресурс:** реализуется поддержка уровня свойств для привязки данных и ресурсы <xref:System.Windows.DependencyProperty> класса и встроенного в системе свойств, но возможность разрешения значение элемента, хранятся в виде <xref:System.Windows.Expression> (программных конструкций, лежащей в основе привязка данных и динамические ресурсы) реализуется <xref:System.Windows.FrameworkElement>. Дополнительные сведения см. в разделе [Общие сведения о привязке данных](~/docs/framework/wpf/data/data-binding-overview.md) и [ресурсов XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
-   **Стили:** <xref:System.Windows.FrameworkElement> определяет <xref:System.Windows.FrameworkElement.Style%2A> свойство. Однако <xref:System.Windows.FrameworkElement> еще не определить поддержку для шаблонов, или поддерживает декораторов. Эти функции представлены классы элементов управления, таких как <xref:System.Windows.Controls.Control> и <xref:System.Windows.Controls.ContentControl>.  
  
-   **Дополнительная поддержка анимации:** некоторую поддержку анимации уже был определен на уровне ядра WPF, но <xref:System.Windows.FrameworkElement> расширяет это путем реализации <xref:System.Windows.FrameworkElement.BeginStoryboard%2A> и связанных с ними элементов.  
  
 Как видно из иерархии классов много [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] классы являются производными от <xref:System.Windows.FrameworkElement>, напрямую либо через промежуточный базовые классы, такие как <xref:System.Windows.Controls.Panel> или <xref:System.Windows.Controls.Control>.  
  
 Если вы планируете использовать <xref:System.Windows.FrameworkElement> как базовый класс, может потребоваться сначала проверить существующие производные классы. <xref:System.Windows.FrameworkElement> обеспечивает поддержку нескольких основных сценариев, но также не имеет ряд возможностей, которые предпочтительны для «element» в том смысле стандартного блока, который используется для создания [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] в [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]. Например <xref:System.Windows.FrameworkElement> не определяет true модели содержимого; <xref:System.Windows.FrameworkElement> как базовый класс не определяет свойство, которое можно создать [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] дочерних элементов. В частности, может потребоваться рассмотреть <xref:System.Windows.Controls.Control> и <xref:System.Windows.Controls.ContentControl>.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.DependencyObject" />
    <altmember cref="T:System.Windows.FrameworkContentElement" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkElement();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeight">
      <MemberSignature Language="C#" Value="public double ActualHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualHeight" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualHeight { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает визуализированную высоту данного элемента.</summary>
        <value>Высота элемента, представленная в [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Значение по умолчанию — 0 (нуль).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство имеет значение, вычисленное на основе других входных значений высоты и системы макета. Значение задается самой системой макета в зависимости от фактического прохода отрисовки, а может поэтому немного отставать от установки значений свойств таких как <xref:System.Windows.FrameworkElement.Height%2A> , служат основой для изменения ввода.  
  
 Поскольку <xref:System.Windows.FrameworkElement.ActualHeight%2A> является вычисляемым значением, следует иметь в виду, может существовать несколько или инкрементные делает его в результате выполнения различных операций системы макета. Система макета может вычислять требуемое место измерения для дочерних элементов, ограничения родительского элемента и т. д.  
  
 Несмотря на то, что невозможно задать это свойство из [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], можно построить <xref:System.Windows.Trigger> после его значение в стиле.  
  
<a name="dependencyPropertyInfo_ActualHeight"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.ActualHeightProperty>|  
|Значение свойства метаданных `true`|Нет|  
  
   
  
## Examples  
 Следующий пример показывает различные свойства высоты.  
  
 [!code-csharp[HeightMinHeightMaxHeight#3](~/samples/snippets/csharp/VS_Snippets_Wpf/HeightMinHeightMaxHeight/CSharp/Window1.xaml.cs#3)]
 [!code-vb[HeightMinHeightMaxHeight#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HeightMinHeightMaxHeight/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualHeightProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.ActualHeight" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidth">
      <MemberSignature Language="C#" Value="public double ActualWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 ActualWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ActualWidth" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActualWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double ActualWidth { double get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает визуализированную ширину данного элемента.</summary>
        <value>Ширина элемента, представленная в [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Значение по умолчанию — 0 (нуль).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство имеет значение, вычисленное на основе других входных значений ширины и системы макета. Значение задается самой системой макета в зависимости от фактического прохода отрисовки, а может поэтому немного отставать от установки значений свойств таких как <xref:System.Windows.FrameworkElement.Width%2A> , служат основой для изменения ввода.  
  
 Поскольку <xref:System.Windows.FrameworkElement.ActualWidth%2A> является вычисляемым значением, следует иметь в виду, может существовать несколько или инкрементные делает его в результате выполнения различных операций системы макета. Система макета может вычислять требуемое место измерения для дочерних элементов, ограничения родительского элемента и т. д.  
  
 Несмотря на то, что невозможно задать это свойство из [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], можно построить <xref:System.Windows.Trigger> после его значение в стиле.  
  
<a name="dependencyPropertyInfo_ActualWidth"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.ActualWidthProperty>|  
|Значение свойства метаданных `true`|Нет|  
  
   
  
## Examples  
 Следующий пример показывает различные свойства ширины.  
  
 [!code-csharp[WidthMinWidthMaxWidth#3](~/samples/snippets/csharp/VS_Snippets_Wpf/WidthMinWidthMaxWidth/CSharp/Window1.xaml.cs#3)]
 [!code-vb[WidthMinWidthMaxWidth#3](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WidthMinWidthMaxWidth/VisualBasic/Window1.xaml.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ActualWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ActualWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ActualWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ActualWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ActualWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ActualWidthProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.ActualWidth" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void AddLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void AddLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub AddLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void AddLogicalChild(System::Object ^ child);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Добавляемый дочерний элемент.</param>
        <summary>Добавляет указанный объект в логическое дерево данного элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для реализации коллекции объектов, представляющих логические дочерние элементы данного элемента. Обслуживание коллекции для коллекции дочерних элементов может производиться в методы получения свойств или методов задания, обработчик событий Changed, конструкторов, или внутри самих типов коллекций класса.  
  
 Для разработчиков элементов управления обработка логического дерева на этом уровне не рекомендуется, если только ни одна из моделей содержимого для доступных базовых классов элементов управления не подходит для вашего сценария управления. Рассмотрите возможность создания подкласса на уровне <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>, и <xref:System.Windows.Controls.HeaderedItemsControl>. Эти классы обеспечивают модель содержимого с определенной применения дочерних элементов в логическом дереве через выделенное [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)], а также поддержку для других функций, как правило, желательно в [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] управления, например стилей с помощью шаблонов. Дополнительные сведения об использовании <xref:System.Windows.FrameworkElement.LogicalChildren%2A> и <xref:System.Windows.FrameworkElement.AddLogicalChild%2A>, в разделе [деревьев в WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 <xref:System.Windows.FrameworkElement.AddLogicalChild%2A> может привести к исключению, если вызывается в момент, когда выполняется итерация логического дерева с помощью другого процесса.  
  
   
  
## Examples  
 В следующем примере реализуется `Child` свойство в пользовательском <xref:System.Windows.FrameworkElement> , который выполняет собственную реализацию визуального уровня. Метод задания свойства разработан, чтобы при изменении значения старое значение удаляется из логического дерева, а также коллекцию визуальных элементов данного класса. Значение свойства кэшируется и затем добавляется новое значение для логического дерева и коллекция пользовательских визуальных элементов.  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ApplyTemplate">
      <MemberSignature Language="C#" Value="public bool ApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyTemplate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ApplyTemplate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При необходимости строит визуальное дерево текущего шаблона и возвращает значение, указывающее, было ли это визуальное дерево перестроено в результате этого вызова.</summary>
        <returns>
          <see langword="true" />, если в дерево были добавлены визуальные элементы; в противном случае возвращает <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Приложения могут вызывать этот метод, чтобы гарантировать, что элемент визуального дерева завершения. Такая гарантия может быть необходимо, если код будет проверять дочерние элементы в дереве. При обычной логике элементов внутри приложения, вызывающие <xref:System.Windows.FrameworkElement.ApplyTemplate%2A> нет необходимости, так как шаблоны будут применяться к элементам в соответствующий момент их времени существования автоматически.  
  
 <xref:System.Windows.FrameworkElement.ApplyTemplate%2A> вызывается для всех мер передать системой макета уровня платформы WPF.  
  
 <xref:System.Windows.FrameworkElement> производные классы могут использовать <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> обработчик класса уведомляемых случаев, когда этот метод был вызван явным образом или системой макета. <xref:System.Windows.FrameworkElement.OnApplyTemplate%2A> вызывается после шаблона полностью создается и прикрепляется к логического дерева.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ControlTemplate" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeCore">
      <MemberSignature Language="C#" Value="protected override sealed void ArrangeCore (System.Windows.Rect finalRect);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ArrangeCore(valuetype System.Windows.Rect finalRect) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Sub ArrangeCore (finalRect As Rect)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ArrangeCore(System::Windows::Rect finalRect);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalRect" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="finalRect">Итоговая область в родительском элементе, которую этот элемент должен использовать для размещения себя и своих дочерних элементов.</param>
        <summary>Реализует метод <see cref="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" /> (определенный как виртуальный в классе <see cref="T:System.Windows.UIElement" />) и запечатывает реализацию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является запечатанным. Чтобы переопределить логику в ваш пользовательский элемент специально для компоновки макета элемента вашей <xref:System.Windows.FrameworkElement> производный класс должен переопределять <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size ArrangeOverride (System.Windows.Size finalSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size finalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function ArrangeOverride (finalSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size ArrangeOverride(System::Windows::Size finalSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="finalSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="finalSize">Итоговая область в родительском элементе, которую этот элемент должен использовать для размещения себя и своих дочерних элементов.</param>
        <summary>При переопределении в производном классе размещает дочерние элементы и определяет размер для класса, производного от <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <returns>Фактический используемый размер.</returns>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Разработчики элементов управления, которые хотят настроить проход компоновки при обработке следует переопределить этот метод. Шаблон реализации должен вызывать <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> на каждом видимым дочернего элемента и передайте конечное желаемый размер для каждого дочернего элемента, как <paramref name="finalRect" /> параметр. Родительские элементы должны вызывать <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> на каждый дочерний элемент, в противном случае дочерние элементы не будут отображаться.  
  
 Во многих производных классах реализации этого метода. Показательным из них включают: <see cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />, <see cref="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" /> и <see cref="M:System.Windows.Controls.Control.ArrangeOverride(System.Windows.Size)" />.</para>
        </block>
        <altmember cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" />
      </Docs>
    </Member>
    <Member MemberName="BeginInit">
      <MemberSignature Language="C#" Value="public virtual void BeginInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub BeginInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Запускает процесс инициализации данного элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно вызывать для отдельных элементов, если они выравниваются способами, которые еще не предоставлять или подключиться к любой элемент дерева элемента. Например, вы могли создать новый <xref:System.Windows.FrameworkElement>, но не еще подключено его любого логического дерева. Или логического дерева, в котором элемент является дочерним элементом в ней не подключен к окну или страницу приложения.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Реализуйте этот метод, чтобы обеспечить специальную обработку, которая будет выполняться перед инициализацией элемента в процессе его загрузки.  
  
 Реализация должна вызывать базовую реализацию, поскольку реализация base (по умолчанию) устанавливает внутренние флаги для отслеживания инициализации. С помощью этого метода в качестве ловушки в собственных закрытых процедурах инициализации класса, не включены конструкторами является одной из возможных реализаций.  
  
 Базовая реализация будет вызывать исключение, если <see cref="M:System.Windows.FrameworkElement.BeginInit" /> вызывается более одного раза в том же элементе до <see cref="M:System.Windows.FrameworkElement.EndInit" /> вызова.</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.EndInit" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginStoryboard">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Начинает последовательность действий, содержащихся в предоставленной раскадровке.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
      </Parameters>
      <Docs>
        <param name="storyboard">Раскадровка, которая будет начата.</param>
        <summary>Начинает последовательность действий, содержащихся в предоставленной раскадровке.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Наиболее типичные сценарии анимации не используйте этот метод. Как правило, создаются <xref:System.Windows.Media.Animation.Storyboard> или <xref:System.Windows.Media.Animation.BeginStoryboard> элемент в разметке, а затем поместить их в качестве <xref:System.Windows.EventTrigger> содержимого элемента. При срабатывании триггера события запускается анимация. Большинство аспектов управления <xref:System.Windows.Media.Animation.Storyboard> можно работать посредством свойств, предоставляемых в разметке.  
  
 Для подписей, которые не используют `isControllable`, параметра, или при указании этого параметра `false`, связанные с анимацией часы шкалы времени удаляются сразу анимации достигнет периода «Заливка». Поэтому анимацию нельзя перезапустить после однократного запуска. Управление анимацией также требует, чтобы раскадровку [директива x: Name](~/docs/framework/xaml-services/x-name-directive.md) или доступ к ней по ссылке в коде.  
  
   
  
## Examples  
 В следующем примере извлекается <xref:System.Windows.Media.Animation.Storyboard> из ресурсов, а затем запускается, <xref:System.Windows.Media.Animation.Storyboard> при внутреннее событие обрабатывается классом.  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="storyboard">Раскадровка, которая будет начата.</param>
        <param name="handoffBehavior">Значение перечисления, описывающего поведение в случае, если описанное в раскадровке свойство уже анимировано.</param>
        <summary>Начинает последовательность действий, содержащихся в предоставленной раскадровке, с параметрами, указывающими на реакцию в случае уже анимированного свойства.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Наиболее типичные сценарии анимации не используйте этот метод. Как правило, создаются <xref:System.Windows.Media.Animation.Storyboard> или <xref:System.Windows.Media.Animation.BeginStoryboard> элемент в разметке, а затем поместить их в качестве <xref:System.Windows.EventTrigger> содержимого элемента. При срабатывании триггера события запускается анимация. Большинство аспектов управления <xref:System.Windows.Media.Animation.Storyboard> можно работать посредством свойств, предоставляемых в разметке.  
  
 Для подписей, которые не используют `isControllable`, параметра, или при указании этого параметра `false`, связанные с анимацией часы шкалы времени удаляются сразу анимации достигнет периода «Заливка». Поэтому анимацию нельзя перезапустить после однократного запуска. Управление анимацией также требует, чтобы раскадровку [директива x: Name](~/docs/framework/xaml-services/x-name-directive.md) или доступ к ней по ссылке в коде.  
  
 Поведение перемещения может быть указан как атрибут <xref:System.Windows.Media.Animation.BeginStoryboard>.  
  
## <a name="using-the-compose-handoffbehavior"></a>Использование составлять руководство.  
 При применении <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, или <xref:System.Windows.Media.Animation.AnimationClock> к свойству с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, любые <xref:System.Windows.Media.Animation.Clock> ранее связанную с ним объекты по-прежнему потребление системных ресурсов; в случае система времени не удаляет эти часы автоматически.  
  
 Чтобы избежать проблем с производительностью при применении большое число часов с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, необходимо удалить составляющую часами анимированное свойство после их завершения. Существует несколько способов удаления часов:  
  
-   Чтобы удалить все часы из свойства, используйте <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> или <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> метод анимированного объекта. Укажите в качестве первого параметра, анимируемого свойства и `null` вторым. При этом удаляются все часы анимации из свойства.  
  
-   Для удаления определенных <xref:System.Windows.Media.Animation.AnimationClock> из списка часов используйте <xref:System.Windows.Media.Animation.Clock.Controller%2A> свойство <xref:System.Windows.Media.Animation.AnimationClock> для получения <xref:System.Windows.Media.Animation.ClockController>, затем вызовите <xref:System.Windows.Media.Animation.ClockController.Remove%2A> метод <xref:System.Windows.Media.Animation.ClockController>. Обычно это делается <xref:System.Windows.Media.Animation.Clock.Completed> обработчика событий для часов. Обратите внимание, что только корневые часы могут управляться <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> свойство дочерних часов возвращает `null`. Обратите внимание, что <xref:System.Windows.Media.Animation.Clock.Completed> событие не происходит, если эффективная продолжительность часов является бесконечностью.  В этом случае пользователь должен определить, когда вызывать <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 В основном это проблема для анимации объектов, имеющих длинное время жизни.  При обнаружении объектов сбора мусора, его часы также будут отключены и собраны как мусор.  
  
 Дополнительные сведения об объектах часов см. в разделе [анимации и общие сведения о синхронизации системы](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 В следующем примере извлекается <xref:System.Windows.Media.Animation.Storyboard> из ресурсов, а затем запускается, <xref:System.Windows.Media.Animation.Storyboard> при внутреннее событие обрабатывается классом.  
  
 [!code-csharp[CubeAnimation#FEBeginStoryboard](~/samples/snippets/csharp/VS_Snippets_Wpf/CubeAnimation/CSharp/Page1.xaml.cs#febeginstoryboard)]
 [!code-vb[CubeAnimation#FEBeginStoryboard](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CubeAnimation/visualbasic/page1.xaml.vb#febeginstoryboard)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginStoryboard">
      <MemberSignature Language="C#" Value="public void BeginStoryboard (System.Windows.Media.Animation.Storyboard storyboard, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BeginStoryboard(class System.Windows.Media.Animation.Storyboard storyboard, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BeginStoryboard(System::Windows::Media::Animation::Storyboard ^ storyboard, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storyboard" Type="System.Windows.Media.Animation.Storyboard" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="storyboard">Раскадровка, которая будет начата.</param>
        <param name="handoffBehavior">Значение перечисления, описывающего поведение в случае, если описанное в раскадровке свойство уже анимировано.</param>
        <param name="isControllable">Объявляет, является ли анимация управляемой после запуска (можно ли ее приостановить).</param>
        <summary>Начинает последовательность действий, содержащихся в предоставленной раскадровке, с указанным состоянием элемента управления анимацией после ее запуска.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Наиболее типичные сценарии анимации не используйте этот метод. Как правило, создаются <xref:System.Windows.Media.Animation.Storyboard> или <xref:System.Windows.Media.Animation.BeginStoryboard> элемент в разметке, а затем поместить их в качестве <xref:System.Windows.EventTrigger> содержимого элемента. При срабатывании триггера события запускается анимация. Большинство аспектов управления <xref:System.Windows.Media.Animation.Storyboard> можно работать посредством свойств, предоставляемых в разметке.  
  
 Для подписей, которые не используют `isControllable`, параметра, или при указании этого параметра `false`, связанные с анимацией часы шкалы времени удаляются сразу анимации достигнет периода «Заливка». Поэтому анимацию нельзя перезапустить после однократного запуска. Управление анимацией также требует, чтобы раскадровку [директива x: Name](~/docs/framework/xaml-services/x-name-directive.md) или доступ к ней по ссылке в коде.  
  
 Поведение перемещения может быть указан как атрибут <xref:System.Windows.Media.Animation.BeginStoryboard>.  
  
## <a name="using-the-compose-handoffbehavior"></a>Использование составлять руководство.  
 При применении <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, или <xref:System.Windows.Media.Animation.AnimationClock> к свойству с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, любые <xref:System.Windows.Media.Animation.Clock> ранее связанную с ним объекты по-прежнему потребление системных ресурсов; в случае система времени не удаляет эти часы автоматически.  
  
 Чтобы избежать проблем с производительностью при применении большое число часов с помощью <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, необходимо удалить составляющую часами анимированное свойство после их завершения. Существует несколько способов удаления часов:  
  
-   Чтобы удалить все часы из свойства, используйте <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> или <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> метод анимированного объекта. Укажите в качестве первого параметра, анимируемого свойства и `null` вторым. При этом удаляются все часы анимации из свойства.  
  
-   Для удаления определенных <xref:System.Windows.Media.Animation.AnimationClock> из списка часов используйте <xref:System.Windows.Media.Animation.Clock.Controller%2A> свойство <xref:System.Windows.Media.Animation.AnimationClock> для получения <xref:System.Windows.Media.Animation.ClockController>, затем вызовите <xref:System.Windows.Media.Animation.ClockController.Remove%2A> метод <xref:System.Windows.Media.Animation.ClockController>. Обычно это делается <xref:System.Windows.Media.Animation.Clock.Completed> обработчика событий для часов. Обратите внимание, что только корневые часы могут управляться <xref:System.Windows.Media.Animation.ClockController>; <xref:System.Windows.Media.Animation.Clock.Controller%2A> свойство дочерних часов возвращает `null`. Обратите внимание, что <xref:System.Windows.Media.Animation.Clock.Completed> событие не происходит, если эффективная продолжительность часов является бесконечностью.  В этом случае пользователь должен определить, когда вызывать <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 В основном это проблема для анимации объектов, имеющих длинное время жизни.  При обнаружении объектов сбора мусора, его часы также будут отключены и собраны как мусор.  
  
 Дополнительные сведения об объектах часов см. в разделе [анимации и общие сведения о синхронизации системы](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroup">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingGroup BindingGroup { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Data.BindingGroup BindingGroup" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.BindingGroup" />
      <MemberSignature Language="VB.NET" Value="Public Property BindingGroup As BindingGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::BindingGroup ^ BindingGroup { System::Windows::Data::BindingGroup ^ get(); void set(System::Windows::Data::BindingGroup ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingGroup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает группу <see cref="T:System.Windows.Data.BindingGroup" />,  которая используется для элемента.</summary>
        <value>Группа <see cref="T:System.Windows.Data.BindingGroup" />, используемая для элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Windows.Data.BindingGroup> можно использовать для проверки значений нескольких свойств объекта. Предположим, что приложение предлагает пользователю ввести адрес и заполняет объект типа `Address`, который имеет свойства `Street`, `City`, `ZipCode`, и `Country`, со значениями, пользователь предоставлен. Приложение имеет панель, которая содержит четыре <xref:System.Windows.Controls.TextBox> элементов управления, привязанных к одному из свойств объекта. Можно использовать <xref:System.Windows.Controls.ValidationRule> в <xref:System.Windows.Data.BindingGroup> для проверки `Address` объекта. Например <xref:System.Windows.Controls.ValidationRule> можно обеспечить допустимость ZIP-код страны адреса.  
  
 Дочерние элементы наследуют <xref:System.Windows.Data.BindingGroup> от своих родительских элементов, как и в случае любого другого наследуемые свойства.  
  
<a name="dependencyPropertyInfo_BindingGroup"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.BindingGroupProperty>|  
|Значение свойства метаданных **true**|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 Следующие примеры являются частью приложения, которое проверяет, ли пользователь задать свойства одинаковые значения для двух объектов. В первом примере создается два <xref:System.Windows.Controls.TextBox> элементов управления, привязанных к источнику данных. <xref:System.Windows.Controls.StackPanel> Имеет <xref:System.Windows.Data.BindingGroup> , содержащий <xref:System.Windows.Controls.ValidationRule> , проверяет, что две строки равны.  
  
 [!code-xaml[BindingGroupSnippets#BindingGroupComplete](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml#bindinggroupcomplete)]  
  
 В следующем примере показан <xref:System.Windows.Controls.ValidationRule> , в предыдущем примере.  В <xref:System.Windows.Controls.ValidationRule.Validate%2A> переопределяющий метод в примере показано получение каждого исходного объекта, из <xref:System.Windows.Data.BindingGroup> и проверяет, равны ли свойства объектов.  
  
 [!code-csharp[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#bindinggroupnamevalidationrule)]
 [!code-vb[BindingGroupSnippets#BindingGroupNameValidationRule](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#bindinggroupnamevalidationrule)]  
  
 Для вызова <xref:System.Windows.Controls.ValidationRule>, вызовите <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> метод.  В следующем примере вызывается <xref:System.Windows.Data.BindingGroup.UpdateSources%2A> при возникновении события щелчка кнопки.  
  
 [!code-csharp[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/csharp/VS_Snippets_Wpf/BindingGroupSnippets/CSharp/Window3.xaml.cs#updatesourcesclick)]
 [!code-vb[BindingGroupSnippets#UpdateSourcesClick](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BindingGroupSnippets/visualbasic/window3.xaml.vb#updatesourcesclick)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindingGroupProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty BindingGroupProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty BindingGroupProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.BindingGroupProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly BindingGroupProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ BindingGroupProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.BindingGroup" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BringIntoView">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Пытается отобразить данный элемент вместе с содержащимися в нем прокручиваемыми областями.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Пытается отобразить данный элемент вместе с содержащимися в нем прокручиваемыми областями.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Путем вызова данного метода, вызывают <xref:System.Windows.FrameworkElement.RequestBringIntoView> событие, которое исходит от текущего элемента. Это событие возникает, чтобы оно могло быть обработано <xref:System.Windows.Controls.ScrollViewer>, или класс производного или аналогичную. Ожидаемым поведением является событие обрабатывается родительским элементом, помечено как обработанное в данных события, и источник события заносятся в представлении через логику, встроенную в <xref:System.Windows.Controls.ScrollViewer> элемента управления. Ни <xref:System.Windows.FrameworkElement.RequestBringIntoView> событий ни <xref:System.Windows.FrameworkElement.BringIntoView%2A> метод передачи все сведения об успешном или неуспешном, отличный от того, обычно событие является помечен обработано на успех. Причинами сбоя могут включать параметры элемента, например <xref:System.Windows.UIElement.Visibility%2A> выполняется какое-либо значение, отличное от <xref:System.Windows.Visibility.Visible>.  
  
 Если вы используете подпись, которая не соответствует `targetRectangle`, затем размер всего элемента (его <xref:System.Windows.UIElement.RenderSize%2A>) будет виден.  
  
 Путем вызова данного метода, потенциально будет вызываться <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> на все родительские прокручиваемую область, которая содержит элемент. Если этот элемент не содержится в прокручиваемой области <xref:System.Windows.FrameworkElement.RequestBringIntoView> событие по-прежнему, но будет недоступен, так как отсутствуют прослушиватели событий.  
  
   
  
## Examples  
 В следующем примере реализуется обработчик для события навигации в приложении, каждый раз, когда отвечает [!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)] , куда выполняется переход включает фрагмент. Фрагмент именуется в [!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)] следующие решетки (#), и реализованное поведение заставляет элемент, который прокручивается в представлении в рамках области. <xref:System.Windows.FrameworkElement.BringIntoView%2A> и <xref:System.Windows.FrameworkElement.RequestBringIntoView> запроса, поведение прокрутки в примере.  
  
 [!code-csharp[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/csharp/VS_Snippets_Wpf/FragmentNavigationSample/CSharp/MainWindow.xaml.cs#febringintoview)]
 [!code-vb[FragmentNavigationSample#FEBringIntoView](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FragmentNavigationSample/VisualBasic/MainWindow.xaml.vb#febringintoview)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="BringIntoView">
      <MemberSignature Language="C#" Value="public void BringIntoView (System.Windows.Rect targetRectangle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void BringIntoView(valuetype System.Windows.Rect targetRectangle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BringIntoView (targetRectangle As Rect)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void BringIntoView(System::Windows::Rect targetRectangle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetRectangle" Type="System.Windows.Rect" />
      </Parameters>
      <Docs>
        <param name="targetRectangle">Указанный размер элемента, который также следует отобразить.</param>
        <summary>Пытается отобразить указанный размер области данного элемента вместе с содержащимися в нем прокручиваемыми областями.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Путем вызова данного метода, вызывают <xref:System.Windows.FrameworkElement.RequestBringIntoView> событие, которое исходит от текущего элемента. Это событие возникает, чтобы оно могло быть обработано <xref:System.Windows.Controls.ScrollViewer>, или класс производного или аналогичную. Ожидаемым поведением является событие обрабатывается родительским элементом, помечено как обработанное в данных события, и источник события заносятся в представлении через логику, встроенную в <xref:System.Windows.Controls.ScrollViewer> элемента управления. Ни <xref:System.Windows.FrameworkElement.RequestBringIntoView> событий ни <xref:System.Windows.FrameworkElement.BringIntoView%2A> метод передачи все сведения об успешном или неуспешном, отличный от того, обычно событие является помечен обработано на успех. Причинами сбоя могут включать параметры элемента, например <xref:System.Windows.UIElement.Visibility%2A> выполняется какое-либо значение, отличное от <xref:System.Windows.Visibility.Visible>.  
  
 Если вы используете подпись, которая не соответствует `targetRectangle`, затем размер всего элемента (его <xref:System.Windows.UIElement.RenderSize%2A>) будет виден.  
  
 Путем вызова данного метода, потенциально будет вызываться <xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A> на все родительские прокручиваемую область, которая содержит элемент. Если этот элемент не содержится в прокручиваемой области <xref:System.Windows.FrameworkElement.RequestBringIntoView> событие по-прежнему, но будет недоступен, так как отсутствуют прослушиватели событий.  
  
   
  
## Examples  
 В следующем примере имеется большой рисунок в ограниченной области прокрутки. На кнопке на странице есть обработчик, который прокрутку до определенной области большого изображения.  
  
 [!code-xaml[BaseElementsSmorgasbord#BringIntoViewRectMarkup](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml#bringintoviewrectmarkup)]  
  
 [!code-csharp[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#bringintoviewrectcode)]
 [!code-vb[BaseElementsSmorgasbord#BringIntoViewRectCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#bringintoviewrectcode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.FlowDocumentScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenu">
      <MemberSignature Language="C#" Value="public System.Windows.Controls.ContextMenu ContextMenu { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Controls.ContextMenu ContextMenu" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ContextMenu" />
      <MemberSignature Language="VB.NET" Value="Public Property ContextMenu As ContextMenu" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Controls::ContextMenu ^ ContextMenu { System::Windows::Controls::ContextMenu ^ get(); void set(System::Windows::Controls::ContextMenu ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenu</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает элемент контекстного меню, который должен отображаться каждый раз при вызове контекстного меню через [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] из этого элемента.</summary>
        <value>Контекстное меню, назначенное этому элементу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Controls.ContextMenu> сам по себе является <xref:System.Windows.FrameworkElement> производного класса, а также технически возможно для <xref:System.Windows.Controls.ContextMenu> сам иметь <xref:System.Windows.FrameworkElement.ContextMenu%2A> свойство. Тем не менее это создает путаницу качества меню контекст для пользователя, и это не рекомендуется.  
  
<a name="dependencyPropertyInfo_ContextMenu"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.ContextMenuProperty>|  
|Значение свойства метаданных `true`|Нет|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuClosing As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuClosing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит непосредственно перед закрытием какого-либо контекстного меню в элементе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для подавления закрытия контекстных меню обработчики события следует пометить как обработанное.  
  
 Чтобы использовать это событие как <xref:System.Windows.EventTrigger> в стиле, необходимо сослаться на определение базовой службы события:  
  
 [!code-xaml[CorePseudocode#FEContextMenuClosing](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuclosing)]  
  
 (Такое использование является обязательным, поскольку реализация событий в <xref:System.Windows.FrameworkElement> , предоставляет базовое событие службы не сопоставляют <xref:System.Windows.FrameworkElement.ContextMenuClosing> идентификатор таким образом, чтобы ее можно использовать в качестве триггера).  
  
 <xref:System.Windows.Controls.ContextMenu> сам по себе является <xref:System.Windows.FrameworkElement> производного класса, но <xref:System.Windows.FrameworkElement.ContextMenuClosing> события не вызываются, контекстное меню напрямую. Вместо этого событие инициируется элементом, который «владеет» в контекстном меню, как свойство и только тогда, когда пользователь пытается закрыть контекстное меню в пользовательском Интерфейсе. Однако существует возможность <xref:System.Windows.Controls.ContextMenu> сам иметь <xref:System.Windows.FrameworkElement.ContextMenu%2A> свойство (вложенные контекстное меню). В этом случае <xref:System.Windows.Controls.ContextMenu> действительно является владельцем вложенного <xref:System.Windows.Controls.ContextMenu> и может вызвать события с источником события выполняется вложенных контекстного меню.  
  
 <xref:System.Windows.Controls.ContextMenu> Самого класса также имеет такое же событие (<xref:System.Windows.Controls.ContextMenu.Closed>), но <xref:System.Windows.Controls.ContextMenu.Closed> событий не предоставляет возможность отмены действий пользователя.  
  
<a name="routedEventInfo_ContextMenuClosing"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.ContextMenuClosingEvent>|  
|Стратегия маршрутизации|Вверх|  
|делегат|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   Переопределить <xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A> реализации класса обработчик данного события в производных классах.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuClosingEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует направленное событие <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Идентификаторы перенаправленных событий создаются при их регистрации. Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события. Эти идентификаторы можно использовать для добавления обработчиков классов.  
  
 Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ContextMenuEventHandler ContextMenuOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ContextMenuOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContextMenuOpening As ContextMenuEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ContextMenuEventHandler ^ ContextMenuOpening;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ContextMenuEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при открытии какого-либо контекстного меню в элементе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для открытия контекстных меню вручную обработчики событий должны помечать соответствующее событие как обработанное. В противном случае — значение существующего <xref:System.Windows.FrameworkElement.ContextMenu%2A> свойство будет использоваться для автоматического открытия контекстного меню. Маркировка обрабатываемого события эффективно отменит действие по умолчанию и может быть возможность сбросить значение <xref:System.Windows.FrameworkElement.ContextMenu%2A> свойства и откройте новый <xref:System.Windows.Controls.ContextMenu>. Однако есть ошибки синхронизации, которые следует иметь в виду. Чтобы полностью заменить контекстного меню через <xref:System.Windows.FrameworkElement.ContextMenuOpening> обработчик, меню исходного контекста не должно быть null или пустым. Кроме того может потребоваться обработать событие и затем вручную открыть новое контекстное меню. Дополнительные сведения см. в разделе [как: руководство](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md).  
  
 Чтобы использовать это событие как <xref:System.Windows.EventTrigger> в стиле, необходимо сослаться на базовых вложенное событие:  
  
 [!code-xaml[CorePseudocode#FEContextMenuOpening](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/pseudocode.xaml#fecontextmenuopening)]  
  
 (Такое использование является обязательным, поскольку реализация событий в <xref:System.Windows.FrameworkElement> , предоставляет базовое событие службы не сопоставляют <xref:System.Windows.FrameworkElement.ContextMenuOpening> идентификатор таким образом, что его можно использовать в триггерах).  
  
 <xref:System.Windows.Controls.ContextMenu> сам по себе является <xref:System.Windows.FrameworkElement> производного класса, но это событие не будет вызываться из контекстного меню, открываемом в качестве источника. Событие инициируется элементом, который «владеет» в контекстном меню, как свойство и только тогда, когда пользователь пытается открыть контекстное меню в пользовательском Интерфейсе. Существует возможность <xref:System.Windows.Controls.ContextMenu> сам иметь <xref:System.Windows.FrameworkElement.ContextMenu%2A> свойство, но следует избегать этот сценарий (Дополнительные сведения см. в разделе <xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType>).  
  
 <xref:System.Windows.Controls.ContextMenu> Самого класса также имеет такое же событие (<xref:System.Windows.Controls.ContextMenu.Opened>), но <xref:System.Windows.Controls.ContextMenu.Opened> не предоставляет возможность отмены действий пользователя.  
  
<a name="routedEventInfo_ContextMenuOpening"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.ContextMenuOpeningEvent>|  
|Стратегия маршрутизации|Вверх|  
|делегат|<xref:System.Windows.Controls.ContextMenuEventHandler>|  
  
-   Переопределить <xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A> реализации класса обработчик данного события в производных классах.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ContextMenu" />
      </Docs>
    </Member>
    <Member MemberName="ContextMenuOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ContextMenuOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ContextMenuOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ContextMenuOpeningEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует направленное событие <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Идентификаторы перенаправленных событий создаются при их регистрации. Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события. Эти идентификаторы можно использовать для добавления обработчиков классов.  
  
 Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ContextMenuProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ContextMenuProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ContextMenuProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ContextMenuProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ContextMenuProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ContextMenuProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.ContextMenu" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Cursor">
      <MemberSignature Language="C#" Value="public System.Windows.Input.Cursor Cursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.Cursor Cursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Cursor" />
      <MemberSignature Language="VB.NET" Value="Public Property Cursor As Cursor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::Cursor ^ Cursor { System::Windows::Input::Cursor ^ get(); void set(System::Windows::Input::Cursor ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.Cursor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка курсора, который отображается при наведении указателя мыши на этот элемент.</summary>
        <value>Отображаемый курсор. Значение по умолчанию определяется как <see langword="null" /> для данного свойства зависимостей. Однако на практике значение по умолчанию во время выполнения зависит от множества факторов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение этого свойства в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] процессора основывается на преобразование типа для <xref:System.Windows.Input.Cursor> класса для вычисления строки. Предоставленная строка должно выражаться <xref:System.Windows.Input.CursorType> значение. Подробные сведения см. в разделе <xref:System.Windows.Input.Cursor>.  
  
 Ли курсор в соответствии с параметром этого свойства будет или не будет отображаться, когда указатель мыши находится над данным элементом зависит от значения <xref:System.Windows.FrameworkElement.ForceCursor%2A> свойство. Кроме того вопросы, связанные с событиями, как активное перетаскивание, захват мыши, режимы редактирования текста в элементы управления и т. д., также влияет на курсор с более высоким приоритетом, чем значение, указанное в данном свойстве.  
  
 Чтобы отменить поведение этого свойства к стандартному, задайте для него значение `null` еще раз.  
  
 `null` По умолчанию реально означает, что определение практического значения курсора здесь, откладывается и должны быть получены из другого источника. Если представления без программных значений из любого источника, курсор по умолчанию это визуально более [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] приложения будет стрелкой. Однако изменения временной курсора не настроены для <xref:System.Windows.FrameworkElement.Cursor%2A> значения элементов при наведении указателя. <xref:System.Windows.FrameworkElement.Cursor%2A> Свойство будет только отчет не значения null в случаях, где он фактически было задано, например через код или стиль. Каждый движения мыши над [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] приложение создает событие <xref:System.Windows.UIElement.QueryCursor> событий. Событие может передаваться и любой элемент на маршруте имеет возможность обработать событие и задать значение курсора с помощью аргументов этого события. Это механизм обеспечивает визуальное отображение курсора в большинстве случаев. Если <xref:System.Windows.UIElement.QueryCursor> обработчик возвращает результат курсора, а затем тот факт, что событие обработано и имеет измененное значение в аргументах имеет приоритет над значением <xref:System.Windows.FrameworkElement.Cursor%2A> свойство на любом уровне, если <xref:System.Windows.FrameworkElement.ForceCursor%2A> имеет значение.  
  
 Если не создается специальный курсор, вы обычно этому свойству присвоено значение статического свойства <xref:System.Windows.Input.Cursors> класса. Параметр <xref:System.Windows.FrameworkElement.Cursor%2A> в коде требуется один из следующих:  
  
-   Вызовите <xref:System.Windows.Input.Cursor> конструктора для получения <xref:System.Windows.Input.Cursor> экземпляра. Оба подписи <xref:System.Windows.Input.Cursor> использовать конструктор потоков или файлов в будущем, для которого создается <xref:System.Windows.Input.Cursor> объект для настраиваемого курсора.  
  
-   Используйте <xref:System.Windows.Input.CursorConverter> класса и его <xref:System.Windows.Input.CursorConverter.ConvertFrom%2A> метод для указания курсора по <xref:System.Windows.Input.CursorType>, или строку, которая может быть <xref:System.Windows.Input.CursorType>и приведите вернуться к <xref:System.Windows.Input.Cursor>.  
  
 Параметр <xref:System.Windows.Input.Cursor> пользовательское значение не включен в режиме частичного доверия. Дополнительные сведения о специальных курсорах см. в разделе [фокусе](~/docs/framework/wpf/advanced/input-overview.md).  
  
<a name="dependencyPropertyInfo_Cursor"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.CursorProperty>|  
|Значение свойства метаданных `true`|Нет|  
  
   
  
## Examples  
 Приведенный ниже показано, как намеренную установку графического изображения курсора.  
  
 [!code-csharp[cursors#ChangeCursorsSample](~/samples/snippets/csharp/VS_Snippets_Wpf/cursors/CSharp/Window1.xaml.cs#changecursorssample)]
 [!code-vb[cursors#ChangeCursorsSample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/cursors/VisualBasic/Window1.xaml.vb#changecursorssample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.UIElement.QueryCursor" />
        <altmember cref="P:System.Windows.FrameworkElement.ForceCursor" />
        <altmember cref="P:System.Windows.Input.Mouse.OverrideCursor" />
      </Docs>
    </Member>
    <Member MemberName="CursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty CursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty CursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.CursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly CursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ CursorProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.Cursor" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContext">
      <MemberSignature Language="C#" Value="public object DataContext { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DataContext" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DataContext" />
      <MemberSignature Language="VB.NET" Value="Public Property DataContext As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DataContext { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает контекст данных для элемента, участвующего в привязке данных.</summary>
        <value>Объект, используемый в качестве контекста данных.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 *Контекст данных* — концепция, которая позволяет элементам наследовать от своих родительских элементов об источнике данных, который используется для привязки, а также другие характеристики привязки, например путь информацию.  
  
 Контекст данных можно задать непосредственно в [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] объекта с привязками, вычисляемыми в свойства этого объекта. Кроме того, можно задать контекст данных <xref:System.Windows.Data.DataSourceProvider> объекта.  
  
 Это свойство зависимостей наследуется значений свойств. Если имеются дочерние элементы без другие значения для <xref:System.Windows.FrameworkElement.DataContext%2A> установленное с помощью локальных значений или стилей, задайте в системе свойств это значение должно быть <xref:System.Windows.FrameworkElement.DataContext%2A> значение ближайшего родительского элемента с назначенным данным значением.  
  
 Кроме того, можно использовать один из следующих свойств <xref:System.Windows.Data.Binding> класс, чтобы явно указать источник привязки: <xref:System.Windows.Data.Binding.ElementName%2A>, <xref:System.Windows.Data.Binding.Source%2A>, или <xref:System.Windows.Data.Binding.RelativeSource%2A>. Дополнительные сведения см. в разделе [как: Укажите источник привязки](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md).  
  
 В [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], <xref:System.Windows.FrameworkElement.DataContext%2A> наиболее обычно устанавливается как <xref:System.Windows.Data.Binding> объявления. Можно использовать синтаксис элемента свойства или синтаксис атрибутов. Синтаксис атрибутов показан в примере на этой странице. Код также можно использовать для задания <xref:System.Windows.FrameworkElement.DataContext%2A>.  
  
 <xref:System.Windows.FrameworkElement.DataContext%2A> может быть привязано, чтобы облегчить сценарии, где одного контекста может быть привязан к другому. Тем не менее если выполняется привязка к <xref:System.Windows.FrameworkElement.DataContext%2A>, следует соблюдать осторожность, чтобы не создавать привязки циклических ссылок (без привязки <xref:System.Windows.FrameworkElement.DataContext%2A> на себя, это можно сделать из-за особенностей наследования значения свойства <xref:System.Windows.FrameworkElement.DataContext%2A> свойство).  
  
<a name="xamlPropertyElementUsage_DataContext"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<object>  
  <object.DataContext>  
    <dataContextObject />  
  </object.DataContext>  
</object>  
```  
  
<a name="xamlAttributeUsage_DataContext"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object DataContext="bindingUsage"/>  
- or -  
<object DataContext="{resourceExtension contextResourceKey}"/>  
```  
  
<a name="xamlValues_DataContext"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *dataContextObject*  
 Непосредственно внедренный объект, который служит в качестве контекста данных для любых привязок внутри родительского элемента. Как правило, этот объект является <xref:System.Windows.Data.Binding> или другой <xref:System.Windows.Data.BindingBase> производного класса. Кроме того необработанные данные любого [!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)] предназначен для привязки могут быть помещены с фактические привязки определить позже, тип объекта.  
  
 *bindingUsage*  
 Использование привязки, результатом вычисления которого в соответствующий контекст данных. Дополнительные сведения см. в разделе [Привязка расширения разметки](~/docs/framework/wpf/advanced/binding-markup-extension.md).  
  
 *resourceExtension*  
 Одно из следующих: или. Данный подход используется при обращении к необработанным данным объектом, в ресурсах. В разделе [ресурсов XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *contextResourceKey*  
 Идентификатор ключа для запрашиваемого внутри объекта <xref:System.Windows.ResourceDictionary>.  
  
<a name="dependencyPropertyInfo_DataContext"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.DataContextProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
   
  
## Examples  
 В следующем примере показано, как действует контекст данных для привязки и приводятся сведения, определяющую конкретные значения связанных свойств.  
  
 [!code-xaml[MasterDetail#DataContextProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty)]  
[!code-xaml[MasterDetail#DataContextProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty2)]  
[!code-xaml[MasterDetail#DataContextProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/MasterDetail/CSharp/Page1.xaml#datacontextproperty3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DataContextChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DependencyPropertyChangedEventHandler DataContextChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DependencyPropertyChangedEventHandler DataContextChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.DataContextChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DataContextChanged As DependencyPropertyChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DependencyPropertyChangedEventHandler ^ DataContextChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyPropertyChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении контекста данных для элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объяснение контекстов данных и привязки данных см. в разделе [Общие сведения о привязке данных](~/docs/framework/wpf/data/data-binding-overview.md).  
  
> [!IMPORTANT]
>  Когда <xref:System.Windows.FrameworkElement.DataContext%2A> для изменения элемента потенциально затрагиваются все свойства с привязкой к данным для этого элемента. Это относится к любые элементы, которые являются дочерними элементами элемента текущего элемента в логическом дереве наследующим контекст данных, а также сам элемент. Такие существующие привязки необходимо интерпретировать повторно новый <xref:System.Windows.FrameworkElement.DataContext%2A> и повторного вычисления результатов привязки. Механизм привязки данных не является детерминированным о порядке эти повторные вычисления, относительно формирование <xref:System.Windows.FrameworkElement.DataContextChanged> событий. Повторные вычисления могут производиться перед событием, после события или в любом сочетании.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.DataContext" />
      </Docs>
    </Member>
    <Member MemberName="DataContextProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty DataContextProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty DataContextProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DataContextProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DataContextProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ DataContextProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.DataContext" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKey">
      <MemberSignature Language="C#" Value="protected internal object DefaultStyleKey { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultStyleKey" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.DefaultStyleKey" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property DefaultStyleKey As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Object ^ DefaultStyleKey { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает ключ, используемый для ссылки на стиль этого элемента управления, при использовании или определении тематических стилей.</summary>
        <value>Ключ стиля. Для правильной работы этого значения в ходе поиска стиля темы ожидается, что оно принадлежит к типу <see cref="T:System.Type" /> элемента управления, к которому применяется стиль.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство обычно не задается через какой-либо из его прямых методов доступа. Вместо этого каждый раз при создании нового переопределения метаданных определенного типа этого свойства зависимостей <xref:System.Windows.FrameworkElement> производного класса. При создании производного элемента управления, вызовите <xref:System.Windows.DependencyProperty.OverrideMetadata%2A> метода для <xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty> идентификатор в статическом конструкторе элемента управления производный класс (или эквивалентный класс инициализации).  
  
 Элемент управления обычно переопределяет значение по умолчанию этого свойства должен иметь свой собственный тип, но в некоторых случаях может также использовать базовый тип, для которого существует стиль в словарях темы. Это практически возможно только если шаблоны базового элемента управления полностью определяют визуальное представление производного элемента управления и любые дополнительные элементы, производные типы предоставлять не требуется дополнительных элементов в рамках шаблона элемента управления.  
  
 Элемент или элемент управления, намеренно не используемый тематических стилей, установите <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> свойства `true`.  
  
<a name="dependencyPropertyInfo_DefaultStyleKey"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 В следующем примере показано использование переопределения метаданных свойства зависимостей, рассматриваемые в примечания. Этот код определяет класс пользовательского элемента управления `NumericUpDown` предназначен для использования из сборки библиотеку выделенного элемента управления. Иллюстрированные статический конструктор ссылается на некоторые закрытые функции инициализации, регистрирует обработчик класса (другой распространенный сценарий создания подкласса элемента управления см. в разделе [как Handled и обработка класса](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)) и, наконец, переопределяет <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> метаданные свойства зависимостей на `NumericUpDown` класса. <xref:System.Windows.FrameworkElement.DefaultStyleKey%2A> всегда возвращает собственный тип как предполагаемый ключ, который является соглашением, системой стиля темы для поиска стиля для некоторых произвольных без стиля элемента управления. Полный пример также определяет стиль темы фактического элемента управления, на который ссылается этому ключу; в разделе [пользовательский элемент управления NumericUpDown с темой и пример Поддержка модели автоматизации пользовательского интерфейса](http://go.microsoft.com/fwlink/?LinkID=160025).  
  
 [!code-csharp[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/NumericUpDown.cs#staticctorofcustomclasscommontasks)]
 [!code-vb[CustomControlNumericUpDown#StaticCtorOfCustomClassCommonTasks](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/numericupdown.vb#staticctorofcustomclasscommontasks)]  
[!code-csharp[CustomControlNumericUpDown#Close](~/samples/snippets/csharp/VS_Snippets_Wpf/CustomControlNumericUpDown/CSharp/CustomControlLibrary/NumericUpDown.cs#close)]
[!code-vb[CustomControlNumericUpDown#Close](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CustomControlNumericUpDown/visualbasic/customcontrollibrary/numericupdown.vb#close)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
      </Docs>
    </Member>
    <Member MemberName="DefaultStyleKeyProperty">
      <MemberSignature Language="C#" Value="protected internal static readonly System.Windows.DependencyProperty DefaultStyleKeyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field familyorassembly static initonly class System.Windows.DependencyProperty DefaultStyleKeyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.DefaultStyleKeyProperty" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Shared ReadOnly DefaultStyleKeyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="protected public: static initonly System::Windows::DependencyProperty ^ DefaultStyleKeyProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.DefaultStyleKey" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndInit">
      <MemberSignature Language="C#" Value="public virtual void EndInit ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void EndInit() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.EndInit" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub EndInit ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void EndInit();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Указывает на завершение процесса инициализации элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Windows.FrameworkElement.BeginInit%2A> был вызван ранее, базовый вызывает реализацию <xref:System.Windows.FrameworkElement.Initialized> событий. В противном случае, если <xref:System.Windows.FrameworkElement.BeginInit%2A> не был вызван или не удалось определить, является ли <xref:System.Windows.FrameworkElement.BeginInit%2A> был вызван <xref:System.Windows.FrameworkElement.Initialized> не возникает и вместо этого создается исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          Метод <see cref="M:System.Windows.FrameworkElement.EndInit" /> был вызван без предварительного вызова метода <see cref="M:System.Windows.FrameworkElement.BeginInit" /> для элемента.</exception>
        <block subset="none" type="overrides">
          <para>Реализуйте этот метод, чтобы обеспечить специальную обработку, которая будет выполняться при инициализации элемента в процессе его загрузки.  
  
 Реализация должна вызывать базовую реализацию, поскольку реализация base (по умолчанию) устанавливает внутренние флаги для отслеживания инициализации.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="FindName">
      <MemberSignature Language="C#" Value="public object FindName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindName (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя запрошенного элемента.</param>
        <summary>Находит элемент по указанному имени идентификатора.</summary>
        <returns>Запрошенный элемент. Может иметь значение <see langword="null" />, если соответствующий элемент не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если элемент содержит дочерние элементы, эти дочерние элементы являются все выполняется рекурсивный поиск запрошенного именованного элемента.  
  
 <xref:System.Windows.FrameworkElement.FindName%2A> действует в пределах области видимости имен текущего элемента. Дополнительные сведения см. в разделе [области имен XAML WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="FindResource">
      <MemberSignature Language="C#" Value="public object FindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object FindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function FindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ FindResource(System::Object ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Ключевой идентификатор запрашиваемого ресурса.</param>
        <summary>Осуществляет поиск ресурса с указанным ключом и вызывает исключение, если запрошенный ресурс не найден.</summary>
        <returns>Запрошенный ресурс. Если ресурс с указанным ключом не найден, выдается исключение. В случае исключение может быть также возвращено значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Если этот метод вызывается для ключа, который не удается найти, создается исключение. Если вы не хотите обрабатывать исключения, возникающие в результате вызова <xref:System.Windows.FrameworkElement.FindResource%2A>, вызовите <xref:System.Windows.FrameworkElement.TryFindResource%2A> вместо него. <xref:System.Windows.FrameworkElement.TryFindResource%2A> Возвращает `null` когда не удается найти запрошенный ресурс и не вызывает исключение.  
  
 Если ресурс не найден в вызывающем элементе, в логическом дереве родительского элемента — выполняется дальнейший поиск, то приложения, а затем темы и наконец системных ресурсов. Этот метод поиска идентична как поиск в дереве, если запрошенного ресурса по ссылке на динамический ресурс в разметке. Дополнительные сведения о поиске ресурсов см. в разделе [ресурсов XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 Как правило, вы сразу же привести <xref:System.Windows.FrameworkElement.FindResource%2A> возвращаемое значение в тип свойства, можно задать значение возвращаемого ресурса.  
  
 Ключи ресурсов не обязательно являются строками. Например, стили для элементов управления на уровне тема представляют собой ключи произвольного <xref:System.Type> элемента управления и стили приложения или страницы для элементов управления обычно используется ключ соглашение. Дополнительные сведения см. в разделе [Стилизация и использование шаблонов](~/docs/framework/wpf/controls/styling-and-templating.md) или [ресурсов XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
   
  
## Examples  
 В следующем примере получает именованный ресурс и приводит его к соответствующему типу для заполнения свойства.  
  
 [!code-csharp[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertiesOvwSupport/CSharp/page3.xaml.cs#resourceproceduralget)]
 [!code-vb[PropertiesOvwSupport#ResourceProceduralGet](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertiesOvwSupport/visualbasic/page3.xaml.vb#resourceproceduralget)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Windows.ResourceReferenceKeyNotFoundException">
          <paramref name="resourceKey" /> не найден, и обработчик событий для события <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" /> не существует.  
  
 - или -  
  
 <paramref name="resourceKey" /> не найден, и свойство <see cref="P:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled" /> имеет значение <see langword="false" /> в событии <see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="resourceKey" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="FlowDirection">
      <MemberSignature Language="C#" Value="public System.Windows.FlowDirection FlowDirection { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.FlowDirection FlowDirection" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FlowDirection" />
      <MemberSignature Language="VB.NET" Value="Public Property FlowDirection As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::FlowDirection FlowDirection { System::Windows::FlowDirection get(); void set(System::Windows::FlowDirection value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает направление потока текста и других элементов [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] внутри любого родительского элемента, управляющего их структурой.</summary>
        <value>Направление потока текста и других элементов [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] внутри их родительского элемента, в виде значения перечисления. Значение по умолчанию — <see cref="F:System.Windows.FlowDirection.LeftToRight" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойство задает использование зависимостей <xref:System.Windows.FrameworkElement.FlowDirection%2A> для этого элемента. Из-за наследование значения свойства, задание <xref:System.Windows.FrameworkElement.FlowDirection%2A> на элемент потенциально можно задать <xref:System.Windows.FrameworkElement.FlowDirection%2A> на все дочерние элементы, которые не задал <xref:System.Windows.FrameworkElement.FlowDirection%2A> локально или менее других средств, таких как стили.  
  
 Это свойство не задано автоматически в рамках языка и региональных параметров сведений о приложении, так как элемент может содержать содержимое, которое не обязательно соблюдать общие направление содержится в сведения языка и региональных параметров. Дополнительные сведения о вопросах глобализации см. в разделе [Глобализация для WPF](~/docs/framework/wpf/advanced/globalization-for-wpf.md).  
  
 Это свойство не определил [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] доступа к свойству, поэтому он функционирует как свойство зависимостей. Тем не менее он также регистрируется как подключенные, поэтому он также может работать как вложенное свойство. Вложенная регистрация является главным образом, что поддерживается наследование значения свойства, но свойство также может использоваться как истинное вложенное свойство. Использование вложенного свойства применяется, только если вы хотите задать направление потока на объект имеет <xref:System.Windows.FrameworkElement> сам не является родительским элементом, выполняющий макета с ней, <xref:System.Windows.FrameworkElement>и еще не содержит более явно определенные `FlowDirection` свойство. (Некоторые потока документов классы, такие как <xref:System.Windows.Documents.Block> и <xref:System.Windows.Documents.Inline> определять свои собственные `FlowDirection`, и это свойство можно также задать направление потока. Значение свойства затем считывается конечного узла содержимого без необходимости использования вложенного свойства.)  
  
<a name="xamlAttributeUsage_FlowDirection"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
 \<*Объект* **FlowDirection**=»<xref:System.Windows.FlowDirection>«/ >  
  
<a name="xamlTextUsage_FlowDirection"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Это свойство можно также задать в классах, которые не являются <xref:System.Windows.FrameworkElement> производные классы, с помощью следующего [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] прикрепленное свойство:  
  
 `<` *Объект* `FrameworkElement.` **FlowDirection**=»<xref:System.Windows.FlowDirection>`"/>`  
  
<a name="dependencyPropertyInfo_FlowDirection"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.FlowDirectionProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>, <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A>, <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 Это свойство является свойством зависимостей и присоединенным свойством; см. заметки.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FlowDirectionProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FlowDirectionProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FlowDirectionProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FlowDirectionProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FlowDirectionProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FlowDirectionProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.FlowDirection" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyle">
      <MemberSignature Language="C#" Value="public System.Windows.Style FocusVisualStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style FocusVisualStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.FocusVisualStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property FocusVisualStyle As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ FocusVisualStyle { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает свойство, позволяющее настройку внешнего вида, эффектов или других характеристик стиля, применяемых к данному элементу, когда он получает фокус клавиатуры.</summary>
        <value>Требуемый стиль для применения при получении фокуса. Значение по умолчанию, объявленное в свойстве зависимостей, представляет собой пустой статический <see cref="T:System.Windows.Style" />. Тем не менее, действительным значением во время выполнения часто (но не всегда) является стиль, представленный поддержкой тем для элементов управления.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство влияет на внешний вид, но не сообщает о <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> в метаданных. Это так, как изменение внешнего вида управляется событиями и могут применяться не все время, поэтому не следует обычно сообщать любые сведения о visual или макета в метаданных.  
  
 По существу visual поведение фокуса, примененного к элементу управления, должно быть согласовано от элемента управления. Наиболее понятным способом применения согласованности является изменение стиля визуального отображения фокуса только при составлении целой темы. Задание этого свойства отдельных стилей элементов управления, а не как часть темы не предполагаемого использования этого свойства, так как это может привести к путанице при использовании фокуса клавиатуры. Если планируется поведение элемента управления, намеренно не согласовано в теме гораздо лучшим подходом является использование триггеров в стилях для отдельных свойств состояния ввода, такие как <xref:System.Windows.UIElement.IsFocused%2A> или <xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A>и таким образом, в результате которого не визуально мешать любой существующий стиль визуального отображения фокуса. Дополнительные сведения о необходимым <xref:System.Windows.FrameworkElement.FocusVisualStyle%2A> и альтернативное сосредоточиться свойств см. в разделе [стиля фокуса в элементах управления и стиля визуального отображения фокуса](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md).  
  
<a name="xamlAttributeUsage_FocusVisualStyle"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object FocusVisualStyle="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_FocusVisualStyle"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
<a name="xamlValues_FocusVisualStyle"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *resourceExtension*  
 Одно из следующих:, или. В разделе [ресурсов XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 Ключ, идентифицирующий запрашиваемый стиль. Ключ ссылается на существующий ресурс в <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Синтаксис элемента свойства технически возможно, но не рекомендуется. В разделе [встроенные стили и шаблоны](~/docs/framework/wpf/advanced/inline-styles-and-templates.md). Ссылка привязки с помощью или <xref:System.Windows.Data.Binding> также является, возможно, но встречается редко.  
  
<a name="dependencyPropertyInfo_FocusVisualStyle"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.FocusVisualStyleProperty>|  
|Значение свойства метаданных `true`|Нет|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      </Docs>
    </Member>
    <Member MemberName="FocusVisualStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty FocusVisualStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty FocusVisualStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.FocusVisualStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FocusVisualStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ FocusVisualStyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.FocusVisualStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ForceCursor">
      <MemberSignature Language="C#" Value="public bool ForceCursor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ForceCursor" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ForceCursor" />
      <MemberSignature Language="VB.NET" Value="Public Property ForceCursor As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ForceCursor { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, следует ли данному <see cref="T:System.Windows.FrameworkElement" /> заставлять [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)] визуализировать курсор, как объявлено свойством <see cref="P:System.Windows.FrameworkElement.Cursor" />.</summary>
        <value>
          <see langword="true" />, если для презентации курсора, расположенного над данным элементом, принудительно используются текущие настройки <see cref="P:System.Windows.FrameworkElement.Cursor" /> для курсора (а также для всех дочерних элементов); в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение этого свойства `true` переопределяют настройки курсора, установленные дочерними элементами. Поэтому в общем приложения это [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] может сбить с толку для пользователей, особенно в том случае, если дочерние элементы пытаются задавать курсоры. Параметр <xref:System.Windows.FrameworkElement.ForceCursor%2A> больше подходит в сценариях управления подклассы или композиции.  
  
<a name="dependencyPropertyInfo_ForceCursor"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.ForceCursorProperty>|  
|Значение свойства метаданных `true`|Нет|  
  
   
  
## Examples  
 Следующий пример принудительно значение курсора.  
  
 [!code-xaml[ForceCursor#ForceCursor](~/samples/snippets/csharp/VS_Snippets_Wpf/ForceCursor/CS/default.xaml#forcecursor)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.Cursor" />
      </Docs>
    </Member>
    <Member MemberName="ForceCursorProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ForceCursorProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ForceCursorProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ForceCursorProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ForceCursorProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ForceCursorProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.ForceCursor" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBindingExpression">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression GetBindingExpression (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression GetBindingExpression(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetBindingExpression (dp As DependencyProperty) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ GetBindingExpression(System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Целевое <see cref="T:System.Windows.DependencyProperty" />, из которого получается привязка.</param>
        <summary>Возвращает выражение <see cref="T:System.Windows.Data.BindingExpression" />, представляющее привязку для указанного свойства.</summary>
        <returns>Выражение <see cref="T:System.Windows.Data.BindingExpression" />, если целевое свойство содержит активную привязку; в противном случае возвращает <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Проверять возвращаемое значение для `null` — это метод, который можно использовать для определения, является ли свойство имеет активную привязку.  
  
 Этот метод является лишь удобную оболочку вокруг <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType> метод. <xref:System.Windows.FrameworkElement.GetBindingExpression%2A> передает текущий экземпляр и `dp` параметр <xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Data.BindingOperations" />
      </Docs>
    </Member>
    <Member MemberName="GetFlowDirection">
      <MemberSignature Language="C#" Value="public static System.Windows.FlowDirection GetFlowDirection (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Windows.FlowDirection GetFlowDirection(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFlowDirection (element As DependencyObject) As FlowDirection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::FlowDirection GetFlowDirection(System::Windows::DependencyObject ^ element);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.FlowDirection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Элемент, для которого возвращается свойство <see cref="P:System.Windows.FrameworkElement.FlowDirection" />.</param>
        <summary>Получает значение присоединенного свойства <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> указанного элемента <see cref="T:System.Windows.DependencyObject" />.</summary>
        <returns>Запрошенное направление потока, как значение перечисления.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Основное назначение этого метода является поддержка синтаксис присоединенного свойства для <xref:System.Windows.FrameworkElement.FlowDirection%2A> свойство, таким образом позволяя дочерних элементов указанного <xref:System.Windows.FrameworkElement> для указания направления потока для упорядочения в родительском элементе. Для получения значения в текущем <xref:System.Windows.FrameworkElement>, использовать прямые [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] доступа <xref:System.Windows.FrameworkElement.FlowDirection%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="GetLayoutClip">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Geometry GetLayoutClip (System.Windows.Size layoutSlotSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Geometry GetLayoutClip(valuetype System.Windows.Size layoutSlotSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetLayoutClip (layoutSlotSize As Size) As Geometry" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Geometry ^ GetLayoutClip(System::Windows::Size layoutSlotSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Geometry</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="layoutSlotSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="layoutSlotSize">Размер части элемента, выполняющей визуальную презентацию.</param>
        <summary>Возвращает геометрию маски отсечения. Маска применяется при попытке системы структуры скомпоновать элемент, размер которого превышает доступное экранное пространство.</summary>
        <returns>Геометрия отсечения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поля вычитаются из `layoutSlotSize` как часть поведение системы макета.  
  
 Возвращаемая ссылка null указывает, что отсечение выполнено не будет. Реализация по умолчанию всегда возвращает `null` при <xref:System.Windows.UIElement.ClipToBounds%2A> — `false`. Этот метод переопределяет метод <xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=nameWithType>. <xref:System.Windows.FrameworkElement> Реализация использует <xref:System.Windows.FrameworkElement.MaxHeight%2A> и <xref:System.Windows.FrameworkElement.MaxWidth%2A> в вычислениях. Несколько подклассы <xref:System.Windows.FrameworkElement> Переопределите этот метод еще раз. <xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=nameWithType>, переопределяет всегда возвращают `null` так, как графические элементы намеренно часто находятся за пределами обычного границы. <xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=nameWithType> и <xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=nameWithType> возвращают `null` Если <xref:System.Windows.UIElement.ClipToBounds%2A> — `false`.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Реализация по умолчанию всегда возвращает <see langword="null" /> при <see cref="P:System.Windows.UIElement.ClipToBounds" /> — <see langword="false" />. Переопределений обычно ожидается сохранение этого поведения, хотя существуют исключения, в зависимости от связи и назначения производного класса и его логики структуры, в отличие от базового класса.</para>
        </block>
        <altmember cref="P:System.Windows.UIElement.Clip" />
        <altmember cref="P:System.Windows.UIElement.ClipToBounds" />
      </Docs>
    </Member>
    <Member MemberName="GetTemplateChild">
      <MemberSignature Language="C#" Value="protected internal System.Windows.DependencyObject GetTemplateChild (string childName);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance class System.Windows.DependencyObject GetTemplateChild(string childName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetTemplateChild(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Function GetTemplateChild (childName As String) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; System::Windows::DependencyObject ^ GetTemplateChild(System::String ^ childName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="childName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="childName">Имя искомого дочернего элемента.</param>
        <summary>Возвращает именованный элемент в визуальном дереве объекта <see cref="T:System.Windows.Controls.ControlTemplate" />, для которого создан экземпляр.</summary>
        <returns>Запрошенный элемент. Может иметь значение <see langword="null" />, если элемента с запрошенным именем не существует.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Шаблоны в [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] быть самодостаточным имен. Это так, как шаблоны повторно используются и любое имя, определенное в шаблоне не уникальности при его шаблон экземпляра несколько экземпляров элемента управления. Вызовите <xref:System.Windows.FrameworkElement.GetTemplateChild%2A> метод для возврата ссылки на объекты, полученные из шаблона, после ее создания. Нельзя использовать <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> метод для поиска элементов на основе шаблонов, так как <xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType> действует в более общим области, поэтому нет соединения между <xref:System.Windows.Controls.ControlTemplate> класса себя и экземпляра шаблона после его применения.  
  
 <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> предоставляет ту же функцию, как этот метод. <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> public, а не защищен и использует правильный имен вопросы, позволяющие получить доступ к шаблону в элементе и поиска с именем элементов внутри него. Используйте <xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType> при необходимости получения элемента за пределами его родительского элемента управления.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkTemplate.FindName(System.String,System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <Member MemberName="GetUIParentCore">
      <MemberSignature Language="C#" Value="protected internal override System.Windows.DependencyObject GetUIParentCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance class System.Windows.DependencyObject GetUIParentCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetUIParentCore" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Function GetUIParentCore () As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override System::Windows::DependencyObject ^ GetUIParentCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает альтернативный логический родительский объект для этого элемента при отсутствии визуального родительского объекта.</summary>
        <returns>Возвращает нечто, отличное от <see langword="null" />, каждый раз, когда реализация уровня инфраструктуры WPF этого метода имеет подключение без визуального родительского объекта.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет метод <xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=nameWithType>. Значение по умолчанию <xref:System.Windows.FrameworkElement> реализация возвращает ожидаемый единый визуальный родитель, который является тем же, как получение <xref:System.Windows.FrameworkElement.Parent%2A> значение. Реализации производных классов могут возвращать альтернативные родительские связи.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Parent" />
      </Docs>
    </Member>
    <Member MemberName="GetVisualChild">
      <MemberSignature Language="C#" Value="protected override System.Windows.Media.Visual GetVisualChild (int index);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Media.Visual GetVisualChild(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetVisualChild (index As Integer) As Visual" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Media::Visual ^ GetVisualChild(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Visual</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">Отсчитываемый от нуля индекс запрошенного дочернего элемента коллекции.</param>
        <summary>Переопределяет метод <see cref="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" /> и возвращает дочерний элемент по указанному индексу из коллекции дочерних элементов.</summary>
        <returns>Запрошенный дочерний элемент. Не должен возвращать значение <see langword="null" />; если указанный индекс находится за пределами диапазона, происходит исключение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В <xref:System.Windows.FrameworkElement> реализации единственным допустимым индексом равно нулю. Модель содержимого для <xref:System.Windows.FrameworkElement.GetVisualChild%2A> содержит ноль или один дочерние элементы управления, не коллекцию.  
  
   
  
## Examples  
 В следующем примере показано, как пользовательский графический элемент использует значения, объявленные с <xref:System.Windows.Media.VisualCollection> , он поддерживает для множества визуальных дочерних элементов. Эти значения передаются через переопределения <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> и <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Эта реализация допустимо только для элементов, которые не поддерживают более описательную коллекцию визуальных дочерних элементов. Любой элемент, имеющий такой коллекции необходимо переопределить этот метод и сопоставлять индекс с эквивалентным индексом в коллекции дочерних элементов, поддерживаемой данным элементом. Индекс в диапазоне от 0 до <see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" /> (минус) должен возвращать допустимый элемент; любого другого индекса должен создать исключение вне диапазона. Пример типа элемента, который поддерживает коллекцию дочерних и переопределяет <see cref="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" /> для возврата нескольких возможных дочерних — <see cref="T:System.Windows.Controls.Panel" />.  
  
 Реализация по умолчанию в <see cref="T:System.Windows.FrameworkElement" /> предполагает только один дочерний элемент visual. Значение, переданное для <paramref name="index" /> Кроме нуль вызывает исключение, создаваемое исключение. Стандартные элементы, например декораторы, графические элементы или элементы со специальными средствами визуализации, переопределяют <see cref="T:System.Windows.FrameworkElement" /> реализацию (реализации из промежуточных базовых классов). Некоторые реализации все еще требуют одного визуального дочернего элемента, в то время как другие разрешают коллекцию.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Height">
      <MemberSignature Language="C#" Value="public double Height { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Height" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Height" />
      <MemberSignature Language="VB.NET" Value="Public Property Height As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Height { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает предлагаемую высоту элемента.</summary>
        <value>Высота элемента в [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Значение по умолчанию — <see cref="F:System.Double.NaN" />. Это значение должно быть не меньше 0,0.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Height%2A> является одним из трех свойств для записи на <xref:System.Windows.FrameworkElement> , укажите информацию о высоте. Два других — <xref:System.Windows.FrameworkElement.MinHeight%2A> и <xref:System.Windows.FrameworkElement.MaxHeight%2A>. При наличии конфликта между эти значения, порядок приложения для определения фактических высоту, первый <xref:System.Windows.FrameworkElement.MinHeight%2A> должен быть принят на обработку, затем <xref:System.Windows.FrameworkElement.MaxHeight%2A>и, наконец, если он находится в пределах границ, <xref:System.Windows.FrameworkElement.Height%2A>.  
  
 Если этот элемент является дочерним элементом в другой элемент, затем этому свойству присвоить значение самом деле предлагаемое значение. Система макета, а также конкретной логикой структуры родительского элемента будет использовать значение как несвязанного ввода во время процесса компоновки. На практике <xref:System.Windows.FrameworkElement> почти всегда является дочерним элементом еще; даже в том случае, если задать <xref:System.Windows.FrameworkElement.Height%2A> на <xref:System.Windows.Window>. (Для <xref:System.Windows.Window>, данное значение используется, когда базовой моделью приложения устанавливает основные отрисовки допущений, создают Hwnd, где размещается приложение.)  
  
 В дополнение к допустимого <xref:System.Double> значения, это свойство также может быть <xref:System.Double.NaN?displayProperty=nameWithType>. Это показано, как указать поведение автоматического изменения размеров в коде. В [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] значение в строку «Auto» (без учета регистра) чтобы включить автоматическое изменение размеров. Автоматическое изменение размеров предполагает, что элемент заполнит доступную ему высоту. Обратите внимание, что определенные элементы управления передают значения по умолчанию через их тематические стили по умолчанию, которые отключают автоматическое изменение размеров, если его специально повторно включить.  
  
 Возвращаемое значение этого свойства всегда является таким же, как любое значение, которое было задано. Напротив, значение <xref:System.Windows.FrameworkElement.ActualHeight%2A> могут различаться. Это может происходить как статически, так как макет отклонить предполагаемый размер по какой-либо причине, или моментально. Сама система структуры работает асинхронно относительно набора в системе свойств <xref:System.Windows.FrameworkElement.Height%2A> и может не обработать конкретное изменение свойства размера еще.  
  
 Значение ограничения <xref:System.Double> определяется значение <xref:System.Windows.ValidateValueCallback> механизм. При попытке задать недопустимое значение, возникает исключение времени выполнения.  
  
 В дополнение к проверке подлинности является недетерминированной наибольшее значение, привязанное к <xref:System.Windows.FrameworkElement.Height%2A> , обеспечивается системой макета (это очень большое число, большее, чем <xref:System.Single.MaxValue?displayProperty=nameWithType> но меньше, чем <xref:System.Double.MaxValue?displayProperty=nameWithType>). Если превысить это ограничение, элемент не будет отображаться, и исключение не возникает. Не устанавливайте <xref:System.Windows.FrameworkElement.Height%2A> значение значительно больше, чем максимальный размер любого возможного визуального дисплея, или может превысить эту недетерминированную верхнюю границу.  
  
<a name="xamlAttributeUsage_Height"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object Height="double"/>  
- or -  
<object Height="qualifiedDouble"/>  
- or -  
<object Height="Auto"/>  
```  
  
<a name="xamlValues_Height"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *double*  
 <xref:System.Double>  
  
 Строковое представление <xref:System.Double> значение, равное или больше 0,0. Сведения о верхней границе см. в разделе "Примечания". Это значение интерпретируется как [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] измерения. Строки не нужно явно указывать десятичного разделителя. Для экземпляра значение `1` является допустимым.  
  
 *qualifiedDouble*  
 Объект *двойные* значение как описано выше, за которым следует один из следующих строк объявления единицы измерения: `px`, `in`, `cm`, `pt`.  
  
 `px` (по умолчанию) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` дюймах; 1 дюйм == 96 точек  
  
 `cm` сантиметрах; 1см==(96/2,54) пкс  
  
 `pt` точках; 1точка==(96/72) пкс  
  
 **Auto**  
 Включает автоматическое определение размера. См. заметки.  
  
<a name="dependencyPropertyInfo_Height"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.HeightProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.ActualHeight" />
      </Docs>
    </Member>
    <Member MemberName="HeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HeightProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.Height" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.HorizontalAlignment HorizontalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.HorizontalAlignment HorizontalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.HorizontalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property HorizontalAlignment As HorizontalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::HorizontalAlignment HorizontalAlignment { System::Windows::HorizontalAlignment get(); void set(System::Windows::HorizontalAlignment value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.HorizontalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка характеристик выравнивания по горизонтали, применяемых к этому элементу при его размещении в родительском элементе управления, например в панели или элементе управления элементами.</summary>
        <value>Параметр горизонтального выравнивания как значение перечисления. Значение по умолчанию: <see cref="F:System.Windows.HorizontalAlignment.Stretch" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Windows.FrameworkElement.Height%2A> и <xref:System.Windows.FrameworkElement.Width%2A> от элемента явно заданы свойства, этих измерений занять высокий приоритет во время структурирования и отменит типичные эффекты параметр <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> для <xref:System.Windows.HorizontalAlignment.Stretch>.  
  
 <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> — [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] доступа свойства для Какова на самом деле свойство зависимостей. Это свойство зависимостей конкретного довольно часто имеет значение «по умолчанию» по-разному в подклассах элементов, в частности в элементах управления. Обычно такая ситуация возникает в одном из двух способов: свойство зависимости регистрируется повторно подкласса, но с другой метаданных для задания значения по умолчанию; либо стиль по умолчанию применяется, который задает это значение свойства зависимостей по-разному. Например, «по умолчанию» для <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> для <xref:System.Windows.Controls.Label> элемент управления будет <xref:System.Windows.HorizontalAlignment.Left>, даже если <xref:System.Windows.Controls.Label> наследует <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> непосредственно от <xref:System.Windows.FrameworkElement>. Это, поскольку это значение было сброшено в качестве стиля по умолчанию <xref:System.Windows.Controls.Label>, в шаблоне элемента управления стилем.  
  
 <xref:System.Windows.Controls.Canvas> не используйте <xref:System.Windows.FrameworkElement.HorizontalAlignment%2A> при создании макета, так как <xref:System.Windows.Controls.Canvas> основывающаяся на абсолютном позиционировании.  
  
 Если наследуемые <xref:System.Windows.Controls.Label> или производных классов, <xref:System.Windows.Controls.Label> переопределяет значение по умолчанию этого свойства зависимостей, чтобы быть <xref:System.Windows.HorizontalAlignment.Left>.  
  
<a name="dependencyPropertyInfo_HorizontalAlignment"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.HorizontalAlignmentProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HorizontalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty HorizontalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty HorizontalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.HorizontalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly HorizontalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ HorizontalAlignmentProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.HorizontalAlignment" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="InheritanceBehavior">
      <MemberSignature Language="C#" Value="protected internal System.Windows.InheritanceBehavior InheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.InheritanceBehavior InheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Property InheritanceBehavior As InheritanceBehavior" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; property System::Windows::InheritanceBehavior InheritanceBehavior { System::Windows::InheritanceBehavior get(); void set(System::Windows::InheritanceBehavior value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.InheritanceBehavior</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает пределы области видимости для наследования значений свойств, поиска ключей ресурсов и поиска RelativeSource FindAncestor.</summary>
        <value>Значение перечисления. Значение по умолчанию: <see cref="F:System.Windows.InheritanceBehavior.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Определенные границы в элементе дерева набор <xref:System.Windows.FrameworkElement.InheritanceBehavior%2A> чтобы намеренно ограничить область наследования в поиске ресурсов force для проверки ресурсов приложения или для предотвращения подстановки RelativeSource FindAncestor запрос текущего элемента или дальнейшее. RelativeSource FindAncestor уточняющего запроса происходит, когда привязка использует <xref:System.Windows.Data.RelativeSource> с его <xref:System.Windows.Data.RelativeSource.Mode%2A> присвоено <xref:System.Windows.Data.RelativeSourceMode.FindAncestor?displayProperty=nameWithType> значение.  
  
 Если требуется задать это свойство производного класса, необходимо делать это в статическом конструкторе или других процедурах инициализации.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Frame" />
      </Docs>
    </Member>
    <Member MemberName="Initialized">
      <MemberSignature Language="C#" Value="public event EventHandler Initialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Initialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Initialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Initialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Initialized;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит во время инициализации данного <see cref="T:System.Windows.FrameworkElement" />. Данное событие совпадает со случаями, когда значение свойства <see cref="P:System.Windows.FrameworkElement.IsInitialized" /> изменяется с <see langword="false" /> (или неопределенного) на <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие будет каждый раз, когда возникает <xref:System.Windows.FrameworkElement.EndInit%2A> или <xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A> вызываются методы. Вызовы для обоих методов производятся из кода приложения или посредством [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] поведение процессора при [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] обработки страницы.  
  
 Выбор режима обработки <xref:System.Windows.FrameworkElement.Loaded> или <xref:System.Windows.FrameworkElement.Initialized> зависит от требований. Если вам не нужно прочитать свойства элемента, требуется сбросить свойства и не обязательно любые сведения о макете <xref:System.Windows.FrameworkElement.Initialized> может быть лучше событий для обработки. Если требуется все свойства элемента доступны, и установка свойств, которые могут сбросить макет, <xref:System.Windows.FrameworkElement.Loaded> может быть лучше событий для обработки. Будьте внимательны повторного входа, если обработчик сбрасывает все свойства, которые интерпретируются системой макета означает, что требуется новый передачи макета. (Может понадобиться вернуть <xref:System.Windows.FrameworkPropertyMetadata> значения для свойства, если вы не знаете, какие свойства могут требовать новый макет передачи, если они были изменены.)  
  
 Дополнительные сведения о последовательности событий объекта для <xref:System.Windows.FrameworkElement>и для нескольких связанных классах приложений и элементов, см. также [события времени жизни объектов](~/docs/framework/wpf/advanced/object-lifetime-events.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="InputScope">
      <MemberSignature Language="C#" Value="public System.Windows.Input.InputScope InputScope { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Input.InputScope InputScope" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.InputScope" />
      <MemberSignature Language="VB.NET" Value="Public Property InputScope As InputScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Input::InputScope ^ InputScope { System::Windows::Input::InputScope ^ get(); void set(System::Windows::Input::InputScope ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Input.InputScope</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает контекст для ввода, используемый данным <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <value>Область ввода, которая изменяет интерпретацию ввода с помощью альтернативных методов. Значение по умолчанию равно <see langword="null" /> (что приводит к обработке команд по умолчанию).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство зависимостей наследуется значений свойств. Если имеются дочерние элементы без другие значения для <xref:System.Windows.FrameworkElement.InputScope%2A> установленное с помощью локальных значений или стилей, задайте в системе свойств это значение должно быть <xref:System.Windows.FrameworkElement.InputScope%2A> значение ближайшего предка элемента с назначенным данным значением.  
  
 Несмотря на то что [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] использование синтаксиса указано и синтаксически разрешено, задание этого свойства [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] не так часто.  
  
<a name="dependencyPropertyInfo_InputScope"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.InputScopeProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Input.InputScope" />
        <altmember cref="T:System.Windows.IInputElement" />
      </Docs>
    </Member>
    <Member MemberName="InputScopeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty InputScopeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty InputScopeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.InputScopeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InputScopeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ InputScopeProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.InputScope" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInitialized">
      <MemberSignature Language="C#" Value="public bool IsInitialized { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInitialized" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsInitialized" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInitialized As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInitialized { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Advanced)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, показывающее, был ли инициализирован данный элемент — либо в ходе обработки процессором [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], либо путем явного вызова его метода <see cref="M:System.Windows.FrameworkElement.EndInit" />.</summary>
        <value>
          <see langword="true" />, если элемент инициализирован путем вышеупомянутой обработки [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] или вызова методов; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство также может быть `true` Если этот элемент был перемещен в логическом дереве таким образом, что он имеет новый родительский элемент и снова станет перегруженным.  
  
 Это свойство полезно, если вы используете <xref:System.Windows.FrameworkElement.BeginInit%2A> и <xref:System.Windows.FrameworkElement.EndInit%2A>. Элементы в логическом дереве, загружаемой в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] процессора гарантированно инициализации. Элементы не в логическом дереве инициализируются при <xref:System.Windows.FrameworkElement.EndInit%2A> вызывается. В отсутствие любого конкретного обработка <xref:System.Windows.FrameworkElement.BeginInit%2A> и <xref:System.Windows.FrameworkElement.EndInit%2A>, это происходит сразу после завершения работы конструктор возвращает инициализированное результат.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsLoaded">
      <MemberSignature Language="C#" Value="public bool IsLoaded { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLoaded" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.IsLoaded" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLoaded As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLoaded { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, загружен ли данный элемент для презентации.</summary>
        <value>
          <see langword="true" />, если текущий элемент присоединен к дереву элементов; <see langword="false" />, если элемент никогда не был присоединен к загруженному дереву элементов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Из только что созданной <xref:System.Windows.FrameworkElement>, это свойство начинается `false`и остается `true` было присвоено `true`, даже если элемент впоследствии удаляется из подключенного логического дерева из кода. `true` состояние задается общей логикой презентации при загрузке элементов в механизм презентации.  
  
 Как правило, загруженных элементов, готовый для просмотра, но не все <xref:System.Windows.FrameworkElement> производные классы имеют презентации и другие свойства, такие как <xref:System.Windows.UIElement.Visibility%2A> могут повлиять на презентации.  
  
   
  
## Examples  
 Следующий пример реализует два обработчика: один обрабатывает <xref:System.Windows.FrameworkElement.Loaded> событий корневого элемента, чтобы убедиться в загруженный корневой элемент страницы так, как это является значением события. Другой обработчик привязан к пользовательского элемента управления и вызовы <xref:System.Windows.FrameworkElement.IsLoaded%2A> чтобы убедиться, что корневой элемент загружается полностью. Оба обработчика вызывают ту же функцию (не показано), заполняет дочерние элементы свежими данными.  
  
 [!code-csharp[GroupBoxExample#FEIsLoaded](~/samples/snippets/csharp/VS_Snippets_Wpf/GroupBoxExample/CSharp/Page1.xaml.cs#feisloaded)]  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Language">
      <MemberSignature Language="C#" Value="public System.Windows.Markup.XmlLanguage Language { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Markup.XmlLanguage Language" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Language" />
      <MemberSignature Language="VB.NET" Value="Public Property Language As XmlLanguage" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Markup::XmlLanguage ^ Language { System::Windows::Markup::XmlLanguage ^ get(); void set(System::Windows::Markup::XmlLanguage ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Markup.XmlLanguage</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает сведения о языке локализации и глобализации, который применяется к элементу.</summary>
        <value>Сведения о языке для этого элемента. Значение по умолчанию — <see cref="T:System.Windows.Markup.XmlLanguage" />, для свойства <see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /> которого установлено строковое значение "en-US".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Строковые форматы соответствуют стандарту RFC 3066. К примеру США Английский — «en US». Дополнительные сведения о значениях и формате см. в разделе <xref:System.Windows.Markup.XmlLanguage>.  
  
 Это свойство зависимостей наследуется значений свойств. Если имеются дочерние элементы без другие значения для <xref:System.Windows.FrameworkElement.Language%2A> установленное с помощью локальных значений или стилей, в системе свойств будет задать это значение должно быть <xref:System.Windows.FrameworkElement.Language%2A> значение ближайшего предка элемента с назначенным данным значением.  
  
 [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)] Определяет общие значения `xml:lang` атрибута. <xref:System.Windows.FrameworkElement.Language%2A> по существу представляет значение этого атрибута как свойство зависимостей. <xref:System.Windows.FrameworkElement.Language%2A> можно изменить программным способом и могут участвовать в наследование значения свойства системы в виде, параллельно как `xml:lang` атрибута может наследовать область дочерний элемент в [!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]. Если задать <xref:System.Windows.FrameworkElement.Language%2A>, это значение становится `xml:lang` и перезаписывает все предыдущие значения. Дополнительные сведения см. в разделе [XML: lang в XAML](~/docs/framework/xaml-services/xml-lang-handling-in-xaml.md).  
  
<a name="dependencyPropertyInfo_CultureInfo"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.LanguageProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LanguageProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LanguageProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LanguageProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LanguageProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LanguageProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LanguageProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.Language" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransform">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Transform LayoutTransform { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.Transform LayoutTransform" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LayoutTransform" />
      <MemberSignature Language="VB.NET" Value="Public Property LayoutTransform As Transform" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::Transform ^ LayoutTransform { System::Windows::Media::Transform ^ get(); void set(System::Windows::Media::Transform ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Transform</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает графическое преобразование, которое применяется к элементу при изменении параметров размещения.</summary>
        <value>Преобразование, которое должен использовать данный элемент. Значение по умолчанию: <see cref="P:System.Windows.Media.Transform.Identity" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от к <xref:System.Windows.UIElement.RenderTransform%2A>, <xref:System.Windows.FrameworkElement.LayoutTransform%2A> повлияет на результаты макета.  
  
 Задание преобразования предоставляет мощные возможности масштабирования и вращения. Тем не менее <xref:System.Windows.FrameworkElement.LayoutTransform%2A> игнорирует <xref:System.Windows.Media.TranslateTransform> операций. Это, поскольку поведение системы макета для дочерних элементов <xref:System.Windows.FrameworkElement> автоматически исправляет любые смещения позиции масштабируемого или повернутый элемента в макет и система координат родительского элемента.  
  
 <xref:System.Windows.FrameworkElement.LayoutTransform%2A> может привести к ухудшению производительности приложения, если вызывается в случае, когда не требуется полный проход системы макета. При применении <xref:System.Windows.FrameworkElement.LayoutTransform%2A> для <xref:System.Windows.Controls.Panel.Children%2A> коллекцию <xref:System.Windows.Controls.Panel>, система инициирует новый проход системой макета и заставляет все объекты на экране принудительно упорядочиваются и переупорядочить. Если вы обновляете полное приложение [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)], эта функция может оказаться именно то, что нужно. Тем не менее, если не требуется полная передача макета, используйте <xref:System.Windows.UIElement.RenderTransform%2A> свойство, которое не вызывает систему макета и, как правило, лучшим выбором для этого сценария.  
  
 Примеры сценариев где <xref:System.Windows.FrameworkElement.LayoutTransform%2A> может быть полезно включить: поворот элементов, таких как компоненты меню с горизонтальной на вертикальную или наоборот, масштабирование элементы (увеличивать) при получении фокуса, предоставляя возможность редактирования и т. д.  
  
<a name="dependencyPropertyInfo_LayoutTransform"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.LayoutTransformProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 В следующем примере показано, как применить <xref:System.Windows.FrameworkElement.LayoutTransform%2A> к элементу. В примере создается экземпляр <xref:System.Windows.Controls.Button> и размещает в родительском элементе <xref:System.Windows.Controls.Grid>. Она также использует <xref:System.Windows.FrameworkElement.LayoutTransform%2A> свойства для применения <xref:System.Windows.Media.RotateTransform> для <xref:System.Windows.Controls.Button>.  
  
 [!code-cpp[LayoutTransform#1](~/samples/snippets/cpp/VS_Snippets_Wpf/LayoutTransform/CPP/LayoutTransform.cpp#1)]
 [!code-csharp[LayoutTransform#1](~/samples/snippets/csharp/VS_Snippets_Wpf/LayoutTransform/CSharp/LayoutTransform.cs#1)]
 [!code-vb[LayoutTransform#1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/LayoutTransform/VisualBasic/LayoutTransform.vb#1)]
 [!code-xaml[LayoutTransform#1](~/samples/snippets/xaml/VS_Snippets_Wpf/LayoutTransform/XAML/default.xaml#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LayoutTransformProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LayoutTransformProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LayoutTransformProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LayoutTransformProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LayoutTransformProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LayoutTransformProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.LayoutTransform" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Loaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Loaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Loaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Loaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Loaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Loaded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, если элемент размещен, отрисован и готов к взаимодействию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Loaded> Обычно последнее событие вызывается в последовательности инициализации элементов. Всегда будет вызываться после <xref:System.Windows.FrameworkElement.Initialized>. Выбор режима обработки <xref:System.Windows.FrameworkElement.Loaded> или <xref:System.Windows.FrameworkElement.Initialized> зависит от требований. Если вам не нужно прочитать свойства элемента, требуется сбросить свойства и не обязательно любые сведения о макете <xref:System.Windows.FrameworkElement.Initialized> может быть лучше событий для обработки. Если требуется все свойства элемента доступны, и установка свойств, которые могут сбросить макет, <xref:System.Windows.FrameworkElement.Loaded> может быть лучше событий для обработки. Будьте внимательны повторного входа, если обработчик сбрасывает все свойства, которые интерпретируются системой макета означает, что требуется новый передачи макета. (Может понадобиться вернуть <xref:System.Windows.FrameworkPropertyMetadata> значения для свойства, если вы не знаете, какие свойства могут требовать новый макет передачи, если они были изменены.)  
  
 Дополнительные сведения о последовательности событий объекта для <xref:System.Windows.FrameworkElement>и для нескольких связанных классах приложений и элементов, см. также [события времени жизни объектов](~/docs/framework/wpf/advanced/object-lifetime-events.md).  
  
 События с прямой маршрутизацией не следуют по маршруту, они обрабатываются только внутри элемента, на котором они вызываются. Прямые перенаправленные события поддерживают другое поведение перенаправленных событий: они поддерживают коллекцию доступных обработчиков и могут использоваться как <xref:System.Windows.EventTrigger> в стиле.  
  
 <xref:System.Windows.FrameworkElement.Loaded> и <xref:System.Windows.FrameworkElement.Unloaded> и может быть вызвано в элементе управления, в результате изменения темы инициированной пользователем системы. Изменение темы делает недействительность шаблон элемента управления и автономной визуального дерева, который в свою очередь вызывает выгрузке и повторной загрузке всего элемента управления. Поэтому <xref:System.Windows.FrameworkElement.Loaded> неизвестно возникает только при первой загрузке страницы посредством перехода к странице.  
  
<a name="routedEventInfo_Loaded"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.LoadedEvent>|  
|Стратегия маршрутизации|Direct|  
|делегат|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="LoadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent LoadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent LoadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.LoadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LoadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ LoadedEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует направленное событие <see cref="E:System.Windows.FrameworkElement.Loaded" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Идентификаторы перенаправленных событий создаются при их регистрации. Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события. Эти идентификаторы можно использовать для добавления обработчиков классов.  
  
 Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal virtual System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает перечислитель для логических дочерних элементов данного элемента.</summary>
        <value>Перечислитель для логических дочерних элементов данного элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.LogicalChildren%2A> позволяет проходить по дочерним элементам. Это полезно для элементов, которые могут не определена выделенная коллекция, но по-прежнему содержать более одного дочернего элемента, особенно <xref:System.Windows.FrameworkContentElement> дочерних элементов.  
  
 Дополнительные сведения об использовании <xref:System.Windows.FrameworkElement.LogicalChildren%2A> и <xref:System.Windows.FrameworkElement.AddLogicalChild%2A>, в разделе [деревьев в WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Margin">
      <MemberSignature Language="C#" Value="public System.Windows.Thickness Margin { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Thickness Margin" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Margin" />
      <MemberSignature Language="VB.NET" Value="Public Property Margin As Thickness" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Thickness Margin { System::Windows::Thickness get(); void set(System::Windows::Thickness value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Thickness</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение внешнего поля элемента.</summary>
        <value>Предоставляет значения полей для элемента. Значение по умолчанию равно <see cref="T:System.Windows.Thickness" /> со всеми свойствами, равными 0 (нулю).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Поле представляет собой пространство между элементом и другие элементы, которые будут смежные при создании макета [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]. Общие элементы могут быть одноранговыми (например, другие элементы в коллекции общего родительского элемента управления) или может быть родительским для данного элемента.  
  
 <xref:System.Windows.FrameworkElement.Margin%2A> задается как <xref:System.Windows.Thickness> структуры, а не как число, чтобы поле можно задать асимметричного. <xref:System.Windows.Thickness> Самой структуры поддерживает преобразование типов в строку, чтобы можно было указать асимметричный <xref:System.Windows.FrameworkElement.Margin%2A> в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] также синтаксис атрибута.  
  
 Задает поля ненулевой вне макета элемента <xref:System.Windows.FrameworkElement.ActualWidth%2A> и <xref:System.Windows.FrameworkElement.ActualHeight%2A>.  
  
 Поля являются аддитивными для одноуровневых элементов в макете; Например два смежных элемента, установить оба поля 30 смежные границы бы 60 единиц пробела между ними.  
  
 Элементы, которые заданы поля, обычно не ограничивают размер указанного <xref:System.Windows.FrameworkElement.Margin%2A> если выделенное прямоугольное пространство не является достаточно большим для поля и область содержимого элемента. Область содержимого элемента будет ограничен вместо этого, при вычислении структуры. Единственный случай, где будет ограничен поля также — если содержимое уже ограничено до нуля.  
  
<a name="xamlAttributeUsage_Margin"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object Margin="left,top,right,bottom"/>  
- or -  
<object Margin="left,top"/>  
- or -  
<object Margin="thicknessReference"/>  
```  
  
<a name="xamlPropertyElementUsage_Margin"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<object>  
  <object.Margin>  
    <Thickness Left="left" Top="top" Right="right" Bottom="bottom"/>  
  </object.Margin>  
</object>  
```  
  
<a name="xamlValues_Margin"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *слева, сверху, справа, снизу*  
 Числовые значения между 0 и <xref:System.Double.PositiveInfinity> , указать четыре возможных измерений свойства <xref:System.Windows.Thickness> структуры.  
  
 Использование атрибута также принимает сокращенные значения, применяемые в указанном порядке, симметрично и логически. Например `Margin="20"` будет трактуется как <xref:System.Windows.Thickness> со свойствами, установленными на 20. `Margin="20,50"` будет трактуется как <xref:System.Windows.Thickness> с <xref:System.Windows.Thickness.Left%2A> и <xref:System.Windows.Thickness.Right%2A> равным 20, а <xref:System.Windows.Thickness.Top%2A> и <xref:System.Windows.Thickness.Bottom%2A> значение 50.  
  
 Единицы измерения по умолчанию для <xref:System.Windows.Thickness> мера является [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]. Также можно указать другие единицы измерения путем добавления строк с единицей измерения типа `cm`, `in`, или `pt` к любой величине.  
  
 Числовые значения, указанные как [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] атрибуты не требуется указывать десятичные точки (0 приемлемо, не должен предоставляться как 0,0). Дополнительные сведения о [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] использования, в разделе <xref:System.Windows.Thickness>.  
  
 *thicknessReference*  
 Ссылка на объект на существующий <xref:System.Windows.Thickness>. Это может быть `}`,, или `}` ссылки. Дополнительные сведения о [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] использования, в разделе <xref:System.Windows.Thickness>.  
  
<a name="dependencyPropertyInfo_Margin"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.MarginProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Thickness" />
      </Docs>
    </Member>
    <Member MemberName="MarginProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MarginProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MarginProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MarginProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MarginProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MarginProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.Margin" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeight">
      <MemberSignature Language="C#" Value="public double MaxHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxHeight { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка максимально допустимой высоты элемента.</summary>
        <value>Максимальная высота элемента в [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Значение по умолчанию — <see cref="F:System.Double.PositiveInfinity" />. Это значение может быть больше или равно 0,0. Значение <see cref="F:System.Double.PositiveInfinity" /> также является допустимым.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это один из трех свойств на <xref:System.Windows.FrameworkElement> , укажите информацию о высоте. Два других — <xref:System.Windows.FrameworkElement.MinHeight%2A> и <xref:System.Windows.FrameworkElement.Height%2A>.  Если возникает конфликт между этими значениями, порядок приложения для определения фактических Высота первого <xref:System.Windows.FrameworkElement.MinHeight%2A> должен быть принят на обработку, затем <xref:System.Windows.FrameworkElement.MaxHeight%2A>и, наконец, если каждый из них находятся в пределах границ, <xref:System.Windows.FrameworkElement.Height%2A>.  
  
 Значение ограничения <xref:System.Double> определяется значение <xref:System.Windows.ValidateValueCallback> механизм. При попытке задать недопустимое значение исключения во время выполнения.  
  
<a name="xamlAttributeUsage_MaxHeight"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object MaxHeight="double"/>  
- or –  
<object MaxHeight ="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MaxHeight"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *double*  
 <xref:System.Double>  
  
 Строковое представление <xref:System.Double> значение, равное или больше 0,0. Это значение интерпретируется как [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] измерения. Строки не нужно явно указывать десятичного разделителя. Для экземпляра значение `1` является допустимым.  
  
 Соответствует <xref:System.Double> применить ограничения диапазона, как упоминалось в разделе значение свойства, за исключением того, необходимо использовать [расширение разметки x: Static](~/docs/framework/xaml-services/x-static-markup-extension.md) необходимо явно задать это значение должно быть <xref:System.Double.PositiveInfinity>.  
  
 *qualifiedDouble*  
 Объект *двойные* значение как описано выше, за которым следует один из следующих строк объявления единицы измерения: `px`, `in`, `cm`, `pt`.  
  
 `px` (по умолчанию) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` дюймах; 1 дюйм == 96 точек  
  
 `cm` сантиметрах; 1см==(96/2,54) пкс  
  
 `pt` точках; 1точка==(96/72) пкс  
  
<a name="dependencyPropertyInfo_MaxHeight"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.MaxHeightProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxHeightProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.MaxHeight" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidth">
      <MemberSignature Language="C#" Value="public double MaxWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MaxWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MaxWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MaxWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MaxWidth { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка максимально допустимой ширины элемента.</summary>
        <value>Максимальная ширина элемента в [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Значение по умолчанию — <see cref="F:System.Double.PositiveInfinity" />. Это значение может быть больше или равно 0,0. Значение <see cref="F:System.Double.PositiveInfinity" /> также является допустимым.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это один из трех свойств на <xref:System.Windows.FrameworkElement> , укажите ширину сведения. Два других — <xref:System.Windows.FrameworkElement.MinWidth%2A> и <xref:System.Windows.FrameworkElement.Width%2A>. Если возникает конфликт между этими значениями, порядок приложения для определения фактическую ширину первый <xref:System.Windows.FrameworkElement.MinWidth%2A> должен быть принят на обработку, затем <xref:System.Windows.FrameworkElement.MaxWidth%2A>и, наконец, если каждый из них находятся в пределах границ, <xref:System.Windows.FrameworkElement.Width%2A>.  
  
 Значение ограничения <xref:System.Double> определяется значение <xref:System.Windows.ValidateValueCallback> механизм. При попытке задать недопустимое значение, возникает исключение времени выполнения.  
  
<a name="xamlAttributeUsage_MaxWidth"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object MaxWidth="double"/>  
- or -  
<object MaxWidth="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MaxWidth"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *double*  
 <xref:System.Double>  
  
 Строковое представление <xref:System.Double> значение, равное или больше 0,0. Это значение интерпретируется как [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] измерения. Строки не нужно явно указывать десятичного разделителя. Для экземпляра значение `1` является допустимым.  
  
 Соответствует <xref:System.Double> применить ограничения диапазона, как упоминалось в разделе значение свойства, за исключением того, необходимо использовать [расширение разметки x: Static](~/docs/framework/xaml-services/x-static-markup-extension.md) присвоить это значение должно быть <xref:System.Double.PositiveInfinity>.  
  
 *qualifiedDouble*  
 Объект *двойные* значение как описано выше, за которым следует один из следующих строк объявления единицы измерения: `px`, `in`, `cm`, `pt`.  
  
 `px` (по умолчанию) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` дюймах; 1 дюйм == 96 точек  
  
 `cm` сантиметрах; 1см==(96/2,54) пкс  
  
 `pt` точках; 1точка==(96/72) пкс  
  
<a name="dependencyPropertyInfo_MaxWidth"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.MaxWidthProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MaxWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MaxWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MaxWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MaxWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MaxWidthProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.MaxWidth" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureCore">
      <MemberSignature Language="C#" Value="protected override sealed System.Windows.Size MeasureCore (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureCore(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides NotOverridable Function MeasureCore (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureCore(System::Windows::Size availableSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Доступный размер, который родительский элемент может предоставить дочерним элементам.</param>
        <summary>Реализует основное поведение системы структуры при проходе измерения для <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <returns>Желательный размер этого элемента в макете.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType> подключения уровня ядра WPF и реализации мер макета уровня платформы WPF. <xref:System.Windows.FrameworkElement> Реализации запечатывает метод. Чтобы настроить поведение макета проход измерения любого элемента, который основан на уровня платформы WPF, переопределите <xref:System.Windows.FrameworkElement.MeasureOverride%2A> вместо него. Чтобы настроить поведение макета элемента, который намеренно не на основе уровня платформы WPF или используйте проход измерения <xref:System.Windows.FrameworkElement>, переопределите <xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Доступный размер, который этот элемент может предоставить дочерним элементам. Можно задать бесконечное значение, указав таким образом, что элемент будет масштабироваться в соответствии с любым содержимым.</param>
        <summary>При переопределении в производном классе измеряет размер в структуре, требуемый для дочерних элементов, и определяет размер для класса, производного от <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <returns>Размер, определяемый данным элементом для своих потребностей во время структурирования на основе вычисления размеров дочерних элементов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Переопределить <xref:System.Windows.FrameworkElement.MeasureOverride%2A> реализуйте поведение при изменении размера пользовательский макет для элемента, как оно участвует в [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] система макета. Реализация должна делать следующее:  
  
1.  Итерации элемента в определенной коллекции дочерних элементов, которые являются частью макета, вызов <xref:System.Windows.UIElement.Measure%2A> для каждого дочернего элемента.  
  
2.  Сразу получить <xref:System.Windows.UIElement.DesiredSize%2A> для дочернего элемента (он задается как свойство после <xref:System.Windows.UIElement.Measure%2A> вызывается).  
  
3.  Вычислите чистый требуемый размер родительского элемента на основе измерений дочерних элементов.  
  
 Возвращаемое значение <xref:System.Windows.FrameworkElement.MeasureOverride%2A> должен совпадать с размером элемента собственные требуемого, которая становится входных данных для родительского элемента текущего элемента меры. Этот процесс продолжается всей системы структуры, пока не будет достигнут корневой элемент страницы.  
  
 Во время этого процесса может возвратить более крупный дочерние элементы <xref:System.Windows.UIElement.DesiredSize%2A> размер больше исходного `availableSize` указать, что дочерний элемент больше места. Это может быть обработано в вашей собственной реализации внедрения прокручиваемой области, путем изменения размеров родительского элемента управления путем создания каким-либо образом стекового порядка или любого количества решений для измерения или компоновки содержимого.  
  
> [!IMPORTANT]
>  Элементы должны вызывать <xref:System.Windows.UIElement.Measure%2A> для каждого дочернего во время этого процесса, в противном случае дочерние элементы не будет правильно размера или упорядочены.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>В следующем коде-компиляции показано этой реализации шаблона.  <c>VisualChildren</c> представляет свойство перечисляемую коллекцию дочерних элементов, определяющих собственного элемента. Свойство может быть любое имя. <c>VisualChildren</c> является именем-заполнителем для этого примера <c>VisualChildren</c> не [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)] в соответствии со [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] или его часть шаблон именования...  
  
 [!code-csharp[CorePseudocode#FEMeasureOverride](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#femeasureoverride)]
 [!code-vb[CorePseudocode#FEMeasureOverride](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#femeasureoverride)]</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="MinHeight">
      <MemberSignature Language="C#" Value="public double MinHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinHeight" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinHeight" />
      <MemberSignature Language="VB.NET" Value="Public Property MinHeight As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinHeight { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка минимально допустимой высоты элемента.</summary>
        <value>Минимальная высота элемента в [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Значение по умолчанию — 0,0. Это значение может быть больше или равно 0,0. Однако константа <see cref="F:System.Double.PositiveInfinity" /> допустимой не является, равно как и <see cref="F:System.Double.NaN" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это один из трех свойств на <xref:System.Windows.FrameworkElement> , укажите информацию о высоте.  Два других — <xref:System.Windows.FrameworkElement.Height%2A> и <xref:System.Windows.FrameworkElement.MaxHeight%2A>. Если возникает конфликт между этими значениями, порядок приложения для определения фактических Высота первого <xref:System.Windows.FrameworkElement.MinHeight%2A> должен быть принят на обработку, затем <xref:System.Windows.FrameworkElement.MaxHeight%2A>и, наконец, если каждый из них находятся в пределах границ, <xref:System.Windows.FrameworkElement.Height%2A>.  
  
 Значение ограничения <xref:System.Double> определяется значение <xref:System.Windows.ValidateValueCallback> механизм. При попытке задать недопустимое значение, возникает исключение времени выполнения.  
  
<a name="xamlAttributeUsage_MinHeight"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object MinHeight="double"/>  
- or -  
<object MinHeight="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MinHeight"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *double*  
 <xref:System.Double>  
  
 Строковое представление <xref:System.Double> значение, равное или больше 0,0. Это значение интерпретируется как [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] измерения. Строки не нужно явно указывать десятичного разделителя. Для экземпляра значение `1` является допустимым.  
  
 Соответствует <xref:System.Double> ограничения диапазона, как упоминалось в разделе "значение свойства".  
  
 *qualifiedDouble*  
 Объект *двойные* значение как описано выше, за которым следует один из следующих строк объявления единицы измерения: `px`, `in`, `cm`, `pt`.  
  
 `px` (по умолчанию) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` дюймах; 1 дюйм == 96 точек  
  
 `cm` сантиметрах; 1см==(96/2,54) пкс  
  
 `pt` точках; 1точка==(96/72) пкс  
  
<a name="dependencyPropertyInfo_MinHeight"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.MinHeightProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinHeightProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinHeightProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinHeightProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinHeightProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinHeightProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinHeightProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.MinHeight" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidth">
      <MemberSignature Language="C#" Value="public double MinWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 MinWidth" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.MinWidth" />
      <MemberSignature Language="VB.NET" Value="Public Property MinWidth As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double MinWidth { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка минимально допустимой ширины элемента.</summary>
        <value>Минимальная ширина элемента в [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Значение по умолчанию — 0,0. Это значение может быть больше или равно 0,0. Однако константа <see cref="F:System.Double.PositiveInfinity" /> допустимой не является, равно как и <see cref="F:System.Double.NaN" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это один из трех свойств на <xref:System.Windows.FrameworkElement> , укажите ширину сведения.  Два других — <xref:System.Windows.FrameworkElement.Width%2A> и <xref:System.Windows.FrameworkElement.MaxWidth%2A>.  Если возникает конфликт между этими значениями, порядок приложения для определения фактическую ширину первый <xref:System.Windows.FrameworkElement.MinWidth%2A> должен быть принят на обработку, затем <xref:System.Windows.FrameworkElement.MaxWidth%2A>и, наконец, если каждый из них находятся в пределах границ, <xref:System.Windows.FrameworkElement.Width%2A>.  
  
 Значение ограничения <xref:System.Double> определяется значение <xref:System.Windows.ValidateValueCallback> механизм. При попытке задать недопустимое значение, возникает исключение времени выполнения.  
  
<a name="xamlAttributeUsage_MinWidth"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object MinWidth="double"/>  
- or -  
<object MinWidth="qualifiedDouble"/>  
```  
  
<a name="xamlValues_MinWidth"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *double*  
 <xref:System.Double>  
  
 Строковое представление <xref:System.Double> значение, равное или больше 0,0. Это значение интерпретируется как [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] измерения. Строки не нужно явно указывать десятичного разделителя. Для экземпляра значение `1` является допустимым.  
  
 Соответствует <xref:System.Double> ограничения диапазона, как упоминалось в разделе "значение свойства".  
  
 *qualifiedDouble*  
 Объект *двойные* значение как описано выше, за которым следует один из следующих строк объявления единицы измерения: `px`, `in`, `cm`, `pt`.  
  
 `px` (по умолчанию) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` дюймах; 1 дюйм == 96 точек  
  
 `cm` сантиметрах; 1см==(96/2,54) пкс  
  
 `pt` точках; 1точка==(96/72) пкс  
  
<a name="dependencyPropertyInfo_MinWidth"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.MinWidthProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinWidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty MinWidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty MinWidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.MinWidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly MinWidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ MinWidthProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.MinWidth" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveFocus">
      <MemberSignature Language="C#" Value="public override sealed bool MoveFocus (System.Windows.Input.TraversalRequest request);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveFocus(class System.Windows.Input.TraversalRequest request) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function MoveFocus (request As TraversalRequest) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveFocus(System::Windows::Input::TraversalRequest ^ request);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="request" Type="System.Windows.Input.TraversalRequest" />
      </Parameters>
      <Docs>
        <param name="request">Направление, в котором перемещается фокус, в виде значения перечисления.</param>
        <summary>Перемещает клавиатурный фокус от данного элемента на другой элемент в указанном направлении обхода.</summary>
        <returns>Возвращает значение <see langword="true" />, если фокус успешно перемещен; <see langword="false" />, если целевого элемента в указанном направлении не существует или на него нельзя установить клавиатурный фокус.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта реализация переопределяет <xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=nameWithType> и запечатывает метод.  
  
   
  
## Examples  
 В следующем примере реализуется обработчик, который обрабатывает несколько возможных вводов кнопок. Каждая кнопка представляет возможного <xref:System.Windows.Input.FocusNavigationDirection>. Обработчик отслеживает элемента с текущей фокус клавиатуры и вызовы <xref:System.Windows.FrameworkElement.MoveFocus%2A> на этот элемент, указав соответствующую <xref:System.Windows.Input.FocusNavigationDirection> для инициализации <xref:System.Windows.Input.TraversalRequest> введите указанный параметр.  
  
 [!code-csharp[FocusSample#FocusSampleMoveFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#focussamplemovefocus)]
 [!code-vb[FocusSample#FocusSampleMoveFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#focussamplemovefocus)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.Focus" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IFrameworkInputElement.Name</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.MergableProperty(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Markup.DesignerSerializationOptions</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает имя, обозначающее элемент. Имя позволяет обращаться из с выделенным кодом, например из кода обработчика событий, к элементу разметки после его создания в ходе обработки процессором [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].</summary>
        <value>Имя элемента. Значение по умолчанию - пустая строка.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Наиболее распространенное использование этого свойства является указание [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] имя элемента как атрибут в разметке.  
  
 По сути, это свойство предоставляет свойство удобства уровня платформы WPF для задания [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] [директива x: Name](~/docs/framework/xaml-services/x-name-directive.md).  
  
 Имена должны быть уникальными в пределах области видимости имен. Дополнительные сведения см. в разделе [области имен XAML WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 Получение <xref:System.Windows.FrameworkElement.Name%2A> при создании элементов кода не так часто. Если в коде уже присутствует соответствующая ссылка, может просто вызвать методы и свойства в элементе ссылки и не будет обычно необходимость <xref:System.Windows.FrameworkElement.Name%2A>. Исключение — если <xref:System.Windows.FrameworkElement.Name%2A> строка имеет несколько перегруженных значение, например если полезно отображать это имя в [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]. Установка <xref:System.Windows.FrameworkElement.Name%2A> из кода если исходное <xref:System.Windows.FrameworkElement.Name%2A> было задано из разметки также не рекомендуется использовать и изменение свойства после загрузки [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] ссылку на исходный объект не изменится. Ссылки на объекты создаются только в том случае, если основной области видимости имен явно создаются во время синтаксического анализа. Необходимо явно вызывать <xref:System.Windows.FrameworkElement.RegisterName%2A> действующие сделать для <xref:System.Windows.FrameworkElement.Name%2A> свойства элемента уже загружен.  
  
 Важные один вариант, где параметр <xref:System.Windows.FrameworkElement.Name%2A> из кода важно при регистрации имен для элементов, которые раскадровки будет выполняться, чтобы к ним могут обращаться во время выполнения. Прежде чем выполнять регистрацию имени, может потребоваться создать и назначить <xref:System.Windows.NameScope> экземпляра. См. в разделе, или [Общие](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
 Установка <xref:System.Windows.FrameworkElement.Name%2A> из кода имеет ограниченные приложения, но Получение элемента с <xref:System.Windows.FrameworkElement.Name%2A> чаще всего. Один из сценариев является, если приложение поддерживает модель навигации, где перезагрузкой страниц в приложение, и код времени выполнения не обязательно является кода программной части, определенным для этой страницы. Вспомогательный метод <xref:System.Windows.FrameworkElement.FindName%2A>, которое доступно из любого <xref:System.Windows.FrameworkElement>, можно найти любой элемент, <xref:System.Windows.FrameworkElement.Name%2A> в логическом дереве для этого элемента, поиск рекурсивно дерева при необходимости. Или можно использовать <xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A> статический метод <xref:System.Windows.LogicalTreeHelper>, которая также принимает <xref:System.Windows.FrameworkElement.Name%2A> строку в качестве аргумента.  
  
 Как правило, используется корневых элементов (<xref:System.Windows.Window>, <xref:System.Windows.Controls.Page> например) реализуют интерфейс <xref:System.Windows.Markup.INameScope>. Реализации этого интерфейса ожидается обеспечение однозначности имен в пределах их области. Корневые элементы, определяющие этот интерфейс также определяют поведение границы области видимости имен для всех связанных [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)].  
  
 <xref:System.Windows.FrameworkElement.Name%2A> Также служит в качестве идентификатора для других процессов. Например [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] будет использовать модель автоматизации <xref:System.Windows.FrameworkElement.Name%2A> как AutomationId для клиентов и поставщиков.  
  
 Строковые значения, используемые для <xref:System.Windows.FrameworkElement.Name%2A> имеют некоторые ограничения, как основной, установленные [директива x: Name](~/docs/framework/xaml-services/x-name-directive.md) определяется [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] спецификации. Прежде всего <xref:System.Windows.FrameworkElement.Name%2A> должно начинаться с буквы или символа подчеркивания (_) и должно содержать только буквы, цифры или символы подчеркивания. Дополнительные сведения см. в разделе [области имен XAML WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 <xref:System.Windows.FrameworkElement.Name%2A> является одним из очень мало свойств зависимостей, которые невозможно анимировать (<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> — `true` в метаданных), так как само имя крайне важно для нацеливания на анимации. Привязка данных <xref:System.Windows.FrameworkElement.Name%2A> технически возможно, но встречается крайне редко, так как привязки к данным <xref:System.Windows.FrameworkElement.Name%2A> не может служить главной назначение свойства: для предоставления идентификатор точки подключения для кода.  
  
<a name="dependencyPropertyInfo_Name"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.NameProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A>|  
  
   
  
## Examples  
 В следующем примере задается <xref:System.Windows.FrameworkElement.Name%2A> свойства в коде, а затем регистрирует имя в только что созданный <xref:System.Windows.NameScope> путем вызова <xref:System.Windows.FrameworkElement.RegisterName%2A>. Показанный здесь прием является обязательным для анимации с помощью Storyboard, так как раскадровки требуют указания цели с <xref:System.Windows.FrameworkElement.Name%2A>и не может обращаться по ссылке объекта.  
  
 [!code-csharp[animateHeight_procedural#FEName](~/samples/snippets/csharp/VS_Snippets_Wpf/animateHeight_procedural/CSharp/AnimatedHeightExample.cs#fename)]
 [!code-vb[animateHeight_procedural#FEName](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animateHeight_procedural/visualbasic/animatedheightexample.vb#fename)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty NameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty NameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.NameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ NameProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.Name" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnApplyTemplate">
      <MemberSignature Language="C#" Value="public virtual void OnApplyTemplate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnApplyTemplate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnApplyTemplate" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnApplyTemplate ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnApplyTemplate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>При переопределении в производном классе вызывается каждый раз, когда код приложения или внутренние процессы вызывают <see cref="M:System.Windows.FrameworkElement.ApplyTemplate" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 У этого метода нет реализации по умолчанию.  
  
 Шаблоны представляют собой часть элемента визуального дерева, поступающие из свойства шаблона <xref:System.Windows.Style> , применяемый для элемента. Более подробную информацию см. в разделе [Стилизация и использование шаблонов](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Классы, унаследованные от <see cref="T:System.Windows.FrameworkElement" /> можно использовать этот метод для уведомления о различных возможных сценариев:  
  
-   Можно вызвать собственную реализацию кода, выполняющего построение оставшейся части визуального дерева элемента.  
  
-   Можно запустить код, основанный на визуальное дерево из примененных шаблонов, например для получения ссылок на именованные элементы, полученные из шаблона.  
  
-   Можно внедрить службы, которые имеют смысл только существование после завершения визуального дерева с помощью шаблонов.  
  
-   Можно задать состояния и свойства элементов в шаблоне, зависящих от других факторов. Для экземпляра значения свойств могут быть доступными только зная родительского элемента, или если конкретный производной класс использует общий шаблон.  
  
 Исполнители должен всегда вызывать базовую реализацию перед свою собственную реализацию. <see cref="T:System.Windows.FrameworkElement" /> сам не имеет стандартного реализации, но промежуточные классы могут.  
  
 <see cref="T:System.Windows.Controls.Control" /> предоставляет аналогичные override, <see cref="M:System.Windows.Controls.Control.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuClosing (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuClosing(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuClosing (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuClosing(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Предоставляет данные о событии.</param>
        <summary>Вызывается, когда необработанное перенаправленное событие <see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /> достигает этого класса на своем пути. Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 У этого метода нет реализации по умолчанию. По-прежнему должен вызвать базовую реализацию, если промежуточный класс в цепочке наследования реализует данный метод.  
  
 Этот метод похож на [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On * методы: она предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра. В этом случае соответствующее событие является маршрутизируемым. Шаблон реализации методов On * отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, не обязательно является элементом, вызывающим обработчики, так что реализации требуется выполнять источника аргументов события свойства в учетной записи (и не пытаться повторно вызвать событие в большинстве случаев). Подклассы <xref:System.Windows.FrameworkElement> может выбрать для вызова методов обработчика закрытый класс при получении события в маршруте. Одним из потенциальных сценариев является получение аргументов события и пометка его как обработанное.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContextMenuOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnContextMenuOpening (System.Windows.Controls.ContextMenuEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContextMenuOpening(class System.Windows.Controls.ContextMenuEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContextMenuOpening (e As ContextMenuEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContextMenuOpening(System::Windows::Controls::ContextMenuEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ContextMenuEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.Windows.RoutedEventArgs" />, содержащий данные о событии.</param>
        <summary>Вызывается, когда необработанное перенаправленное событие <see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /> достигает этого класса на своем пути. Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 У этого метода нет реализации по умолчанию. По-прежнему должен вызвать базовую реализацию, если промежуточный класс в цепочке наследования реализует данный метод.  
  
 Этот метод похож на [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On * методы: она предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра. В этом случае соответствующее событие является маршрутизируемым. Шаблон реализации методов On * отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, не обязательно является элементом, вызывающим обработчики, так что реализации требуется выполнять источника аргументов события свойства в учетной записи (и не пытаться повторно вызвать событие в большинстве случаев). Подклассы <xref:System.Windows.FrameworkElement> может выбрать для вызова методов обработчика закрытый класс при получении события в маршруте. Одним из потенциальных сценариев является получение аргументов события и пометка его как обработанное.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnGotFocus">
      <MemberSignature Language="C#" Value="protected override void OnGotFocus (System.Windows.RoutedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnGotFocus(class System.Windows.RoutedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnGotFocus (e As RoutedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnGotFocus(System::Windows::RoutedEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.RoutedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.Windows.RoutedEventArgs" />, содержащий данные о событии.</param>
        <summary>Вызывается, когда необработанное событие <see cref="E:System.Windows.UIElement.GotFocus" /> достигает этого элемента на своем пути.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отличие от некоторых других на * методам, предоставляемым базовых элементах <xref:System.Windows.FrameworkElement.OnGotFocus%2A> имеет реализацию по умолчанию. В частности, он имеет реализацию, переопределяет реализацию null на следующем уровне базового элемента вниз, <xref:System.Windows.UIElement.OnGotFocus%2A>. При вызове <xref:System.Windows.FrameworkElement.OnGotFocus%2A> задает соответствующее поведение фокуса на этот элемент в случаях, источник события из текущего элемента из-за фокус клавиатуры. <xref:System.Windows.FrameworkElement.OnGotFocus%2A> Обработчик не помечает аргументы события как обработанное, даже если установить фокус на текущий элемент. Если источником события был другой элемент в дереве (а не текущего элемента), обработчик не выполняет никаких действий.  
  
 Можно переопределить этот метод, чтобы изменить поведение по умолчанию фокус на элемент, но имейте в виду, что изменение поведения фокуса таким способом можно реализовать лучше, не позволяя элемента вообще (см. <xref:System.Windows.UIElement.Focusable%2A>).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Если планируется пометить событие как обработанное в аргументах следует учитывать последствия обработки события в других родительских элементов в дереве элементов. Так как данный обработчик действует на событие с восходящей маршрутизацией, установка фокуса в текущий <paramref name="sender" /> на событие аргументов может быть неприемлемо. Фокус может потребоваться перейти на составной дочерний элемент или родительский элемент, в зависимости от композиции определенных элементов управления. Поэтому помечать событие фокуса как обработанное рекомендуется только если во время всего визуального дерева, событием является частью композиции элемента управления, созданные.</para>
        </block>
        <altmember cref="P:System.Windows.UIElement.Focusable" />
      </Docs>
    </Member>
    <Member MemberName="OnInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnInitialized(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.Windows.RoutedEventArgs" />, содержащий данные о событии.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.FrameworkElement.Initialized" />. Этот метод вызывается всякий раз, когда <see cref="P:System.Windows.FrameworkElement.IsInitialized" /> имеет внутреннее значение <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данный конкретный на * метод не является ловушкой обработчика класса. Ни он точно следовать установленному [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] на * метод соглашение, соответствующее событие можно подавить путем переопределения этого метода и не вызывает базовую реализацию.  
  
 Обратите внимание, что <xref:System.Windows.FrameworkElement.IsInitialized%2A> свойство только для чтения, поэтому нельзя задать <xref:System.Windows.FrameworkElement.IsInitialized%2A> на принудительную инициализацию. Задание состояния инициализации должен выполняться только [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] framework.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Реализация по умолчанию данного виртуального метода вызывает вышеописанное событие. Для поддержания данного режима работы переопределение должно вызывать базовую реализацию. Если не удается вызвать базовую реализацию, не только вы не приведет к <see cref="E:System.Windows.FrameworkElement.Initialized" /> события как обычно ожидается <see cref="T:System.Windows.FrameworkElement" /> производного класса, но также подавляет два важных стиль и тему стиль инициализации операции, которые будут реализован этой базовой реализации.</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.OnApplyTemplate" />
        <altmember cref="E:System.Windows.FrameworkElement.Initialized" />
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Данные события, описывающие измененное свойство, а также старое и новое значения.</param>
        <summary>Вызывается всякий раз при обновлении действующего значения какого-либо свойства зависимостей относительно данного элемента <see cref="T:System.Windows.FrameworkElement" />. Конкретное измененное свойство зависимостей сообщается в параметре аргументов. Переопределяет свойство <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод не предназначен для общего выявления изменений свойств или их недействительности. Он предназначен для изменения общего шаблона недействительности, если известна определенная информация о широких классификациях свойств.  
  
 Этот метод потенциально вызывается несколько раз за время существования объекта. Таким образом, можно улучшить производительность, если переопределения метаданных свойств, а затем подключите <xref:System.Windows.CoerceValueCallback> или <xref:System.Windows.PropertyChangedCallback> функции для отдельных свойств. Тем не менее, будет использовать этот метод, если <xref:System.Windows.FrameworkElement> включает значительное количество свойств зависимостей с взаимосвязанными значениями, или если он содержит логику, например поведение отрисовки, необходимо повторно для нескольких связанных случаев недействительности свойств.  
  
 Обратите внимание, что таким же именем `OnPropertyChanged` метод с другой сигнатурой (тип параметра является <xref:System.ComponentModel.PropertyChangedEventArgs>), которые могут возникнуть на несколько классов. Что `OnPropertyChanged` используется для уведомления объекта данных и является частью контракта для <xref:System.ComponentModel.INotifyPropertyChanged>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Всегда вызовите базовую реализацию в качестве первой операции в вашей реализации. В противном случае значительно отключит всего [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] системы свойств, вследствие чего будут сообщены неверные значения. Конкретный <see cref="T:System.Windows.FrameworkElement" /> реализация также отвечает за поддержку надлежащего состояния различных свойств, влияющих на видимый пользовательский интерфейс. К ним относится недействительность визуального дерева в зависимости от изменений стиля в соответствующие моменты.</para>
        </block>
        <altmember cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
        <altmember cref="T:System.Windows.PropertyChangedCallback" />
      </Docs>
    </Member>
    <Member MemberName="OnRenderSizeChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnRenderSizeChanged (System.Windows.SizeChangedInfo sizeInfo);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnRenderSizeChanged(class System.Windows.SizeChangedInfo sizeInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnRenderSizeChanged (sizeInfo As SizeChangedInfo)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnRenderSizeChanged(System::Windows::SizeChangedInfo ^ sizeInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sizeInfo" Type="System.Windows.SizeChangedInfo" />
      </Parameters>
      <Docs>
        <param name="sizeInfo">Сведения о старом и новом размерах при изменении.</param>
        <summary>Инициирует событие <see cref="E:System.Windows.FrameworkElement.SizeChanged" />, используя указанную информацию как часть окончательных данных события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет метод <xref:System.Windows.UIElement.OnRenderSizeChanged%2A>. Если вызвать этот метод будет заново <xref:System.Windows.FrameworkElement.ActualWidth%2A> свойства <xref:System.Windows.FrameworkElement.ActualHeight%2A> свойства (или оба) в зависимости от того, что указано в качестве изменено в предоставленных аргументов, и вы всегда вызывает событие.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Не следует переопределять этот метод для обычных сценариях структуры. Система структуры работает в намеренно асинхронном режиме, чтобы обеспечить, упорядочить все возможные макета и случаев меры. Система макета переопределения методов <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /> и <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" /> обычно достаточно для настройки любой требуемый макет. <see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /> предоставляется виртуальным. Можно переопределить <see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /> исправление в исключительных случаях, где изменение поведения во время выполнения, связанные с входными событиями, в сочетании с элементом управления рекомпозиции в ответ может предоставить сведения о макете неточной.  
  
 Вы по-прежнему может переопределить этот метод в производных классах (он защищен, но не запечатан). Всегда вызовите базовую реализацию для сохранения поведение, описанное выше, если у вас нет особых причин для отключения поведение отрисовки уровня платформы WPF по умолчанию. Сбой вызова <see cref="E:System.Windows.FrameworkElement.SizeChanged" /> событий приведет к стандартным макетом поведение при использовании стандартной реализации системы макета уровня платформы WPF.</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.UIElement.OnRender(System.Windows.Media.DrawingContext)" />
      </Docs>
    </Member>
    <Member MemberName="OnStyleChanged">
      <MemberSignature Language="C#" Value="protected internal virtual void OnStyleChanged (System.Windows.Style oldStyle, System.Windows.Style newStyle);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnStyleChanged(class System.Windows.Style oldStyle, class System.Windows.Style newStyle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnStyleChanged (oldStyle As Style, newStyle As Style)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnStyleChanged(System::Windows::Style ^ oldStyle, System::Windows::Style ^ newStyle);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldStyle" Type="System.Windows.Style" />
        <Parameter Name="newStyle" Type="System.Windows.Style" />
      </Parameters>
      <Docs>
        <param name="oldStyle">Старый стиль.</param>
        <param name="newStyle">Новый стиль.</param>
        <summary>Вызывается при изменении текущего стиля данного элемента, что ведет к недействительности структуры.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод имеет реализацию по умолчанию, которая устанавливает внутренний флаг, заметки о состоянии изменения стиля.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Вам не следует обычно переопределить этот метод. Любой изменить стиль, который включает в себя меру или упорядочивания, изменение приведет к запуску уже следующего цикла отрисовки, при условии, что типичная реализация <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />  /  <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />, или значения по умолчанию. Переопределений <see cref="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" /> может использоваться, если ваш <see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />  /  <see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /> реализации были намеренно оптимизации или поддержки частичных обновлений, но по-прежнему необходимо было для применения изменений в стили напрямую. (Частичное обновление будет предпринята во избежание нескольких вызовов добавочное <see cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" /> и <see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /> на всех дочерних элементов).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipClosing (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipClosing(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipClosing (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipClosing(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Предоставляет данные о событии.</param>
        <summary>Вызывается, когда необработанное перенаправленное событие <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" /> достигает этого класса на своем пути. Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 У этого метода нет реализации по умолчанию. По-прежнему должен вызвать базовую реализацию, если промежуточный класс в цепочке наследования реализует данный метод.  
  
 Этот метод похож на [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On * методы: она предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра. В этом случае соответствующее событие является маршрутизируемым. Шаблон реализации методов On * отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, не обязательно является элементом, вызывающим обработчики, так что реализации требуется выполнять источника аргументов события свойства в учетной записи (и не пытаться повторно вызвать событие в большинстве случаев). Подклассы <xref:System.Windows.FrameworkElement> может выбрать для вызова методов обработчика закрытый класс при получении события в маршруте. Одним из потенциальных сценариев является получение аргументов события и пометка его как обработанное.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnToolTipOpening">
      <MemberSignature Language="C#" Value="protected virtual void OnToolTipOpening (System.Windows.Controls.ToolTipEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnToolTipOpening(class System.Windows.Controls.ToolTipEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnToolTipOpening (e As ToolTipEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnToolTipOpening(System::Windows::Controls::ToolTipEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Controls.ToolTipEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Предоставляет данные о событии.</param>
        <summary>Вызывается, когда перенаправленное событие <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" /> достигает этого класса на своем пути. Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 У этого метода нет реализации по умолчанию. По-прежнему должен вызвать базовую реализацию, если промежуточный класс в цепочке наследования реализует данный метод.  
  
 Этот метод похож на [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] шаблона On * методы: она предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра. В этом случае соответствующее событие является маршрутизируемым. Шаблон реализации методов On * отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, не обязательно является элементом, вызывающим обработчики, так что реализации требуется выполнять источника аргументов события свойства в учетной записи (и не пытаться повторно вызвать событие в большинстве случаев). Подклассы <xref:System.Windows.FrameworkElement> может выбрать для вызова методов обработчика закрытый класс при получении события в маршруте. Одним из потенциальных сценариев является получение аргументов события и пометка его как обработанного для сокращения маршрута.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Прежний родительский элемент. Может иметь значение <see langword="null" />, указывающее, что до этого у элемента не было визуального родителя.</param>
        <summary>Вызывается при изменении родителя данного элемента в визуальном дереве. Переопределяет свойство <see cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Визуальное дерево потенциально отличается от логического дерева, так как он не содержит элементы, которые не отображаются визуально, таких как коллекции и раскрывает некоторые элементы на основе их темы и композиции стиля. Дополнительные сведения см. в разделе [Деревья в WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Реализация по умолчанию данного виртуального метода запрашивает нового родителя, инициирует различные события инициализации и устанавливает внутренние флаги состояния инициализации для <see cref="T:System.Windows.FrameworkElement" /> соответствующим образом. Наконец, он вызывает последовательных базовой реализации, объявленном с <see cref="T:System.Windows.UIElement" />, который в свою очередь вызывает базовую <see cref="T:System.Windows.Media.Visual" />. Всегда вызовите базовую реализацию для сохранения этого поведения, в противном случае поведение дерева элементов для данного элемента, объявленного дочерним другого элемента, может отличаться от ожидаемого.  
  
 Несколько существующих [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] классы переопределять этот метод, например: <see cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />, <see cref="M:System.Windows.Controls.ListBoxItem.OnVisualParentChanged(System.Windows.DependencyObject)" />. Наиболее распространенным сценарием является принудительное, что новый родительский объект должен быть определенного типа. Это может вызвать исключение, если новый родитель не пройдет определенную проверку типа. Специализированная версия этого сценария существует в реализациях элементов списков и пунктов меню, которые не смысла за пределами родительского визуального, владеющего соответствующей коллекцией для их хранения. Обратите внимание, что эти случаи не обязательно вызывают исключения, так как может быть конструктора сценарии, основанные на Переподчинение элементы, которые являются моментально без родительских «стандартными».  
  
 Этот метод также переопределяется в некоторых элементах, обычно являются корневого элемента, например <see cref="T:System.Windows.Window" />. Другим случаем являются элементы, которые являются очевидными корневой элемент в разметке, но который Автоформирование обширную инфраструктуру в скомпилированном логическом дереве (такие как <see cref="T:System.Windows.Controls.Page" />). <see cref="T:System.Windows.Window" /> И <see cref="T:System.Windows.Controls.Page" /> реализации намеренно запечатать метод.</para>
        </block>
        <altmember cref="M:System.Windows.Media.Visual.OnVisualParentChanged(System.Windows.DependencyObject)" />
        <altmember cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyle">
      <MemberSignature Language="C#" Value="public bool OverridesDefaultStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesDefaultStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesDefaultStyle As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesDefaultStyle { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка значения, определяющего использование в элементе свойств стиля, заданных в стилях темы.</summary>
        <value>
          Значение <see langword="true" />, если этот элемент не использует свойства стиля темы; все свойства, определяющие стиль, получаются из локальных стилей приложения, а свойства стиля темы не применяются. Значение <see langword="false" />, если сначала применяются стили приложения, а затем стили тем для свойств, которые не были явным образом заданы в стилях приложения. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Наиболее распространенное использование этого свойства является непрямое использование в переключателе стиля, который передает тематический стиль.  
  
> [!IMPORTANT]
>  Если задать <xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A> для `true` элемента управления будет подавление шаблон элемента управления по умолчанию, предоставляемые тематических стилей. Этот шаблон элемента управления обычно включает средство презентации содержимого и другие составные элементы, обеспечивающие основные [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] функциональные возможности и визуализации для элемента управления. Если требуется установить элемент управления для поддержки тех же компонентов тематических стилей по умолчанию, вы должны предоставить альтернативный стиль с шаблоном элемента управления, которое реплицирует ту же структуру. Дополнительные сведения см. в разделе [Общие сведения о разработке элементов управления](~/docs/framework/wpf/controls/control-authoring-overview.md).  
  
<a name="dependencyPropertyInfo_OverridesDefaultStyle"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.OverridesDefaultStyleProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OverridesDefaultStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty OverridesDefaultStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty OverridesDefaultStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.OverridesDefaultStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly OverridesDefaultStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ OverridesDefaultStyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject Parent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ Parent { System::Windows::DependencyObject ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает логический родительский элемент этого элемента.</summary>
        <value>Логический родительский объект этого элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.Parent%2A> может быть `null` в случаях, где был создан экземпляр элемента, но не подключен к логическому дереву, в конечном итоге подключается к уровня корневого элемента страницы или объекта приложения.  
  
 Обратите внимание, что логический родительский элемент может измениться в зависимости от функциональности приложения, и сохранение значения этого свойства не отражает такое изменение. Обычно следует получать значение, непосредственно перед он нужен.  
  
 В разделе [деревьев в WPF](~/docs/framework/wpf/advanced/trees-in-wpf.md) случаях и Дополнительные сведения о логическом дереве обхода там, где с помощью <xref:System.Windows.FrameworkElement.Parent%2A> как способ родительского элемента подходит обнаружения.  
  
 Механизм свойств потенциально пересчитает все значения свойств элемента при изменении его родителя, так как некоторые свойства наследуют значения через логическое дерево. <xref:System.Windows.FrameworkElement.DataContext%2A> , Применяемый для привязки также можно изменить при изменении элементов родителя.  
  
 Изменение родителя элемента обычно выполняется только через управление коллекциями, с использованием выделенных методов добавления и удаления, или путем задания свойств содержимого элементов.  
  
 Наиболее типичный сценарий использования <xref:System.Windows.FrameworkElement.Parent%2A> свойство является получить ссылку, а затем получить различные <xref:System.Windows.FrameworkElement> значения свойств из родительского элемента. Для шаблонов <xref:System.Windows.FrameworkElement.Parent%2A> шаблона в конечном итоге будет `null`. Чтобы получить на этом этапе и расширить в логическом дереве, где фактически применяется шаблон, используйте <xref:System.Windows.FrameworkElement.TemplatedParent%2A>.  
  
 Обратите внимание, что это свойство не сообщает о родительских элементов визуального дерева в случаях, когда они отличаются от родителей логического дерева. Родители визуального дерева обычно не важны в общих случаях приложений, но может быть целевыми родительскими элементами в некоторых случаях визуального уровня. См. раздел <xref:System.Windows.Media.VisualTreeHelper>.  
  
   
  
## Examples  
 В примере показан код, который проверяет наличие родительский элемент, а затем использует значения свойств из родительского элемента для задания свойств для дочернего элемента для сопоставления. В этом случае это свойства, которые влияют на размер отрисовки.  
  
 [!code-csharp[GeometryDesigner#FEParentProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/GeometryDesigner/CSharp/Window1.xaml.cs#feparentproperty)]
 [!code-vb[GeometryDesigner#FEParentProperty](~/samples/snippets/visualbasic/VS_Snippets_Wpf/GeometryDesigner/visualbasic/window1.xaml.vb#feparentproperty)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.TemplatedParent" />
        <altmember cref="T:System.Windows.LogicalTreeHelper" />
      </Docs>
    </Member>
    <Member MemberName="ParentLayoutInvalidated">
      <MemberSignature Language="C#" Value="protected internal virtual void ParentLayoutInvalidated (System.Windows.UIElement child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void ParentLayoutInvalidated(class System.Windows.UIElement child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub ParentLayoutInvalidated (child As UIElement)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void ParentLayoutInvalidated(System::Windows::UIElement ^ child);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Windows.UIElement" />
      </Parameters>
      <Docs>
        <param name="child">Дочерний элемент, сообщающий об изменении.</param>
        <summary>Поддерживает добавочные реализации структуры в специализированных подклассах <see cref="T:System.Windows.FrameworkElement" />. Метод <see cref="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" /> вызывается, когда дочерний элемент делает недействительным свойство, помеченное в метаданных как влияющее на проходы измерения или компоновки родительского элемента во время структурирования.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот элемент содержит дочерний элемент, на котором был объявлен недействительным, некоторые свойства, а свойство был помечен как <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> или <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> свойства метаданных во время регистрации, этот метод вызывается. Вызов метода уведомляет родительский элемент, конкретный дочерний элемент которого необходимо подвергнуть повторному измерению, если этот элемент поддерживает частичное (добавочное) обновление макета.  
  
 По умолчанию <xref:System.Windows.FrameworkElement> не поддерживает последовательный макет и в <xref:System.Windows.FrameworkElement> класса этот метод, у которого нет реализации по умолчанию. Сценарий, в котором было бы необходимо переопределение этого метода не так часто, поскольку для нее требуется возможность изменять поведение системы макета по умолчанию.  
  
 Пример сценария реализации может быть Если класс ограничения на тип возможных дочерних элементов, значительно более строгим, чем система макета уровня платформы WPF. Из-за особенностей данных пользовательских элементов изменения свойств могут быть намеренно отложены при реализации особого поведения структуры. Например измерения или компоновки переопределения методов, которые пытаются оптимизировать дочерний элемент прохода отрисовки, могут быть отложены для некоторых типов изменений, которые обычно приводят к проходу структуры.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PredictFocus">
      <MemberSignature Language="C#" Value="public override sealed System.Windows.DependencyObject PredictFocus (System.Windows.Input.FocusNavigationDirection direction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Windows.DependencyObject PredictFocus(valuetype System.Windows.Input.FocusNavigationDirection direction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides NotOverridable Function PredictFocus (direction As FocusNavigationDirection) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Windows::DependencyObject ^ PredictFocus(System::Windows::Input::FocusNavigationDirection direction);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="direction" Type="System.Windows.Input.FocusNavigationDirection" />
      </Parameters>
      <Docs>
        <param name="direction">Направление, в котором следует определить перспективное изменение фокуса.</param>
        <summary>Определяет следующий элемент, который получит фокус, относительно данного элемента для указанного направления движения фокуса, но реально фокус не перемещает.</summary>
        <returns>Следующий элемент, на который будет перемещен фокус в случае фактического обхода фокуса. Может возвращать значение <see langword="null" />, если фокус нельзя переместить относительно данного элемента в указанном направлении.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.MoveFocus%2A> имеет связанный метод, который фактически перемещения фокуса.  
  
   
  
## Examples  
 В следующем примере реализуется обработчик, который обрабатывает несколько возможных вводов кнопок, каждая кнопка представляет возможного <xref:System.Windows.Input.FocusNavigationDirection>. Обработчик отслеживает элемента с текущей фокус клавиатуры и вызовы <xref:System.Windows.FrameworkElement.PredictFocus%2A> на этот элемент и задает соответствующий <xref:System.Windows.Input.FocusNavigationDirection> для инициализации <xref:System.Windows.Input.TraversalRequest> введите указанный параметр. Вместо перемещения на этот элемент как <xref:System.Windows.FrameworkElement.MoveFocus%2A> делаете, обработчик изменяет размеры назначения прогнозируемое фокус в целях визуализации.  
  
 [!code-csharp[FocusSample#FEPredictFocus](~/samples/snippets/csharp/VS_Snippets_Wpf/FocusSample/CSharp/Window1.xaml.cs#fepredictfocus)]
 [!code-vb[FocusSample#FEPredictFocus](~/samples/snippets/visualbasic/VS_Snippets_Wpf/FocusSample/visualbasic/window1.xaml.vb#fepredictfocus)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException">Одно из следующих направлений, указанное в <see cref="T:System.Windows.Input.TraversalRequest" />: <see cref="F:System.Windows.Input.FocusNavigationDirection.Next" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.First" />, <see cref="F:System.Windows.Input.FocusNavigationDirection.Last" />. Эти направления недопустимы для метода <see cref="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /> (однако допустимы для метода <see cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />).</exception>
        <altmember cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" />
        <altmember cref="M:System.Windows.UIElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterName">
      <MemberSignature Language="C#" Value="public void RegisterName (string name, object scopedElement);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RegisterName(string name, object scopedElement) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RegisterName (name As String, scopedElement As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RegisterName(System::String ^ name, System::Object ^ scopedElement);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="scopedElement" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Имя, используемое для сопоставления указанного имени с объектом.</param>
        <param name="scopedElement">Объект для сопоставления.</param>
        <summary>Предоставляет метод доступа, упрощающий доступ к методу регистрации <see cref="T:System.Windows.NameScope" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является самым удобным для вызова <xref:System.Windows.NameScope.RegisterName%2A>. Реализация будет проверять последовательных родительских элементов, пока не найдет применимый <xref:System.Windows.NameScope> реализации, в которой находится с помощью поиск элемента, который реализует <xref:System.Windows.Markup.INameScope>. Дополнительные сведения об области видимости имен см. в разделе [области имен XAML WPF](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md).  
  
 Вызов <xref:System.Windows.FrameworkElement.RegisterName%2A> необходим, чтобы правильно подключать анимации раскадровки для приложений, созданных в коде. Это вызвано одно из ключевых раскадровки свойства, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>, выполняет поиск имени во время выполнения не предоставляется возможность указать ссылку на целевой элемент. Это верно, даже если этому элементу осуществляется по ссылке из кода. Дополнительные сведения о том, почему необходимо зарегистрировать имена целей раскадровки см. в разделе [Общие](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
   
  
## Examples  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/ScopeExample.cs#namescopeexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#NameScopeExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/scopeexample.vb#namescopeexample)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.NameScope.RegisterName(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveLogicalChild">
      <MemberSignature Language="C#" Value="protected internal void RemoveLogicalChild (object child);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig instance void RemoveLogicalChild(object child) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Sub RemoveLogicalChild (child As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; void RemoveLogicalChild(System::Object ^ child);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="child" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="child">Подлежащий удалению элемент.</param>
        <summary>Удаляет предоставленный объект из логического дерева этого элемента. Объект <see cref="T:System.Windows.FrameworkElement" /> обновляет затронутые указатели родительских элементов в логическом дереве для поддержания синхронизации с данным удалением.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется для реализации коллекции объектов, представляющих логических дочерних элементов элемента. Это можно сделать в методы получения свойств или методов задания, обработчиков класса `Changed` события, конструкторы, или в коллекции типов сами.  
  
 Для разработчиков элементов управления обработка логического дерева на этом уровне не рекомендуется, если не подходит ни одна из моделей содержимого, предоставленный базового класса элемента управления. Рассмотрите возможность создания подкласса на уровне <xref:System.Windows.Controls.ContentControl>, <xref:System.Windows.Controls.ItemsControl>, и <xref:System.Windows.Controls.HeaderedItemsControl>. Эти классы обеспечивают модель содержимого с конкретной реализацией средствами логических дочерних через выделенное [!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)], а также поддержку для других функций, как правило, желательно в [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] управления, например стилей с помощью шаблонов.  
  
   
  
## Examples  
 В следующем примере реализуется `Child` свойство в пользовательском <xref:System.Windows.FrameworkElement> , который выполняет собственную реализацию визуального уровня. Метод задания свойства разработан, чтобы при изменении значения старое значение удаляется из логического дерева, а также коллекцию визуальных элементов данного класса. Значения кэшируются, а затем новое значение добавляется стандартная WPF framework уровня логического дерева и коллекция пользовательских визуальных элементов.  
  
 [!code-csharp[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/csharp/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/CSharp/ParticleEffectExamples/OverlayRenderDecorator.cs#addremovelogicalchild)]
 [!code-vb[CompositionTargetRenderingAnimations#AddRemoveLogicalChild](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CompositionTargetRenderingAnimations/visualbasic/particleeffectexamples/overlayrenderdecorator.vb#addremovelogicalchild)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoView">
      <MemberSignature Language="C#" Value="public event System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RequestBringIntoViewEventHandler RequestBringIntoView" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.RequestBringIntoView" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event RequestBringIntoView As RequestBringIntoViewEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RequestBringIntoViewEventHandler ^ RequestBringIntoView;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RequestBringIntoViewEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при вызове метода <see cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" /> в данном элементе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие показывает, к родительскому элементу <xref:System.Windows.Controls.ScrollViewer> (или производный класс), на элемент, который вызывает <xref:System.Windows.FrameworkElement.RequestBringIntoView> событий следует сделать видимой в пределах области прокрутки. <xref:System.Windows.Controls.ScrollViewer> Затем будут отмечены как <xref:System.Windows.FrameworkElement.RequestBringIntoView> событие как обработанное с помощью класса обработки события. В целом <xref:System.Windows.FrameworkElement.RequestBringIntoView> события, данные не следует помечать обработанное классом, который управляет области прокрутки или каким-либо экземпляр обработчика, так как это может повлиять на целью элемента, который называется <xref:System.Windows.FrameworkElement.BringIntoView%2A>.  
  
<a name="routedEventInfo_RequestBringIntoView"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.RequestBringIntoViewEvent>|  
|Стратегия маршрутизации|Вверх|  
|делегат|<xref:System.Windows.RequestBringIntoViewEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" />
        <altmember cref="T:System.Windows.Controls.ScrollViewer" />
      </Docs>
    </Member>
    <Member MemberName="RequestBringIntoViewEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent RequestBringIntoViewEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent RequestBringIntoViewEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.RequestBringIntoViewEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly RequestBringIntoViewEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ RequestBringIntoViewEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует направленное событие <see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resources">
      <MemberSignature Language="C#" Value="public System.Windows.ResourceDictionary Resources { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.ResourceDictionary Resources" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Resources" />
      <MemberSignature Language="VB.NET" Value="Public Property Resources As ResourceDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResourceDictionary ^ Resources { System::Windows::ResourceDictionary ^ get(); void set(System::Windows::ResourceDictionary ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Markup.IHaveResources.Resources</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Markup.Ambient</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.ResourceDictionary</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает локально определенный словарь ресурсов.</summary>
        <value>Текущий локально определенный словарь ресурсов, где доступ к каждому ресурсу может осуществляться по ключу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Словари ресурсов, которые могут быть определены полностью или частично в [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] обычно создаются как элемент свойства и обычно представляют собой в корневом элементе любой отдельной страницы или приложения. Размещение словаря ресурсов на этом уровне облегчает поиск из отдельных дочерних элементов на странице (или на любой странице, в случае приложения). В большинстве сценариев приложений, рекомендуется определить эти стили как элементы-объекты в словаре ресурсов или как внешние ресурсы, чтобы весь ресурс стиля мог быть автономным (этот подход помогает отдельный конструктор Ответственность от ответственности разработчика путем разделения физических файлов, которые нужно редактировать).  
  
 Обратите внимание, что это свойство возвращает только словарь ресурсов, объявленный непосредственно внутри этого элемента. Это отличается от фактического процесса поиска ресурсов, где дочерний элемент можно использовать все ресурсы, определенные в каждом родительском элементе, выполняя рекурсивный восходящий поиск.  
  
 Ресурсы также могут ссылаться с помощью кода из коллекции, но имейте в виду, что ресурсы, созданные в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] определенно будут недоступны до после <xref:System.Windows.FrameworkElement.Loaded> возникает для элемента, который объявляет словаря. На самом деле синтаксического анализа ресурсов асинхронно и не даже <xref:System.Windows.FrameworkElement.Loaded> событий является гарантией того, можно ссылаться [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] определенных ресурсов. По этой причине следует обычно только обращаться к [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] определены ресурсы в рамках кода во время выполнения, или с помощью других [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] методы, такие как ссылки на расширение ресурса для значений атрибутов или стилей. При доступе к ресурсам через код, он фактически эквивалентна ссылку из [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 Базовый <xref:System.Windows.ResourceDictionary> поддерживает методы, необходимые для добавления, удаления или запроса ресурсов из коллекции с помощью кода. <xref:System.Windows.FrameworkElement.Resources%2A> Свойства можно настроить для поддержки полной замены коллекции ресурсов элемента как новый или другой сценарий <xref:System.Windows.ResourceDictionary>.  
  
 Обратите внимание, что [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] синтаксис, показанный отсутствует элемент для <xref:System.Windows.ResourceDictionary>. Это пример неявного синтаксиса коллекции; можно опустить тег представляет элемент коллекции. Вместо этого указаны элементы, которые будут добавлены как элементы в коллекцию. Дополнительные сведения о неявных коллекциях и [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], в разделе [XAML Syntax In Detail](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md). Один вариант где <xref:System.Windows.ResourceDictionary> по-прежнему задается явным образом как элемент есть ли вы ввели объединенный словарь, в этом случае обычно нет дочерних элементов для этого <xref:System.Windows.ResourceDictionary>. Дополнительные сведения см. в разделе [слияние словари ресурсов](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md).  
  
<a name="xamlPropertyElementUsage_Resources"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<object>  
  <object.Resources>  
    oneOrMoreResourceElements  
  </object.Resources>  
</object>  
```  
  
<a name="xamlValues_Resources"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *oneOrMoreResourceElements*  
 Один или несколько объектов элементов, каждый из которых определяет ресурс. Каждого элемента property ресурсов в каждом <xref:System.Windows.ResourceDictionary> должен иметь уникальное значение для [директива x: Key](~/docs/framework/xaml-services/x-key-directive.md), который используется в качестве уникального ключа при извлечении значений из <xref:System.Windows.ResourceDictionary>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Application.Resources" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBinding">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Присоединяет привязку к этому элементу для указанного свойства зависимостей.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpression SetBinding (System.Windows.DependencyProperty dp, string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpression SetBinding(class System.Windows.DependencyProperty dp, string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, path As String) As BindingExpression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpression ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="dp">Идентифицирует свойство назначения, к которому следует установить привязку.</param>
        <param name="path">Имя исходного свойства или путь к свойству, используемому для привязки.</param>
        <summary>Прикрепляет привязку к данному элементу на основе указанного имени исходного свойства в виде классификационного пути к источнику данных.</summary>
        <returns>Фиксирует состояния привязки. Это возвращаемое значение можно использовать для проверки ошибок.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является самым удобным для вызова <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, который передает текущего экземпляра в качестве <xref:System.Windows.DependencyObject>и создает новый <xref:System.Windows.Data.Binding> на основе предоставленной `path` параметра. Эта подпись является более удобным в том случае, если устанавливается простой привязки по умолчанию. Если вам нужно указать любые свойства привязки для нестандартных условий, или использовать <xref:System.Windows.Data.MultiBinding> или <xref:System.Windows.Data.PriorityBinding>, следует использовать <xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29> подписи.  
  
   
  
## Examples  
 В следующем примере задается привязка по определенному пути.  
  
 [!code-csharp[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#setbindingpath)]
 [!code-vb[BaseElementsSmorgasbord#SetBindingPath](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#setbindingpath)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBinding">
      <MemberSignature Language="C#" Value="public System.Windows.Data.BindingExpressionBase SetBinding (System.Windows.DependencyProperty dp, System.Windows.Data.BindingBase binding);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Data.BindingExpressionBase SetBinding(class System.Windows.DependencyProperty dp, class System.Windows.Data.BindingBase binding) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)" />
      <MemberSignature Language="VB.NET" Value="Public Function SetBinding (dp As DependencyProperty, binding As BindingBase) As BindingExpressionBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Data::BindingExpressionBase ^ SetBinding(System::Windows::DependencyProperty ^ dp, System::Windows::Data::BindingBase ^ binding);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.BindingExpressionBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="binding" Type="System.Windows.Data.BindingBase" />
      </Parameters>
      <Docs>
        <param name="dp">Определяет свойство, которому следует установить привязку.</param>
        <param name="binding">Представляет подробные сведения о привязки данных.</param>
        <summary>Прикрепляет привязку к данному элементу на основе предоставленной привязки объекта.</summary>
        <returns>Фиксирует состояния привязки. Это возвращаемое значение можно использовать для проверки ошибок.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод является самым удобным для вызова <xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType>, который передает текущего экземпляра в качестве <xref:System.Windows.DependencyObject>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetFlowDirection">
      <MemberSignature Language="C#" Value="public static void SetFlowDirection (System.Windows.DependencyObject element, System.Windows.FlowDirection value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetFlowDirection(class System.Windows.DependencyObject element, valuetype System.Windows.FlowDirection value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetFlowDirection (element As DependencyObject, value As FlowDirection)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetFlowDirection(System::Windows::DependencyObject ^ element, System::Windows::FlowDirection value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.FlowDirection" />
      </Parameters>
      <Docs>
        <param name="element">Элемент, указывающий направление потока.</param>
        <param name="value">Значение перечисления, указывающее направление.</param>
        <summary>Задает значение присоединенного свойства <see cref="P:System.Windows.FrameworkElement.FlowDirection" /> указанного элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод поддерживает синтаксис присоединенного свойства для <xref:System.Windows.FrameworkElement.FlowDirection%2A> свойство, таким образом позволяя дочерних элементов указанного <xref:System.Windows.FrameworkElement> для указания направления потока для упорядочения в родительском элементе. Требуется задать значение в текущем <xref:System.Windows.FrameworkElement>, использовать прямые [!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)] доступа <xref:System.Windows.FrameworkElement.FlowDirection%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.FlowDirection" />
      </Docs>
    </Member>
    <Member MemberName="SetResourceReference">
      <MemberSignature Language="C#" Value="public void SetResourceReference (System.Windows.DependencyProperty dp, object name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetResourceReference(class System.Windows.DependencyProperty dp, object name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetResourceReference (dp As DependencyProperty, name As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetResourceReference(System::Windows::DependencyProperty ^ dp, System::Object ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="name" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="dp">Свойство, к которому привязан ресурс.</param>
        <param name="name">Имя ресурса.</param>
        <summary>Выполняет поиск ресурса по указанному имени и устанавливает ссылку на этот ресурс для указанного свойства.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ссылка на ресурс похож на использование [DynamicResource Markup Extension](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md) в разметке. Ссылка на ресурс создает внутреннее выражение, содержащий значение заданного свойства на основе отложенного выполнения. Выражение будет повторно вычисляться каждый раз, когда словарем ресурсов измененного значения через внутренние события или при изменении родителя текущего элемента (родителя изменяется путь для поиска словаря).  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
        <altmember cref="P:System.Windows.Application.Resources" />
        <altmember cref="P:System.Windows.FrameworkElement.Resources" />
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeResources">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeResources ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeResources() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeResources" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeResources () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeResources();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает логическое значение, указывающее, следует ли процессам сериализации сериализировать содержимое свойства <see cref="P:System.Windows.FrameworkElement.Resources" />.</summary>
        <returns>
          Значение <see langword="true" />, если значение свойства <see cref="P:System.Windows.FrameworkElement.Resources" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Будет возвращен `true` при условии, что имеется по крайней мере один ресурс с ключом в локальной <xref:System.Windows.FrameworkElement.Resources%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStyle">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeStyle" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeStyle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeStyle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает логическое значение, указывающее, следует ли процессам сериализации сериализировать содержимое свойства <see cref="P:System.Windows.FrameworkElement.Style" />.</summary>
        <returns>
          Значение <see langword="true" />, если значение свойства <see cref="P:System.Windows.FrameworkElement.Style" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Будет возвращен `true` Если <xref:System.Windows.Style> установлено локально.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeTriggers">
      <MemberSignature Language="C#" Value="public bool ShouldSerializeTriggers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ShouldSerializeTriggers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.ShouldSerializeTriggers" />
      <MemberSignature Language="VB.NET" Value="Public Function ShouldSerializeTriggers () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ShouldSerializeTriggers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает логическое значение, указывающее, следует ли процессам сериализации сериализировать содержимое свойства <see cref="P:System.Windows.FrameworkElement.Triggers" />.</summary>
        <returns>
          Значение <see langword="true" />, если значение свойства <see cref="P:System.Windows.FrameworkElement.Triggers" /> подлежит сериализации, в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает `true` Если <xref:System.Windows.FrameworkElement.Triggers%2A> свойству локально.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.SizeChangedEventHandler SizeChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.SizeChangedEventHandler SizeChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SizeChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SizeChanged As SizeChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::SizeChangedEventHandler ^ SizeChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении значения любого из свойств <see cref="P:System.Windows.FrameworkElement.ActualHeight" /> или <see cref="P:System.Windows.FrameworkElement.ActualWidth" /> данного элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 События с прямой маршрутизацией не следуют по маршруту, они обрабатываются только внутри элемента, на котором они вызываются. Прямые перенаправленные события поддерживают другое поведение перенаправленных событий: они поддерживают коллекцию доступных обработчиков и могут использоваться как <xref:System.Windows.EventTrigger> в стиле.  
  
 Система макета считывает свойства <xref:System.Windows.SizeChangedEventArgs> класс аргументов этого события, чтобы определить, является ли сообщенные изменения размера должно считаться важным. Это позволяет системе структуры или реализации макет элемента управления, чтобы избежать принудительного обновления структуры из-за визуально незаметной различия между значениями старой и новой высоты или ширины. Из-за округления или одинаковых результатов вычислений типов данных с плавающей запятой может быть незаметным различия.  
  
<a name="routedEventInfo_SizeChanged"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.SizeChangedEvent>|  
|Стратегия маршрутизации|Direct|  
|делегат|<xref:System.Windows.SizeChangedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Height" />
        <altmember cref="P:System.Windows.FrameworkElement.Width" />
      </Docs>
    </Member>
    <Member MemberName="SizeChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent SizeChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent SizeChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.SizeChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ SizeChangedEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует направленное событие <see cref="E:System.Windows.FrameworkElement.SizeChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Идентификаторы перенаправленных событий создаются при их регистрации. Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события. Эти идентификаторы можно использовать для добавления обработчиков классов.  
  
 Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; SourceUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.SourceUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ SourceUpdated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении исходного значения любого существующего свойства, привязанного к данному элементу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие создается псевдоним для <xref:System.Windows.Data.Binding.SourceUpdated> событие, возникающее по любому <xref:System.Windows.Data.Binding> связанные с данным элементом.  
  
<a name="xamlAttributeUsage_SourceUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object SourceUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.SourceUpdated" />
      </Docs>
    </Member>
    <Member MemberName="Style">
      <MemberSignature Language="C#" Value="public System.Windows.Style Style { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Style Style" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Style" />
      <MemberSignature Language="VB.NET" Value="Public Property Style As Style" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Style ^ Style { System::Windows::Style ^ get(); void set(System::Windows::Style ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Style</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает стиль, который должен использоваться этим элементом при его отрисовке.</summary>
        <value>Примененный стиль не по умолчанию для элемента, если присутствует. В противном случае — значение <see langword="null" />. Значение по умолчанию для созданного по умолчанию объекта <see cref="T:System.Windows.FrameworkElement" /> — <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для элементов управления текущий стиль часто предоставляемые стиль по умолчанию из темы элементов управления или из стилей обычно применяется к элементам управления этого типа ресурсами на уровне страницы или приложения (неявный стиль). Данное свойство не устанавливает и не возвращает по умолчанию стили (тема), но возвращает неявный стиль или явный стиль, действующий на элемент. В случае неявных или явных стилей не проверяются ли стиль указан в качестве ресурса или определен локально.  
  
 Задание стилей имеет некоторые ограничения. Вы можете сбросить всего <xref:System.Windows.FrameworkElement.Style%2A> для нового <xref:System.Windows.Style> в любое время, который выполняет принудительное рекомпозиции макета. Тем не менее, как можно раньше этим стилем помещается используется загруженным элементом <xref:System.Windows.Style> следует учитывать sealed. Попытка внести изменение любое отдельное свойство для используемого стиля (такие как что-либо из коллекции <xref:System.Windows.Style.Setters%2A>) приводит к созданию исключения. Стиль, определенный в разметке считается используется сразу после ее загрузки из словаря ресурсов (для ресурсов) или загрузки страницы, в которой он содержится в (для встроенные стили).  
  
 <xref:System.Windows.FrameworkElement.Style%2A> — Это свойство зависимостей с специальные приоритетом. Локально заданное стиль обычно действует с более высоким приоритетом в системе свойств. Если <xref:System.Windows.FrameworkElement.Style%2A> имеет значение null в этот момент во время загрузки в системе свойств проверяет наличие неявных стилей в ресурсах локального или приложения, которые указания этого типа. Если стиль равен null после выполнения этого шага, то действующий стиль для целей презентации обычно поступает из стиля по умолчанию (тема), но стиль по умолчанию не возвращается в <xref:System.Windows.FrameworkElement.Style%2A> значение свойства. В разделе [приоритет значения свойства зависимости](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md) или [Стилизация и использование шаблонов](~/docs/framework/wpf/controls/styling-and-templating.md).  
  
<a name="xamlAttributeUsage_Style"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object Style="{resourceExtension styleResourceKey}"/>  
```  
  
<a name="xamlPropertyElementUsage_Style"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
<a name="xamlValues_Style"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *resourceExtension*  
 Одно из следующих:, или. В разделе [ресурсов XAML](~/docs/framework/wpf/advanced/xaml-resources.md).  
  
 *styleResourceKey*  
 Ключ, идентифицирующий запрашиваемый стиль. Ключ ссылается на существующий ресурс в <xref:System.Windows.ResourceDictionary>.  
  
> [!NOTE]
>  Синтаксис элемента свойства технически возможно, но не рекомендуется для большинства сценариев стилей. В разделе [встроенные стили и шаблоны](~/docs/framework/wpf/advanced/inline-styles-and-templates.md). Ссылка привязки с помощью или <xref:System.Windows.Data.Binding> также является, возможно, но встречается редко.  
  
<a name="dependencyPropertyInfo_Style"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.StyleProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
   
  
## Examples  
 В следующем примере определяется стиль в словаре ресурсов.  
  
 [!code-xaml[FEResource#StyleProperty](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty)]  
[!code-xaml[FEResource#StyleProperty2](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty2)]  
[!code-xaml[FEResource#StyleProperty3](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty3)]  
[!code-xaml[FEResource#StyleProperty4](~/samples/snippets/csharp/VS_Snippets_Wpf/FEResource/CS/default.xaml#styleproperty4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="StyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty StyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty StyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.StyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly StyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ StyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.Style" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable">
      <MemberSignature Language="C#" Value="bool IQueryAmbient.IsAmbientPropertyAvailable (string propertyName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(string propertyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsAmbientPropertyAvailable (propertyName As String) As Boolean Implements IQueryAmbient.IsAmbientPropertyAvailable" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System::String ^ propertyName) = System::Windows::Markup::IQueryAmbient::IsAmbientPropertyAvailable;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="propertyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="propertyName">Имя запрошенного внешнего свойства.</param>
        <summary>Описание этого элемента содержится в методе <see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" />.</summary>
        <returns>
          Значение <see langword="true" />, если свойство с именем в параметре <paramref name="propertyName" /> доступно; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Windows.FrameworkElement> приведен к типу интерфейса <xref:System.Windows.Markup.IQueryAmbient>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Tag">
      <MemberSignature Language="C#" Value="public object Tag { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Tag" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Tag" />
      <MemberSignature Language="VB.NET" Value="Public Property Tag As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Tag { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.NeverLocalize)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка произвольного значения объекта, которое может использоваться для хранения особых сведений об этом элементе.</summary>
        <value>Целевое значение. Это свойство не имеет значения по умолчанию.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство является аналогом тег свойства в других моделях программирования для Microsoft, например Visual Basic для приложений и Windows Forms. <xref:System.Windows.FrameworkElement.Tag%2A> предназначен для предоставления существующие свойства расположению, где можно хранить базовой пользовательской информации о каких-либо <xref:System.Windows.FrameworkElement> без необходимости создать подкласс элемента.  
  
 Поскольку это свойство принимает объект, необходимо использовать использование элемента свойства, чтобы задать <xref:System.Windows.FrameworkElement.Tag%2A> свойства в XAML только на объект с известным и встроенным преобразователя, такие как строка. Объекты, используемые таким образом, обычно не входят в стандартные пространства имен WPF и поэтому может потребоваться сопоставление пространства имен с внешним пространством имен для новых элементов XAML. Дополнительные сведения см. в разделе [пространства имен XAML и сопоставление пространства имен WPF XAML](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md) и [XAML и пользовательские классы для WPF](~/docs/framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md).  
  
<a name="dependencyPropertyInfo_Tag"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.TagProperty>|  
|Значение свойства метаданных `true`|Нет|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.FrameworkElement.Name" />
      </Docs>
    </Member>
    <Member MemberName="TagProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TagProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TagProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.TagProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TagProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TagProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.Tag" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetUpdated">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Windows.Data.DataTransferEventArgs&gt; TargetUpdated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.TargetUpdated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TargetUpdated As EventHandler(Of DataTransferEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Windows::Data::DataTransferEventArgs ^&gt; ^ TargetUpdated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Windows.Data.DataTransferEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении целевого значения для любого свойства, привязанного к этому элементу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие создается псевдоним для <xref:System.Windows.Data.Binding.TargetUpdated> событие, возникающее по любому <xref:System.Windows.Data.Binding> связанные с данным элементом. Обычно это означает, что рассматриваемая является двусторонней привязкой и что свойства привязанного зависимостей подтверждает, что предыдущее значение свойства теперь является недопустимым в соответствии с любой схемой валидации или кэширования, свойство или источник данных поддерживает.  
  
 Использовать данные события из <xref:System.Windows.FrameworkElement.TargetUpdated> событий для определения нужного сообщает обновления значение целевого свойства.  
  
<a name="xamlAttributeUsage_TargetUpdated"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object TargetUpdated="eventHandler"/>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Data.Binding.TargetUpdated" />
      </Docs>
    </Member>
    <Member MemberName="TemplatedParent">
      <MemberSignature Language="C#" Value="public System.Windows.DependencyObject TemplatedParent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.DependencyObject TemplatedParent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.TemplatedParent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TemplatedParent As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::DependencyObject ^ TemplatedParent { System::Windows::DependencyObject ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает ссылку на родительский объект шаблона данного элемента. Это свойство не актуально, если элемент не был создан с помощью шаблона.</summary>
        <value>Элемент, свойство <see cref="T:System.Windows.FrameworkTemplate" /> шаблона <see cref="P:System.Windows.FrameworkTemplate.VisualTree" />  которого вызвало создание данного элемента. Это значение часто равно <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement.TemplatedParent%2A> часто `null` для объектов, создаваемых в разметке приложения или код. Это так, как непосредственно, создания этих объектов не с помощью шаблона. Получен путем прохода логического дерева начиная с корневого или по ссылкам типичное имя ссылки на объекты, не исходят из шаблона.  
  
 Ситуации, когда <xref:System.Windows.FrameworkElement.TemplatedParent%2A> не может быть `null` включает операции, такие как проверка нажатия, обработка событий для определенных низкоуровневых событий ввода, обход визуального дерева с <xref:System.Windows.Media.VisualTreeHelper>, или работа с перечислителями, могут возвращать элементы, поступившие с помощью шаблонов. Другой случай, если явно вызывать <xref:System.Windows.FrameworkTemplate.FindName%2A> от существующего <xref:System.Windows.FrameworkTemplate> и работа с возвращаемого объекта.  
  
 Шаблоны являются фактически общие объекты, в котором содержимое шаблона создаются только один раз. Таким образом Если получить ссылку на элемент, поступивший из шаблона, может оказаться очевидной логического дерева не достигает корня страницы. Чтобы подключить такая ссылка шаблона в дереве логической страницы, вы должны получить <xref:System.Windows.FrameworkElement.TemplatedParent%2A> значения и продолжить для перемещения этого элемента дерева в случае необходимости.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTip">
      <MemberSignature Language="C#" Value="public object ToolTip { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object ToolTip" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.ToolTip" />
      <MemberSignature Language="VB.NET" Value="Public Property ToolTip As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ ToolTip { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Bindable(true)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.Category("Appearance")</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.ToolTip)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает объект подсказки, отображаемый для данного элемента в [!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)].</summary>
        <value>Объект подсказки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение этого свойства имеет тип <xref:System.Windows.Controls.ToolTip>, то это значение будет всплывающей подсказки, будет использоваться в [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)].  Если значение любого другого типа, то это значение будет использоваться в качестве *содержимого* для <xref:System.Windows.Controls.ToolTip> указано (создан) системой. Дополнительные сведения см. в разделе <xref:System.Windows.Controls.ToolTipService>. Служебный класс предоставляет вложенные свойства, которые могут использоваться для дальнейшей настройки <xref:System.Windows.Controls.ToolTip>.  
  
<a name="xamlAttributeUsage_ToolTip"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object ToolTip="toolTipContent"/>  
```  
  
<a name="xamlPropertyElementUsage_ToolTip"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<object>  
  <object.ToolTip>  
    <ToolTip .../>  
  </object.ToolTip>  
</object>  
- or -  
<object>  
  <object.ToolTip>  
    toolTipObjectContent  
  </object.ToolTip>  
</object>  
```  
  
<a name="xamlValues_ToolTip"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *toolTipContent*  
 Строка, которая становится отображаемый текст для <xref:System.Windows.FrameworkElement.ToolTip%2A>.  
  
 *toolTipObjectContent*  
 Некоторые объектом, указанным в форме элемента объекта, который должен использоваться в качестве содержимого для <xref:System.Windows.FrameworkElement> . Обычно это было бы <xref:System.Windows.FrameworkElement> или другой элемент, создающий композиции макета для <xref:System.Windows.FrameworkElement.ToolTip%2A>, в конечном итоге содержащий текстового содержимого в композиции. При таком использовании <xref:System.Windows.Controls.ToolTip> создается элемент неявно из проанализированный [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]и *toolTipObjectContent* содержимое задано как его <xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType> свойство.  
  
 <`ToolTip` .../>  
 См. раздел <xref:System.Windows.Controls.ToolTip>.  
  
<a name="dependencyPropertyInfo_ToolTip"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.ToolTipProperty>|  
|Значение свойства метаданных `true`|Нет|  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Windows.Controls.ToolTip> в коде, а затем устанавливает <xref:System.Windows.FrameworkElement.ToolTip%2A> свойства <xref:System.Windows.Controls.Primitives.StatusBar> элемента управления.  
  
 [!code-csharp[StatusBar#MakeProgressBar](~/samples/snippets/csharp/VS_Snippets_Wpf/StatusBar/CSharp/Window1.xaml.cs#makeprogressbar)]
 [!code-vb[StatusBar#MakeProgressBar](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StatusBar/visualbasic/window1.xaml.vb#makeprogressbar)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosing">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipClosing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipClosing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipClosing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipClosing As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipClosing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит непосредственно перед закрытием какой-либо подсказки в элементе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пометка <xref:System.Windows.FrameworkElement.ToolTipClosing> событие как обработанное не отменяет закрытие подсказки. Если подсказка отображается, закрытие подсказки выполняется только в ответ на взаимодействие пользователя с помощью пользовательского интерфейса.  
  
 Это событие не может быть <xref:System.Windows.EventTrigger> в стиле. Это потому, что поле идентификатора данного события повторно использует реализацию из службы, которая не предоставляет методы добавления и удаления событий для события уровня службы.  
  
<a name="routedEventInfo_ToolTipClosing"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.ToolTipClosingEvent>|  
|Стратегия маршрутизации|Direct|  
|делегат|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   Переопределить <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> реализации класса обработчик данного события в производных классах.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipClosingEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipClosingEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipClosingEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipClosingEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipClosingEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipClosingEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует направленное событие <see cref="E:System.Windows.FrameworkElement.ToolTipClosing" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Идентификаторы перенаправленных событий создаются при их регистрации. Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события. Эти идентификаторы можно использовать для добавления обработчиков классов.  
  
 Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpening">
      <MemberSignature Language="C#" Value="public event System.Windows.Controls.ToolTipEventHandler ToolTipOpening;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.Controls.ToolTipEventHandler ToolTipOpening" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.ToolTipOpening" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ToolTipOpening As ToolTipEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::Controls::ToolTipEventHandler ^ ToolTipOpening;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Controls.ToolTipEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при открытии любой всплывающей подсказки к элементу.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы предотвратить появление в пользовательском Интерфейсе обработчиком для всплывающей подсказки <xref:System.Windows.FrameworkElement.ToolTipOpening> можно пометить <xref:System.Windows.Controls.ToolTipEventArgs> обрабатывать данные события. В противном случае отображается всплывающая подсказка, с использованием значения <xref:System.Windows.FrameworkElement.ToolTip%2A> свойство в качестве содержимого всплывающей подсказки. Другой возможный сценарий заключается в том, что можно написать обработчик, который сбрасывает значение <xref:System.Windows.FrameworkElement.ToolTip%2A> свойства для элемента, который является источником события, непосредственно перед отображением подсказки.  
  
 <xref:System.Windows.FrameworkElement.ToolTipOpening> не будет вызываться, если значение <xref:System.Windows.FrameworkElement.ToolTip%2A> — `null` или в противном случае значение не задано. Не устанавливайте намеренно <xref:System.Windows.FrameworkElement.ToolTip%2A> для `null` пока открыт всплывающей подсказки или открыв; это не будет иметь эффекта закрытия подсказки и создаст нежелательный визуальный артефакт в пользовательском Интерфейсе.  
  
 <xref:System.Windows.FrameworkElement.ToolTipOpening> Событие не может быть <xref:System.Windows.EventTrigger> в стиле. Это потому, что поле идентификатора данного события повторно использует реализацию из службы, которая не предоставляет методы добавления и удаления событий для события уровня службы.  
  
<a name="routedEventInfo_ToolTipOpening"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.ToolTipOpeningEvent>|  
|Стратегия маршрутизации|Direct|  
|делегат|<xref:System.Windows.Controls.ToolTipEventHandler>|  
  
-   Переопределить <xref:System.Windows.FrameworkElement.OnToolTipClosing%2A> реализации класса обработчик данного события в производных классах.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.ToolTip" />
      </Docs>
    </Member>
    <Member MemberName="ToolTipOpeningEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent ToolTipOpeningEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent ToolTipOpeningEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipOpeningEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipOpeningEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ ToolTipOpeningEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует направленное событие <see cref="E:System.Windows.FrameworkElement.ToolTipOpening" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Идентификаторы перенаправленных событий создаются при их регистрации. Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события. Эти идентификаторы можно использовать для добавления обработчиков классов.  
  
 Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToolTipProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ToolTipProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ToolTipProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.ToolTipProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ToolTipProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ToolTipProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.ToolTip" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Triggers">
      <MemberSignature Language="C#" Value="public System.Windows.TriggerCollection Triggers { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.TriggerCollection Triggers" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Triggers" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Triggers As TriggerCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::TriggerCollection ^ Triggers { System::Windows::TriggerCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.TriggerCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает коллекцию триггеров, установленных непосредственно в этом элементе или в его дочерних элементах.</summary>
        <value>Строго типизированная коллекция объектов <see cref="T:System.Windows.Trigger" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Это свойство может быть задано только в [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)] через показанного синтаксиса коллекции или путем доступа к объекту коллекции и использования его различных методов, например Add. Свойство для доступа к объекту коллекции доступно только для чтения, сама коллекция доступна для чтения и записи. Свойство существует только в корневых элементах; Попытка найти или задать в другом месте приведет к созданию исключения.  
  
 Это свойство позволяет проверять триггеры, существующие как часть стилей, используемых для этого элемента. Он только сообщает коллекцию триггеров, которые буквально добавляются в коллекцию, либо в разметке или коде. Элементы обычно не имеют таких элементов по умолчанию (через шаблон для экземпляра); Это чаще используются триггеры, поступающие из композиции элементов управления, чтобы установить его в стилях.  
  
 С точки зрения поведения (и устанавливается, какой эффект поступил из объявленного элемента <xref:System.Windows.FrameworkElement.Triggers%2A> коллекции), условие триггера и его эффект может быть на этот элемент, или его дочерних элементов в логическом дереве. Обратите внимание, что при использовании события времени жизни <xref:System.Windows.FrameworkElement.Loaded> для получения этой коллекции, триггеры дочернего элемента могут еще не быть полной загрузки и коллекция будет меньше, чем было бы действительно во время выполнения.  
  
 Обратите внимание, что коллекция триггеров, установленных на элементе поддерживает только <xref:System.Windows.EventTrigger>, не триггеры свойств (<xref:System.Windows.Trigger>). Если требуются триггеры свойств, необходимо разместить их в стиле или шаблоне и затем назначить этот стиль или шаблон элемента либо напрямую с помощью <xref:System.Windows.FrameworkElement.Style%2A> свойства, либо косвенно через неявную ссылку на стиль.  
  
<a name="xamlPropertyElementUsage_Triggers"></a>   
## <a name="xaml-property-element-usage"></a>Использование элемента свойства XAML  
  
```  
<object>  
  <object.Triggers>  
    oneOrMoreTriggers  
  </object.Triggers>  
</object>  
```  
  
<a name="xamlValues_Triggers"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *oneOrMoreTriggers*  
 Один или несколько определенных <xref:System.Windows.EventTrigger> элементов. Каждый такой триггер должен содержать допустимые действия раскадровки и ссылки. Обратите внимание, что эта коллекция может быть установлено только в корневом элементе страницы. Дополнительные сведения см. в разделе [Общие сведения о Storyboard](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.EventTrigger" />
      </Docs>
    </Member>
    <Member MemberName="TryFindResource">
      <MemberSignature Language="C#" Value="public object TryFindResource (object resourceKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object TryFindResource(object resourceKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.TryFindResource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFindResource (resourceKey As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ TryFindResource(System::Object ^ resourceKey);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceKey" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="resourceKey">Ключевой идентификатор искомого ресурса.</param>
        <summary>Ищет ресурс с указанным ключом и возвращает его, если он найден.</summary>
        <returns>Найденный ресурс или значение <see langword="null" />, если ресурс с указанным <paramref name="key" /> не обнаружен.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если ресурс не найден в вызывающем элементе, выполняется поиск в дереве ресурсов родительского вверх по дереву логических, таким же образом, что было бы дереве поисковое Если ресурс был запрошен по ключу во время выполнения. Метод возвращает `null` только в том случае, если ресурс этого ключа не существует в любом месте в дереве ресурсов на существующих условий дерева во время, <xref:System.Windows.FrameworkElement.TryFindResource%2A> вызывается.  
  
 Обычно вы сразу же привести возвращаемое значение к типу свойства, которое вы пытаетесь набор с возвращенным значением ресурса.  
  
 <xref:System.Windows.FrameworkElement.FindResource%2A> Метод имеет аналогичное поведение, за исключением того, метод создает исключение, если ресурс с указанным ключом не был возвращен.  
  
   
  
## Examples  
 Следующий пример реализуется как обработчик кнопки, где кнопке выбираемой наборов его фоновой кисти ресурс определен получается вызовом <xref:System.Windows.FrameworkElement.TryFindResource%2A> на себя. Это обходит дерево элементов и поиск ресурса (сам ресурс определен в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] и не отображается).  
  
 [!code-csharp[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/csharp/VS_Snippets_Wpf/BaseElementsSmorgasbord/CSharp/Page1.xaml.cs#fetryfindresource)]
 [!code-vb[BaseElementsSmorgasbord#FETryFindResource](~/samples/snippets/visualbasic/VS_Snippets_Wpf/BaseElementsSmorgasbord/visualbasic/page1.xaml.vb#fetryfindresource)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.FindResource(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Unloaded">
      <MemberSignature Language="C#" Value="public event System.Windows.RoutedEventHandler Unloaded;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.RoutedEventHandler Unloaded" />
      <MemberSignature Language="DocId" Value="E:System.Windows.FrameworkElement.Unloaded" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloaded As RoutedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::RoutedEventHandler ^ Unloaded;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при удалении элемента из дерева с загруженными элементами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 События с прямой маршрутизацией не следуют по маршруту, они обрабатываются только внутри элемента, на котором они вызываются. Прямые перенаправленные события поддерживают другое поведение перенаправленных событий: они поддерживают коллекцию доступных обработчиков и могут использоваться как <xref:System.Windows.EventTrigger> в стиле.  
  
 <xref:System.Windows.FrameworkElement.Loaded> и <xref:System.Windows.FrameworkElement.Unloaded> и может быть вызвано в элементе управления, в результате изменения темы инициированной пользователем системы. Изменение темы делает недействительность шаблон элемента управления и автономной визуального дерева, который в свою очередь вызывает выгрузке и повторной загрузке всего элемента управления. Поэтому <xref:System.Windows.FrameworkElement.Unloaded> не может предположить, что возникают только при навигации страницы на другую.  
  
 Обратите внимание, что <xref:System.Windows.FrameworkElement.Unloaded> событие не происходит после начала приложение завершает работу. Выключение приложения выполняется, если условие предиката <xref:System.Windows.Application.ShutdownMode%2A> происходит свойство. Если поместить код очистки в обработчик <xref:System.Windows.FrameworkElement.Unloaded> событий, таких как <xref:System.Windows.Window> или <xref:System.Windows.Controls.UserControl>, он не может вызываться должным образом.  
  
<a name="routedEventInfo_Unloaded"></a>   
## <a name="routed-event-information"></a>Сведения о маршрутизируемом событии  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.UnloadedEvent>|  
|Стратегия маршрутизации|Direct|  
|делегат|<xref:System.Windows.RoutedEventHandler>|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="UnloadedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent UnloadedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent UnloadedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UnloadedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UnloadedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ UnloadedEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует направленное событие <see cref="E:System.Windows.FrameworkElement.Unloaded" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Идентификаторы перенаправленных событий создаются при их регистрации. Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события. Эти идентификаторы можно использовать для добавления обработчиков классов.  
  
 Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <xref:System.Windows.EventManager.RegisterRoutedEvent%2A>. Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <xref:System.Windows.EventManager.RegisterClassHandler%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnregisterName">
      <MemberSignature Language="C#" Value="public void UnregisterName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UnregisterName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UnregisterName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnregisterName (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UnregisterName(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя пары имя-объект, которую необходимо удалить из текущей области видимости.</param>
        <summary>Упрощает доступ к методу отмены регистрации <see cref="T:System.Windows.NameScope" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Только необходимо отменить регистрацию имен Если предполагается повторно зарегистрировать другой элемент с таким же именем.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)" />
        <altmember cref="T:System.Windows.NameScope" />
      </Docs>
    </Member>
    <Member MemberName="UpdateDefaultStyle">
      <MemberSignature Language="C#" Value="public void UpdateDefaultStyle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void UpdateDefaultStyle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkElement.UpdateDefaultStyle" />
      <MemberSignature Language="VB.NET" Value="Public Sub UpdateDefaultStyle ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void UpdateDefaultStyle();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Повторно применяет стиль по умолчанию к текущему объекту <see cref="T:System.Windows.FrameworkElement" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRounding">
      <MemberSignature Language="C#" Value="public bool UseLayoutRounding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseLayoutRounding" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.UseLayoutRounding" />
      <MemberSignature Language="VB.NET" Value="Public Property UseLayoutRounding As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseLayoutRounding { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, должно ли применяться округление макета для размера и позиции данного элемента во время структурирования.</summary>
        <value>
          Значение <see langword="true" />, если округление структуры применяется; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> свойство элемента является `true`, все пикселей не целочисленного значения, которые вычисляются во время <xref:System.Windows.UIElement.Measure%2A> и <xref:System.Windows.UIElement.Arrange%2A> передает округляются до целых значений пикселей.  
  
 Данное свойство наследуется дочерними элементами.  
  
> [!NOTE]
>  Необходимо задать <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> для `true` для корневого элемента. Система макета добавляет координаты дочернего координатам родительского; Таким образом Если координаты родительского элемента не на границе пикселов, координаты дочернего, также не на границе пикселов. Если <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> нельзя задать в корне, установите <xref:System.Windows.UIElement.SnapsToDevicePixels%2A> для дочернего элемента для получения необходимого эффекта.  
  
 Графические объекты на границах пикселей устраняет полупрозрачные края, производимые сглаживания, когда граница попадает на середину пикселя устройства. Ниже показан результат выполнения одного пикселя ширины строки, приходится на середину пикселя устройства. Строки в левой части не использует округление макета и является значение свойства. Строка справа использует округление макета.  
  
 ![Приложения для защиты&#45;псевдоним линия в сравнении с одного пикселя в высоту строки. ] (~/add/media/pixelsnaplinecompare.PNG "Сглаженная линия в сравнении с линией из одного пикселя в высоту.")  
  
 При использовании округление макета и <xref:System.Windows.GridUnitType.Star> изменения размера, система макета создает небольшие вариации в измерениях столбцов или строк во избежание субпиксельной визуализации. Например, если сетка содержит общая ширина 100 с 3 столбцами размера <xref:System.Windows.GridUnitType.Star>, вместо создания трех столбцов, имеющих ширину 33,3, система макета создает 2 столбца, имеющих ширину 33 и один шириной 34.  
  
> [!NOTE]
>  В .NET 4.6 для снижения числа вхождений обрезки в элементах управления с границами округление макетов внесены изменения. По умолчанию эта функция включена, если свою целевую платформу .NET Framework 4.6 или более поздней версии. Приложения, которые предназначены для более ранних версий платформы, можно выбрать в новое поведение, добавив следующий параметр в файл app.config: `<runtime><AppContextSwitchOverrides value="Switch.MS.Internal.DoNotApplyLayoutRoundingToMarginsAndBorderThickness=false"/></runtime>` параметр вступает в силу только при запуске приложения на платформе .NET Framework 4.6.  
  
   
  
## Examples  
 В следующем примере демонстрируется эффект, <xref:System.Windows.FrameworkElement.UseLayoutRounding%2A> свойство имеет на один пиксель ширины строки. Строки в левой части не использует округление макета и строка справа использует округление макета. Если медленно изменять размер окна, можно увидеть разницу, создаваемую округлением макета.  
  
```xaml  
  
<Page x:Class="LayoutRounding.Lines"  
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"  
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"  
    Title="Lines" Name="linesPage"  
    >  
  <StackPanel Width="150"  Margin="7" Orientation="Horizontal">  
    <!-- Single pixel line with layout rounding turned OFF.-->  
    <Rectangle UseLayoutRounding="False"  
       Width="45.5" Margin="10" Height="1" Fill="Red"/>  
    <!-- Single pixel line with layout rounding turned ON.-->  
    <Rectangle UseLayoutRounding="True"  
      Width="45.5" Margin="10" Height="1" Fill="Red"/>  
  </StackPanel>  
  <!-- Background Grid -->  
  <Page.Background>  
    <DrawingBrush  Viewport="0,0,10,10" ViewportUnits="Absolute" TileMode="Tile">  
      <DrawingBrush.Drawing>  
        <DrawingGroup>  
          <GeometryDrawing Brush="White">  
            <GeometryDrawing.Geometry>  
              <RectangleGeometry Rect="0,0,1,1" />  
            </GeometryDrawing.Geometry>  
          </GeometryDrawing>  
          <GeometryDrawing Geometry="M0,0 L1,0 1,0.1, 0,0.1Z " Brush="#CCCCFF" />  
          <GeometryDrawing Geometry="M0,0 L0,1 0.1,1, 0.1,0Z" Brush="#CCCCFF" />  
        </DrawingGroup>  
      </DrawingBrush.Drawing>  
    </DrawingBrush>  
  </Page.Background>  
</Page>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UseLayoutRoundingProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty UseLayoutRoundingProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty UseLayoutRoundingProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.UseLayoutRoundingProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly UseLayoutRoundingProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ UseLayoutRoundingProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.UseLayoutRounding" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignment">
      <MemberSignature Language="C#" Value="public System.Windows.VerticalAlignment VerticalAlignment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.VerticalAlignment VerticalAlignment" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VerticalAlignment" />
      <MemberSignature Language="VB.NET" Value="Public Property VerticalAlignment As VerticalAlignment" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::VerticalAlignment VerticalAlignment { System::Windows::VerticalAlignment get(); void set(System::Windows::VerticalAlignment value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.VerticalAlignment</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает характеристики выравнивания по вертикали, применяемые к этому элементу при его размещении в родительском элементе, например в панели или элементе управления элементами.</summary>
        <value>Настройка вертикального выравнивания. Значение по умолчанию: <see cref="F:System.Windows.VerticalAlignment.Stretch" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Windows.FrameworkElement.Height%2A> и <xref:System.Windows.FrameworkElement.Width%2A> от элемента явно заданы свойства, этих измерений имеют приоритет и отменяют обычный эффект от присвоить этому свойству значение <xref:System.Windows.VerticalAlignment.Stretch>.  
  
 <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> — [!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)] доступа свойства для Какова на самом деле свойство зависимостей. Это свойство определенная зависимость довольно часто имеет значение «по умолчанию» по-разному в производных классах элементов, особенно элементов управления. Обычно такая ситуация возникает в одном из двух способов: свойство зависимостей повторно зарегистрирован для определенного производного класса, но с другой метаданных для задания значения по умолчанию; либо стиль по умолчанию применяется, который задает это значение свойства зависимостей по-разному. Например, «по умолчанию» для <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> для <xref:System.Windows.Controls.ComboBoxItem> элемент управления будет <xref:System.Windows.VerticalAlignment.Center>, даже если <xref:System.Windows.Controls.ComboBoxItem> наследует <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> непосредственно от <xref:System.Windows.FrameworkElement>. Это, поскольку это значение было сброшено в качестве стиля по умолчанию <xref:System.Windows.Controls.ComboBoxItem>, в шаблоне элемента управления стилем.  
  
 <xref:System.Windows.Controls.Canvas> не используйте <xref:System.Windows.FrameworkElement.VerticalAlignment%2A> при создании макета, так как <xref:System.Windows.Controls.Canvas> основывающаяся на абсолютном позиционировании.  
  
 Если наследуемые <xref:System.Windows.Controls.ComboBoxItem> или любых производных классов, <xref:System.Windows.Controls.ComboBoxItem> переопределяет значение по умолчанию этого свойства было <xref:System.Windows.VerticalAlignment.Center>.  
  
<a name="dependencyPropertyInfo_VerticalAlignment"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.VerticalAlignmentProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VerticalAlignmentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty VerticalAlignmentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty VerticalAlignmentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.VerticalAlignmentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly VerticalAlignmentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ VerticalAlignmentProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.VerticalAlignment" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="VisualChildrenCount">
      <MemberSignature Language="C#" Value="protected override int VisualChildrenCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 VisualChildrenCount" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.VisualChildrenCount" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides ReadOnly Property VisualChildrenCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual property int VisualChildrenCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает количество визуальных дочерних элементов внутри этого элемента.</summary>
        <value>Количество визуальных дочерних элементов для этого элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> Реализация <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> всегда возвращает 0 или 1. Классы, которые поддерживают, может превышать одну коллекцию визуальных дочерних необходимо переопределить и это свойство и <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  
  
 Это свойство обычно используется для определения верхней границы в текущей коллекции дочерних для целей реализации переопределений макета (<xref:System.Windows.FrameworkElement.MeasureOverride%2A>, <xref:System.Windows.FrameworkElement.ArrangeOverride%2A>).  
  
   
  
## Examples  
 В следующем примере показано, как пользовательский графический элемент использует значения, объявленные с <xref:System.Windows.Media.VisualCollection> он поддерживает для множества визуальных дочерних элементов и сообщает эти значения через переопределения <xref:System.Windows.FrameworkElement.VisualChildrenCount%2A> и <xref:System.Windows.FrameworkElement.GetVisualChild%2A>.  
  
 [!code-csharp[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverridespre)]
 [!code-vb[Adorners_ResizingAdorner#FEVisualOverridesPre](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverridespre)]  
[!code-csharp[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/csharp/VS_Snippets_Wpf/Adorners_ResizingAdorner/CSharp/ResizingAdorner.cs#fevisualoverrides)]
[!code-vb[Adorners_ResizingAdorner#FEVisualOverrides](~/samples/snippets/visualbasic/VS_Snippets_Wpf/Adorners_ResizingAdorner/visualbasic/resizingadorner.vb#fevisualoverrides)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Если ваш класс поддерживает более одного визуального дочернего элемента в коллекцию дочерних элементов, переопределите это свойство, чтобы возвращать число элементов в этой коллекции. Это необходимо выполнить, даже если сам объект коллекции возвращает счетчик. Логику макета элемента на уровне WPF framework предполагает, что все элементы будут возвращать допустимое значение счетчика через их <see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" /> свойство.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Width">
      <MemberSignature Language="C#" Value="public double Width { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Width" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkElement.Width" />
      <MemberSignature Language="VB.NET" Value="Public Property Width As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Width { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.LengthConverter))</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.None, Readability=System.Windows.Readability.Unreadable)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка ширины элемента.</summary>
        <value>Ширина элемента в [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]. Значение по умолчанию — <see cref="F:System.Double.NaN" />. Это значение должно быть не меньше 0,0. Сведения о верхней границе см. в разделе "Примечания".</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это один из трех свойств на <xref:System.Windows.FrameworkElement> , укажите ширину сведения.  Два других — <xref:System.Windows.FrameworkElement.MinWidth%2A> и <xref:System.Windows.FrameworkElement.MaxWidth%2A>.  Если возникает конфликт между этими значениями, порядок приложения для определения фактическую ширину первый <xref:System.Windows.FrameworkElement.MinWidth%2A> должен быть принят на обработку, затем <xref:System.Windows.FrameworkElement.MaxWidth%2A>и, наконец, если каждый из них находятся в пределах границ, <xref:System.Windows.FrameworkElement.Width%2A>.  
  
 Возвращаемое значение этого свойства всегда является таким же, как любое значение, которое было задано. Напротив, значение <xref:System.Windows.FrameworkElement.ActualWidth%2A> могут различаться. Макет может отклонить предполагаемый размер по некоторым причинам. Кроме того, сама система структуры работает асинхронно относительно набора системных свойств <xref:System.Windows.FrameworkElement.Width%2A> и может не обработать конкретное изменение свойства размера еще.  
  
 В дополнение к допустимого <xref:System.Double> значения, это свойство также может быть <xref:System.Double.NaN?displayProperty=nameWithType>. Это показано, как указать поведение автоматического изменения размеров. В [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] значение в строку «Auto» (без учета регистра) чтобы включить автоматическое изменение размеров. Автоматическое изменение размеров предполагает, что элемент заполнит доступную ему ширину. Обратите внимание, что определенные элементы управления передают значения по умолчанию в их стили по умолчанию, которые отключают автоматическое изменение размеров, если он не является специально не включить повторно.  
  
 В дополнение к проверке подлинности является недетерминированной наибольшее значение, привязанное к <xref:System.Windows.FrameworkElement.Width%2A> , обеспечивается системой макета (это очень большое число, большее, чем <xref:System.Single.MaxValue?displayProperty=nameWithType> но меньше, чем <xref:System.Double.MaxValue?displayProperty=nameWithType>). Если превысить это ограничение, элемент не будет отображаться, и исключение не возникает. Не устанавливайте <xref:System.Windows.FrameworkElement.Width%2A> значение значительно больше, чем максимальный размер любого возможного визуального дисплея, или может превысить эту недетерминированную верхнюю границу.  
  
<a name="xamlAttributeUsage_Width"></a>   
## <a name="xaml-attribute-usage"></a>Использование атрибута XAML  
  
```  
<object Width="double"/>  
- or –  
<object Width ="qualifiedDouble"/>  
- or -  
<object Width ="Auto"/>  
```  
  
<a name="xamlValues_Width"></a>   
## <a name="xaml-values"></a>Значения XAML  
 *double*  
 <xref:System.Double>  
  
 Строковое представление <xref:System.Double> значение, равное или больше 0,0. Сведения о верхней границе см. в разделе "Примечания". Это значение интерпретируется как [!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)] измерения. Строки не нужно явно указывать десятичного разделителя. Для экземпляра значение `1` является допустимым.  
  
 *qualifiedDouble*  
 Объект *двойные* значение как описано выше, за которым следует один из следующих строк объявления единицы измерения: `px`, `in`, `cm`, `pt`.  
  
 `px` (по умолчанию) [!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]  
  
 `in` дюймах; 1 дюйм == 96 точек  
  
 `cm` сантиметрах; 1см==(96/2,54) пкс  
  
 `pt` точках; 1точка==(96/72) пкс  
  
 `Auto`  
 Включает автоматическое определение размера. См. заметки.  
  
<a name="dependencyPropertyInfo_Width"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.FrameworkElement.WidthProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WidthProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WidthProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WidthProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.FrameworkElement.WidthProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WidthProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WidthProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.FrameworkElement.Width" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>