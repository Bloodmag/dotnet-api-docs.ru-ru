<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="FrameworkElement.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac518d1098f1b9a5e35ee665acf1608578bf6a2bb4f.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">18d1098f1b9a5e35ee665acf1608578bf6a2bb4f</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkElement">
          <source>Provides a WPF framework-level set of properties, events, and methods for Windows Presentation Foundation (WPF) elements.</source>
          <target state="translated">Предоставляет набор свойств, событий и методов уровня платформы WPF для элементов Windows Presentation Foundation (WPF).</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkElement">
          <source>This class represents the provided WPF framework-level implementation that is built on the WPF core-level APIs that are defined by <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph>.</source>
          <target state="translated">Этот класс представляет предоставленную реализацию уровня платформы WPF, созданную на базе API уровня ядра WPF, которые определяются <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkElement">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> is the connecting point between WPF framework-level element classes and the WPF core-level set of <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> presentation services.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> Представляет точку соединения между классами элементов уровня платформы WPF и набора уровня ядра WPF <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> службами презентации.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkElement">
          <source>For more information about these concepts, see <bpt id="p1">[</bpt>WPF Architecture<ept id="p1">](~/docs/framework/wpf/advanced/wpf-architecture.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об этих понятиях см. в разделе <bpt id="p1">[</bpt>архитектура WPF<ept id="p1">](~/docs/framework/wpf/advanced/wpf-architecture.md)</ept>.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkElement">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> extends <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> and adds the following capabilities:</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> расширяет <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph> и добавляет следующие возможности:</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkElement">
          <source><bpt id="p1">**</bpt>Layout system definition<ept id="p1">**</ept>: <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> provides specific WPF framework-level implementations for certain methods that were defined as virtual members in  <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">**</bpt>Определение системы макета<ept id="p1">**</ept>: <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> предоставляет определенные реализации уровня платформы WPF для некоторых методов, которые были определены как виртуальные члены в <ph id="ph2">&lt;xref:System.Windows.UIElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkElement">
          <source>Most notably, <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> seals certain WPF core-level layout overrides, and instead provides a WPF framework-level equivalent that derived classes should override instead.</source>
          <target state="translated">Прежде всего <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> запечатывает некоторые переопределения макета уровня ядра WPF, а вместо этого предоставляет эквивалента уровня инфраструктуры WPF, которые производные классы должны переопределять вместо.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkElement">
          <source>For example, <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> seals <ph id="ph2">&lt;xref:System.Windows.UIElement.ArrangeCore%2A&gt;</ph> but provides <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.ArrangeOverride%2A&gt;</ph>.</source>
          <target state="translated">Например <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> печати <ph id="ph2">&lt;xref:System.Windows.UIElement.ArrangeCore%2A&gt;</ph> , но предоставляет <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.ArrangeOverride%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkElement">
          <source>These changes reflect the fact that at the WPF framework-level there is a full layout system in place that can render any <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> derived class.</source>
          <target state="translated">Эти изменения отражают тот факт, на уровня платформы WPF это полная система структуры на месте, который может преобразовать любой <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> производного класса.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkElement">
          <source>At the WPF core level, certain members that will structure a general <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> based layout solution are in place, but the actual engine of the layout system is not defined.</source>
          <target state="translated">В WPF основы уровня, некоторые элементы, которые будут структуры общая <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> решения на основе макета в месте, но фактические ядра системы макета не определен.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkElement">
          <source>For more information, see <bpt id="p1">[</bpt>Layout<ept id="p1">](~/docs/framework/wpf/advanced/layout.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>макета<ept id="p1">](~/docs/framework/wpf/advanced/layout.md)</ept>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkElement">
          <source><bpt id="p1">**</bpt>The logical tree:<ept id="p1">**</ept> The general <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> programming model is often expressed in terms of being a tree of elements.</source>
          <target state="translated"><bpt id="p1">**</bpt>Логическое дерево:<ept id="p1">**</ept> Общие <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> модели программирования обычно выражается в терминах выполняется дерево элементов.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkElement">
          <source>Support for expressing the tree of elements as a logical tree, and accompanying support for defining that tree in markup is implemented at the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> level.</source>
          <target state="translated">Поддержка выражения дерева элементов в логическом дереве и сопутствующие поддержки для определения этого дерева в разметке реализуется на <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> уровне.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkElement">
          <source>Note however that <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> deliberately does not define a content model, and leaves that responsibility to derived classes.</source>
          <target state="translated">Примечание тем не менее, <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> намеренно не определяет модель содержимого и оставляя эту ответственность производным классам.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkElement">
          <source>For more information, see <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Деревья в WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkElement">
          <source><bpt id="p1">**</bpt>Object lifetime events:<ept id="p1">**</ept> It is often useful to know when an element is initialized (the constructor is called) or when the element is first loaded into a logical tree.</source>
          <target state="translated"><bpt id="p1">**</bpt>Объект события времени жизни:<ept id="p1">**</ept> часто бывает полезно знать, когда инициализируется элемент (конструктор вызывается) или при первой загрузке элемента в логическом дереве.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkElement">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> defines several events related to object lifetime that provide useful hooks for code-behind operations that involve elements, such as adding more child elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> определяет несколько событий, связанных с временем жизни объекта, которые предоставляют полезные обработчики для кода операции, которые включают элементы, такие как добавление нескольких дочерних элементов.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkElement">
          <source>For more information, see <bpt id="p1">[</bpt>Object Lifetime Events<ept id="p1">](~/docs/framework/wpf/advanced/object-lifetime-events.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>события времени жизни объектов<ept id="p1">](~/docs/framework/wpf/advanced/object-lifetime-events.md)</ept>.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkElement">
          <source><bpt id="p1">**</bpt>Support for data binding and dynamic resource references:<ept id="p1">**</ept> The property-level support for data binding and resources is implemented by the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> class and embodied in the property system, but the ability to resolve a member value that is stored as an <ph id="ph2">&lt;xref:System.Windows.Expression&gt;</ph> (the programming construct that underlies both data binding and dynamic resources) is implemented by <ph id="ph3">&lt;xref:System.Windows.FrameworkElement&gt;</ph>.</source>
          <target state="translated"><bpt id="p1">**</bpt>Поддержка привязки данных и ссылки на динамический ресурс:<ept id="p1">**</ept> реализуется поддержка уровня свойств для привязки данных и ресурсы <ph id="ph1">&lt;xref:System.Windows.DependencyProperty&gt;</ph> класса и встроенного в системе свойств, но возможность разрешения значение элемента, хранятся в виде <ph id="ph2">&lt;xref:System.Windows.Expression&gt;</ph> (программных конструкций, лежащей в основе привязка данных и динамические ресурсы) реализуется <ph id="ph3">&lt;xref:System.Windows.FrameworkElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkElement">
          <source>For more information, see <bpt id="p1">[</bpt>Data Binding Overview<ept id="p1">](~/docs/framework/wpf/data/data-binding-overview.md)</ept> and <bpt id="p2">[</bpt>XAML Resources<ept id="p2">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Общие сведения о привязке данных<ept id="p1">](~/docs/framework/wpf/data/data-binding-overview.md)</ept> и <bpt id="p2">[</bpt>ресурсов XAML<ept id="p2">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkElement">
          <source><bpt id="p1">**</bpt>Styles:<ept id="p1">**</ept> <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> defines the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Style%2A&gt;</ph> property.</source>
          <target state="translated"><bpt id="p1">**</bpt>Стили:<ept id="p1">**</ept> <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> определяет <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Style%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkElement">
          <source>However, <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> does not yet define support for templates, or support decorators.</source>
          <target state="translated">Однако <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> еще не определить поддержку для шаблонов, или поддерживает декораторов.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkElement">
          <source>These features are introduced by control classes such as <ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Controls.ContentControl&gt;</ph>.</source>
          <target state="translated">Эти функции представлены классы элементов управления, таких как <ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.Controls.ContentControl&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkElement">
          <source><bpt id="p1">**</bpt>More animation support:<ept id="p1">**</ept> Some animation support was already defined at the WPF core level, but <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> extends this by implementing <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.BeginStoryboard%2A&gt;</ph> and related members.</source>
          <target state="translated"><bpt id="p1">**</bpt>Дополнительная поддержка анимации:<ept id="p1">**</ept> некоторую поддержку анимации уже был определен на уровне ядра WPF, но <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> расширяет это путем реализации <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.BeginStoryboard%2A&gt;</ph> и связанных с ними элементов.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkElement">
          <source>As can be seen from the class hierarchy, many <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> classes derive from <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, either directly or through intermediate base classes such as <ph id="ph3">&lt;xref:System.Windows.Controls.Panel&gt;</ph> or <ph id="ph4">&lt;xref:System.Windows.Controls.Control&gt;</ph>.</source>
          <target state="translated">Как видно из иерархии классов много <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> классы являются производными от <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, напрямую либо через промежуточный базовые классы, такие как <ph id="ph3">&lt;xref:System.Windows.Controls.Panel&gt;</ph> или <ph id="ph4">&lt;xref:System.Windows.Controls.Control&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkElement">
          <source>If you intend to use <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> as a base class, you might want to first examine the existing derived classes.</source>
          <target state="translated">Если вы планируете использовать <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> как базовый класс, может потребоваться сначала проверить существующие производные классы.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkElement">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> provides support for a number of basic scenarios, but also lacks a number of features that are desirable for an "element" in the sense of a building block that you use to create <ph id="ph2">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> in <ph id="ph3">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> обеспечивает поддержку нескольких основных сценариев, но также не имеет ряд возможностей, которые предпочтительны для «element» в том смысле стандартного блока, который используется для создания <ph id="ph2">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> в <ph id="ph3">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkElement">
          <source>For instance, a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> does not define any true content model; <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> as a base class does not define a property that can create <ph id="ph3">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> child elements.</source>
          <target state="translated">Например <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> не определяет true модели содержимого; <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> как базовый класс не определяет свойство, которое можно создать <ph id="ph3">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> дочерних элементов.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.FrameworkElement">
          <source>In particular, you might want to look at <ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Controls.ContentControl&gt;</ph>.</source>
          <target state="translated">В частности, может потребоваться рассмотреть <ph id="ph1">&lt;xref:System.Windows.Controls.Control&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.Controls.ContentControl&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> class.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.ActualHeight">
          <source>Gets the rendered height of this element.</source>
          <target state="translated">Возвращает визуализированную высоту данного элемента.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ActualHeight">
          <source>The element's height, as a value in <ph id="ph1">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph>.</source>
          <target state="translated">Высота элемента, представленная в <ph id="ph1">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ActualHeight">
          <source>The default value is 0 (zero).</source>
          <target state="translated">Значение по умолчанию — 0 (нуль).</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ActualHeight">
          <source>This property is a calculated value based on other height inputs, and the layout system.</source>
          <target state="translated">Это свойство имеет значение, вычисленное на основе других входных значений высоты и системы макета.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ActualHeight">
          <source>The value is set by the layout system itself, based on an actual rendering pass, and may therefore lag slightly behind the set value of properties such as <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph> that are the basis of the input change.</source>
          <target state="translated">Значение задается самой системой макета в зависимости от фактического прохода отрисовки, а может поэтому немного отставать от установки значений свойств таких как <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph> , служат основой для изменения ввода.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ActualHeight">
          <source>Because <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ActualHeight%2A&gt;</ph> is a calculated value, you should be aware that there could be multiple or incremental reported changes to it as a result of various operations by the layout system.</source>
          <target state="translated">Поскольку <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ActualHeight%2A&gt;</ph> является вычисляемым значением, следует иметь в виду, может существовать несколько или инкрементные делает его в результате выполнения различных операций системы макета.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ActualHeight">
          <source>The layout system may be calculating required measure space for child elements, constraints by the parent element, and so on.</source>
          <target state="translated">Система макета может вычислять требуемое место измерения для дочерних элементов, ограничения родительского элемента и т. д.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ActualHeight">
          <source>Although you cannot set this property from <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, you can base a <ph id="ph2">&lt;xref:System.Windows.Trigger&gt;</ph> upon its value in a style.</source>
          <target state="translated">Несмотря на то, что невозможно задать это свойство из <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, можно построить <ph id="ph2">&lt;xref:System.Windows.Trigger&gt;</ph> после его значение в стиле.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ActualHeight">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ActualHeight">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ActualHeight">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ActualHeight">
          <source>None</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ActualHeight">
          <source>The following example displays various height properties.</source>
          <target state="translated">Следующий пример показывает различные свойства высоты.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.ActualHeightProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.ActualHeight" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.ActualHeight" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.ActualWidth">
          <source>Gets the rendered width of this element.</source>
          <target state="translated">Возвращает визуализированную ширину данного элемента.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ActualWidth">
          <source>The element's width, as a value in <ph id="ph1">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph>.</source>
          <target state="translated">Ширина элемента, представленная в <ph id="ph1">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ActualWidth">
          <source>The default value is 0 (zero).</source>
          <target state="translated">Значение по умолчанию — 0 (нуль).</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ActualWidth">
          <source>This property is a calculated value based on other width inputs, and the layout system.</source>
          <target state="translated">Это свойство имеет значение, вычисленное на основе других входных значений ширины и системы макета.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ActualWidth">
          <source>The value is set by the layout system itself, based on an actual rendering pass, and may therefore lag slightly behind the set value of properties such as <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph> that are the basis of the input change.</source>
          <target state="translated">Значение задается самой системой макета в зависимости от фактического прохода отрисовки, а может поэтому немного отставать от установки значений свойств таких как <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph> , служат основой для изменения ввода.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ActualWidth">
          <source>Because <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ActualWidth%2A&gt;</ph> is a calculated value, you should be aware that there could be multiple or incremental reported changes to it as a result of various operations by the layout system.</source>
          <target state="translated">Поскольку <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ActualWidth%2A&gt;</ph> является вычисляемым значением, следует иметь в виду, может существовать несколько или инкрементные делает его в результате выполнения различных операций системы макета.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ActualWidth">
          <source>The layout system may be calculating required measure space for child elements, constraints by the parent element, and so on.</source>
          <target state="translated">Система макета может вычислять требуемое место измерения для дочерних элементов, ограничения родительского элемента и т. д.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ActualWidth">
          <source>Although you cannot set this property from <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, you can base a <ph id="ph2">&lt;xref:System.Windows.Trigger&gt;</ph> upon its value in a style.</source>
          <target state="translated">Несмотря на то, что невозможно задать это свойство из <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, можно построить <ph id="ph2">&lt;xref:System.Windows.Trigger&gt;</ph> после его значение в стиле.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ActualWidth">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ActualWidth">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ActualWidth">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ActualWidth">
          <source>None</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ActualWidth">
          <source>The following example displays various width properties.</source>
          <target state="translated">Следующий пример показывает различные свойства ширины.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.ActualWidthProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.ActualWidth" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.ActualWidth" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)">
          <source>Child element to be added.</source>
          <target state="translated">Добавляемый дочерний элемент.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)">
          <source>Adds the provided object to the logical tree of this element.</source>
          <target state="translated">Добавляет указанный объект в логическое дерево данного элемента.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)">
          <source>Use this method for the implementation of collections on objects that represent logical child elements of an element.</source>
          <target state="translated">Этот метод используется для реализации коллекции объектов, представляющих логические дочерние элементы данного элемента.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)">
          <source>Collection maintenance for child element collections might be done in property getters or setters, class handling of Changed events, constructors, or within the collection types themselves.</source>
          <target state="translated">Обслуживание коллекции для коллекции дочерних элементов может производиться в методы получения свойств или методов задания, обработчик событий Changed, конструкторов, или внутри самих типов коллекций класса.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)">
          <source>For control authors, manipulating the logical tree at this level is not the recommended practice, unless none of the content models for available base control classes are appropriate for your control scenario.</source>
          <target state="translated">Для разработчиков элементов управления обработка логического дерева на этом уровне не рекомендуется, если только ни одна из моделей содержимого для доступных базовых классов элементов управления не подходит для вашего сценария управления.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)">
          <source>Consider subclassing at the level of <ph id="ph1">&lt;xref:System.Windows.Controls.ContentControl&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph>, and <ph id="ph3">&lt;xref:System.Windows.Controls.HeaderedItemsControl&gt;</ph>.</source>
          <target state="translated">Рассмотрите возможность создания подкласса на уровне <ph id="ph1">&lt;xref:System.Windows.Controls.ContentControl&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph>, и <ph id="ph3">&lt;xref:System.Windows.Controls.HeaderedItemsControl&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)">
          <source>These classes provide a content model with particular enforcement of logical tree child elements through dedicated <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph>, as well as support for other features typically desirable in a <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> control such as styling through templates.</source>
          <target state="translated">Эти классы обеспечивают модель содержимого с определенной применения дочерних элементов в логическом дереве через выделенное <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph>, а также поддержку для других функций, как правило, желательно в <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> управления, например стилей с помощью шаблонов.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)">
          <source>For more information on how to use <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.LogicalChildren%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.AddLogicalChild%2A&gt;</ph>, see <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об использовании <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.LogicalChildren%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.AddLogicalChild%2A&gt;</ph>, в разделе <bpt id="p1">[</bpt>деревьев в WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.AddLogicalChild%2A&gt;</ph> may throw an exception if called at a time when the logical tree is being iterated by another process.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.AddLogicalChild%2A&gt;</ph> может привести к исключению, если вызывается в момент, когда выполняется итерация логического дерева с помощью другого процесса.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)">
          <source>The following example implements a <ph id="ph1">`Child`</ph> property on a custom <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> that does its own visual layer implementation.</source>
          <target state="translated">В следующем примере реализуется <ph id="ph1">`Child`</ph> свойство в пользовательском <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> , который выполняет собственную реализацию визуального уровня.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)">
          <source>The property setter is designed so that if the value changes, the old value is removed from the logical tree, as well as a class-specific visual collection.</source>
          <target state="translated">Метод задания свойства разработан, чтобы при изменении значения старое значение удаляется из логического дерева, а также коллекцию визуальных элементов данного класса.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.AddLogicalChild(System.Object)">
          <source>The property value is cached, and then the new value is added to both the logical tree and the custom visual collection.</source>
          <target state="translated">Значение свойства кэшируется и затем добавляется новое значение для логического дерева и коллекция пользовательских визуальных элементов.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.ApplyTemplate">
          <source>Builds the current template's visual tree if necessary, and returns a value that indicates whether the visual tree was rebuilt by this call.</source>
          <target state="translated">При необходимости строит визуальное дерево текущего шаблона и возвращает значение, указывающее, было ли это визуальное дерево перестроено в результате этого вызова.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.ApplyTemplate">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if visuals were added to the tree; returns <ph id="ph2">&lt;see langword="false" /&gt;</ph> otherwise.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если в дерево были добавлены визуальные элементы; в противном случае возвращает <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.ApplyTemplate">
          <source>Applications can call this method to guarantee that the visual tree of an element is complete.</source>
          <target state="translated">Приложения могут вызывать этот метод, чтобы гарантировать, что элемент визуального дерева завершения.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.ApplyTemplate">
          <source>This guarantee step might be necessary if code will be checking the child elements in the tree.</source>
          <target state="translated">Такая гарантия может быть необходимо, если код будет проверять дочерние элементы в дереве.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.ApplyTemplate">
          <source>For typical element logic within applications, calling <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ApplyTemplate%2A&gt;</ph> is not necessary, because templates will be applied to elements at an appropriate point in their lifetimes automatically.</source>
          <target state="translated">При обычной логике элементов внутри приложения, вызывающие <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ApplyTemplate%2A&gt;</ph> нет необходимости, так как шаблоны будут применяться к элементам в соответствующий момент их времени существования автоматически.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.ApplyTemplate">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ApplyTemplate%2A&gt;</ph> is called on every Measure pass by the WPF framework-level layout system.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ApplyTemplate%2A&gt;</ph> вызывается для всех мер передать системой макета уровня платформы WPF.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.ApplyTemplate">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> derived classes can use the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.OnApplyTemplate%2A&gt;</ph> class handler to be notified of cases where this method was called explicitly, or by the layout system.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> производные классы могут использовать <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.OnApplyTemplate%2A&gt;</ph> обработчик класса уведомляемых случаев, когда этот метод был вызван явным образом или системой макета.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.ApplyTemplate">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.OnApplyTemplate%2A&gt;</ph> is called after the template is completely generated and attached to the logical tree.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.OnApplyTemplate%2A&gt;</ph> вызывается после шаблона полностью создается и прикрепляется к логического дерева.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)">
          <source>The final area within the parent that this element should use to arrange itself and its children.</source>
          <target state="translated">Итоговая область в родительском элементе, которую этот элемент должен использовать для размещения себя и своих дочерних элементов.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)">
          <source>Implements <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" /&gt;</ph> (defined as virtual in <ph id="ph2">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph>) and seals the implementation.</source>
          <target state="translated">Реализует метод <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.ArrangeCore(System.Windows.Rect)" /&gt;</ph> (определенный как виртуальный в классе <ph id="ph2">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph>) и запечатывает реализацию.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)">
          <source>This method is sealed.</source>
          <target state="translated">Этот метод является запечатанным.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.ArrangeCore(System.Windows.Rect)">
          <source>In order to override the logic in your custom element specifically for the arrange pass of element layout, your <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> derived class must override <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.ArrangeOverride%2A&gt;</ph>.</source>
          <target state="translated">Чтобы переопределить логику в ваш пользовательский элемент специально для компоновки макета элемента вашей <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> производный класс должен переопределять <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.ArrangeOverride%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)">
          <source>The final area within the parent that this element should use to arrange itself and its children.</source>
          <target state="translated">Итоговая область в родительском элементе, которую этот элемент должен использовать для размещения себя и своих дочерних элементов.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)">
          <source>When overridden in a derived class, positions child elements and determines a size for a <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> derived class.</source>
          <target state="translated">При переопределении в производном классе размещает дочерние элементы и определяет размер для класса, производного от <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)">
          <source>The actual size used.</source>
          <target state="translated">Фактический используемый размер.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)">
          <source>Control authors who want to customize the arrange pass of layout processing should override this method.</source>
          <target state="translated">Разработчики элементов управления, которые хотят настроить проход компоновки при обработке следует переопределить этот метод.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)">
          <source>The implementation pattern should call <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /&gt;</ph> on each visible child element, and pass the final desired size for each child element as the <ph id="ph2">&lt;paramref name="finalRect" /&gt;</ph> parameter.</source>
          <target state="translated">Шаблон реализации должен вызывать <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /&gt;</ph> на каждом видимым дочернего элемента и передайте конечное желаемый размер для каждого дочернего элемента, как <ph id="ph2">&lt;paramref name="finalRect" /&gt;</ph> параметр.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)">
          <source>Parent elements should call <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /&gt;</ph> on each child, otherwise the child elements will not be rendered.</source>
          <target state="translated">Родительские элементы должны вызывать <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /&gt;</ph> на каждый дочерний элемент, в противном случае дочерние элементы не будут отображаться.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)">
          <source>Many derived classes offer implementations of this method.</source>
          <target state="translated">Во многих производных классах реализации этого метода.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)">
          <source>Prominent ones include: <ph id="ph1">&lt;see cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" /&gt;</ph> and <ph id="ph3">&lt;see cref="M:System.Windows.Controls.Control.ArrangeOverride(System.Windows.Size)" /&gt;</ph>.</source>
          <target state="translated">Показательным из них включают: <ph id="ph1">&lt;see cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Windows.Controls.Page.ArrangeOverride(System.Windows.Size)" /&gt;</ph> и <ph id="ph3">&lt;see cref="M:System.Windows.Controls.Control.ArrangeOverride(System.Windows.Size)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.BeginInit">
          <source>Starts the initialization process for this element.</source>
          <target state="translated">Запускает процесс инициализации данного элемента.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginInit">
          <source>You can call this method on individual elements if you are adjusting them in ways that do not yet expose or connect the element to any element tree.</source>
          <target state="translated">Этот метод можно вызывать для отдельных элементов, если они выравниваются способами, которые еще не предоставлять или подключиться к любой элемент дерева элемента.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginInit">
          <source>For instance, you might have created a new <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, but have not yet attached it to any logical tree.</source>
          <target state="translated">Например, вы могли создать новый <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, но не еще подключено его любого логического дерева.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginInit">
          <source>Or, the logical tree where your element is a child element within it might not be connected to a window or page of the application.</source>
          <target state="translated">Или логического дерева, в котором элемент является дочерним элементом в ней не подключен к окну или страницу приложения.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginInit">
          <source>Implement this method to provide special handling that should happen before your element is initialized during the element loading process.</source>
          <target state="translated">Реализуйте этот метод, чтобы обеспечить специальную обработку, которая будет выполняться перед инициализацией элемента в процессе его загрузки.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginInit">
          <source>Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</source>
          <target state="translated">Реализация должна вызывать базовую реализацию, поскольку реализация base (по умолчанию) устанавливает внутренние флаги для отслеживания инициализации.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginInit">
          <source>One possible implementation is to use this method as a hook into your own private class initialization routines that are not already enabled by constructors.</source>
          <target state="translated">С помощью этого метода в качестве ловушки в собственных закрытых процедурах инициализации класса, не включены конструкторами является одной из возможных реализаций.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginInit">
          <source>The base implementation will throw an exception if <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkElement.BeginInit" /&gt;</ph> is called more than one time on the same element prior to <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkElement.EndInit" /&gt;</ph> being called.</source>
          <target state="translated">Базовая реализация будет вызывать исключение, если <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkElement.BeginInit" /&gt;</ph> вызывается более одного раза в том же элементе до <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkElement.EndInit" /&gt;</ph> вызова.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkElement">
          <source>Begins the sequence of actions contained in the provided storyboard.</source>
          <target state="translated">Начинает последовательность действий, содержащихся в предоставленной раскадровке.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>The storyboard to begin.</source>
          <target state="translated">Раскадровка, которая будет начата.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>Begins the sequence of actions that are contained in the provided storyboard.</source>
          <target state="translated">Начинает последовательность действий, содержащихся в предоставленной раскадровке.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>Most typical animation scenarios do not use this method.</source>
          <target state="translated">Наиболее типичные сценарии анимации не используйте этот метод.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>Typically, you create the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.Media.Animation.BeginStoryboard&gt;</ph> element in markup, and then you place these as the <ph id="ph3">&lt;xref:System.Windows.EventTrigger&gt;</ph> content on an element.</source>
          <target state="translated">Как правило, создаются <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph> или <ph id="ph2">&lt;xref:System.Windows.Media.Animation.BeginStoryboard&gt;</ph> элемент в разметке, а затем поместить их в качестве <ph id="ph3">&lt;xref:System.Windows.EventTrigger&gt;</ph> содержимого элемента.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>When triggered by the event, the animation then runs.</source>
          <target state="translated">При срабатывании триггера события запускается анимация.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>Most of the control aspects of a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph> can be addressed by properties that are exposed in markup.</source>
          <target state="translated">Большинство аспектов управления <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph> можно работать посредством свойств, предоставляемых в разметке.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>For the signatures that do not use the <ph id="ph1">`isControllable`</ph>, parameter, or when that parameter is specified <ph id="ph2">`false`</ph>, the timeline clocks that are associated with the animation are removed as soon as the animation reaches the "Fill" period.</source>
          <target state="translated">Для подписей, которые не используют <ph id="ph1">`isControllable`</ph>, параметра, или при указании этого параметра <ph id="ph2">`false`</ph>, связанные с анимацией часы шкалы времени удаляются сразу анимации достигнет периода «Заливка».</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>Therefore the animation cannot be restarted after running once.</source>
          <target state="translated">Поэтому анимацию нельзя перезапустить после однократного запуска.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>Controlling an animation also requires that the storyboard have an <bpt id="p1">[</bpt>x:Name Directive<ept id="p1">](~/docs/framework/xaml-services/x-name-directive.md)</ept> or be accessible by reference in code.</source>
          <target state="translated">Управление анимацией также требует, чтобы раскадровку <bpt id="p1">[</bpt>директива x: Name<ept id="p1">](~/docs/framework/xaml-services/x-name-directive.md)</ept> или доступ к ней по ссылке в коде.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard)">
          <source>The following example retrieves a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph> from resources, and then runs that <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph> when an internal event is class handled.</source>
          <target state="translated">В следующем примере извлекается <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph> из ресурсов, а затем запускается, <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph> при внутреннее событие обрабатывается классом.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>The storyboard to begin.</source>
          <target state="translated">Раскадровка, которая будет начата.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>A value of the enumeration that describes behavior to use if a property described in the storyboard is already animated.</source>
          <target state="translated">Значение перечисления, описывающего поведение в случае, если описанное в раскадровке свойство уже анимировано.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Begins the sequence of actions contained in the provided storyboard, with options specified for what should happen if the property is already animated.</source>
          <target state="translated">Начинает последовательность действий, содержащихся в предоставленной раскадровке, с параметрами, указывающими на реакцию в случае уже анимированного свойства.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Most typical animation scenarios do not use this method.</source>
          <target state="translated">Наиболее типичные сценарии анимации не используйте этот метод.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Typically, you create the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.Media.Animation.BeginStoryboard&gt;</ph> element in markup, and then you place these as the <ph id="ph3">&lt;xref:System.Windows.EventTrigger&gt;</ph> content on an element.</source>
          <target state="translated">Как правило, создаются <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph> или <ph id="ph2">&lt;xref:System.Windows.Media.Animation.BeginStoryboard&gt;</ph> элемент в разметке, а затем поместить их в качестве <ph id="ph3">&lt;xref:System.Windows.EventTrigger&gt;</ph> содержимого элемента.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>When triggered by the event, the animation then runs.</source>
          <target state="translated">При срабатывании триггера события запускается анимация.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Most of the control aspects of a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph> can be addressed by properties that are exposed in markup.</source>
          <target state="translated">Большинство аспектов управления <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph> можно работать посредством свойств, предоставляемых в разметке.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>For the signatures that do not use the <ph id="ph1">`isControllable`</ph>, parameter, or when that parameter is specified <ph id="ph2">`false`</ph>, the timeline clocks that are associated with the animation are removed as soon as the animation reaches the "Fill" period.</source>
          <target state="translated">Для подписей, которые не используют <ph id="ph1">`isControllable`</ph>, параметра, или при указании этого параметра <ph id="ph2">`false`</ph>, связанные с анимацией часы шкалы времени удаляются сразу анимации достигнет периода «Заливка».</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Therefore the animation cannot be restarted after running once.</source>
          <target state="translated">Поэтому анимацию нельзя перезапустить после однократного запуска.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Controlling an animation also requires that the storyboard have an <bpt id="p1">[</bpt>x:Name Directive<ept id="p1">](~/docs/framework/xaml-services/x-name-directive.md)</ept> or be accessible by reference in code.</source>
          <target state="translated">Управление анимацией также требует, чтобы раскадровку <bpt id="p1">[</bpt>директива x: Name<ept id="p1">](~/docs/framework/xaml-services/x-name-directive.md)</ept> или доступ к ней по ссылке в коде.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Handoff behavior can be specified as an attribute of <ph id="ph1">&lt;xref:System.Windows.Media.Animation.BeginStoryboard&gt;</ph>.</source>
          <target state="translated">Поведение перемещения может быть указан как атрибут <ph id="ph1">&lt;xref:System.Windows.Media.Animation.BeginStoryboard&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Using the Compose HandoffBehavior</source>
          <target state="translated">Использование составлять руководство.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>When you apply a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.Animation.AnimationTimeline&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> to a property by using the <ph id="ph4">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph> <ph id="ph5">&lt;xref:System.Windows.Media.Animation.HandoffBehavior&gt;</ph>, any <ph id="ph6">&lt;xref:System.Windows.Media.Animation.Clock&gt;</ph> objects previously associated with that property continue to consume system resources; the timing system does not remove the clocks automatically.</source>
          <target state="translated">При применении <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.Animation.AnimationTimeline&gt;</ph>, или <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> к свойству с помощью <ph id="ph4">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph> <ph id="ph5">&lt;xref:System.Windows.Media.Animation.HandoffBehavior&gt;</ph>, любые <ph id="ph6">&lt;xref:System.Windows.Media.Animation.Clock&gt;</ph> ранее связанную с ним объекты по-прежнему потребление системных ресурсов; в случае система времени не удаляет эти часы автоматически.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>To avoid performance issues when you apply a large number of clocks by using <ph id="ph1">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph>, you should remove composing clocks from the animated property after they complete.</source>
          <target state="translated">Чтобы избежать проблем с производительностью при применении большое число часов с помощью <ph id="ph1">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph>, необходимо удалить составляющую часами анимированное свойство после их завершения.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>There are several ways to remove a clock:</source>
          <target state="translated">Существует несколько способов удаления часов:</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>To remove all clocks from a property, use the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29&gt;</ph> method of the animated object.</source>
          <target state="translated">Чтобы удалить все часы из свойства, используйте <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29&gt;</ph> или <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29&gt;</ph> метод анимированного объекта.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Specify the property being animated as the first parameter, and <ph id="ph1">`null`</ph> as the second.</source>
          <target state="translated">Укажите в качестве первого параметра, анимируемого свойства и <ph id="ph1">`null`</ph> вторым.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>This removes all animation clocks from the property.</source>
          <target state="translated">При этом удаляются все часы анимации из свойства.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>To remove a specific <ph id="ph1">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> from a list of clocks, use the <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> property of the <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> to retrieve a <ph id="ph4">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>, then call the <ph id="ph5">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph> method of the <ph id="ph6">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>.</source>
          <target state="translated">Для удаления определенных <ph id="ph1">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> из списка часов используйте <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> свойство <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> для получения <ph id="ph4">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>, затем вызовите <ph id="ph5">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph> метод <ph id="ph6">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>This is typically done in the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> event handler for a clock.</source>
          <target state="translated">Обычно это делается <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> обработчика событий для часов.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Note that only root clocks can be controlled by a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>; the <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> property of a child clock returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Обратите внимание, что только корневые часы могут управляться <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>; <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> свойство дочерних часов возвращает <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>Note also that the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> event is not raised if the effective duration of the clock is forever.</source>
          <target state="translated">Обратите внимание, что <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> событие не происходит, если эффективная продолжительность часов является бесконечностью.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>In that case, the user must determine when to call <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph>.</source>
          <target state="translated">В этом случае пользователь должен определить, когда вызывать <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>This is primarily an issue for animations on objects that have a long lifetime.</source>
          <target state="translated">В основном это проблема для анимации объектов, имеющих длинное время жизни.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>When an object is garbage collected, its clocks are also disconnected and garbage collected.</source>
          <target state="translated">При обнаружении объектов сбора мусора, его часы также будут отключены и собраны как мусор.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>For more information about clock objects, see <bpt id="p1">[</bpt>Animation and Timing System Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об объектах часов см. в разделе <bpt id="p1">[</bpt>анимации и общие сведения о синхронизации системы<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior)">
          <source>The following example retrieves a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph> from resources, and then runs that <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph> when an internal event is class handled.</source>
          <target state="translated">В следующем примере извлекается <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph> из ресурсов, а затем запускается, <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph> при внутреннее событие обрабатывается классом.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>The storyboard to begin.</source>
          <target state="translated">Раскадровка, которая будет начата.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>A value of the enumeration that describes behavior to use if a property described in the storyboard is already animated.</source>
          <target state="translated">Значение перечисления, описывающего поведение в случае, если описанное в раскадровке свойство уже анимировано.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Declares whether the animation is controllable (can be paused) after it is started.</source>
          <target state="translated">Объявляет, является ли анимация управляемой после запуска (можно ли ее приостановить).</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Begins the sequence of actions contained in the provided storyboard, with specified state for control of the animation after it is started.</source>
          <target state="translated">Начинает последовательность действий, содержащихся в предоставленной раскадровке, с указанным состоянием элемента управления анимацией после ее запуска.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Most typical animation scenarios do not use this method.</source>
          <target state="translated">Наиболее типичные сценарии анимации не используйте этот метод.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Typically, you create the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.Media.Animation.BeginStoryboard&gt;</ph> element in markup, and then you place these as the <ph id="ph3">&lt;xref:System.Windows.EventTrigger&gt;</ph> content on an element.</source>
          <target state="translated">Как правило, создаются <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph> или <ph id="ph2">&lt;xref:System.Windows.Media.Animation.BeginStoryboard&gt;</ph> элемент в разметке, а затем поместить их в качестве <ph id="ph3">&lt;xref:System.Windows.EventTrigger&gt;</ph> содержимого элемента.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>When triggered by the event, the animation then runs.</source>
          <target state="translated">При срабатывании триггера события запускается анимация.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Most of the control aspects of a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph> can be addressed by properties that are exposed in markup.</source>
          <target state="translated">Большинство аспектов управления <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph> можно работать посредством свойств, предоставляемых в разметке.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>For the signatures that do not use the <ph id="ph1">`isControllable`</ph>, parameter, or when that parameter is specified <ph id="ph2">`false`</ph>, the timeline clocks that are associated with the animation are removed as soon as the animation reaches the "Fill" period.</source>
          <target state="translated">Для подписей, которые не используют <ph id="ph1">`isControllable`</ph>, параметра, или при указании этого параметра <ph id="ph2">`false`</ph>, связанные с анимацией часы шкалы времени удаляются сразу анимации достигнет периода «Заливка».</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Therefore the animation cannot be restarted after running once.</source>
          <target state="translated">Поэтому анимацию нельзя перезапустить после однократного запуска.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Controlling an animation also requires that the storyboard have an <bpt id="p1">[</bpt>x:Name Directive<ept id="p1">](~/docs/framework/xaml-services/x-name-directive.md)</ept> or be accessible by reference in code.</source>
          <target state="translated">Управление анимацией также требует, чтобы раскадровку <bpt id="p1">[</bpt>директива x: Name<ept id="p1">](~/docs/framework/xaml-services/x-name-directive.md)</ept> или доступ к ней по ссылке в коде.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Handoff behavior can be specified as an attribute of <ph id="ph1">&lt;xref:System.Windows.Media.Animation.BeginStoryboard&gt;</ph>.</source>
          <target state="translated">Поведение перемещения может быть указан как атрибут <ph id="ph1">&lt;xref:System.Windows.Media.Animation.BeginStoryboard&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Using the Compose HandoffBehavior</source>
          <target state="translated">Использование составлять руководство.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>When you apply a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.Animation.AnimationTimeline&gt;</ph>, or <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> to a property by using the <ph id="ph4">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph> <ph id="ph5">&lt;xref:System.Windows.Media.Animation.HandoffBehavior&gt;</ph>, any <ph id="ph6">&lt;xref:System.Windows.Media.Animation.Clock&gt;</ph> objects previously associated with that property continue to consume system resources; the timing system does not remove the clocks automatically.</source>
          <target state="translated">При применении <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Media.Animation.AnimationTimeline&gt;</ph>, или <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> к свойству с помощью <ph id="ph4">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph> <ph id="ph5">&lt;xref:System.Windows.Media.Animation.HandoffBehavior&gt;</ph>, любые <ph id="ph6">&lt;xref:System.Windows.Media.Animation.Clock&gt;</ph> ранее связанную с ним объекты по-прежнему потребление системных ресурсов; в случае система времени не удаляет эти часы автоматически.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>To avoid performance issues when you apply a large number of clocks by using <ph id="ph1">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph>, you should remove composing clocks from the animated property after they complete.</source>
          <target state="translated">Чтобы избежать проблем с производительностью при применении большое число часов с помощью <ph id="ph1">&lt;xref:System.Windows.Media.Animation.HandoffBehavior.Compose&gt;</ph>, необходимо удалить составляющую часами анимированное свойство после их завершения.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>There are several ways to remove a clock:</source>
          <target state="translated">Существует несколько способов удаления часов:</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>To remove all clocks from a property, use the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29&gt;</ph> method of the animated object.</source>
          <target state="translated">Чтобы удалить все часы из свойства, используйте <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29&gt;</ph> или <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29&gt;</ph> метод анимированного объекта.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Specify the property being animated as the first parameter, and <ph id="ph1">`null`</ph> as the second.</source>
          <target state="translated">Укажите в качестве первого параметра, анимируемого свойства и <ph id="ph1">`null`</ph> вторым.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>This removes all animation clocks from the property.</source>
          <target state="translated">При этом удаляются все часы анимации из свойства.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>To remove a specific <ph id="ph1">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> from a list of clocks, use the <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> property of the <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> to retrieve a <ph id="ph4">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>, then call the <ph id="ph5">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph> method of the <ph id="ph6">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>.</source>
          <target state="translated">Для удаления определенных <ph id="ph1">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> из списка часов используйте <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> свойство <ph id="ph3">&lt;xref:System.Windows.Media.Animation.AnimationClock&gt;</ph> для получения <ph id="ph4">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>, затем вызовите <ph id="ph5">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph> метод <ph id="ph6">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>This is typically done in the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> event handler for a clock.</source>
          <target state="translated">Обычно это делается <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> обработчика событий для часов.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Note that only root clocks can be controlled by a <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>; the <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> property of a child clock returns <ph id="ph3">`null`</ph>.</source>
          <target state="translated">Обратите внимание, что только корневые часы могут управляться <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController&gt;</ph>; <ph id="ph2">&lt;xref:System.Windows.Media.Animation.Clock.Controller%2A&gt;</ph> свойство дочерних часов возвращает <ph id="ph3">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>Note also that the <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> event is not raised if the effective duration of the clock is forever.</source>
          <target state="translated">Обратите внимание, что <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Clock.Completed&gt;</ph> событие не происходит, если эффективная продолжительность часов является бесконечностью.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>In that case, the user must determine when to call <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph>.</source>
          <target state="translated">В этом случае пользователь должен определить, когда вызывать <ph id="ph1">&lt;xref:System.Windows.Media.Animation.ClockController.Remove%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>This is primarily an issue for animations on objects that have a long lifetime.</source>
          <target state="translated">В основном это проблема для анимации объектов, имеющих длинное время жизни.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>When an object is garbage collected, its clocks are also disconnected and garbage collected.</source>
          <target state="translated">При обнаружении объектов сбора мусора, его часы также будут отключены и собраны как мусор.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BeginStoryboard(System.Windows.Media.Animation.Storyboard,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)">
          <source>For more information about clock objects, see <bpt id="p1">[</bpt>Animation and Timing System Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об объектах часов см. в разделе <bpt id="p1">[</bpt>анимации и общие сведения о синхронизации системы<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.BindingGroup">
          <source>Gets or sets the <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph> that is used for the element.</source>
          <target state="translated">Возвращает или задает группу <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph>,  которая используется для элемента.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.BindingGroup">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph> that is used for the element.</source>
          <target state="translated">Группа <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingGroup" /&gt;</ph>, используемая для элемента.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.BindingGroup">
          <source>A <ph id="ph1">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> can be used to validate the values of multiple properties of an object.</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> можно использовать для проверки значений нескольких свойств объекта.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.BindingGroup">
          <source>For example, suppose that an application prompts the user to enter an address and then populates an object of type <ph id="ph1">`Address`</ph>, which has the properties <ph id="ph2">`Street`</ph>, <ph id="ph3">`City`</ph>, <ph id="ph4">`ZipCode`</ph>, and <ph id="ph5">`Country`</ph>, with the values that the user provided.</source>
          <target state="translated">Предположим, что приложение предлагает пользователю ввести адрес и заполняет объект типа <ph id="ph1">`Address`</ph>, который имеет свойства <ph id="ph2">`Street`</ph>, <ph id="ph3">`City`</ph>, <ph id="ph4">`ZipCode`</ph>, и <ph id="ph5">`Country`</ph>, со значениями, пользователь предоставлен.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.BindingGroup">
          <source>The application has a panel that contains four <ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> controls, each of which is bound to one of the object’s properties.</source>
          <target state="translated">Приложение имеет панель, которая содержит четыре <ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> элементов управления, привязанных к одному из свойств объекта.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.BindingGroup">
          <source>You can use a <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph> in a <ph id="ph2">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> to validate the <ph id="ph3">`Address`</ph> object.</source>
          <target state="translated">Можно использовать <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph> в <ph id="ph2">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> для проверки <ph id="ph3">`Address`</ph> объекта.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.BindingGroup">
          <source>For example, the <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph> can ensure that the zip code is valid for the country of the address.</source>
          <target state="translated">Например <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph> можно обеспечить допустимость ZIP-код страны адреса.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.BindingGroup">
          <source>Child elements inherit the <ph id="ph1">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> from their parent elements, just as with any other inheritable property.</source>
          <target state="translated">Дочерние элементы наследуют <ph id="ph1">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> от своих родительских элементов, как и в случае любого другого наследуемые свойства.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.BindingGroup">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.BindingGroup">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.BindingGroup">
          <source>Metadata properties set to <bpt id="p1">**</bpt>true<ept id="p1">**</ept></source>
          <target state="translated">Значение свойства метаданных <bpt id="p1">**</bpt>true<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.BindingGroup">
          <source>The following examples are part of an application that checks whether the user has set the properties of two objects to equal values.</source>
          <target state="translated">Следующие примеры являются частью приложения, которое проверяет, ли пользователь задать свойства одинаковые значения для двух объектов.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.BindingGroup">
          <source>The first example creates two <ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> controls, each of which is bound to a different data source.</source>
          <target state="translated">В первом примере создается два <ph id="ph1">&lt;xref:System.Windows.Controls.TextBox&gt;</ph> элементов управления, привязанных к источнику данных.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.BindingGroup">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Controls.StackPanel&gt;</ph> has a <ph id="ph2">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> that contains a <ph id="ph3">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph> that checks that the two strings are equal.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.StackPanel&gt;</ph> Имеет <ph id="ph2">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> , содержащий <ph id="ph3">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph> , проверяет, что две строки равны.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.BindingGroup">
          <source>The following example shows the <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph> that the previous example uses.</source>
          <target state="translated">В следующем примере показан <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph> , в предыдущем примере.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.BindingGroup">
          <source>In the <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule.Validate%2A&gt;</ph> method override, the example gets each source object from the <ph id="ph2">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> and checks whether the properties of the objects are equal.</source>
          <target state="translated">В <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule.Validate%2A&gt;</ph> переопределяющий метод в примере показано получение каждого исходного объекта, из <ph id="ph2">&lt;xref:System.Windows.Data.BindingGroup&gt;</ph> и проверяет, равны ли свойства объектов.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.BindingGroup">
          <source>To invoke the <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Windows.Data.BindingGroup.UpdateSources%2A&gt;</ph> method.</source>
          <target state="translated">Для вызова <ph id="ph1">&lt;xref:System.Windows.Controls.ValidationRule&gt;</ph>, вызовите <ph id="ph2">&lt;xref:System.Windows.Data.BindingGroup.UpdateSources%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.BindingGroup">
          <source>The following example calls <ph id="ph1">&lt;xref:System.Windows.Data.BindingGroup.UpdateSources%2A&gt;</ph> when the click event of the button occurs.</source>
          <target state="translated">В следующем примере вызывается <ph id="ph1">&lt;xref:System.Windows.Data.BindingGroup.UpdateSources%2A&gt;</ph> при возникновении события щелчка кнопки.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.BindingGroupProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.BindingGroup" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.BindingGroup" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkElement">
          <source>Attempts to bring this element into view, within any scrollable regions it is contained within.</source>
          <target state="translated">Пытается отобразить данный элемент вместе с содержащимися в нем прокручиваемыми областями.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.BringIntoView">
          <source>Attempts to bring this element into view, within any scrollable regions it is contained within.</source>
          <target state="translated">Пытается отобразить данный элемент вместе с содержащимися в нем прокручиваемыми областями.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BringIntoView">
          <source>By calling this method, you raise a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView&gt;</ph> event that originates from the current element.</source>
          <target state="translated">Путем вызова данного метода, вызывают <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView&gt;</ph> событие, которое исходит от текущего элемента.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BringIntoView">
          <source>This event is raised so that it can be handled by a <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>, or a derived or similar class.</source>
          <target state="translated">Это событие возникает, чтобы оно могло быть обработано <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>, или класс производного или аналогичную.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BringIntoView">
          <source>The expected behavior is that the event is handled by the parent element, marked handled in the event data, and the source of the event is brought into view through the logic embedded in the <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph> control.</source>
          <target state="translated">Ожидаемым поведением является событие обрабатывается родительским элементом, помечено как обработанное в данных события, и источник события заносятся в представлении через логику, встроенную в <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph> элемента управления.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BringIntoView">
          <source>Neither the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView&gt;</ph> event nor the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.BringIntoView%2A&gt;</ph> method transmit any information about success or failure, other than that the event is typically marked handled on success.</source>
          <target state="translated">Ни <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView&gt;</ph> событий ни <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.BringIntoView%2A&gt;</ph> метод передачи все сведения об успешном или неуспешном, отличный от того, обычно событие является помечен обработано на успех.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BringIntoView">
          <source>Reasons for failure can include the element settings, such as <ph id="ph1">&lt;xref:System.Windows.UIElement.Visibility%2A&gt;</ph> being some value other than <ph id="ph2">&lt;xref:System.Windows.Visibility.Visible&gt;</ph>.</source>
          <target state="translated">Причинами сбоя могут включать параметры элемента, например <ph id="ph1">&lt;xref:System.Windows.UIElement.Visibility%2A&gt;</ph> выполняется какое-либо значение, отличное от <ph id="ph2">&lt;xref:System.Windows.Visibility.Visible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BringIntoView">
          <source>If you use the signature that does not specify a <ph id="ph1">`targetRectangle`</ph>, then the entire element size (its <ph id="ph2">&lt;xref:System.Windows.UIElement.RenderSize%2A&gt;</ph>) will be made visible.</source>
          <target state="translated">Если вы используете подпись, которая не соответствует <ph id="ph1">`targetRectangle`</ph>, затем размер всего элемента (его <ph id="ph2">&lt;xref:System.Windows.UIElement.RenderSize%2A&gt;</ph>) будет виден.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BringIntoView">
          <source>By calling this method, you potentially will call <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A&gt;</ph> on any parent scrollable area that contains the element.</source>
          <target state="translated">Путем вызова данного метода, потенциально будет вызываться <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A&gt;</ph> на все родительские прокручиваемую область, которая содержит элемент.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BringIntoView">
          <source>If this element is not contained in a scrollable area, the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView&gt;</ph> event is still raised, but there will be no effect because there are no event listeners.</source>
          <target state="translated">Если этот элемент не содержится в прокручиваемой области <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView&gt;</ph> событие по-прежнему, но будет недоступен, так как отсутствуют прослушиватели событий.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BringIntoView">
          <source>The following example implements a handler for an application navigation event that responds whenever the <ph id="ph1">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]</ph> being navigated to includes a fragment.</source>
          <target state="translated">В следующем примере реализуется обработчик для события навигации в приложении, каждый раз, когда отвечает <ph id="ph1">[!INCLUDE[TLA#tla_uri](~/includes/tlasharptla-uri-md.md)]</ph> , куда выполняется переход включает фрагмент.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BringIntoView">
          <source>The fragment is named in the <ph id="ph1">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]</ph> following the hash sign (#), and the implemented behavior causes the element to scroll into view within the frame.</source>
          <target state="translated">Фрагмент именуется в <ph id="ph1">[!INCLUDE[TLA2#tla_uri](~/includes/tla2sharptla-uri-md.md)]</ph> следующие решетки (#), и реализованное поведение заставляет элемент, который прокручивается в представлении в рамках области.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BringIntoView">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.BringIntoView%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView&gt;</ph> request that scrolling behavior in the example.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.BringIntoView%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView&gt;</ph> запроса, поведение прокрутки в примере.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)">
          <source>Specified size of the element that should also be brought into view.</source>
          <target state="translated">Указанный размер элемента, который также следует отобразить.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)">
          <source>Attempts to bring the provided region size of this element into view, within any scrollable regions it is contained within.</source>
          <target state="translated">Пытается отобразить указанный размер области данного элемента вместе с содержащимися в нем прокручиваемыми областями.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)">
          <source>By calling this method, you raise a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView&gt;</ph> event that originates from the current element.</source>
          <target state="translated">Путем вызова данного метода, вызывают <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView&gt;</ph> событие, которое исходит от текущего элемента.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)">
          <source>This event is raised so that it can be handled by a <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>, or a derived or similar class.</source>
          <target state="translated">Это событие возникает, чтобы оно могло быть обработано <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>, или класс производного или аналогичную.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)">
          <source>The expected behavior is that the event is handled by the parent element, marked handled in the event data, and the source of the event is brought into view through the logic embedded in the <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph> control.</source>
          <target state="translated">Ожидаемым поведением является событие обрабатывается родительским элементом, помечено как обработанное в данных события, и источник события заносятся в представлении через логику, встроенную в <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph> элемента управления.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)">
          <source>Neither the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView&gt;</ph> event nor the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.BringIntoView%2A&gt;</ph> method transmit any information about success or failure, other than that the event is typically marked handled on success.</source>
          <target state="translated">Ни <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView&gt;</ph> событий ни <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.BringIntoView%2A&gt;</ph> метод передачи все сведения об успешном или неуспешном, отличный от того, обычно событие является помечен обработано на успех.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)">
          <source>Reasons for failure can include the element settings, such as <ph id="ph1">&lt;xref:System.Windows.UIElement.Visibility%2A&gt;</ph> being some value other than <ph id="ph2">&lt;xref:System.Windows.Visibility.Visible&gt;</ph>.</source>
          <target state="translated">Причинами сбоя могут включать параметры элемента, например <ph id="ph1">&lt;xref:System.Windows.UIElement.Visibility%2A&gt;</ph> выполняется какое-либо значение, отличное от <ph id="ph2">&lt;xref:System.Windows.Visibility.Visible&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)">
          <source>If you use the signature that does not specify a <ph id="ph1">`targetRectangle`</ph>, then the entire element size (its <ph id="ph2">&lt;xref:System.Windows.UIElement.RenderSize%2A&gt;</ph>) will be made visible.</source>
          <target state="translated">Если вы используете подпись, которая не соответствует <ph id="ph1">`targetRectangle`</ph>, затем размер всего элемента (его <ph id="ph2">&lt;xref:System.Windows.UIElement.RenderSize%2A&gt;</ph>) будет виден.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)">
          <source>By calling this method, you potentially will call <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A&gt;</ph> on any parent scrollable area that contains the element.</source>
          <target state="translated">Путем вызова данного метода, потенциально будет вызываться <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollContentPresenter.MakeVisible%2A&gt;</ph> на все родительские прокручиваемую область, которая содержит элемент.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)">
          <source>If this element is not contained in a scrollable area, the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView&gt;</ph> event is still raised, but there will be no effect because there are no event listeners.</source>
          <target state="translated">Если этот элемент не содержится в прокручиваемой области <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView&gt;</ph> событие по-прежнему, но будет недоступен, так как отсутствуют прослушиватели событий.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)">
          <source>The following example has a large graphic in a constrained scrolling region.</source>
          <target state="translated">В следующем примере имеется большой рисунок в ограниченной области прокрутки.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)">
          <source>A button on the page has a handler that scrolls the view to a particular region of the large graphic.</source>
          <target state="translated">На кнопке на странице есть обработчик, который прокрутку до определенной области большого изображения.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.ContextMenu">
          <source>Gets or sets the context menu element that should appear whenever the context menu is requested through <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> from within this element.</source>
          <target state="translated">Возвращает или задает элемент контекстного меню, который должен отображаться каждый раз при вызове контекстного меню через <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> из этого элемента.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ContextMenu">
          <source>The context menu assigned to this element.</source>
          <target state="translated">Контекстное меню, назначенное этому элементу.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ContextMenu">
          <source><ph id="ph1">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> itself is a <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> derived class, and it is technically possible for <ph id="ph3">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> itself to have a <ph id="ph4">&lt;xref:System.Windows.FrameworkElement.ContextMenu%2A&gt;</ph> property.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> сам по себе является <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> производного класса, а также технически возможно для <ph id="ph3">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> сам иметь <ph id="ph4">&lt;xref:System.Windows.FrameworkElement.ContextMenu%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ContextMenu">
          <source>However, this creates a confusing context menu experience for the user and this practice is not recommended.</source>
          <target state="translated">Тем не менее это создает путаницу качества меню контекст для пользователя, и это не рекомендуется.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ContextMenu">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ContextMenu">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ContextMenu">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ContextMenu">
          <source>None</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkElement.ContextMenuClosing">
          <source>Occurs just before any context menu on the element is closed.</source>
          <target state="translated">Происходит непосредственно перед закрытием какого-либо контекстного меню в элементе.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuClosing">
          <source>To suppress closing context menus, handlers of the event should mark it as handled.</source>
          <target state="translated">Для подавления закрытия контекстных меню обработчики события следует пометить как обработанное.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuClosing">
          <source>To use this event as an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style, you must reference the underlying service's definition of the event:</source>
          <target state="translated">Чтобы использовать это событие как <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> в стиле, необходимо сослаться на определение базовой службы события:</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuClosing">
          <source>(This usage is required because the event implementation on <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> that exposes the underlying service event does not map the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.ContextMenuClosing&gt;</ph> identifier such that you can use it as a trigger).</source>
          <target state="translated">(Такое использование является обязательным, поскольку реализация событий в <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> , предоставляет базовое событие службы не сопоставляют <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.ContextMenuClosing&gt;</ph> идентификатор таким образом, чтобы ее можно использовать в качестве триггера).</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuClosing">
          <source><ph id="ph1">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> itself is a <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> derived class, but the <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.ContextMenuClosing&gt;</ph> event will not be raised by a context menu directly.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> сам по себе является <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> производного класса, но <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.ContextMenuClosing&gt;</ph> события не вызываются, контекстное меню напрямую.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuClosing">
          <source>Instead, the event is raised from the element that "owns" the context menu as a property and is only raised when a user attempts to close a context menu in the UI.</source>
          <target state="translated">Вместо этого событие инициируется элементом, который «владеет» в контекстном меню, как свойство и только тогда, когда пользователь пытается закрыть контекстное меню в пользовательском Интерфейсе.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuClosing">
          <source>However it is possible for <ph id="ph1">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> itself to have a <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.ContextMenu%2A&gt;</ph> property (a nested context menu).</source>
          <target state="translated">Однако существует возможность <ph id="ph1">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> сам иметь <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.ContextMenu%2A&gt;</ph> свойство (вложенные контекстное меню).</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuClosing">
          <source>In this case the <ph id="ph1">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> really does own the nested <ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> and might raise the event, with the source of the event being the nested context menu.</source>
          <target state="translated">В этом случае <ph id="ph1">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> действительно является владельцем вложенного <ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> и может вызвать события с источником события выполняется вложенных контекстного меню.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuClosing">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> class itself also has a similar event (<ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu.Closed&gt;</ph>) but the <ph id="ph3">&lt;xref:System.Windows.Controls.ContextMenu.Closed&gt;</ph> event does not provide you the opportunity to cancel the user action.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> Самого класса также имеет такое же событие (<ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu.Closed&gt;</ph>), но <ph id="ph3">&lt;xref:System.Windows.Controls.ContextMenu.Closed&gt;</ph> событий не предоставляет возможность отмены действий пользователя.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuClosing">
          <source>Routed Event Information</source>
          <target state="translated">Сведения о маршрутизируемом событии</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuClosing">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuClosing">
          <source>Routing strategy</source>
          <target state="translated">Стратегия маршрутизации</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuClosing">
          <source>Bubbling</source>
          <target state="translated">Вверх</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuClosing">
          <source>Delegate</source>
          <target state="translated">делегат</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuClosing">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Переопределить <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.OnContextMenuClosing%2A&gt;</ph> реализации класса обработчик данного события в производных классах.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.ContextMenuClosingEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /&gt;</ph> routed event.</source>
          <target state="translated">Идентифицирует направленное событие <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.ContextMenuClosingEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Идентификаторы перенаправленных событий создаются при их регистрации.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.ContextMenuClosingEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.ContextMenuClosingEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Эти идентификаторы можно использовать для добавления обработчиков классов.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.ContextMenuClosingEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.ContextMenuClosingEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkElement.ContextMenuOpening">
          <source>Occurs when any context menu on the element is opened.</source>
          <target state="translated">Происходит при открытии какого-либо контекстного меню в элементе.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuOpening">
          <source>To manually open context menus, handlers of the events should mark the relevant event as handled.</source>
          <target state="translated">Для открытия контекстных меню вручную обработчики событий должны помечать соответствующее событие как обработанное.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuOpening">
          <source>Otherwise, the existing value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ContextMenu%2A&gt;</ph> property will be used to automatically open a context menu.</source>
          <target state="translated">В противном случае — значение существующего <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ContextMenu%2A&gt;</ph> свойство будет использоваться для автоматического открытия контекстного меню.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuOpening">
          <source>Marking the event handled will effectively cancel the default action, and could be an opportunity to reset the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ContextMenu%2A&gt;</ph> property and then open the new <ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph>.</source>
          <target state="translated">Маркировка обрабатываемого события эффективно отменит действие по умолчанию и может быть возможность сбросить значение <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ContextMenu%2A&gt;</ph> свойства и откройте новый <ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuOpening">
          <source>However, there is a timing issue you should be aware of.</source>
          <target state="translated">Однако есть ошибки синхронизации, которые следует иметь в виду.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuOpening">
          <source>In order to completely replace the context menu through a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ContextMenuOpening&gt;</ph> handler, the initial context menu must not be null / empty.</source>
          <target state="translated">Чтобы полностью заменить контекстного меню через <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ContextMenuOpening&gt;</ph> обработчик, меню исходного контекста не должно быть null или пустым.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuOpening">
          <source>Alternatively, you might need to handle the event and then manually open a new context menu.</source>
          <target state="translated">Кроме того может потребоваться обработать событие и затем вручную открыть новое контекстное меню.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuOpening">
          <source>For details, see <bpt id="p1">[</bpt>How to: Handle the ContextMenuOpening Event<ept id="p1">](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>как: руководство<ept id="p1">](~/docs/framework/wpf/advanced/how-to-handle-the-contextmenuopening-event.md)</ept>.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuOpening">
          <source>To use this event as an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style, you must reference the underlying attached event:</source>
          <target state="translated">Чтобы использовать это событие как <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> в стиле, необходимо сослаться на базовых вложенное событие:</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuOpening">
          <source>(This usage is required because the event implementation on <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> that exposes the underlying service event does not map the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.ContextMenuOpening&gt;</ph> identifier such that you can use it in triggers).</source>
          <target state="translated">(Такое использование является обязательным, поскольку реализация событий в <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> , предоставляет базовое событие службы не сопоставляют <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.ContextMenuOpening&gt;</ph> идентификатор таким образом, что его можно использовать в триггерах).</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuOpening">
          <source><ph id="ph1">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> itself is a <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> derived class, but this event will not be raised from the context menu being opened as a source.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> сам по себе является <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> производного класса, но это событие не будет вызываться из контекстного меню, открываемом в качестве источника.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuOpening">
          <source>The event is raised from the element that "owns" the context menu as a property and is only raised when a user attempts to open a context menu in the UI.</source>
          <target state="translated">Событие инициируется элементом, который «владеет» в контекстном меню, как свойство и только тогда, когда пользователь пытается открыть контекстное меню в пользовательском Интерфейсе.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuOpening">
          <source>It is possible for <ph id="ph1">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> itself to have a <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.ContextMenu%2A&gt;</ph> property, but you should avoid this scenario (for details, see <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">Существует возможность <ph id="ph1">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> сам иметь <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.ContextMenu%2A&gt;</ph> свойство, но следует избегать этот сценарий (Дополнительные сведения см. в разделе <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.ContextMenu%2A?displayProperty=nameWithType&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuOpening">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> class itself also has a similar event (<ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu.Opened&gt;</ph>) but <ph id="ph3">&lt;xref:System.Windows.Controls.ContextMenu.Opened&gt;</ph> does not provide you the opportunity to cancel the user action.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.ContextMenu&gt;</ph> Самого класса также имеет такое же событие (<ph id="ph2">&lt;xref:System.Windows.Controls.ContextMenu.Opened&gt;</ph>), но <ph id="ph3">&lt;xref:System.Windows.Controls.ContextMenu.Opened&gt;</ph> не предоставляет возможность отмены действий пользователя.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuOpening">
          <source>Routed Event Information</source>
          <target state="translated">Сведения о маршрутизируемом событии</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuOpening">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuOpening">
          <source>Routing strategy</source>
          <target state="translated">Стратегия маршрутизации</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuOpening">
          <source>Bubbling</source>
          <target state="translated">Вверх</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuOpening">
          <source>Delegate</source>
          <target state="translated">делегат</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ContextMenuOpening">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Переопределить <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.OnContextMenuOpening%2A&gt;</ph> реализации класса обработчик данного события в производных классах.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.ContextMenuOpeningEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /&gt;</ph> routed event.</source>
          <target state="translated">Идентифицирует направленное событие <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.ContextMenuOpeningEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Идентификаторы перенаправленных событий создаются при их регистрации.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.ContextMenuOpeningEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.ContextMenuOpeningEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Эти идентификаторы можно использовать для добавления обработчиков классов.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.ContextMenuOpeningEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.ContextMenuOpeningEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.ContextMenuProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.ContextMenu" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.ContextMenu" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>Gets or sets the cursor that displays when the mouse pointer is over this element.</source>
          <target state="translated">Получение или установка курсора, который отображается при наведении указателя мыши на этот элемент.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>The cursor to display.</source>
          <target state="translated">Отображаемый курсор.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>The default value is defined as <ph id="ph1">&lt;see langword="null" /&gt;</ph> per this dependency property.</source>
          <target state="translated">Значение по умолчанию определяется как <ph id="ph1">&lt;see langword="null" /&gt;</ph> для данного свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>However, the practical default at run time will come from a variety of factors.</source>
          <target state="translated">Однако на практике значение по умолчанию во время выполнения зависит от множества факторов.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>When you set this property in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, the <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> processor relies on type conversion for the <ph id="ph3">&lt;xref:System.Windows.Input.Cursor&gt;</ph> class to evaluate the string.</source>
          <target state="translated">Если значение этого свойства в <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> процессора основывается на преобразование типа для <ph id="ph3">&lt;xref:System.Windows.Input.Cursor&gt;</ph> класса для вычисления строки.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>The provided string should evaluate to a <ph id="ph1">&lt;xref:System.Windows.Input.CursorType&gt;</ph> value.</source>
          <target state="translated">Предоставленная строка должно выражаться <ph id="ph1">&lt;xref:System.Windows.Input.CursorType&gt;</ph> значение.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph> for details.</source>
          <target state="translated">Подробные сведения см. в разделе <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>Whether the cursor as established by this property will or will not display when the mouse pointer is over this element is also dependent on the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ForceCursor%2A&gt;</ph> property.</source>
          <target state="translated">Ли курсор в соответствии с параметром этого свойства будет или не будет отображаться, когда указатель мыши находится над данным элементом зависит от значения <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ForceCursor%2A&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>Also, event-related considerations such as an active drag, mouse capture, text editing modes within controls, and so on, will also affect the cursor with higher priority than the value you specify in this property.</source>
          <target state="translated">Кроме того вопросы, связанные с событиями, как активное перетаскивание, захват мыши, режимы редактирования текста в элементы управления и т. д., также влияет на курсор с более высоким приоритетом, чем значение, указанное в данном свойстве.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>To revert the behavior of setting this property to the eventual default, set it to <ph id="ph1">`null`</ph> again.</source>
          <target state="translated">Чтобы отменить поведение этого свойства к стандартному, задайте для него значение <ph id="ph1">`null`</ph> еще раз.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>The <ph id="ph1">`null`</ph> default really means that determination of the practical cursor value is deferred here and should be obtained from elsewhere.</source>
          <target state="translated"><ph id="ph1">`null`</ph> По умолчанию реально означает, что определение практического значения курсора здесь, откладывается и должны быть получены из другого источника.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>If presented without programmatic values from any source, the default cursor that is visually over a <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> application will be an arrow.</source>
          <target state="translated">Если представления без программных значений из любого источника, курсор по умолчанию это визуально более <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> приложения будет стрелкой.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>However, the transient cursor changes are not set to the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Cursor%2A&gt;</ph> values of the elements when they are passed over.</source>
          <target state="translated">Однако изменения временной курсора не настроены для <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Cursor%2A&gt;</ph> значения элементов при наведении указателя.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Cursor%2A&gt;</ph> property will only report non null values in cases where it was actually set, for instance through code or a style.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Cursor%2A&gt;</ph> Свойство будет только отчет не значения null в случаях, где он фактически было задано, например через код или стиль.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>Each movement of the mouse over a <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> application raises a <ph id="ph2">&lt;xref:System.Windows.UIElement.QueryCursor&gt;</ph> event.</source>
          <target state="translated">Каждый движения мыши над <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> приложение создает событие <ph id="ph2">&lt;xref:System.Windows.UIElement.QueryCursor&gt;</ph> событий.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>The event bubbles, and any element along the route has the opportunity to handle the event and to set the value of the cursor through the arguments of this event.</source>
          <target state="translated">Событие может передаваться и любой элемент на маршруте имеет возможность обработать событие и задать значение курсора с помощью аргументов этого события.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>This is the mechanism that produces the visually apparent cursor in most cases.</source>
          <target state="translated">Это механизм обеспечивает визуальное отображение курсора в большинстве случаев.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>If a <ph id="ph1">&lt;xref:System.Windows.UIElement.QueryCursor&gt;</ph> handler returns a cursor result, then the fact that the event is handled and has a changed value in the arguments takes precedence over the value of the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Cursor%2A&gt;</ph> property at any level, unless <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.ForceCursor%2A&gt;</ph> is set.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Windows.UIElement.QueryCursor&gt;</ph> обработчик возвращает результат курсора, а затем тот факт, что событие обработано и имеет измененное значение в аргументах имеет приоритет над значением <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Cursor%2A&gt;</ph> свойство на любом уровне, если <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.ForceCursor%2A&gt;</ph> имеет значение.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>If not are not creating a custom cursor, you typically set this property to a static property value of the <ph id="ph1">&lt;xref:System.Windows.Input.Cursors&gt;</ph> class.</source>
          <target state="translated">Если не создается специальный курсор, вы обычно этому свойству присвоено значение статического свойства <ph id="ph1">&lt;xref:System.Windows.Input.Cursors&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>Setting <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Cursor%2A&gt;</ph> in code requires one of the following:</source>
          <target state="translated">Параметр <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Cursor%2A&gt;</ph> в коде требуется один из следующих:</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>Call the <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph> constructor to get a <ph id="ph2">&lt;xref:System.Windows.Input.Cursor&gt;</ph> instance.</source>
          <target state="translated">Вызовите <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph> конструктора для получения <ph id="ph2">&lt;xref:System.Windows.Input.Cursor&gt;</ph> экземпляра.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>Both signatures of the <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph> constructor use streams or files, in anticipation that you are creating the <ph id="ph2">&lt;xref:System.Windows.Input.Cursor&gt;</ph> object for a custom cursor.</source>
          <target state="translated">Оба подписи <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph> использовать конструктор потоков или файлов в будущем, для которого создается <ph id="ph2">&lt;xref:System.Windows.Input.Cursor&gt;</ph> объект для настраиваемого курсора.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>Use the <ph id="ph1">&lt;xref:System.Windows.Input.CursorConverter&gt;</ph> class and its <ph id="ph2">&lt;xref:System.Windows.Input.CursorConverter.ConvertFrom%2A&gt;</ph> method to specify a cursor by <ph id="ph3">&lt;xref:System.Windows.Input.CursorType&gt;</ph>, or a string that can evaluate to a <ph id="ph4">&lt;xref:System.Windows.Input.CursorType&gt;</ph>, and cast the return to <ph id="ph5">&lt;xref:System.Windows.Input.Cursor&gt;</ph>.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Windows.Input.CursorConverter&gt;</ph> класса и его <ph id="ph2">&lt;xref:System.Windows.Input.CursorConverter.ConvertFrom%2A&gt;</ph> метод для указания курсора по <ph id="ph3">&lt;xref:System.Windows.Input.CursorType&gt;</ph>, или строку, которая может быть <ph id="ph4">&lt;xref:System.Windows.Input.CursorType&gt;</ph>и приведите вернуться к <ph id="ph5">&lt;xref:System.Windows.Input.Cursor&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>Setting the <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph> to a custom value is not enabled in partial trust.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;xref:System.Windows.Input.Cursor&gt;</ph> пользовательское значение не включен в режиме частичного доверия.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>For more information on custom cursors, see <bpt id="p1">[</bpt>Input Overview<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о специальных курсорах см. в разделе <bpt id="p1">[</bpt>фокусе<ept id="p1">](~/docs/framework/wpf/advanced/input-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>None</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Cursor">
          <source>The following example shows how to deliberately set the cursor graphic.</source>
          <target state="translated">Приведенный ниже показано, как намеренную установку графического изображения курсора.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.CursorProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.Cursor" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.Cursor" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>Gets or sets the data context for an element when it participates in data binding.</source>
          <target state="translated">Получает или задает контекст данных для элемента, участвующего в привязке данных.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>The object to use as data context.</source>
          <target state="translated">Объект, используемый в качестве контекста данных.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source><bpt id="p1">*</bpt>Data context<ept id="p1">*</ept> is a concept that allows elements to inherit information from their parent elements about the data source that is used for binding, as well as other characteristics of the binding, such as the path.</source>
          <target state="translated"><bpt id="p1">*</bpt>Контекст данных<ept id="p1">*</ept> — концепция, которая позволяет элементам наследовать от своих родительских элементов об источнике данных, который используется для привязки, а также другие характеристики привязки, например путь информацию.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>Data context can be set directly to a <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> object, with the bindings evaluating to properties of that object.</source>
          <target state="translated">Контекст данных можно задать непосредственно в <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> объекта с привязками, вычисляемыми в свойства этого объекта.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>Alternatively, you can set the data context to a <ph id="ph1">&lt;xref:System.Windows.Data.DataSourceProvider&gt;</ph> object.</source>
          <target state="translated">Кроме того, можно задать контекст данных <ph id="ph1">&lt;xref:System.Windows.Data.DataSourceProvider&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>This dependency property inherits property values.</source>
          <target state="translated">Это свойство зависимостей наследуется значений свойств.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>If there are child elements without other values for <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> established through local values or styles, then the property system will set the value to be the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> value of the nearest parent element with this value assigned.</source>
          <target state="translated">Если имеются дочерние элементы без другие значения для <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> установленное с помощью локальных значений или стилей, задайте в системе свойств это значение должно быть <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> значение ближайшего родительского элемента с назначенным данным значением.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>Alternatively, you can use one of the following properties of the <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> class to specify the binding source explicitly: <ph id="ph2">&lt;xref:System.Windows.Data.Binding.ElementName%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Data.Binding.Source%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.Windows.Data.Binding.RelativeSource%2A&gt;</ph>.</source>
          <target state="translated">Кроме того, можно использовать один из следующих свойств <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> класс, чтобы явно указать источник привязки: <ph id="ph2">&lt;xref:System.Windows.Data.Binding.ElementName%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.Data.Binding.Source%2A&gt;</ph>, или <ph id="ph4">&lt;xref:System.Windows.Data.Binding.RelativeSource%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>For more information, see <bpt id="p1">[</bpt>How to: Specify the Binding Source<ept id="p1">](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>как: Укажите источник привязки<ept id="p1">](~/docs/framework/wpf/data/how-to-specify-the-binding-source.md)</ept>.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>In <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> is most typically set to as a <ph id="ph3">&lt;xref:System.Windows.Data.Binding&gt;</ph> declaration.</source>
          <target state="translated">В <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> наиболее обычно устанавливается как <ph id="ph3">&lt;xref:System.Windows.Data.Binding&gt;</ph> объявления.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>You can use either property element syntax or attribute syntax.</source>
          <target state="translated">Можно использовать синтаксис элемента свойства или синтаксис атрибутов.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>Attribute syntax is shown in the example on this page.</source>
          <target state="translated">Синтаксис атрибутов показан в примере на этой странице.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>You can also use code to set <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph>.</source>
          <target state="translated">Код также можно использовать для задания <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> is a bindable property, to facilitate scenarios where one context might be bound to another.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> может быть привязано, чтобы облегчить сценарии, где одного контекста может быть привязан к другому.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>However, if you bind to <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph>, be careful to not create circular binding references (do not bind a <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> to itself, which is possible to do because of the property value inheritance nature of the <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> property).</source>
          <target state="translated">Тем не менее если выполняется привязка к <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph>, следует соблюдать осторожность, чтобы не создавать привязки циклических ссылок (без привязки <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> на себя, это можно сделать из-за особенностей наследования значения свойства <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> свойство).</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>XAML Property Element Usage</source>
          <target state="translated">Использование элемента свойства XAML</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>XAML Attribute Usage</source>
          <target state="translated">Использование атрибута XAML</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>XAML Values</source>
          <target state="translated">Значения XAML</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source><bpt id="p1">*</bpt>dataContextObject<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>dataContextObject<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>A directly embedded object that serves as data context for any bindings within the parent element.</source>
          <target state="translated">Непосредственно внедренный объект, который служит в качестве контекста данных для любых привязок внутри родительского элемента.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>Typically, this object is a <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> or another <ph id="ph2">&lt;xref:System.Windows.Data.BindingBase&gt;</ph> derived class.</source>
          <target state="translated">Как правило, этот объект является <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> или другой <ph id="ph2">&lt;xref:System.Windows.Data.BindingBase&gt;</ph> производного класса.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>Alternatively, raw data of any <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> object type intended for binding may be placed here, with the actual bindings defined later.</source>
          <target state="translated">Кроме того необработанные данные любого <ph id="ph1">[!INCLUDE[TLA2#tla_clr](~/includes/tla2sharptla-clr-md.md)]</ph> предназначен для привязки могут быть помещены с фактические привязки определить позже, тип объекта.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source><bpt id="p1">*</bpt>bindingUsage<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>bindingUsage<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>A binding usage that evaluates to an appropriate data context.</source>
          <target state="translated">Использование привязки, результатом вычисления которого в соответствующий контекст данных.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>For details, see <bpt id="p1">[</bpt>Binding Markup Extension<ept id="p1">](~/docs/framework/wpf/advanced/binding-markup-extension.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Привязка расширения разметки<ept id="p1">](~/docs/framework/wpf/advanced/binding-markup-extension.md)</ept>.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>One of the following:  or .</source>
          <target state="translated">Одно из следующих: или.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>This usage is used when referring to raw data defined as an object in resources.</source>
          <target state="translated">Данный подход используется при обращении к необработанным данным объектом, в ресурсах.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>See <bpt id="p1">[</bpt>XAML Resources<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</source>
          <target state="translated">В разделе <bpt id="p1">[</bpt>ресурсов XAML<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source><bpt id="p1">*</bpt>contextResourceKey<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>contextResourceKey<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>The key identifier for the object being requested from within a <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">Идентификатор ключа для запрашиваемого внутри объекта <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DataContext">
          <source>The following example illustrates how a data context acts on a binding and provides the information that defines the specific values of bound properties.</source>
          <target state="translated">В следующем примере показано, как действует контекст данных для привязки и приводятся сведения, определяющую конкретные значения связанных свойств.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkElement.DataContextChanged">
          <source>Occurs when the data context for this element changes.</source>
          <target state="translated">Происходит при изменении контекста данных для элемента.</target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.DataContextChanged">
          <source>For an explanation of data contexts and data binding, see <bpt id="p1">[</bpt>Data Binding Overview<ept id="p1">](~/docs/framework/wpf/data/data-binding-overview.md)</ept>.</source>
          <target state="translated">Объяснение контекстов данных и привязки данных см. в разделе <bpt id="p1">[</bpt>Общие сведения о привязке данных<ept id="p1">](~/docs/framework/wpf/data/data-binding-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.DataContextChanged">
          <source>When the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> for an element changes, all data-bound properties on this element are potentially affected.</source>
          <target state="translated">Когда <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> для изменения элемента потенциально затрагиваются все свойства с привязкой к данным для этого элемента.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.DataContextChanged">
          <source>This applies to any elements that are child elements of the current element in the logical tree, which inherit the data context, and also the current element itself.</source>
          <target state="translated">Это относится к любые элементы, которые являются дочерними элементами элемента текущего элемента в логическом дереве наследующим контекст данных, а также сам элемент.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.DataContextChanged">
          <source>All such existing bindings must re-interpret the new <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> and will reevaluate the binding results.</source>
          <target state="translated">Такие существующие привязки необходимо интерпретировать повторно новый <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> и повторного вычисления результатов привязки.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.DataContextChanged">
          <source>The data binding engine is not deterministic about the order of these reevaluations, relative to the raising of the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.DataContextChanged&gt;</ph> event.</source>
          <target state="translated">Механизм привязки данных не является детерминированным о порядке эти повторные вычисления, относительно формирование <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.DataContextChanged&gt;</ph> событий.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.DataContextChanged">
          <source>The reevaluations can occur before the event, after the event, or in any mixture.</source>
          <target state="translated">Повторные вычисления могут производиться перед событием, после события или в любом сочетании.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.DataContextProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.DataContext" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.DataContext" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.DefaultStyleKey">
          <source>Gets or sets the key to use to reference the style for this control, when theme styles are used or defined.</source>
          <target state="translated">Возвращает или задает ключ, используемый для ссылки на стиль этого элемента управления, при использовании или определении тематических стилей.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DefaultStyleKey">
          <source>The style key.</source>
          <target state="translated">Ключ стиля.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DefaultStyleKey">
          <source>To work correctly as part of theme style lookup, this value is expected to be the <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> of the control being styled.</source>
          <target state="translated">Для правильной работы этого значения в ходе поиска стиля темы ожидается, что оно принадлежит к типу <ph id="ph1">&lt;see cref="T:System.Type" /&gt;</ph> элемента управления, к которому применяется стиль.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DefaultStyleKey">
          <source>This property is typically not set through any of its direct property accessors.</source>
          <target state="translated">Это свойство обычно не задается через какой-либо из его прямых методов доступа.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DefaultStyleKey">
          <source>Instead, you override the type-specific metadata of this dependency property every time you create a new <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> derived class.</source>
          <target state="translated">Вместо этого каждый раз при создании нового переопределения метаданных определенного типа этого свойства зависимостей <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> производного класса.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DefaultStyleKey">
          <source>When you derive a control, call the <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> method against the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty&gt;</ph> identifier, within the static constructor of the control derived class (or equivalent class initialization).</source>
          <target state="translated">При создании производного элемента управления, вызовите <ph id="ph1">&lt;xref:System.Windows.DependencyProperty.OverrideMetadata%2A&gt;</ph> метода для <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.DefaultStyleKeyProperty&gt;</ph> идентификатор в статическом конструкторе элемента управления производный класс (или эквивалентный класс инициализации).</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DefaultStyleKey">
          <source>A control typically overrides the default value of this property to be its own type, but in some cases could also use a base type for which a style in the theme dictionaries exists.</source>
          <target state="translated">Элемент управления обычно переопределяет значение по умолчанию этого свойства должен иметь свой собственный тип, но в некоторых случаях может также использовать базовый тип, для которого существует стиль в словарях темы.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DefaultStyleKey">
          <source>This is only practical if the control templates of the base control entirely define the visual representation of that derived control, and if whatever additional members the derived types expose do not require additional elements as part of the control template.</source>
          <target state="translated">Это практически возможно только если шаблоны базового элемента управления полностью определяют визуальное представление производного элемента управления и любые дополнительные элементы, производные типы предоставлять не требуется дополнительных элементов в рамках шаблона элемента управления.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DefaultStyleKey">
          <source>If you want your element or control to deliberately not use theme styles, set the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A&gt;</ph> property to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Элемент или элемент управления, намеренно не используемый тематических стилей, установите <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A&gt;</ph> свойства <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DefaultStyleKey">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DefaultStyleKey">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DefaultStyleKey">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DefaultStyleKey">
          <source>The following example illustrates the dependency property metadata override usage discussed in Remarks.</source>
          <target state="translated">В следующем примере показано использование переопределения метаданных свойства зависимостей, рассматриваемые в примечания.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DefaultStyleKey">
          <source>This code defines a custom control class <ph id="ph1">`NumericUpDown`</ph> intended to be used from a dedicated control library assembly.</source>
          <target state="translated">Этот код определяет класс пользовательского элемента управления <ph id="ph1">`NumericUpDown`</ph> предназначен для использования из сборки библиотеку выделенного элемента управления.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DefaultStyleKey">
          <source>The illustrated static constructor references some private initialization function, registers a class handler (another common control subclassing scenario; see <bpt id="p1">[</bpt>Marking Routed Events as Handled, and Class Handling<ept id="p1">](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)</ept>) and finally overrides the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.DefaultStyleKey%2A&gt;</ph> dependency property metadata on the <ph id="ph2">`NumericUpDown`</ph> class.</source>
          <target state="translated">Иллюстрированные статический конструктор ссылается на некоторые закрытые функции инициализации, регистрирует обработчик класса (другой распространенный сценарий создания подкласса элемента управления см. в разделе <bpt id="p1">[</bpt>как Handled и обработка класса<ept id="p1">](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)</ept>) и, наконец, переопределяет <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.DefaultStyleKey%2A&gt;</ph> метаданные свойства зависимостей на <ph id="ph2">`NumericUpDown`</ph> класса.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DefaultStyleKey">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.DefaultStyleKey%2A&gt;</ph> always returns its own type as the intended key, which is the convention that the theme style system uses to look up the style for some arbitrary otherwise non-styled control.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.DefaultStyleKey%2A&gt;</ph> всегда возвращает собственный тип как предполагаемый ключ, который является соглашением, системой стиля темы для поиска стиля для некоторых произвольных без стиля элемента управления.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.DefaultStyleKey">
          <source>The complete sample also defines the actual control's theme style that is referenced by that key; see <bpt id="p1">[</bpt>NumericUpDown Custom Control with Theme and UI Automation Support Sample<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=160025)</ept>.</source>
          <target state="translated">Полный пример также определяет стиль темы фактического элемента управления, на который ссылается этому ключу; в разделе <bpt id="p1">[</bpt>пользовательский элемент управления NumericUpDown с темой и пример Поддержка модели автоматизации пользовательского интерфейса<ept id="p1">](http://go.microsoft.com/fwlink/?LinkID=160025)</ept>.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.DefaultStyleKeyProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.DefaultStyleKey" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.DefaultStyleKey" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.EndInit">
          <source>Indicates that the initialization process for the element is complete.</source>
          <target state="translated">Указывает на завершение процесса инициализации элемента.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.EndInit">
          <source>If <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.BeginInit%2A&gt;</ph> was previously called, the base implementation will raise the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Initialized&gt;</ph> event.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.BeginInit%2A&gt;</ph> был вызван ранее, базовый вызывает реализацию <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Initialized&gt;</ph> событий.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.EndInit">
          <source>Otherwise, if <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.BeginInit%2A&gt;</ph> was not called or it could not be determined whether <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.BeginInit%2A&gt;</ph> was called, <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.Initialized&gt;</ph> is not raised and an exception is thrown instead.</source>
          <target state="translated">В противном случае, если <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.BeginInit%2A&gt;</ph> не был вызван или не удалось определить, является ли <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.BeginInit%2A&gt;</ph> был вызван <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.Initialized&gt;</ph> не возникает и вместо этого создается исключение.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.EndInit">
          <source><ph id="ph1">&lt;see cref="M:System.Windows.FrameworkElement.EndInit" /&gt;</ph> was called without <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkElement.BeginInit" /&gt;</ph> having previously been called on the element.</source>
          <target state="translated">Метод <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkElement.EndInit" /&gt;</ph> был вызван без предварительного вызова метода <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkElement.BeginInit" /&gt;</ph> для элемента.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.EndInit">
          <source>Implement this method to provide special handling that should happen when your element is initialized during the element loading process.</source>
          <target state="translated">Реализуйте этот метод, чтобы обеспечить специальную обработку, которая будет выполняться при инициализации элемента в процессе его загрузки.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.EndInit">
          <source>Your implementation should call the base implementation, because the base (default) implementation sets some internal flags to keep track of initialization.</source>
          <target state="translated">Реализация должна вызывать базовую реализацию, поскольку реализация base (по умолчанию) устанавливает внутренние флаги для отслеживания инициализации.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.FindName(System.String)">
          <source>The name of the requested element.</source>
          <target state="translated">Имя запрошенного элемента.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.FindName(System.String)">
          <source>Finds an element that has the provided identifier name.</source>
          <target state="translated">Находит элемент по указанному имени идентификатора.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.FindName(System.String)">
          <source>The requested element.</source>
          <target state="translated">Запрошенный элемент.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.FindName(System.String)">
          <source>This can be <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no matching element was found.</source>
          <target state="translated">Может иметь значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>, если соответствующий элемент не найден.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.FindName(System.String)">
          <source>If the element has child elements, these child elements are all searched recursively for the requested named element.</source>
          <target state="translated">Если элемент содержит дочерние элементы, эти дочерние элементы являются все выполняется рекурсивный поиск запрошенного именованного элемента.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.FindName(System.String)">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FindName%2A&gt;</ph> operates within the current element's namescope.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FindName%2A&gt;</ph> действует в пределах области видимости имен текущего элемента.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.FindName(System.String)">
          <source>For details, see <bpt id="p1">[</bpt>WPF XAML Namescopes<ept id="p1">](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>области имен XAML WPF<ept id="p1">](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.FindResource(System.Object)">
          <source>The key identifier for the requested resource.</source>
          <target state="translated">Ключевой идентификатор запрашиваемого ресурса.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.FindResource(System.Object)">
          <source>Searches for a resource with the specified key, and throws an exception if the requested resource is not found.</source>
          <target state="translated">Осуществляет поиск ресурса с указанным ключом и вызывает исключение, если запрошенный ресурс не найден.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.FindResource(System.Object)">
          <source>The requested resource.</source>
          <target state="translated">Запрошенный ресурс.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.FindResource(System.Object)">
          <source>If no resource with the provided key was found, an exception is thrown.</source>
          <target state="translated">Если ресурс с указанным ключом не найден, выдается исключение.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.FindResource(System.Object)">
          <source>An <ph id="ph1">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph> value might also be returned in the exception case.</source>
          <target state="translated">В случае исключение может быть также возвращено значение <ph id="ph1">&lt;see cref="F:System.Windows.DependencyProperty.UnsetValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.FindResource(System.Object)">
          <source>If you call this method for a key that cannot be found, an exception is thrown.</source>
          <target state="translated">Если этот метод вызывается для ключа, который не удается найти, создается исключение.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.FindResource(System.Object)">
          <source>If you do not want to handle exceptions that result from calling <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FindResource%2A&gt;</ph>, call <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.TryFindResource%2A&gt;</ph> instead.</source>
          <target state="translated">Если вы не хотите обрабатывать исключения, возникающие в результате вызова <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FindResource%2A&gt;</ph>, вызовите <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.TryFindResource%2A&gt;</ph> вместо него.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.FindResource(System.Object)">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.TryFindResource%2A&gt;</ph> returns <ph id="ph2">`null`</ph> when a requested resource cannot be found, and does not throw an exception.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.TryFindResource%2A&gt;</ph> Возвращает <ph id="ph2">`null`</ph> когда не удается найти запрошенный ресурс и не вызывает исключение.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.FindResource(System.Object)">
          <source>If the resource is not found on the calling element, the parent element in the logical tree is searched next, then the application, then themes, and finally system resources.</source>
          <target state="translated">Если ресурс не найден в вызывающем элементе, в логическом дереве родительского элемента — выполняется дальнейший поиск, то приложения, а затем темы и наконец системных ресурсов.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.FindResource(System.Object)">
          <source>This lookup methodology is identical to how the tree is searched if a resource were requested by a dynamic resource reference in markup.</source>
          <target state="translated">Этот метод поиска идентична как поиск в дереве, если запрошенного ресурса по ссылке на динамический ресурс в разметке.</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.FindResource(System.Object)">
          <source>For more information about resource lookup, see <bpt id="p1">[</bpt>XAML Resources<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о поиске ресурсов см. в разделе <bpt id="p1">[</bpt>ресурсов XAML<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.FindResource(System.Object)">
          <source>Typically, you immediately cast a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FindResource%2A&gt;</ph> return value to the type of the property that you setting with the returned resource value.</source>
          <target state="translated">Как правило, вы сразу же привести <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FindResource%2A&gt;</ph> возвращаемое значение в тип свойства, можно задать значение возвращаемого ресурса.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.FindResource(System.Object)">
          <source>Resource keys are not necessarily strings.</source>
          <target state="translated">Ключи ресурсов не обязательно являются строками.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.FindResource(System.Object)">
          <source>For instance, styles for controls at the theme level are deliberately keyed to the <ph id="ph1">&lt;xref:System.Type&gt;</ph> of the control, and application or page styles for controls typically use this same key convention.</source>
          <target state="translated">Например, стили для элементов управления на уровне тема представляют собой ключи произвольного <ph id="ph1">&lt;xref:System.Type&gt;</ph> элемента управления и стили приложения или страницы для элементов управления обычно используется ключ соглашение.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.FindResource(System.Object)">
          <source>For details, see <bpt id="p1">[</bpt>Styling and Templating<ept id="p1">](~/docs/framework/wpf/controls/styling-and-templating.md)</ept> or <bpt id="p2">[</bpt>XAML Resources<ept id="p2">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Стилизация и использование шаблонов<ept id="p1">](~/docs/framework/wpf/controls/styling-and-templating.md)</ept> или <bpt id="p2">[</bpt>ресурсов XAML<ept id="p2">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.FindResource(System.Object)">
          <source>The following example obtains a named resource and casts it to an appropriate type to fill a property.</source>
          <target state="translated">В следующем примере получает именованный ресурс и приводит его к соответствующему типу для заполнения свойства.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.FindResource(System.Object)">
          <source><ph id="ph1">&lt;paramref name="resourceKey" /&gt;</ph> was not found and an event handler does not exist for the <ph id="ph2">&lt;see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" /&gt;</ph> event.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceKey" /&gt;</ph> не найден, и обработчик событий для события <ph id="ph2">&lt;see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" /&gt;</ph> не существует.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.FindResource(System.Object)">
          <source>-or-</source>
          <target state="translated">- или -</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.FindResource(System.Object)">
          <source><ph id="ph1">&lt;paramref name="resourceKey" /&gt;</ph> was not found and the <ph id="ph2">&lt;see cref="P:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled" /&gt;</ph> property is <ph id="ph3">&lt;see langword="false" /&gt;</ph> in the <ph id="ph4">&lt;see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" /&gt;</ph> event.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="resourceKey" /&gt;</ph> не найден, и свойство <ph id="ph2">&lt;see cref="P:System.Windows.Threading.DispatcherUnhandledExceptionEventArgs.Handled" /&gt;</ph> имеет значение <ph id="ph3">&lt;see langword="false" /&gt;</ph> в событии <ph id="ph4">&lt;see cref="E:System.Windows.Threading.Dispatcher.UnhandledException" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.FindResource(System.Object)">
          <source><ph id="ph1">&lt;paramref name="resourceKey" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="resourceKey" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.FlowDirection">
          <source>Gets or sets the direction that text and other <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> elements flow within any parent element that controls their layout.</source>
          <target state="translated">Возвращает или задает направление потока текста и других элементов <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> внутри любого родительского элемента, управляющего их структурой.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FlowDirection">
          <source>The direction that text and other <ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph> elements flow within their parent element, as a value of the enumeration.</source>
          <target state="translated">Направление потока текста и других элементов <ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph> внутри их родительского элемента, в виде значения перечисления.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FlowDirection">
          <source>The default value is <ph id="ph1">&lt;see cref="F:System.Windows.FlowDirection.LeftToRight" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию — <ph id="ph1">&lt;see cref="F:System.Windows.FlowDirection.LeftToRight" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FlowDirection">
          <source>The dependency property usage sets the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FlowDirection%2A&gt;</ph> on this element.</source>
          <target state="translated">Свойство задает использование зависимостей <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FlowDirection%2A&gt;</ph> для этого элемента.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FlowDirection">
          <source>Because of property value inheritance, setting <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FlowDirection%2A&gt;</ph> on an element can potentially set <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.FlowDirection%2A&gt;</ph> on all child elements that did not set <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.FlowDirection%2A&gt;</ph> locally or though other means such as styles.</source>
          <target state="translated">Из-за наследование значения свойства, задание <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FlowDirection%2A&gt;</ph> на элемент потенциально можно задать <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.FlowDirection%2A&gt;</ph> на все дочерние элементы, которые не задал <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.FlowDirection%2A&gt;</ph> локально или менее других средств, таких как стили.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FlowDirection">
          <source>This property is not automatically set as part of any application culture information, because an element might contain content that is not necessarily intended to obey the general flow direction implied by the culture information.</source>
          <target state="translated">Это свойство не задано автоматически в рамках языка и региональных параметров сведений о приложении, так как элемент может содержать содержимое, которое не обязательно соблюдать общие направление содержится в сведения языка и региональных параметров.</target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FlowDirection">
          <source>For more information on globalization considerations, see <bpt id="p1">[</bpt>Globalization for WPF<ept id="p1">](~/docs/framework/wpf/advanced/globalization-for-wpf.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о вопросах глобализации см. в разделе <bpt id="p1">[</bpt>Глобализация для WPF<ept id="p1">](~/docs/framework/wpf/advanced/globalization-for-wpf.md)</ept>.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FlowDirection">
          <source>This property has a defined <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> property accessor, so it functions as a dependency property.</source>
          <target state="translated">Это свойство не определил <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> доступа к свойству, поэтому он функционирует как свойство зависимостей.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FlowDirection">
          <source>However, it is also registered as attached, so it can also function as an attached property.</source>
          <target state="translated">Тем не менее он также регистрируется как подключенные, поэтому он также может работать как вложенное свойство.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FlowDirection">
          <source>The attached registration is mainly so that property value inheritance is supported, but the property can also be used as a true attached property.</source>
          <target state="translated">Вложенная регистрация является главным образом, что поддерживается наследование значения свойства, но свойство также может использоваться как истинное вложенное свойство.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FlowDirection">
          <source>The attached property usage is only relevant if the object you intend to set the flow direction on has a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> parent element that performs layout upon it, is itself not a <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, and does not already have a more directly defined <ph id="ph3">`FlowDirection`</ph> property.</source>
          <target state="translated">Использование вложенного свойства применяется, только если вы хотите задать направление потока на объект имеет <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> сам не является родительским элементом, выполняющий макета с ней, <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph>и еще не содержит более явно определенные <ph id="ph3">`FlowDirection`</ph> свойство.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FlowDirection">
          <source>(Some of the flow document classes such as <ph id="ph1">&lt;xref:System.Windows.Documents.Block&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Documents.Inline&gt;</ph> define their own <ph id="ph3">`FlowDirection`</ph>, and this property can also set the flow direction.</source>
          <target state="translated">(Некоторые потока документов классы, такие как <ph id="ph1">&lt;xref:System.Windows.Documents.Block&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.Documents.Inline&gt;</ph> определять свои собственные <ph id="ph3">`FlowDirection`</ph>, и это свойство можно также задать направление потока.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FlowDirection">
          <source>The property value is then read by the eventual content host without requiring attached property usage.)</source>
          <target state="translated">Значение свойства затем считывается конечного узла содержимого без необходимости использования вложенного свойства.)</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FlowDirection">
          <source>XAML Attribute Usage</source>
          <target state="translated">Использование атрибута XAML</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FlowDirection">
          <source><ph id="ph1">\&lt;</ph><bpt id="p1">*</bpt>object<ept id="p1">*</ept> <bpt id="p2">**</bpt>FlowDirection<ept id="p2">**</ept>="<ph id="ph2">&lt;xref:System.Windows.FlowDirection&gt;</ph>"/&gt;</source>
          <target state="translated"><ph id="ph1">\&lt;</ph><bpt id="p1">*</bpt>Объект<ept id="p1">*</ept> <bpt id="p2">**</bpt>FlowDirection<ept id="p2">**</ept>=»<ph id="ph2">&lt;xref:System.Windows.FlowDirection&gt;</ph>«/ &gt;</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FlowDirection">
          <source>XAML Text Usage</source>
          <target state="translated">Использование текста XAML</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FlowDirection">
          <source>This property can also be set on classes that are not <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> derived classes, by the following <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> attached property usage:</source>
          <target state="translated">Это свойство можно также задать в классах, которые не являются <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> производные классы, с помощью следующего <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> прикрепленное свойство:</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FlowDirection">
          <source><ph id="ph1">`&lt;`</ph> <bpt id="p1">*</bpt>object<ept id="p1">*</ept> <ph id="ph2">`FrameworkElement.`</ph><bpt id="p2">**</bpt>FlowDirection<ept id="p2">**</ept>="<ph id="ph3">&lt;xref:System.Windows.FlowDirection&gt;</ph><ph id="ph4">`"/&gt;`</ph></source>
          <target state="translated"><ph id="ph1">`&lt;`</ph> <bpt id="p1">*</bpt>Объект<ept id="p1">*</ept> <ph id="ph2">`FrameworkElement.`</ph> <bpt id="p2">**</bpt>FlowDirection<ept id="p2">**</ept>=»<ph id="ph3">&lt;xref:System.Windows.FlowDirection&gt;</ph><ph id="ph4">`"/&gt;`</ph></target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FlowDirection">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FlowDirection">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FlowDirection">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FlowDirection">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A&gt;</ph></target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FlowDirection">
          <source>This property is both a dependency property and an attached property; see Remarks.</source>
          <target state="translated">Это свойство является свойством зависимостей и присоединенным свойством; см. заметки.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.FlowDirectionProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.FlowDirection" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.FlowDirection" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.FocusVisualStyle">
          <source>Gets or sets a property that enables customization of appearance, effects, or other style characteristics that will apply to this element when it captures keyboard focus.</source>
          <target state="translated">Получает или задает свойство, позволяющее настройку внешнего вида, эффектов или других характеристик стиля, применяемых к данному элементу, когда он получает фокус клавиатуры.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FocusVisualStyle">
          <source>The desired style to apply on focus.</source>
          <target state="translated">Требуемый стиль для применения при получении фокуса.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FocusVisualStyle">
          <source>The default value as declared in the dependency property is an empty static <ph id="ph1">&lt;see cref="T:System.Windows.Style" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию, объявленное в свойстве зависимостей, представляет собой пустой статический <ph id="ph1">&lt;see cref="T:System.Windows.Style" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FocusVisualStyle">
          <source>However, the effective value at run time is often (but not always) a style as supplied by theme support for controls.</source>
          <target state="translated">Тем не менее, действительным значением во время выполнения часто (но не всегда) является стиль, представленный поддержкой тем для элементов управления.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FocusVisualStyle">
          <source>This property affects visual appearance but does not report <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A&gt;</ph> in metadata.</source>
          <target state="translated">Это свойство влияет на внешний вид, но не сообщает о <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A&gt;</ph> в метаданных.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FocusVisualStyle">
          <source>This is because the visual appearance change is event-driven and may not apply at all times, and therefore should not generally report any visual or layout information in metadata.</source>
          <target state="translated">Это так, как изменение внешнего вида управляется событиями и могут применяться не все время, поэтому не следует обычно сообщать любые сведения о visual или макета в метаданных.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FocusVisualStyle">
          <source>Conceptually, the visual behavior of focus applied to a control should be coherent from control to control.</source>
          <target state="translated">По существу visual поведение фокуса, примененного к элементу управления, должно быть согласовано от элемента управления.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FocusVisualStyle">
          <source>The most sensible way to enforce coherence is to only change the focus visual style if you are composing an entire theme.</source>
          <target state="translated">Наиболее понятным способом применения согласованности является изменение стиля визуального отображения фокуса только при составлении целой темы.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FocusVisualStyle">
          <source>Setting this property on individual control styles and not as part of a theme is not the intended usage of this property, because it may lead to a confusing user experience regarding keyboard focus.</source>
          <target state="translated">Задание этого свойства отдельных стилей элементов управления, а не как часть темы не предполагаемого использования этого свойства, так как это может привести к путанице при использовании фокуса клавиатуры.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FocusVisualStyle">
          <source>If you are intending control-specific behavior that is deliberately not coherent across a theme, a much better approach is to use triggers in styles for individual input state properties, such as <ph id="ph1">&lt;xref:System.Windows.UIElement.IsFocused%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A&gt;</ph>, and to do so in a way that does not visually interfere with any existing focus visual style.</source>
          <target state="translated">Если планируется поведение элемента управления, намеренно не согласовано в теме гораздо лучшим подходом является использование триггеров в стилях для отдельных свойств состояния ввода, такие как <ph id="ph1">&lt;xref:System.Windows.UIElement.IsFocused%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Windows.UIElement.IsKeyboardFocusWithin%2A&gt;</ph>и таким образом, в результате которого не визуально мешать любой существующий стиль визуального отображения фокуса.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FocusVisualStyle">
          <source>For more information on the design intention of <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FocusVisualStyle%2A&gt;</ph> and alternative focus properties, see <bpt id="p1">[</bpt>Styling for Focus in Controls, and FocusVisualStyle<ept id="p1">](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о необходимым <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FocusVisualStyle%2A&gt;</ph> и альтернативное сосредоточиться свойств см. в разделе <bpt id="p1">[</bpt>стиля фокуса в элементах управления и стиля визуального отображения фокуса<ept id="p1">](~/docs/framework/wpf/advanced/styling-for-focus-in-controls-and-focusvisualstyle.md)</ept>.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FocusVisualStyle">
          <source>XAML Attribute Usage</source>
          <target state="translated">Использование атрибута XAML</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FocusVisualStyle">
          <source>XAML Property Element Usage</source>
          <target state="translated">Использование элемента свойства XAML</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FocusVisualStyle">
          <source>XAML Values</source>
          <target state="translated">Значения XAML</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FocusVisualStyle">
          <source><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FocusVisualStyle">
          <source>One of the following: , or .</source>
          <target state="translated">Одно из следующих:, или.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FocusVisualStyle">
          <source>See <bpt id="p1">[</bpt>XAML Resources<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</source>
          <target state="translated">В разделе <bpt id="p1">[</bpt>ресурсов XAML<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FocusVisualStyle">
          <source><bpt id="p1">*</bpt>styleResourceKey<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>styleResourceKey<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FocusVisualStyle">
          <source>The key that identifies the style being requested.</source>
          <target state="translated">Ключ, идентифицирующий запрашиваемый стиль.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FocusVisualStyle">
          <source>The key refers to an existing resource in a <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">Ключ ссылается на существующий ресурс в <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FocusVisualStyle">
          <source>Property element syntax is technically possible, but not recommended.</source>
          <target state="translated">Синтаксис элемента свойства технически возможно, но не рекомендуется.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FocusVisualStyle">
          <source>See <bpt id="p1">[</bpt>Inline Styles and Templates<ept id="p1">](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)</ept>.</source>
          <target state="translated">В разделе <bpt id="p1">[</bpt>встроенные стили и шаблоны<ept id="p1">](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)</ept>.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FocusVisualStyle">
          <source>A binding reference using  or <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> is also possible, but uncommon.</source>
          <target state="translated">Ссылка привязки с помощью или <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> также является, возможно, но встречается редко.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FocusVisualStyle">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FocusVisualStyle">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FocusVisualStyle">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.FocusVisualStyle">
          <source>None</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.FocusVisualStyleProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.FocusVisualStyle" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.FocusVisualStyle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.ForceCursor">
          <source>Gets or sets a value that indicates whether this <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> should force the <ph id="ph2">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> to render the cursor as declared by the <ph id="ph3">&lt;see cref="P:System.Windows.FrameworkElement.Cursor" /&gt;</ph> property.</source>
          <target state="translated">Возвращает или задает значение, указывающее, следует ли данному <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> заставлять <ph id="ph2">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph> визуализировать курсор, как объявлено свойством <ph id="ph3">&lt;see cref="P:System.Windows.FrameworkElement.Cursor" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ForceCursor">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if cursor presentation while over this element is forced to use current <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkElement.Cursor" /&gt;</ph> settings for the cursor (including on all child elements); otherwise <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если для презентации курсора, расположенного над данным элементом, принудительно используются текущие настройки <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkElement.Cursor" /&gt;</ph> для курсора (а также для всех дочерних элементов); в противном случае — <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ForceCursor">
          <source>The default value is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию — <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ForceCursor">
          <source>If you set this property to <ph id="ph1">`true`</ph> you will override the cursor preferences established by child elements.</source>
          <target state="translated">Если значение этого свойства <ph id="ph1">`true`</ph> переопределяют настройки курсора, установленные дочерними элементами.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ForceCursor">
          <source>Doing so in general application <ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph> might be confusing for the user, particularly if child elements are attempting to specify cursors.</source>
          <target state="translated">Поэтому в общем приложения это <ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph> может сбить с толку для пользователей, особенно в том случае, если дочерние элементы пытаются задавать курсоры.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ForceCursor">
          <source>Setting <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ForceCursor%2A&gt;</ph> is more appropriate in control subclassing or compositing scenarios.</source>
          <target state="translated">Параметр <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ForceCursor%2A&gt;</ph> больше подходит в сценариях управления подклассы или композиции.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ForceCursor">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ForceCursor">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ForceCursor">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ForceCursor">
          <source>None</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ForceCursor">
          <source>The following example forces the cursor value.</source>
          <target state="translated">Следующий пример принудительно значение курсора.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.ForceCursorProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.ForceCursor" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.ForceCursor" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)">
          <source>The target <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph> to get the binding from.</source>
          <target state="translated">Целевое <ph id="ph1">&lt;see cref="T:System.Windows.DependencyProperty" /&gt;</ph>, из которого получается привязка.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)">
          <source>Returns the <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph> that represents the binding on the specified property.</source>
          <target state="translated">Возвращает выражение <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph>, представляющее привязку для указанного свойства.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph> if the target property has an active binding; otherwise, returns <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Выражение <ph id="ph1">&lt;see cref="T:System.Windows.Data.BindingExpression" /&gt;</ph>, если целевое свойство содержит активную привязку; в противном случае возвращает <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)">
          <source>Checking the return value for <ph id="ph1">`null`</ph> is a technique you can use to determine whether a property has an active binding.</source>
          <target state="translated">Проверять возвращаемое значение для <ph id="ph1">`null`</ph> — это метод, который можно использовать для определения, является ли свойство имеет активную привязку.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)">
          <source>This method is really just a convenience wrapper around the <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Этот метод является лишь удобную оболочку вокруг <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetBindingExpression(System.Windows.DependencyProperty)">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.GetBindingExpression%2A&gt;</ph> passes the current instance and the <ph id="ph2">`dp`</ph> parameter to <ph id="ph3">&lt;xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.GetBindingExpression%2A&gt;</ph> передает текущий экземпляр и <ph id="ph2">`dp`</ph> параметр <ph id="ph3">&lt;xref:System.Windows.Data.BindingOperations.GetBindingExpression%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)">
          <source>The element to return a <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.FlowDirection" /&gt;</ph> for.</source>
          <target state="translated">Элемент, для которого возвращается свойство <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.FlowDirection" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)">
          <source>Gets the value of the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.FlowDirection" /&gt;</ph> attached property for the specified <ph id="ph2">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph>.</source>
          <target state="translated">Получает значение присоединенного свойства <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.FlowDirection" /&gt;</ph> указанного элемента <ph id="ph2">&lt;see cref="T:System.Windows.DependencyObject" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)">
          <source>The requested flow direction, as a value of the enumeration.</source>
          <target state="translated">Запрошенное направление потока, как значение перечисления.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)">
          <source>The main purpose of this method is to support attached property syntax for the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FlowDirection%2A&gt;</ph> property, therefore allowing child elements of a provided <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> to specify flow direction for the arrangement within their parent element.</source>
          <target state="translated">Основное назначение этого метода является поддержка синтаксис присоединенного свойства для <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FlowDirection%2A&gt;</ph> свойство, таким образом позволяя дочерних элементов указанного <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> для указания направления потока для упорядочения в родительском элементе.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetFlowDirection(System.Windows.DependencyObject)">
          <source>To get the value on the current <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, use the direct <ph id="ph2">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> accessor <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.FlowDirection%2A&gt;</ph>.</source>
          <target state="translated">Для получения значения в текущем <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, использовать прямые <ph id="ph2">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> доступа <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.FlowDirection%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)">
          <source>The size of the part of the element that does visual presentation.</source>
          <target state="translated">Размер части элемента, выполняющей визуальную презентацию.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)">
          <source>Returns a geometry for a clipping mask.</source>
          <target state="translated">Возвращает геометрию маски отсечения.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)">
          <source>The mask applies if the layout system attempts to arrange an element that is larger than the available display space.</source>
          <target state="translated">Маска применяется при попытке системы структуры скомпоновать элемент, размер которого превышает доступное экранное пространство.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)">
          <source>The clipping geometry.</source>
          <target state="translated">Геометрия отсечения.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)">
          <source>Margins will be subtracted from the <ph id="ph1">`layoutSlotSize`</ph> as part of layout system behavior.</source>
          <target state="translated">Поля вычитаются из <ph id="ph1">`layoutSlotSize`</ph> как часть поведение системы макета.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)">
          <source>A returned null reference indicates that no clipping will occur.</source>
          <target state="translated">Возвращаемая ссылка null указывает, что отсечение выполнено не будет.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)">
          <source>The default implementation always returns <ph id="ph1">`null`</ph> when <ph id="ph2">&lt;xref:System.Windows.UIElement.ClipToBounds%2A&gt;</ph> is <ph id="ph3">`false`</ph>.</source>
          <target state="translated">Реализация по умолчанию всегда возвращает <ph id="ph1">`null`</ph> при <ph id="ph2">&lt;xref:System.Windows.UIElement.ClipToBounds%2A&gt;</ph> — <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Этот метод переопределяет метод <ph id="ph1">&lt;xref:System.Windows.UIElement.GetLayoutClip%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> implementation uses <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.MaxHeight%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.MaxWidth%2A&gt;</ph> in its calculations.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> Реализация использует <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.MaxHeight%2A&gt;</ph> и <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.MaxWidth%2A&gt;</ph> в вычислениях.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)">
          <source>Several subclasses of <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> override this method again.</source>
          <target state="translated">Несколько подклассы <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> Переопределите этот метод еще раз.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)">
          <source><ph id="ph1">&lt;xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=nameWithType&gt;</ph>, overrides to always return <ph id="ph2">`null`</ph> because adorners are often deliberately outside the ordinary bounds.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Documents.Adorner.GetLayoutClip%2A?displayProperty=nameWithType&gt;</ph>, переопределяет всегда возвращают <ph id="ph2">`null`</ph> так, как графические элементы намеренно часто находятся за пределами обычного границы.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)">
          <source><ph id="ph1">&lt;xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=nameWithType&gt;</ph> return <ph id="ph3">`null`</ph> if <ph id="ph4">&lt;xref:System.Windows.UIElement.ClipToBounds%2A&gt;</ph> is <ph id="ph5">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.Canvas.GetLayoutClip%2A?displayProperty=nameWithType&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.Controls.InkPresenter.GetLayoutClip%2A?displayProperty=nameWithType&gt;</ph> возвращают <ph id="ph3">`null`</ph> Если <ph id="ph4">&lt;xref:System.Windows.UIElement.ClipToBounds%2A&gt;</ph> — <ph id="ph5">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)">
          <source>The default implementation always returns <ph id="ph1">&lt;see langword="null" /&gt;</ph> when <ph id="ph2">&lt;see cref="P:System.Windows.UIElement.ClipToBounds" /&gt;</ph> is <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Реализация по умолчанию всегда возвращает <ph id="ph1">&lt;see langword="null" /&gt;</ph> при <ph id="ph2">&lt;see cref="P:System.Windows.UIElement.ClipToBounds" /&gt;</ph> — <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetLayoutClip(System.Windows.Size)">
          <source>Overrides are generally expected to preserve this behavior, although there are exceptions, depending on the relationship and purpose of the derived class and its layout logic as opposed to the base class.</source>
          <target state="translated">Переопределений обычно ожидается сохранение этого поведения, хотя существуют исключения, в зависимости от связи и назначения производного класса и его логики структуры, в отличие от базового класса.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.GetTemplateChild(System.String)">
          <source>Name of the child to find.</source>
          <target state="translated">Имя искомого дочернего элемента.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.GetTemplateChild(System.String)">
          <source>Returns the named element in the visual tree of an instantiated <ph id="ph1">&lt;see cref="T:System.Windows.Controls.ControlTemplate" /&gt;</ph>.</source>
          <target state="translated">Возвращает именованный элемент в визуальном дереве объекта <ph id="ph1">&lt;see cref="T:System.Windows.Controls.ControlTemplate" /&gt;</ph>, для которого создан экземпляр.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.GetTemplateChild(System.String)">
          <source>The requested element.</source>
          <target state="translated">Запрошенный элемент.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.GetTemplateChild(System.String)">
          <source>May be <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no element of the requested name exists.</source>
          <target state="translated">Может иметь значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>, если элемента с запрошенным именем не существует.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetTemplateChild(System.String)">
          <source>Templates in <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> have a self-contained namescope.</source>
          <target state="translated">Шаблоны в <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> быть самодостаточным имен.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetTemplateChild(System.String)">
          <source>This is because templates are re-used, and any name defined in a template cannot remain unique when multiple instances of a control each instantiate its template.</source>
          <target state="translated">Это так, как шаблоны повторно используются и любое имя, определенное в шаблоне не уникальности при его шаблон экземпляра несколько экземпляров элемента управления.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetTemplateChild(System.String)">
          <source>Call the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.GetTemplateChild%2A&gt;</ph> method to return references to objects that come from the template after it is instantiated.</source>
          <target state="translated">Вызовите <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.GetTemplateChild%2A&gt;</ph> метод для возврата ссылки на объекты, полученные из шаблона, после ее создания.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetTemplateChild(System.String)">
          <source>You cannot use the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType&gt;</ph> method to find items from templates because <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType&gt;</ph> acts in a more general scope, and there is no connection between the <ph id="ph3">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> class itself and the instantiated template once it is applied.</source>
          <target state="translated">Нельзя использовать <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType&gt;</ph> метод для поиска элементов на основе шаблонов, так как <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.FindName%2A?displayProperty=nameWithType&gt;</ph> действует в более общим области, поэтому нет соединения между <ph id="ph3">&lt;xref:System.Windows.Controls.ControlTemplate&gt;</ph> класса себя и экземпляра шаблона после его применения.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetTemplateChild(System.String)">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType&gt;</ph> supplies the same function as this method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType&gt;</ph> предоставляет ту же функцию, как этот метод.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetTemplateChild(System.String)">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType&gt;</ph> is public instead of protected, and it uses correct name-scoping considerations that allow it to access the template within an element and find named items within it.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType&gt;</ph> public, а не защищен и использует правильный имен вопросы, позволяющие получить доступ к шаблону в элементе и поиска с именем элементов внутри него.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetTemplateChild(System.String)">
          <source>Use <ph id="ph1">&lt;xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType&gt;</ph> when you need to get an element outside of its parent control.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.Windows.FrameworkTemplate.FindName%2A?displayProperty=nameWithType&gt;</ph> при необходимости получения элемента за пределами его родительского элемента управления.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.GetUIParentCore">
          <source>Returns an alternative logical parent for this element if there is no visual parent.</source>
          <target state="translated">Возвращает альтернативный логический родительский объект для этого элемента при отсутствии визуального родительского объекта.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.GetUIParentCore">
          <source>Returns something other than <ph id="ph1">&lt;see langword="null" /&gt;</ph> whenever a WPF framework-level implementation of this method has a non-visual parent connection.</source>
          <target state="translated">Возвращает нечто, отличное от <ph id="ph1">&lt;see langword="null" /&gt;</ph>, каждый раз, когда реализация уровня инфраструктуры WPF этого метода имеет подключение без визуального родительского объекта.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetUIParentCore">
          <source>This method overrides <ph id="ph1">&lt;xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Этот метод переопределяет метод <ph id="ph1">&lt;xref:System.Windows.UIElement.GetUIParentCore%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetUIParentCore">
          <source>The default <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> implementation returns the expected single visual parent, which is the same result as getting the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Parent%2A&gt;</ph> value.</source>
          <target state="translated">Значение по умолчанию <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> реализация возвращает ожидаемый единый визуальный родитель, который является тем же, как получение <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Parent%2A&gt;</ph> значение.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetUIParentCore">
          <source>Derived class implementations might return alternate parent relationships.</source>
          <target state="translated">Реализации производных классов могут возвращать альтернативные родительские связи.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)">
          <source>The zero-based index of the requested child element in the collection.</source>
          <target state="translated">Отсчитываемый от нуля индекс запрошенного дочернего элемента коллекции.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)">
          <source>Overrides <ph id="ph1">&lt;see cref="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" /&gt;</ph>, and returns a child at the specified index from a collection of child elements.</source>
          <target state="translated">Переопределяет метод <ph id="ph1">&lt;see cref="M:System.Windows.Media.Visual.GetVisualChild(System.Int32)" /&gt;</ph> и возвращает дочерний элемент по указанному индексу из коллекции дочерних элементов.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)">
          <source>The requested child element.</source>
          <target state="translated">Запрошенный дочерний элемент.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)">
          <source>This should not return <ph id="ph1">&lt;see langword="null" /&gt;</ph>; if the provided index is out of range, an exception is thrown.</source>
          <target state="translated">Не должен возвращать значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>; если указанный индекс находится за пределами диапазона, происходит исключение.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)">
          <source>In the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> implementation, the only valid index is zero.</source>
          <target state="translated">В <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> реализации единственным допустимым индексом равно нулю.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)">
          <source>The content model for <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.GetVisualChild%2A&gt;</ph> supports either zero or one child elements, not a collection.</source>
          <target state="translated">Модель содержимого для <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.GetVisualChild%2A&gt;</ph> содержит ноль или один дочерние элементы управления, не коллекцию.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)">
          <source>The following example shows how a custom adorner uses the values declared by a <ph id="ph1">&lt;xref:System.Windows.Media.VisualCollection&gt;</ph> that it maintains for its multiple visual children.</source>
          <target state="translated">В следующем примере показано, как пользовательский графический элемент использует значения, объявленные с <ph id="ph1">&lt;xref:System.Windows.Media.VisualCollection&gt;</ph> , он поддерживает для множества визуальных дочерних элементов.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)">
          <source>These values are reported through overrides of <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.VisualChildrenCount%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.GetVisualChild%2A&gt;</ph>.</source>
          <target state="translated">Эти значения передаются через переопределения <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.VisualChildrenCount%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.GetVisualChild%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)">
          <source>This implementation is only valid for elements that do not maintain any more descriptive collection of visual child elements.</source>
          <target state="translated">Эта реализация допустимо только для элементов, которые не поддерживают более описательную коллекцию визуальных дочерних элементов.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)">
          <source>Any element that does have such a collection must override this method and map the index to an equivalent index in the child element collection that is supported by that element.</source>
          <target state="translated">Любой элемент, имеющий такой коллекции необходимо переопределить этот метод и сопоставлять индекс с эквивалентным индексом в коллекции дочерних элементов, поддерживаемой данным элементом.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)">
          <source>An index in the range from zero to <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" /&gt;</ph> (minus one) should return a valid element; any other index should throw an out-of-range exception.</source>
          <target state="translated">Индекс в диапазоне от 0 до <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" /&gt;</ph> (минус) должен возвращать допустимый элемент; любого другого индекса должен создать исключение вне диапазона.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)">
          <source>An example of an element type that does support a child collection and overrides <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" /&gt;</ph> to return more than one possible child is <ph id="ph2">&lt;see cref="T:System.Windows.Controls.Panel" /&gt;</ph>.</source>
          <target state="translated">Пример типа элемента, который поддерживает коллекцию дочерних и переопределяет <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)" /&gt;</ph> для возврата нескольких возможных дочерних — <ph id="ph2">&lt;see cref="T:System.Windows.Controls.Panel" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)">
          <source>The default implementation in <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> presumes only one visual child.</source>
          <target state="translated">Реализация по умолчанию в <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> предполагает только один дочерний элемент visual.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)">
          <source>Any value passed for <ph id="ph1">&lt;paramref name="index" /&gt;</ph> other than zero causes an exception to be thrown.</source>
          <target state="translated">Значение, переданное для <ph id="ph1">&lt;paramref name="index" /&gt;</ph> Кроме нуль вызывает исключение, создаваемое исключение.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)">
          <source>Several common elements, such as decorators, adorners, or elements with specialized rendering, override the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> implementation (of the implementation from intermediate base classes).</source>
          <target state="translated">Стандартные элементы, например декораторы, графические элементы или элементы со специальными средствами визуализации, переопределяют <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> реализацию (реализации из промежуточных базовых классов).</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.GetVisualChild(System.Int32)">
          <source>Some implementations still enforce one visual child whereas others allow a collection.</source>
          <target state="translated">Некоторые реализации все еще требуют одного визуального дочернего элемента, в то время как другие разрешают коллекцию.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.Height">
          <source>Gets or sets the suggested height of the element.</source>
          <target state="translated">Получает или задает предлагаемую высоту элемента.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>The height of the element, in <ph id="ph1">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph>.</source>
          <target state="translated">Высота элемента в <ph id="ph1">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>The default value is <ph id="ph1">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию — <ph id="ph1">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>This value must be equal to or greater than 0.0.</source>
          <target state="translated">Это значение должно быть не меньше 0,0.</target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph> is one of three writable properties on <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> that specify height information.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph> является одним из трех свойств для записи на <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> , укажите информацию о высоте.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>The other two are <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MinHeight%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.MaxHeight%2A&gt;</ph>.</source>
          <target state="translated">Два других — <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MinHeight%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.MaxHeight%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>If there is a conflict between these values, the order of application for actual height determination is that first <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MinHeight%2A&gt;</ph> must be honored, then <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.MaxHeight%2A&gt;</ph>, and finally, if it is within bounds, <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph>.</source>
          <target state="translated">При наличии конфликта между эти значения, порядок приложения для определения фактических высоту, первый <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MinHeight%2A&gt;</ph> должен быть принят на обработку, затем <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.MaxHeight%2A&gt;</ph>и, наконец, если он находится в пределах границ, <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>If this element is a child element within some other element, then setting this property to a value is really only a suggested value.</source>
          <target state="translated">Если этот элемент является дочерним элементом в другой элемент, затем этому свойству присвоить значение самом деле предлагаемое значение.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>The layout system as well as the particular layout logic of the parent element will use the value as a nonbinding input during the layout process.</source>
          <target state="translated">Система макета, а также конкретной логикой структуры родительского элемента будет использовать значение как несвязанного ввода во время процесса компоновки.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>In practical terms, a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> is almost always the child element of something else; even when you set the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph> on <ph id="ph3">&lt;xref:System.Windows.Window&gt;</ph>.</source>
          <target state="translated">На практике <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> почти всегда является дочерним элементом еще; даже в том случае, если задать <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph> на <ph id="ph3">&lt;xref:System.Windows.Window&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>(For <ph id="ph1">&lt;xref:System.Windows.Window&gt;</ph>, that value is used when the underlying application model establishes the basic rendering assumptions that create the Hwnd that hosts the application.)</source>
          <target state="translated">(Для <ph id="ph1">&lt;xref:System.Windows.Window&gt;</ph>, данное значение используется, когда базовой моделью приложения устанавливает основные отрисовки допущений, создают Hwnd, где размещается приложение.)</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>In addition to acceptable <ph id="ph1">&lt;xref:System.Double&gt;</ph> values, this property can also be <ph id="ph2">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">В дополнение к допустимого <ph id="ph1">&lt;xref:System.Double&gt;</ph> значения, это свойство также может быть <ph id="ph2">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>This is how you specify auto sizing behavior in code.</source>
          <target state="translated">Это показано, как указать поведение автоматического изменения размеров в коде.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>In <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> you set the value to the string "Auto" (case insensitive) to enable the auto sizing behavior.</source>
          <target state="translated">В <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> значение в строку «Auto» (без учета регистра) чтобы включить автоматическое изменение размеров.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>Auto sizing behavior implies that the element will fill the height available to it.</source>
          <target state="translated">Автоматическое изменение размеров предполагает, что элемент заполнит доступную ему высоту.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>Note however that specific controls frequently supply default values through their default theme styles that will disable the auto sizing behavior unless it is specifically re-enabled.</source>
          <target state="translated">Обратите внимание, что определенные элементы управления передают значения по умолчанию через их тематические стили по умолчанию, которые отключают автоматическое изменение размеров, если его специально повторно включить.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>The return value of this property is always the same as any value that was set to it.</source>
          <target state="translated">Возвращаемое значение этого свойства всегда является таким же, как любое значение, которое было задано.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>In contrast, the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ActualHeight%2A&gt;</ph> may vary.</source>
          <target state="translated">Напротив, значение <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ActualHeight%2A&gt;</ph> могут различаться.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>This can happen either statically because the layout rejected the suggested size for some reason, or momentarily.</source>
          <target state="translated">Это может происходить как статически, так как макет отклонить предполагаемый размер по какой-либо причине, или моментально.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>The layout system itself works asynchronously relative to the property system's set of <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph> and may not have processed that particular sizing property change yet.</source>
          <target state="translated">Сама система структуры работает асинхронно относительно набора в системе свойств <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph> и может не обработать конкретное изменение свойства размера еще.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>The value restrictions on the <ph id="ph1">&lt;xref:System.Double&gt;</ph> value are enforced by a <ph id="ph2">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> mechanism.</source>
          <target state="translated">Значение ограничения <ph id="ph1">&lt;xref:System.Double&gt;</ph> определяется значение <ph id="ph2">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> механизм.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>If you attempt to set an invalid value, a run-time exception is thrown.</source>
          <target state="translated">При попытке задать недопустимое значение, возникает исключение времени выполнения.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>In addition to the validation check, there is a nondeterministic upper value bound for <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph> that is enforced by the layout system (this is a very large number, larger than <ph id="ph2">&lt;xref:System.Single.MaxValue?displayProperty=nameWithType&gt;</ph> but smaller than <ph id="ph3">&lt;xref:System.Double.MaxValue?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">В дополнение к проверке подлинности является недетерминированной наибольшее значение, привязанное к <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph> , обеспечивается системой макета (это очень большое число, большее, чем <ph id="ph2">&lt;xref:System.Single.MaxValue?displayProperty=nameWithType&gt;</ph> но меньше, чем <ph id="ph3">&lt;xref:System.Double.MaxValue?displayProperty=nameWithType&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>If you exceed this bound, the element will not render, and no exception is thrown.</source>
          <target state="translated">Если превысить это ограничение, элемент не будет отображаться, и исключение не возникает.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>Do not set <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph> to a value that is significantly larger than the maximum size of any possible visual display, or you may exceed this nondeterministic upper bound.</source>
          <target state="translated">Не устанавливайте <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph> значение значительно больше, чем максимальный размер любого возможного визуального дисплея, или может превысить эту недетерминированную верхнюю границу.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>XAML Attribute Usage</source>
          <target state="translated">Использование атрибута XAML</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>XAML Values</source>
          <target state="translated">Значения XAML</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source><bpt id="p1">*</bpt>double<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>double<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>String representation of a <ph id="ph1">&lt;xref:System.Double&gt;</ph> value equal to or greater than 0.0.</source>
          <target state="translated">Строковое представление <ph id="ph1">&lt;xref:System.Double&gt;</ph> значение, равное или больше 0,0.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>See Remarks for upper bound information.</source>
          <target state="translated">Сведения о верхней границе см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>This value is interpreted as a <ph id="ph1">[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]</ph> measurement.</source>
          <target state="translated">Это значение интерпретируется как <ph id="ph1">[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]</ph> измерения.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>Strings need not explicitly include decimal points.</source>
          <target state="translated">Строки не нужно явно указывать десятичного разделителя.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>For instance a value of <ph id="ph1">`1`</ph> is acceptable.</source>
          <target state="translated">Для экземпляра значение <ph id="ph1">`1`</ph> является допустимым.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source><bpt id="p1">*</bpt>qualifiedDouble<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>qualifiedDouble<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>A <bpt id="p1">*</bpt>double<ept id="p1">*</ept> value as described above, followed by one of the following unit declaration strings: <ph id="ph1">`px`</ph>, <ph id="ph2">`in`</ph>, <ph id="ph3">`cm`</ph>, <ph id="ph4">`pt`</ph>.</source>
          <target state="translated">Объект <bpt id="p1">*</bpt>двойные<ept id="p1">*</ept> значение как описано выше, за которым следует один из следующих строк объявления единицы измерения: <ph id="ph1">`px`</ph>, <ph id="ph2">`in`</ph>, <ph id="ph3">`cm`</ph>, <ph id="ph4">`pt`</ph>.</target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source><ph id="ph1">`px`</ph> (default) is <ph id="ph2">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph></source>
          <target state="translated"><ph id="ph1">`px`</ph> (по умолчанию) <ph id="ph2">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source><ph id="ph1">`in`</ph> is inches; 1in==96px</source>
          <target state="translated"><ph id="ph1">`in`</ph> дюймах; 1 дюйм == 96 точек</target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source><ph id="ph1">`cm`</ph> is centimeters; 1cm==(96/2.54) px</source>
          <target state="translated"><ph id="ph1">`cm`</ph> сантиметрах; 1см==(96/2,54) пкс</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source><ph id="ph1">`pt`</ph> is points; 1pt==(96/72) px</source>
          <target state="translated"><ph id="ph1">`pt`</ph> точках; 1точка==(96/72) пкс</target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source><bpt id="p1">**</bpt>Auto<ept id="p1">**</ept></source>
          <target state="translated"><bpt id="p1">**</bpt>Auto<ept id="p1">**</ept></target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>Enables autosizing behavior.</source>
          <target state="translated">Включает автоматическое определение размера.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>See Remarks.</source>
          <target state="translated">См. заметки.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Height">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.HeightProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.Height" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.Height" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.HorizontalAlignment">
          <source>Gets or sets the horizontal alignment characteristics applied to this element when it is composed within a parent element, such as a panel or items control.</source>
          <target state="translated">Получение или установка характеристик выравнивания по горизонтали, применяемых к этому элементу при его размещении в родительском элементе управления, например в панели или элементе управления элементами.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.HorizontalAlignment">
          <source>A horizontal alignment setting, as a value of the enumeration.</source>
          <target state="translated">Параметр горизонтального выравнивания как значение перечисления.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.HorizontalAlignment">
          <source>The default is <ph id="ph1">&lt;see cref="F:System.Windows.HorizontalAlignment.Stretch" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию: <ph id="ph1">&lt;see cref="F:System.Windows.HorizontalAlignment.Stretch" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.HorizontalAlignment">
          <source>When <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph> properties are explicitly set on an element, these measurements take higher precedent during layout and will cancel the typical effects of setting <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.HorizontalAlignment%2A&gt;</ph> to <ph id="ph4">&lt;xref:System.Windows.HorizontalAlignment.Stretch&gt;</ph>.</source>
          <target state="translated">Когда <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph> от элемента явно заданы свойства, этих измерений занять высокий приоритет во время структурирования и отменит типичные эффекты параметр <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.HorizontalAlignment%2A&gt;</ph> для <ph id="ph4">&lt;xref:System.Windows.HorizontalAlignment.Stretch&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.HorizontalAlignment">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.HorizontalAlignment%2A&gt;</ph> is the <ph id="ph2">[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]</ph> property accessor for what is in reality a dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.HorizontalAlignment%2A&gt;</ph> — <ph id="ph2">[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]</ph> доступа свойства для Какова на самом деле свойство зависимостей.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.HorizontalAlignment">
          <source>This particular dependency property quite frequently has its apparent "default" value set differently in subclassed elements, particularly controls.</source>
          <target state="translated">Это свойство зависимостей конкретного довольно часто имеет значение «по умолчанию» по-разному в подклассах элементов, в частности в элементах управления.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.HorizontalAlignment">
          <source>This generally occurs in one of two ways: the dependency property is re-registered to a particular subclass, but with different metadata for setting its defaults; or there is a default style being applied that sets that dependency property value differently.</source>
          <target state="translated">Обычно такая ситуация возникает в одном из двух способов: свойство зависимости регистрируется повторно подкласса, но с другой метаданных для задания значения по умолчанию; либо стиль по умолчанию применяется, который задает это значение свойства зависимостей по-разному.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.HorizontalAlignment">
          <source>For example, the apparent "default" of <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.HorizontalAlignment%2A&gt;</ph> for a <ph id="ph2">&lt;xref:System.Windows.Controls.Label&gt;</ph> control will be <ph id="ph3">&lt;xref:System.Windows.HorizontalAlignment.Left&gt;</ph>, even though <ph id="ph4">&lt;xref:System.Windows.Controls.Label&gt;</ph> inherits <ph id="ph5">&lt;xref:System.Windows.FrameworkElement.HorizontalAlignment%2A&gt;</ph> direct from <ph id="ph6">&lt;xref:System.Windows.FrameworkElement&gt;</ph>.</source>
          <target state="translated">Например, «по умолчанию» для <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.HorizontalAlignment%2A&gt;</ph> для <ph id="ph2">&lt;xref:System.Windows.Controls.Label&gt;</ph> элемент управления будет <ph id="ph3">&lt;xref:System.Windows.HorizontalAlignment.Left&gt;</ph>, даже если <ph id="ph4">&lt;xref:System.Windows.Controls.Label&gt;</ph> наследует <ph id="ph5">&lt;xref:System.Windows.FrameworkElement.HorizontalAlignment%2A&gt;</ph> непосредственно от <ph id="ph6">&lt;xref:System.Windows.FrameworkElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.HorizontalAlignment">
          <source>This is because that value was reset within the default style of <ph id="ph1">&lt;xref:System.Windows.Controls.Label&gt;</ph>, within the style's control template.</source>
          <target state="translated">Это, поскольку это значение было сброшено в качестве стиля по умолчанию <ph id="ph1">&lt;xref:System.Windows.Controls.Label&gt;</ph>, в шаблоне элемента управления стилем.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.HorizontalAlignment">
          <source><ph id="ph1">&lt;xref:System.Windows.Controls.Canvas&gt;</ph> does not use <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.HorizontalAlignment%2A&gt;</ph> when composing layout, because <ph id="ph3">&lt;xref:System.Windows.Controls.Canvas&gt;</ph> is based on absolute positioning.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.Canvas&gt;</ph> не используйте <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.HorizontalAlignment%2A&gt;</ph> при создании макета, так как <ph id="ph3">&lt;xref:System.Windows.Controls.Canvas&gt;</ph> основывающаяся на абсолютном позиционировании.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.HorizontalAlignment">
          <source>When inherited by <ph id="ph1">&lt;xref:System.Windows.Controls.Label&gt;</ph> or derived classes, <ph id="ph2">&lt;xref:System.Windows.Controls.Label&gt;</ph> redefines the default value of this dependency property to be <ph id="ph3">&lt;xref:System.Windows.HorizontalAlignment.Left&gt;</ph>.</source>
          <target state="translated">Если наследуемые <ph id="ph1">&lt;xref:System.Windows.Controls.Label&gt;</ph> или производных классов, <ph id="ph2">&lt;xref:System.Windows.Controls.Label&gt;</ph> переопределяет значение по умолчанию этого свойства зависимостей, чтобы быть <ph id="ph3">&lt;xref:System.Windows.HorizontalAlignment.Left&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.HorizontalAlignment">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.HorizontalAlignment">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.HorizontalAlignment">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.HorizontalAlignmentProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.HorizontalAlignment" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.HorizontalAlignment" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.InheritanceBehavior">
          <source>Gets or sets the scope limits for property value inheritance, resource key lookup, and RelativeSource FindAncestor lookup.</source>
          <target state="translated">Получает или задает пределы области видимости для наследования значений свойств, поиска ключей ресурсов и поиска RelativeSource FindAncestor.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.InheritanceBehavior">
          <source>A value of the enumeration.</source>
          <target state="translated">Значение перечисления.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.InheritanceBehavior">
          <source>The default is <ph id="ph1">&lt;see cref="F:System.Windows.InheritanceBehavior.Default" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию: <ph id="ph1">&lt;see cref="F:System.Windows.InheritanceBehavior.Default" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.InheritanceBehavior">
          <source>Certain boundaries in the element tree set <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.InheritanceBehavior%2A&gt;</ph> to deliberately limit the scope of inheritance behavior, to a force resource lookup to check the application resources, or to prevent a RelativeSource FindAncestor lookup from querying the current element or any further.</source>
          <target state="translated">Определенные границы в элементе дерева набор <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.InheritanceBehavior%2A&gt;</ph> чтобы намеренно ограничить область наследования в поиске ресурсов force для проверки ресурсов приложения или для предотвращения подстановки RelativeSource FindAncestor запрос текущего элемента или дальнейшее.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.InheritanceBehavior">
          <source>RelativeSource FindAncestor lookup occurs when a binding uses a <ph id="ph1">&lt;xref:System.Windows.Data.RelativeSource&gt;</ph> that has its <ph id="ph2">&lt;xref:System.Windows.Data.RelativeSource.Mode%2A&gt;</ph> property set to the <ph id="ph3">&lt;xref:System.Windows.Data.RelativeSourceMode.FindAncestor?displayProperty=nameWithType&gt;</ph> value.</source>
          <target state="translated">RelativeSource FindAncestor уточняющего запроса происходит, когда привязка использует <ph id="ph1">&lt;xref:System.Windows.Data.RelativeSource&gt;</ph> с его <ph id="ph2">&lt;xref:System.Windows.Data.RelativeSource.Mode%2A&gt;</ph> присвоено <ph id="ph3">&lt;xref:System.Windows.Data.RelativeSourceMode.FindAncestor?displayProperty=nameWithType&gt;</ph> значение.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.InheritanceBehavior">
          <source>If you want your derived class to set this property, you should do so within the static constructor or in other initialization routines.</source>
          <target state="translated">Если требуется задать это свойство производного класса, необходимо делать это в статическом конструкторе или других процедурах инициализации.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkElement.Initialized">
          <source>Occurs when this <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> is initialized.</source>
          <target state="translated">Происходит во время инициализации данного <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkElement.Initialized">
          <source>This event coincides with cases where the value of the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.IsInitialized" /&gt;</ph> property changes from <ph id="ph2">&lt;see langword="false" /&gt;</ph> (or undefined) to <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Данное событие совпадает со случаями, когда значение свойства <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.IsInitialized" /&gt;</ph> изменяется с <ph id="ph2">&lt;see langword="false" /&gt;</ph> (или неопределенного) на <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Initialized">
          <source>This event will be raised whenever the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.EndInit%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A&gt;</ph> methods are called.</source>
          <target state="translated">Это событие будет каждый раз, когда возникает <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.EndInit%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.OnVisualParentChanged%2A&gt;</ph> вызываются методы.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Initialized">
          <source>Calls to either method could have come from application code, or through the <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> processor behavior when a <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> page is processed.</source>
          <target state="translated">Вызовы для обоих методов производятся из кода приложения или посредством <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> поведение процессора при <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> обработки страницы.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Initialized">
          <source>Whether you choose to handle <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Loaded&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Initialized&gt;</ph> depends on your requirements.</source>
          <target state="translated">Выбор режима обработки <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Loaded&gt;</ph> или <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Initialized&gt;</ph> зависит от требований.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Initialized">
          <source>If you do not need to read element properties, intend to reset properties, and do not need any layout information, <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Initialized&gt;</ph> might be the better event to act upon.</source>
          <target state="translated">Если вам не нужно прочитать свойства элемента, требуется сбросить свойства и не обязательно любые сведения о макете <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Initialized&gt;</ph> может быть лучше событий для обработки.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Initialized">
          <source>If you need all properties of the element to be available, and you will be setting properties that are likely to reset the layout, <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Loaded&gt;</ph> might be the better event to act upon.</source>
          <target state="translated">Если требуется все свойства элемента доступны, и установка свойств, которые могут сбросить макет, <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Loaded&gt;</ph> может быть лучше событий для обработки.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Initialized">
          <source>Be careful of reentrancy if your handler resets any properties that are interpreted by the layout system to mean that a new layout pass is required.</source>
          <target state="translated">Будьте внимательны повторного входа, если обработчик сбрасывает все свойства, которые интерпретируются системой макета означает, что требуется новый передачи макета.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Initialized">
          <source>(You might need to check the <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> values on the property if you are unsure of which properties can require a new layout pass if they are changed.)</source>
          <target state="translated">(Может понадобиться вернуть <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> значения для свойства, если вы не знаете, какие свойства могут требовать новый макет передачи, если они были изменены.)</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Initialized">
          <source>For more information about the sequence of object events for a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, and also for several related application and element classes, see <bpt id="p1">[</bpt>Object Lifetime Events<ept id="p1">](~/docs/framework/wpf/advanced/object-lifetime-events.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о последовательности событий объекта для <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>и для нескольких связанных классах приложений и элементов, см. также <bpt id="p1">[</bpt>события времени жизни объектов<ept id="p1">](~/docs/framework/wpf/advanced/object-lifetime-events.md)</ept>.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.InputScope">
          <source>Gets or sets the context for input used by this <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph>.</source>
          <target state="translated">Получает или задает контекст для ввода, используемый данным <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.InputScope">
          <source>The input scope, which modifies how input from alternative input methods is interpreted.</source>
          <target state="translated">Область ввода, которая изменяет интерпретацию ввода с помощью альтернативных методов.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.InputScope">
          <source>The default value is <ph id="ph1">&lt;see langword="null" /&gt;</ph> (which results in a default handling of commands).</source>
          <target state="translated">Значение по умолчанию равно <ph id="ph1">&lt;see langword="null" /&gt;</ph> (что приводит к обработке команд по умолчанию).</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.InputScope">
          <source>This dependency property inherits property values.</source>
          <target state="translated">Это свойство зависимостей наследуется значений свойств.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.InputScope">
          <source>If there are child elements without other values for <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.InputScope%2A&gt;</ph> established through local values or styles, then the property system will set the value to be the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.InputScope%2A&gt;</ph> value of the nearest ancestor element with this value assigned.</source>
          <target state="translated">Если имеются дочерние элементы без другие значения для <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.InputScope%2A&gt;</ph> установленное с помощью локальных значений или стилей, задайте в системе свойств это значение должно быть <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.InputScope%2A&gt;</ph> значение ближайшего предка элемента с назначенным данным значением.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.InputScope">
          <source>Although a <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax usage is listed and is syntactically allowed, setting this property in <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> is not common.</source>
          <target state="translated">Несмотря на то что <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> использование синтаксиса указано и синтаксически разрешено, задание этого свойства <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> не так часто.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.InputScope">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.InputScope">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.InputScope">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.InputScopeProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.InputScope" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.InputScope" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.IsInitialized">
          <source>Gets a value that indicates whether this element has been initialized, either during processing by a <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> processor, or by explicitly having its <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkElement.EndInit" /&gt;</ph> method called.</source>
          <target state="translated">Возвращает значение, показывающее, был ли инициализирован данный элемент — либо в ходе обработки процессором <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, либо путем явного вызова его метода <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkElement.EndInit" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.IsInitialized">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the element is initialized per the aforementioned <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> processing or method calls; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если элемент инициализирован путем вышеупомянутой обработки <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> или вызова методов; в противном случае — <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.IsInitialized">
          <source>This property may also be <ph id="ph1">`true`</ph> if this element has been moved within the logical tree such that it has a new parent element, and therefore becomes reloaded again.</source>
          <target state="translated">Это свойство также может быть <ph id="ph1">`true`</ph> Если этот элемент был перемещен в логическом дереве таким образом, что он имеет новый родительский элемент и снова станет перегруженным.</target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.IsInitialized">
          <source>This property is useful if you also are using <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.BeginInit%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.EndInit%2A&gt;</ph>.</source>
          <target state="translated">Это свойство полезно, если вы используете <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.BeginInit%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.EndInit%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.IsInitialized">
          <source>Elements in the logical tree that is loaded by a <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> processor are assured to be initialized.</source>
          <target state="translated">Элементы в логическом дереве, загружаемой в <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> процессора гарантированно инициализации.</target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.IsInitialized">
          <source>Elements not in the logical tree are initialized when <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.EndInit%2A&gt;</ph> is called.</source>
          <target state="translated">Элементы не в логическом дереве инициализируются при <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.EndInit%2A&gt;</ph> вызывается.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.IsInitialized">
          <source>In absence of any specific handling of <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.BeginInit%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.EndInit%2A&gt;</ph>, this will happen as soon as the constructor returns the initialized result.</source>
          <target state="translated">В отсутствие любого конкретного обработка <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.BeginInit%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.EndInit%2A&gt;</ph>, это происходит сразу после завершения работы конструктор возвращает инициализированное результат.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.IsLoaded">
          <source>Gets a value that indicates whether this element has been loaded for presentation.</source>
          <target state="translated">Возвращает значение, указывающее, загружен ли данный элемент для презентации.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.IsLoaded">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current element is attached to an element tree; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the element has never been attached to a loaded element tree.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если текущий элемент присоединен к дереву элементов; <ph id="ph2">&lt;see langword="false" /&gt;</ph>, если элемент никогда не был присоединен к загруженному дереву элементов.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.IsLoaded">
          <source>From a newly constructed <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, this property starts off <ph id="ph2">`false`</ph>, and remains <ph id="ph3">`true`</ph> after it is set to <ph id="ph4">`true`</ph>, even if the element is subsequently removed from a connected logical tree by code.</source>
          <target state="translated">Из только что созданной <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, это свойство начинается <ph id="ph2">`false`</ph>и остается <ph id="ph3">`true`</ph> было присвоено <ph id="ph4">`true`</ph>, даже если элемент впоследствии удаляется из подключенного логического дерева из кода.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.IsLoaded">
          <source><ph id="ph1">`true`</ph> state is set by the general presentation logic when elements are loaded into the presentation engine.</source>
          <target state="translated"><ph id="ph1">`true`</ph> состояние задается общей логикой презентации при загрузке элементов в механизм презентации.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.IsLoaded">
          <source>Typically, loaded elements are rendered, but not all <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> derived classes have a presentation, and other properties such as <ph id="ph2">&lt;xref:System.Windows.UIElement.Visibility%2A&gt;</ph> can influence presentation.</source>
          <target state="translated">Как правило, загруженных элементов, готовый для просмотра, но не все <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> производные классы имеют презентации и другие свойства, такие как <ph id="ph2">&lt;xref:System.Windows.UIElement.Visibility%2A&gt;</ph> могут повлиять на презентации.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.IsLoaded">
          <source>The following example implements two handlers: one is handling the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Loaded&gt;</ph> event of the root element, so it is certain that the page root element is loaded because that is the significance of the event.</source>
          <target state="translated">Следующий пример реализует два обработчика: один обрабатывает <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Loaded&gt;</ph> событий корневого элемента, чтобы убедиться в загруженный корневой элемент страницы так, как это является значением события.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.IsLoaded">
          <source>The other handler is hooked to a user control, and calls <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.IsLoaded%2A&gt;</ph> to assure that the root element is loaded completely.</source>
          <target state="translated">Другой обработчик привязан к пользовательского элемента управления и вызовы <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.IsLoaded%2A&gt;</ph> чтобы убедиться, что корневой элемент загружается полностью.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.IsLoaded">
          <source>Both handlers call the same function (not shown) that will populate child elements with fresh data.</source>
          <target state="translated">Оба обработчика вызывают ту же функцию (не показано), заполняет дочерние элементы свежими данными.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.Language">
          <source>Gets or sets localization/globalization language information that applies to an element.</source>
          <target state="translated">Возвращает или задает сведения о языке локализации и глобализации, который применяется к элементу.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Language">
          <source>The language information for this element.</source>
          <target state="translated">Сведения о языке для этого элемента.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Language">
          <source>The default value is an <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XmlLanguage" /&gt;</ph> with its <ph id="ph2">&lt;see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /&gt;</ph> value set to the string "en-US".</source>
          <target state="translated">Значение по умолчанию — <ph id="ph1">&lt;see cref="T:System.Windows.Markup.XmlLanguage" /&gt;</ph>, для свойства <ph id="ph2">&lt;see cref="P:System.Windows.Markup.XmlLanguage.IetfLanguageTag" /&gt;</ph> которого установлено строковое значение "en-US".</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Language">
          <source>The string formats follow the RFC 3066 standard.</source>
          <target state="translated">Строковые форматы соответствуют стандарту RFC 3066.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Language">
          <source>For example, U.S. English is "en-US".</source>
          <target state="translated">К примеру США Английский — «en US».</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Language">
          <source>For more information on the values and format, see <ph id="ph1">&lt;xref:System.Windows.Markup.XmlLanguage&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о значениях и формате см. в разделе <ph id="ph1">&lt;xref:System.Windows.Markup.XmlLanguage&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Language">
          <source>This dependency property inherits property values.</source>
          <target state="translated">Это свойство зависимостей наследуется значений свойств.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Language">
          <source>If there are child elements without other values for <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph> established through local values or styles, the property system will set the value to be the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph> value of the nearest ancestor element with this value assigned.</source>
          <target state="translated">Если имеются дочерние элементы без другие значения для <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph> установленное с помощью локальных значений или стилей, в системе свойств будет задать это значение должно быть <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph> значение ближайшего предка элемента с назначенным данным значением.</target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Language">
          <source><ph id="ph1">[!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]</ph> defines the general meaning of the <ph id="ph2">`xml:lang`</ph> attribute.</source>
          <target state="translated"><ph id="ph1">[!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]</ph> Определяет общие значения <ph id="ph2">`xml:lang`</ph> атрибута.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Language">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph> essentially exposes the meaning of this attribute as a dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph> по существу представляет значение этого атрибута как свойство зависимостей.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Language">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph> can be adjusted programmatically, and can participate in property system value inheritance in a way that parallels how the <ph id="ph2">`xml:lang`</ph> attribute can inherit to child element scope in <ph id="ph3">[!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph> можно изменить программным способом и могут участвовать в наследование значения свойства системы в виде, параллельно как <ph id="ph2">`xml:lang`</ph> атрибута может наследовать область дочерний элемент в <ph id="ph3">[!INCLUDE[TLA2#tla_xml](~/includes/tla2sharptla-xml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Language">
          <source>If you set <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph>, that value becomes the <ph id="ph2">`xml:lang`</ph> and overwrites any previous value.</source>
          <target state="translated">Если задать <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Language%2A&gt;</ph>, это значение становится <ph id="ph2">`xml:lang`</ph> и перезаписывает все предыдущие значения.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Language">
          <source>For more information, see <bpt id="p1">[</bpt>xml:lang Handling in XAML<ept id="p1">](~/docs/framework/xaml-services/xml-lang-handling-in-xaml.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>XML: lang в XAML<ept id="p1">](~/docs/framework/xaml-services/xml-lang-handling-in-xaml.md)</ept>.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Language">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Language">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Language">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.LanguageProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.Language" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.Language" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.LayoutTransform">
          <source>Gets or sets a graphics transformation that should apply to this element when  layout is performed.</source>
          <target state="translated">Получает или задает графическое преобразование, которое применяется к элементу при изменении параметров размещения.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.LayoutTransform">
          <source>The transform this element should use.</source>
          <target state="translated">Преобразование, которое должен использовать данный элемент.</target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.LayoutTransform">
          <source>The default is <ph id="ph1">&lt;see cref="P:System.Windows.Media.Transform.Identity" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию: <ph id="ph1">&lt;see cref="P:System.Windows.Media.Transform.Identity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.LayoutTransform">
          <source>In contrast to <ph id="ph1">&lt;xref:System.Windows.UIElement.RenderTransform%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.LayoutTransform%2A&gt;</ph> will affect results of layout.</source>
          <target state="translated">В отличие от к <ph id="ph1">&lt;xref:System.Windows.UIElement.RenderTransform%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.LayoutTransform%2A&gt;</ph> повлияет на результаты макета.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.LayoutTransform">
          <source>Setting a transform provides powerful capabilities of scaling and rotating.</source>
          <target state="translated">Задание преобразования предоставляет мощные возможности масштабирования и вращения.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.LayoutTransform">
          <source>However, <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.LayoutTransform%2A&gt;</ph> ignores <ph id="ph2">&lt;xref:System.Windows.Media.TranslateTransform&gt;</ph> operations.</source>
          <target state="translated">Тем не менее <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.LayoutTransform%2A&gt;</ph> игнорирует <ph id="ph2">&lt;xref:System.Windows.Media.TranslateTransform&gt;</ph> операций.</target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.LayoutTransform">
          <source>This is because the layout system behavior for child elements of a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> auto-corrects any offsets to the position of a scaled or rotated element into the layout and coordinate system of the parent element.</source>
          <target state="translated">Это, поскольку поведение системы макета для дочерних элементов <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> автоматически исправляет любые смещения позиции масштабируемого или повернутый элемента в макет и система координат родительского элемента.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.LayoutTransform">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.LayoutTransform%2A&gt;</ph> can lead to poor application performance if you invoke it in a scenario that does not require a full pass by the layout system.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.LayoutTransform%2A&gt;</ph> может привести к ухудшению производительности приложения, если вызывается в случае, когда не требуется полный проход системы макета.</target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.LayoutTransform">
          <source>When you apply a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.LayoutTransform%2A&gt;</ph> to the <ph id="ph2">&lt;xref:System.Windows.Controls.Panel.Children%2A&gt;</ph> collection of the <ph id="ph3">&lt;xref:System.Windows.Controls.Panel&gt;</ph>, it triggers a new pass by the layout system and forces all on-screen objects to be remeasured and rearranged.</source>
          <target state="translated">При применении <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.LayoutTransform%2A&gt;</ph> для <ph id="ph2">&lt;xref:System.Windows.Controls.Panel.Children%2A&gt;</ph> коллекцию <ph id="ph3">&lt;xref:System.Windows.Controls.Panel&gt;</ph>, система инициирует новый проход системой макета и заставляет все объекты на экране принудительно упорядочиваются и переупорядочить.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.LayoutTransform">
          <source>If you are updating the complete application <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>, this functionality might be exactly what you need.</source>
          <target state="translated">Если вы обновляете полное приложение <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>, эта функция может оказаться именно то, что нужно.</target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.LayoutTransform">
          <source>However, if you do not need a full layout pass, use the <ph id="ph1">&lt;xref:System.Windows.UIElement.RenderTransform%2A&gt;</ph> property, which does not invoke the layout system, and therefore, is typically a better choice for this scenario.</source>
          <target state="translated">Тем не менее, если не требуется полная передача макета, используйте <ph id="ph1">&lt;xref:System.Windows.UIElement.RenderTransform%2A&gt;</ph> свойство, которое не вызывает систему макета и, как правило, лучшим выбором для этого сценария.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.LayoutTransform">
          <source>Example scenarios where <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.LayoutTransform%2A&gt;</ph> would be useful include: rotating elements such as menu components from horizontal to vertical or vice versa, scaling elements (zooming in) on focus, providing editing behavior, etc.</source>
          <target state="translated">Примеры сценариев где <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.LayoutTransform%2A&gt;</ph> может быть полезно включить: поворот элементов, таких как компоненты меню с горизонтальной на вертикальную или наоборот, масштабирование элементы (увеличивать) при получении фокуса, предоставляя возможность редактирования и т. д.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.LayoutTransform">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.LayoutTransform">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.LayoutTransform">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.LayoutTransform">
          <source>The following example shows how to apply a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.LayoutTransform%2A&gt;</ph> to an element.</source>
          <target state="translated">В следующем примере показано, как применить <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.LayoutTransform%2A&gt;</ph> к элементу.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.LayoutTransform">
          <source>The example creates an instance of <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> and hosts it within a parent <ph id="ph2">&lt;xref:System.Windows.Controls.Grid&gt;</ph>.</source>
          <target state="translated">В примере создается экземпляр <ph id="ph1">&lt;xref:System.Windows.Controls.Button&gt;</ph> и размещает в родительском элементе <ph id="ph2">&lt;xref:System.Windows.Controls.Grid&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.LayoutTransform">
          <source>It also uses the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.LayoutTransform%2A&gt;</ph> property to apply a <ph id="ph2">&lt;xref:System.Windows.Media.RotateTransform&gt;</ph> to the <ph id="ph3">&lt;xref:System.Windows.Controls.Button&gt;</ph>.</source>
          <target state="translated">Она также использует <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.LayoutTransform%2A&gt;</ph> свойства для применения <ph id="ph2">&lt;xref:System.Windows.Media.RotateTransform&gt;</ph> для <ph id="ph3">&lt;xref:System.Windows.Controls.Button&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.LayoutTransformProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.LayoutTransform" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.LayoutTransform" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkElement.Loaded">
          <source>Occurs when the element is laid out, rendered, and ready for interaction.</source>
          <target state="translated">Происходит, если элемент размещен, отрисован и готов к взаимодействию.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Loaded">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Loaded&gt;</ph> is usually the last event raised in an element initialization sequence.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Loaded&gt;</ph> Обычно последнее событие вызывается в последовательности инициализации элементов.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Loaded">
          <source>It will always be raised after <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Initialized&gt;</ph>.</source>
          <target state="translated">Всегда будет вызываться после <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Initialized&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Loaded">
          <source>Whether you choose to handle <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Loaded&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Initialized&gt;</ph> depends on your requirements.</source>
          <target state="translated">Выбор режима обработки <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Loaded&gt;</ph> или <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Initialized&gt;</ph> зависит от требований.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Loaded">
          <source>If you do not need to read element properties, intend to reset properties, and do not need any layout information, <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Initialized&gt;</ph> might be the better event to act upon.</source>
          <target state="translated">Если вам не нужно прочитать свойства элемента, требуется сбросить свойства и не обязательно любые сведения о макете <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Initialized&gt;</ph> может быть лучше событий для обработки.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Loaded">
          <source>If you need all properties of the element to be available, and you will be setting properties that are likely to reset the layout, <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Loaded&gt;</ph> might be the better event to act upon.</source>
          <target state="translated">Если требуется все свойства элемента доступны, и установка свойств, которые могут сбросить макет, <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Loaded&gt;</ph> может быть лучше событий для обработки.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Loaded">
          <source>Be careful of reentrancy if your handler resets any properties that are interpreted by the layout system to mean that a new layout pass is required.</source>
          <target state="translated">Будьте внимательны повторного входа, если обработчик сбрасывает все свойства, которые интерпретируются системой макета означает, что требуется новый передачи макета.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Loaded">
          <source>(You might need to check the <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> values on the property if you are unsure of which properties can require a new layout pass if they are changed.)</source>
          <target state="translated">(Может понадобиться вернуть <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata&gt;</ph> значения для свойства, если вы не знаете, какие свойства могут требовать новый макет передачи, если они были изменены.)</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Loaded">
          <source>For more information about the sequence of object events for a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, and also for several related application and element classes, see <bpt id="p1">[</bpt>Object Lifetime Events<ept id="p1">](~/docs/framework/wpf/advanced/object-lifetime-events.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о последовательности событий объекта для <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>и для нескольких связанных классах приложений и элементов, см. также <bpt id="p1">[</bpt>события времени жизни объектов<ept id="p1">](~/docs/framework/wpf/advanced/object-lifetime-events.md)</ept>.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Loaded">
          <source>Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</source>
          <target state="translated">События с прямой маршрутизацией не следуют по маршруту, они обрабатываются только внутри элемента, на котором они вызываются.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Loaded">
          <source>Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style.</source>
          <target state="translated">Прямые перенаправленные события поддерживают другое поведение перенаправленных событий: они поддерживают коллекцию доступных обработчиков и могут использоваться как <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> в стиле.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Loaded">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Loaded&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Unloaded&gt;</ph> might both be raised on controls as a result of user-initiated system theme changes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Loaded&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Unloaded&gt;</ph> и может быть вызвано в элементе управления, в результате изменения темы инициированной пользователем системы.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Loaded">
          <source>A theme change causes an invalidation of the control template and the contained visual tree, which in turn causes the entire control to unload and reload.</source>
          <target state="translated">Изменение темы делает недействительность шаблон элемента управления и автономной визуального дерева, который в свою очередь вызывает выгрузке и повторной загрузке всего элемента управления.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Loaded">
          <source>Therefore <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Loaded&gt;</ph> cannot be assumed to occur only when a page is first loaded through navigation to the page.</source>
          <target state="translated">Поэтому <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Loaded&gt;</ph> неизвестно возникает только при первой загрузке страницы посредством перехода к странице.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Loaded">
          <source>Routed Event Information</source>
          <target state="translated">Сведения о маршрутизируемом событии</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Loaded">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Loaded">
          <source>Routing strategy</source>
          <target state="translated">Стратегия маршрутизации</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Loaded">
          <source>Direct</source>
          <target state="translated">Direct</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Loaded">
          <source>Delegate</source>
          <target state="translated">делегат</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.LoadedEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.Loaded" /&gt;</ph> routed event.</source>
          <target state="translated">Идентифицирует направленное событие <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.Loaded" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.LoadedEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Идентификаторы перенаправленных событий создаются при их регистрации.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.LoadedEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.LoadedEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Эти идентификаторы можно использовать для добавления обработчиков классов.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.LoadedEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.LoadedEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.LogicalChildren">
          <source>Gets an enumerator for logical child elements of this element.</source>
          <target state="translated">Возвращает перечислитель для логических дочерних элементов данного элемента.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.LogicalChildren">
          <source>An enumerator for logical child elements of this element.</source>
          <target state="translated">Перечислитель для логических дочерних элементов данного элемента.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.LogicalChildren">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.LogicalChildren%2A&gt;</ph> allows you to iterate over child elements.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.LogicalChildren%2A&gt;</ph> позволяет проходить по дочерним элементам.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.LogicalChildren">
          <source>This is useful for elements that may not have a defined, dedicated collection but still contain more than one child element, particularly <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> child elements.</source>
          <target state="translated">Это полезно для элементов, которые могут не определена выделенная коллекция, но по-прежнему содержать более одного дочернего элемента, особенно <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement&gt;</ph> дочерних элементов.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.LogicalChildren">
          <source>For more information on how to use <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.LogicalChildren%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.AddLogicalChild%2A&gt;</ph>, see <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об использовании <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.LogicalChildren%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.AddLogicalChild%2A&gt;</ph>, в разделе <bpt id="p1">[</bpt>деревьев в WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.Margin">
          <source>Gets or sets the outer margin of an element.</source>
          <target state="translated">Получает или задает значение внешнего поля элемента.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source>Provides margin values for the element.</source>
          <target state="translated">Предоставляет значения полей для элемента.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source>The default value is a <ph id="ph1">&lt;see cref="T:System.Windows.Thickness" /&gt;</ph> with all properties equal to 0 (zero).</source>
          <target state="translated">Значение по умолчанию равно <ph id="ph1">&lt;see cref="T:System.Windows.Thickness" /&gt;</ph> со всеми свойствами, равными 0 (нулю).</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source>The margin is the space between this element and other elements that will be adjacent when layout creates the <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.</source>
          <target state="translated">Поле представляет собой пространство между элементом и другие элементы, которые будут смежные при создании макета <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source>Shared elements might be peer elements (such as other elements in the collection of a common parent control), or might also be this element's parent.</source>
          <target state="translated">Общие элементы могут быть одноранговыми (например, другие элементы в коллекции общего родительского элемента управления) или может быть родительским для данного элемента.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Margin%2A&gt;</ph> is set as a <ph id="ph2">&lt;xref:System.Windows.Thickness&gt;</ph> structure rather than as a number so that the margin can be set asymmetrically.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Margin%2A&gt;</ph> задается как <ph id="ph2">&lt;xref:System.Windows.Thickness&gt;</ph> структуры, а не как число, чтобы поле можно задать асимметричного.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Thickness&gt;</ph> structure itself supports string type conversion so that you can specify an asymmetric <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Margin%2A&gt;</ph> in <ph id="ph3">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> attribute syntax also.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Thickness&gt;</ph> Самой структуры поддерживает преобразование типов в строку, чтобы можно было указать асимметричный <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Margin%2A&gt;</ph> в <ph id="ph3">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> также синтаксис атрибута.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source>A non-zero margin applies space outside the element layout's <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ActualWidth%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.ActualHeight%2A&gt;</ph>.</source>
          <target state="translated">Задает поля ненулевой вне макета элемента <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ActualWidth%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.ActualHeight%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source>Margins are additive for sibling elements in a layout; for example, two adjacent elements both with a margin of 30 set on the adjoining edge would have 60 units of space between them.</source>
          <target state="translated">Поля являются аддитивными для одноуровневых элементов в макете; Например два смежных элемента, установить оба поля 30 смежные границы бы 60 единиц пробела между ними.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source>Elements that have margins set will not typically constrain the size of the specified <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Margin%2A&gt;</ph> if the allotted rectangle space is not large enough for the margin plus the element content area.</source>
          <target state="translated">Элементы, которые заданы поля, обычно не ограничивают размер указанного <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Margin%2A&gt;</ph> если выделенное прямоугольное пространство не является достаточно большим для поля и область содержимого элемента.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source>The element content area will be constrained instead when layout is calculated.</source>
          <target state="translated">Область содержимого элемента будет ограничен вместо этого, при вычислении структуры.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source>The only case where margins would be constrained also is if the content is already constrained all the way to zero.</source>
          <target state="translated">Единственный случай, где будет ограничен поля также — если содержимое уже ограничено до нуля.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source>XAML Attribute Usage</source>
          <target state="translated">Использование атрибута XAML</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source>XAML Property Element Usage</source>
          <target state="translated">Использование элемента свойства XAML</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source>XAML Values</source>
          <target state="translated">Значения XAML</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source><bpt id="p1">*</bpt>left, top, right, bottom<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>слева, сверху, справа, снизу<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source>Number values between 0 and <ph id="ph1">&lt;xref:System.Double.PositiveInfinity&gt;</ph> that specify the four possible dimension properties of a <ph id="ph2">&lt;xref:System.Windows.Thickness&gt;</ph> structure.</source>
          <target state="translated">Числовые значения между 0 и <ph id="ph1">&lt;xref:System.Double.PositiveInfinity&gt;</ph> , указать четыре возможных измерений свойства <ph id="ph2">&lt;xref:System.Windows.Thickness&gt;</ph> структуры.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source>The attribute usage will also accept abbreviated values that apply in the order provided, symmetrically and logically.</source>
          <target state="translated">Использование атрибута также принимает сокращенные значения, применяемые в указанном порядке, симметрично и логически.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source>For instance, <ph id="ph1">`Margin="20"`</ph> will be interpreted to mean a <ph id="ph2">&lt;xref:System.Windows.Thickness&gt;</ph> with all properties set to 20.</source>
          <target state="translated">Например <ph id="ph1">`Margin="20"`</ph> будет трактуется как <ph id="ph2">&lt;xref:System.Windows.Thickness&gt;</ph> со свойствами, установленными на 20.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source><ph id="ph1">`Margin="20,50"`</ph> will be interpreted to mean a <ph id="ph2">&lt;xref:System.Windows.Thickness&gt;</ph> with <ph id="ph3">&lt;xref:System.Windows.Thickness.Left%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Windows.Thickness.Right%2A&gt;</ph> set to 20, and <ph id="ph5">&lt;xref:System.Windows.Thickness.Top%2A&gt;</ph> and <ph id="ph6">&lt;xref:System.Windows.Thickness.Bottom%2A&gt;</ph> set to 50.</source>
          <target state="translated"><ph id="ph1">`Margin="20,50"`</ph> будет трактуется как <ph id="ph2">&lt;xref:System.Windows.Thickness&gt;</ph> с <ph id="ph3">&lt;xref:System.Windows.Thickness.Left%2A&gt;</ph> и <ph id="ph4">&lt;xref:System.Windows.Thickness.Right%2A&gt;</ph> равным 20, а <ph id="ph5">&lt;xref:System.Windows.Thickness.Top%2A&gt;</ph> и <ph id="ph6">&lt;xref:System.Windows.Thickness.Bottom%2A&gt;</ph> значение 50.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source>The default unit for a <ph id="ph1">&lt;xref:System.Windows.Thickness&gt;</ph> measure is <ph id="ph2">[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]</ph>.</source>
          <target state="translated">Единицы измерения по умолчанию для <ph id="ph1">&lt;xref:System.Windows.Thickness&gt;</ph> мера является <ph id="ph2">[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source>You can also specify other units by appending the unit type strings <ph id="ph1">`cm`</ph>, <ph id="ph2">`in`</ph>, or <ph id="ph3">`pt`</ph> to any measure.</source>
          <target state="translated">Также можно указать другие единицы измерения путем добавления строк с единицей измерения типа <ph id="ph1">`cm`</ph>, <ph id="ph2">`in`</ph>, или <ph id="ph3">`pt`</ph> к любой величине.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source>Number values provided as <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> attributes need not specify decimal points (0 is acceptable, does not have to be provided as 0.0).</source>
          <target state="translated">Числовые значения, указанные как <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> атрибуты не требуется указывать десятичные точки (0 приемлемо, не должен предоставляться как 0,0).</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source>For more information on <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> usage, see <ph id="ph2">&lt;xref:System.Windows.Thickness&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> использования, в разделе <ph id="ph2">&lt;xref:System.Windows.Thickness&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source><bpt id="p1">*</bpt>thicknessReference<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>thicknessReference<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source>An object reference to an existing <ph id="ph1">&lt;xref:System.Windows.Thickness&gt;</ph>.</source>
          <target state="translated">Ссылка на объект на существующий <ph id="ph1">&lt;xref:System.Windows.Thickness&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source>This might be a <ph id="ph1">`}`</ph>, a , or <ph id="ph2">`}`</ph> reference.</source>
          <target state="translated">Это может быть <ph id="ph1">`}`</ph>,, или <ph id="ph2">`}`</ph> ссылки.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source>For more information on <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> usage, see <ph id="ph2">&lt;xref:System.Windows.Thickness&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> использования, в разделе <ph id="ph2">&lt;xref:System.Windows.Thickness&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Margin">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.MarginProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.Margin" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.Margin" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.MaxHeight">
          <source>Gets or sets the maximum height constraint of the element.</source>
          <target state="translated">Получение или установка максимально допустимой высоты элемента.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxHeight">
          <source>The maximum height of the element, in <ph id="ph1">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph>.</source>
          <target state="translated">Максимальная высота элемента в <ph id="ph1">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxHeight">
          <source>The default value is <ph id="ph1">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию — <ph id="ph1">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxHeight">
          <source>This value can be any value equal to or greater than 0.0.</source>
          <target state="translated">Это значение может быть больше или равно 0,0.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxHeight">
          <source><ph id="ph1">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph> is also valid.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph> также является допустимым.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxHeight">
          <source>This is one of three properties on <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> that specify height information.</source>
          <target state="translated">Это один из трех свойств на <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> , укажите информацию о высоте.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxHeight">
          <source>The other two are <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MinHeight%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph>.</source>
          <target state="translated">Два других — <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MinHeight%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxHeight">
          <source>If there is a conflict between these values, the order of application for actual height determination is first <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MinHeight%2A&gt;</ph> must be honored, then <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.MaxHeight%2A&gt;</ph>, and finally if each of these are within bounds, <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph>.</source>
          <target state="translated">Если возникает конфликт между этими значениями, порядок приложения для определения фактических Высота первого <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MinHeight%2A&gt;</ph> должен быть принят на обработку, затем <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.MaxHeight%2A&gt;</ph>и, наконец, если каждый из них находятся в пределах границ, <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxHeight">
          <source>The value restrictions on the <ph id="ph1">&lt;xref:System.Double&gt;</ph> value are enforced by a <ph id="ph2">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> mechanism.</source>
          <target state="translated">Значение ограничения <ph id="ph1">&lt;xref:System.Double&gt;</ph> определяется значение <ph id="ph2">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> механизм.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxHeight">
          <source>If you attempt to set an invalid value a run-time exception is thrown.</source>
          <target state="translated">При попытке задать недопустимое значение исключения во время выполнения.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxHeight">
          <source>XAML Attribute Usage</source>
          <target state="translated">Использование атрибута XAML</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxHeight">
          <source>XAML Values</source>
          <target state="translated">Значения XAML</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxHeight">
          <source><bpt id="p1">*</bpt>double<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>double<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxHeight">
          <source>String representation of a <ph id="ph1">&lt;xref:System.Double&gt;</ph> value equal to or greater than 0.0.</source>
          <target state="translated">Строковое представление <ph id="ph1">&lt;xref:System.Double&gt;</ph> значение, равное или больше 0,0.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxHeight">
          <source>This is interpreted as a <ph id="ph1">[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]</ph> measurement.</source>
          <target state="translated">Это значение интерпретируется как <ph id="ph1">[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]</ph> измерения.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxHeight">
          <source>Strings need not explicitly include decimal points.</source>
          <target state="translated">Строки не нужно явно указывать десятичного разделителя.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxHeight">
          <source>For instance a value of <ph id="ph1">`1`</ph> is acceptable.</source>
          <target state="translated">Для экземпляра значение <ph id="ph1">`1`</ph> является допустимым.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxHeight">
          <source>The same <ph id="ph1">&lt;xref:System.Double&gt;</ph> range restrictions as mentioned in the Property Value section apply, except that you must use <bpt id="p1">[</bpt>x:Static Markup Extension<ept id="p1">](~/docs/framework/xaml-services/x-static-markup-extension.md)</ept> if you need to explicitly set the value to be <ph id="ph2">&lt;xref:System.Double.PositiveInfinity&gt;</ph>.</source>
          <target state="translated">Соответствует <ph id="ph1">&lt;xref:System.Double&gt;</ph> применить ограничения диапазона, как упоминалось в разделе значение свойства, за исключением того, необходимо использовать <bpt id="p1">[</bpt>расширение разметки x: Static<ept id="p1">](~/docs/framework/xaml-services/x-static-markup-extension.md)</ept> необходимо явно задать это значение должно быть <ph id="ph2">&lt;xref:System.Double.PositiveInfinity&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxHeight">
          <source><bpt id="p1">*</bpt>qualifiedDouble<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>qualifiedDouble<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxHeight">
          <source>A <bpt id="p1">*</bpt>double<ept id="p1">*</ept> value as described above, followed by one of the following unit declaration strings: <ph id="ph1">`px`</ph>, <ph id="ph2">`in`</ph>, <ph id="ph3">`cm`</ph>, <ph id="ph4">`pt`</ph>.</source>
          <target state="translated">Объект <bpt id="p1">*</bpt>двойные<ept id="p1">*</ept> значение как описано выше, за которым следует один из следующих строк объявления единицы измерения: <ph id="ph1">`px`</ph>, <ph id="ph2">`in`</ph>, <ph id="ph3">`cm`</ph>, <ph id="ph4">`pt`</ph>.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxHeight">
          <source><ph id="ph1">`px`</ph> (default) is <ph id="ph2">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph></source>
          <target state="translated"><ph id="ph1">`px`</ph> (по умолчанию) <ph id="ph2">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxHeight">
          <source><ph id="ph1">`in`</ph> is inches; 1in==96px</source>
          <target state="translated"><ph id="ph1">`in`</ph> дюймах; 1 дюйм == 96 точек</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxHeight">
          <source><ph id="ph1">`cm`</ph> is centimeters; 1cm==(96/2.54) px</source>
          <target state="translated"><ph id="ph1">`cm`</ph> сантиметрах; 1см==(96/2,54) пкс</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxHeight">
          <source><ph id="ph1">`pt`</ph> is points; 1pt==(96/72) px</source>
          <target state="translated"><ph id="ph1">`pt`</ph> точках; 1точка==(96/72) пкс</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxHeight">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxHeight">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxHeight">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.MaxHeightProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.MaxHeight" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.MaxHeight" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.MaxWidth">
          <source>Gets or sets the maximum width constraint of the element.</source>
          <target state="translated">Получение или установка максимально допустимой ширины элемента.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxWidth">
          <source>The maximum width of the element, in <ph id="ph1">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph>.</source>
          <target state="translated">Максимальная ширина элемента в <ph id="ph1">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxWidth">
          <source>The default value is <ph id="ph1">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию — <ph id="ph1">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxWidth">
          <source>This value can be any value equal to or greater than 0.0.</source>
          <target state="translated">Это значение может быть больше или равно 0,0.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxWidth">
          <source><ph id="ph1">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph> is also valid.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph> также является допустимым.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxWidth">
          <source>This is one of three properties on <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> that specify width information.</source>
          <target state="translated">Это один из трех свойств на <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> , укажите ширину сведения.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxWidth">
          <source>The other two are <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MinWidth%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph>.</source>
          <target state="translated">Два других — <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MinWidth%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxWidth">
          <source>If there is a conflict between these values, the order of application for actual width determination is first <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MinWidth%2A&gt;</ph> must be honored, then <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.MaxWidth%2A&gt;</ph>, and finally if each of these are within bounds, <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph>.</source>
          <target state="translated">Если возникает конфликт между этими значениями, порядок приложения для определения фактическую ширину первый <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MinWidth%2A&gt;</ph> должен быть принят на обработку, затем <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.MaxWidth%2A&gt;</ph>и, наконец, если каждый из них находятся в пределах границ, <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxWidth">
          <source>The value restrictions on the <ph id="ph1">&lt;xref:System.Double&gt;</ph> value are enforced by a <ph id="ph2">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> mechanism.</source>
          <target state="translated">Значение ограничения <ph id="ph1">&lt;xref:System.Double&gt;</ph> определяется значение <ph id="ph2">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> механизм.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxWidth">
          <source>If you attempt to set an invalid value, a run-time exception is thrown.</source>
          <target state="translated">При попытке задать недопустимое значение, возникает исключение времени выполнения.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxWidth">
          <source>XAML Attribute Usage</source>
          <target state="translated">Использование атрибута XAML</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxWidth">
          <source>XAML Values</source>
          <target state="translated">Значения XAML</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxWidth">
          <source><bpt id="p1">*</bpt>double<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>double<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxWidth">
          <source>String representation of a <ph id="ph1">&lt;xref:System.Double&gt;</ph> value equal to or greater than 0.0.</source>
          <target state="translated">Строковое представление <ph id="ph1">&lt;xref:System.Double&gt;</ph> значение, равное или больше 0,0.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxWidth">
          <source>This is interpreted as a <ph id="ph1">[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]</ph> measurement.</source>
          <target state="translated">Это значение интерпретируется как <ph id="ph1">[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]</ph> измерения.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxWidth">
          <source>Strings need not explicitly include decimal points.</source>
          <target state="translated">Строки не нужно явно указывать десятичного разделителя.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxWidth">
          <source>For instance a value of <ph id="ph1">`1`</ph> is acceptable.</source>
          <target state="translated">Для экземпляра значение <ph id="ph1">`1`</ph> является допустимым.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxWidth">
          <source>The same <ph id="ph1">&lt;xref:System.Double&gt;</ph> range restrictions as mentioned in the Property Value section apply, except that you must use <bpt id="p1">[</bpt>x:Static Markup Extension<ept id="p1">](~/docs/framework/xaml-services/x-static-markup-extension.md)</ept> to set the value to be <ph id="ph2">&lt;xref:System.Double.PositiveInfinity&gt;</ph>.</source>
          <target state="translated">Соответствует <ph id="ph1">&lt;xref:System.Double&gt;</ph> применить ограничения диапазона, как упоминалось в разделе значение свойства, за исключением того, необходимо использовать <bpt id="p1">[</bpt>расширение разметки x: Static<ept id="p1">](~/docs/framework/xaml-services/x-static-markup-extension.md)</ept> присвоить это значение должно быть <ph id="ph2">&lt;xref:System.Double.PositiveInfinity&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxWidth">
          <source><bpt id="p1">*</bpt>qualifiedDouble<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>qualifiedDouble<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxWidth">
          <source>A <bpt id="p1">*</bpt>double<ept id="p1">*</ept> value as described above, followed by one of the following unit declaration strings: <ph id="ph1">`px`</ph>, <ph id="ph2">`in`</ph>, <ph id="ph3">`cm`</ph>, <ph id="ph4">`pt`</ph>.</source>
          <target state="translated">Объект <bpt id="p1">*</bpt>двойные<ept id="p1">*</ept> значение как описано выше, за которым следует один из следующих строк объявления единицы измерения: <ph id="ph1">`px`</ph>, <ph id="ph2">`in`</ph>, <ph id="ph3">`cm`</ph>, <ph id="ph4">`pt`</ph>.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxWidth">
          <source><ph id="ph1">`px`</ph> (default) is <ph id="ph2">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph></source>
          <target state="translated"><ph id="ph1">`px`</ph> (по умолчанию) <ph id="ph2">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxWidth">
          <source><ph id="ph1">`in`</ph> is inches; 1in==96px</source>
          <target state="translated"><ph id="ph1">`in`</ph> дюймах; 1 дюйм == 96 точек</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxWidth">
          <source><ph id="ph1">`cm`</ph> is centimeters; 1cm==(96/2.54) px</source>
          <target state="translated"><ph id="ph1">`cm`</ph> сантиметрах; 1см==(96/2,54) пкс</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxWidth">
          <source><ph id="ph1">`pt`</ph> is points; 1pt==(96/72) px</source>
          <target state="translated"><ph id="ph1">`pt`</ph> точках; 1точка==(96/72) пкс</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxWidth">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxWidth">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MaxWidth">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.MaxWidthProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.MaxWidth" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.MaxWidth" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)">
          <source>The available size that the parent element can give to the child elements.</source>
          <target state="translated">Доступный размер, который родительский элемент может предоставить дочерним элементам.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)">
          <source>Implements basic measure-pass layout system behavior for <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph>.</source>
          <target state="translated">Реализует основное поведение системы структуры при проходе измерения для <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)">
          <source>The desired size of this element in layout.</source>
          <target state="translated">Желательный размер этого элемента в макете.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType&gt;</ph> to connect the  WPF core-level and WPF framework-level layout measure implementations.</source>
          <target state="translated">Этот метод переопределяет <ph id="ph1">&lt;xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType&gt;</ph> подключения уровня ядра WPF и реализации мер макета уровня платформы WPF.</target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> implementation seals the method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> Реализации запечатывает метод.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)">
          <source>To adjust the measure pass layout behavior of any element that builds on the WPF framework-level, override <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MeasureOverride%2A&gt;</ph> instead.</source>
          <target state="translated">Чтобы настроить поведение макета проход измерения любого элемента, который основан на уровня платформы WPF, переопределите <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MeasureOverride%2A&gt;</ph> вместо него.</target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.MeasureCore(System.Windows.Size)">
          <source>To adjust the measure pass layout behavior of an element that deliberately does not build on the WPF framework-level or use <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, override <ph id="ph2">&lt;xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Чтобы настроить поведение макета элемента, который намеренно не на основе уровня платформы WPF или используйте проход измерения <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, переопределите <ph id="ph2">&lt;xref:System.Windows.UIElement.MeasureCore%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)">
          <source>The available size that this element can give to child elements.</source>
          <target state="translated">Доступный размер, который этот элемент может предоставить дочерним элементам.</target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)">
          <source>Infinity can be specified as a value to indicate that the element will size to whatever content is available.</source>
          <target state="translated">Можно задать бесконечное значение, указав таким образом, что элемент будет масштабироваться в соответствии с любым содержимым.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)">
          <source>When overridden in a derived class, measures the size in layout required for child elements and determines a size for the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph>-derived class.</source>
          <target state="translated">При переопределении в производном классе измеряет размер в структуре, требуемый для дочерних элементов, и определяет размер для класса, производного от <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)">
          <source>The size that this element determines it needs during layout, based on its calculations of child element sizes.</source>
          <target state="translated">Размер, определяемый данным элементом для своих потребностей во время структурирования на основе вычисления размеров дочерних элементов.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MeasureOverride%2A&gt;</ph> to implement custom layout sizing behavior for your element as it participates in the <ph id="ph2">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> layout system.</source>
          <target state="translated">Переопределить <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MeasureOverride%2A&gt;</ph> реализуйте поведение при изменении размера пользовательский макет для элемента, как оно участвует в <ph id="ph2">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> система макета.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)">
          <source>Your implementation should do the following:</source>
          <target state="translated">Реализация должна делать следующее:</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)">
          <source>Iterate your element's particular collection of children that are part of layout, call <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> on each child element.</source>
          <target state="translated">Итерации элемента в определенной коллекции дочерних элементов, которые являются частью макета, вызов <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> для каждого дочернего элемента.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)">
          <source>Immediately get <ph id="ph1">&lt;xref:System.Windows.UIElement.DesiredSize%2A&gt;</ph> on the child (this is set as a property after <ph id="ph2">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> is called).</source>
          <target state="translated">Сразу получить <ph id="ph1">&lt;xref:System.Windows.UIElement.DesiredSize%2A&gt;</ph> для дочернего элемента (он задается как свойство после <ph id="ph2">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> вызывается).</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)">
          <source>Compute the net desired size of the parent based upon the measurement of the child elements.</source>
          <target state="translated">Вычислите чистый требуемый размер родительского элемента на основе измерений дочерних элементов.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)">
          <source>The return value of <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MeasureOverride%2A&gt;</ph> should be the element's own desired size, which then becomes the measure input for the parent element of the current element.</source>
          <target state="translated">Возвращаемое значение <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MeasureOverride%2A&gt;</ph> должен совпадать с размером элемента собственные требуемого, которая становится входных данных для родительского элемента текущего элемента меры.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)">
          <source>This same process continues through the layout system until the root element of the page is reached.</source>
          <target state="translated">Этот процесс продолжается всей системы структуры, пока не будет достигнут корневой элемент страницы.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)">
          <source>During this process, child elements might return a larger <ph id="ph1">&lt;xref:System.Windows.UIElement.DesiredSize%2A&gt;</ph> size than the initial <ph id="ph2">`availableSize`</ph> to indicate that the child element wants more space.</source>
          <target state="translated">Во время этого процесса может возвратить более крупный дочерние элементы <ph id="ph1">&lt;xref:System.Windows.UIElement.DesiredSize%2A&gt;</ph> размер больше исходного <ph id="ph2">`availableSize`</ph> указать, что дочерний элемент больше места.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)">
          <source>This might be handled in your own implementation by introducing a scrollable region, by resizing the parent control, by establishing some manner of stacked order, or any number of solutions for measuring or arranging content.</source>
          <target state="translated">Это может быть обработано в вашей собственной реализации внедрения прокручиваемой области, путем изменения размеров родительского элемента управления путем создания каким-либо образом стекового порядка или любого количества решений для измерения или компоновки содержимого.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)">
          <source>Elements should call <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> on each child during this process, otherwise the child elements will not be correctly sized or arranged.</source>
          <target state="translated">Элементы должны вызывать <ph id="ph1">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> для каждого дочернего во время этого процесса, в противном случае дочерние элементы не будет правильно размера или упорядочены.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)">
          <source>The following non-compiling code shows this implementation pattern.</source>
          <target state="translated">В следующем коде-компиляции показано этой реализации шаблона.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)">
          <source><bpt id="p1">&lt;c&gt;</bpt>VisualChildren<ept id="p1">&lt;/c&gt;</ept> represents an enumerable collection property of children that your own element should define.</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>VisualChildren<ept id="p1">&lt;/c&gt;</ept> представляет свойство перечисляемую коллекцию дочерних элементов, определяющих собственного элемента.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)">
          <source>The property can be named anything.</source>
          <target state="translated">Свойство может быть любое имя.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)">
          <source><bpt id="p1">&lt;c&gt;</bpt>VisualChildren<ept id="p1">&lt;/c&gt;</ept> is a placeholder name for purposes of this example, <bpt id="p2">&lt;c&gt;</bpt>VisualChildren<ept id="p2">&lt;/c&gt;</ept> is not an <ph id="ph1">[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]</ph> as provided by <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> or a part of a naming pattern..</source>
          <target state="translated"><bpt id="p1">&lt;c&gt;</bpt>VisualChildren<ept id="p1">&lt;/c&gt;</ept> является именем-заполнителем для этого примера <bpt id="p2">&lt;c&gt;</bpt>VisualChildren<ept id="p2">&lt;/c&gt;</ept> не <ph id="ph1">[!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)]</ph> в соответствии со <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> или его часть шаблон именования...</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.MinHeight">
          <source>Gets or sets the minimum height constraint of the element.</source>
          <target state="translated">Получение или установка минимально допустимой высоты элемента.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinHeight">
          <source>The minimum height of the element, in <ph id="ph1">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph>.</source>
          <target state="translated">Минимальная высота элемента в <ph id="ph1">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinHeight">
          <source>The default value is 0.0.</source>
          <target state="translated">Значение по умолчанию — 0,0.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinHeight">
          <source>This value can be any value equal to or greater than 0.0.</source>
          <target state="translated">Это значение может быть больше или равно 0,0.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinHeight">
          <source>However, <ph id="ph1">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph> is NOT valid, nor is <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</source>
          <target state="translated">Однако константа <ph id="ph1">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph> допустимой не является, равно как и <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinHeight">
          <source>This is one of three properties on <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> that specify height information.</source>
          <target state="translated">Это один из трех свойств на <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> , укажите информацию о высоте.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinHeight">
          <source>The other two are <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.MaxHeight%2A&gt;</ph>.</source>
          <target state="translated">Два других — <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.MaxHeight%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinHeight">
          <source>If there is a conflict between these values, the order of application for actual height determination is first <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MinHeight%2A&gt;</ph> must be honored, then <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.MaxHeight%2A&gt;</ph>, and finally if each of these are within bounds, <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph>.</source>
          <target state="translated">Если возникает конфликт между этими значениями, порядок приложения для определения фактических Высота первого <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MinHeight%2A&gt;</ph> должен быть принят на обработку, затем <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.MaxHeight%2A&gt;</ph>и, наконец, если каждый из них находятся в пределах границ, <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinHeight">
          <source>The value restrictions on the <ph id="ph1">&lt;xref:System.Double&gt;</ph> value are enforced by a <ph id="ph2">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> mechanism.</source>
          <target state="translated">Значение ограничения <ph id="ph1">&lt;xref:System.Double&gt;</ph> определяется значение <ph id="ph2">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> механизм.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinHeight">
          <source>If you attempt to set an invalid value, a run-time exception is thrown.</source>
          <target state="translated">При попытке задать недопустимое значение, возникает исключение времени выполнения.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinHeight">
          <source>XAML Attribute Usage</source>
          <target state="translated">Использование атрибута XAML</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinHeight">
          <source>XAML Values</source>
          <target state="translated">Значения XAML</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinHeight">
          <source><bpt id="p1">*</bpt>double<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>double<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinHeight">
          <source>String representation of a <ph id="ph1">&lt;xref:System.Double&gt;</ph> value equal to or greater than 0.0.</source>
          <target state="translated">Строковое представление <ph id="ph1">&lt;xref:System.Double&gt;</ph> значение, равное или больше 0,0.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinHeight">
          <source>This is interpreted as a <ph id="ph1">[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]</ph> measurement.</source>
          <target state="translated">Это значение интерпретируется как <ph id="ph1">[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]</ph> измерения.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinHeight">
          <source>Strings need not explicitly include decimal points.</source>
          <target state="translated">Строки не нужно явно указывать десятичного разделителя.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinHeight">
          <source>For instance a value of <ph id="ph1">`1`</ph> is acceptable.</source>
          <target state="translated">Для экземпляра значение <ph id="ph1">`1`</ph> является допустимым.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinHeight">
          <source>The same <ph id="ph1">&lt;xref:System.Double&gt;</ph> range restrictions as mentioned in the Property Value section apply.</source>
          <target state="translated">Соответствует <ph id="ph1">&lt;xref:System.Double&gt;</ph> ограничения диапазона, как упоминалось в разделе "значение свойства".</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinHeight">
          <source><bpt id="p1">*</bpt>qualifiedDouble<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>qualifiedDouble<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinHeight">
          <source>A <bpt id="p1">*</bpt>double<ept id="p1">*</ept> value as described above, followed by one of the following unit declaration strings: <ph id="ph1">`px`</ph>, <ph id="ph2">`in`</ph>, <ph id="ph3">`cm`</ph>, <ph id="ph4">`pt`</ph>.</source>
          <target state="translated">Объект <bpt id="p1">*</bpt>двойные<ept id="p1">*</ept> значение как описано выше, за которым следует один из следующих строк объявления единицы измерения: <ph id="ph1">`px`</ph>, <ph id="ph2">`in`</ph>, <ph id="ph3">`cm`</ph>, <ph id="ph4">`pt`</ph>.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinHeight">
          <source><ph id="ph1">`px`</ph> (default) is <ph id="ph2">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph></source>
          <target state="translated"><ph id="ph1">`px`</ph> (по умолчанию) <ph id="ph2">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinHeight">
          <source><ph id="ph1">`in`</ph> is inches; 1in==96px</source>
          <target state="translated"><ph id="ph1">`in`</ph> дюймах; 1 дюйм == 96 точек</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinHeight">
          <source><ph id="ph1">`cm`</ph> is centimeters; 1cm==(96/2.54) px</source>
          <target state="translated"><ph id="ph1">`cm`</ph> сантиметрах; 1см==(96/2,54) пкс</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinHeight">
          <source><ph id="ph1">`pt`</ph> is points; 1pt==(96/72) px</source>
          <target state="translated"><ph id="ph1">`pt`</ph> точках; 1точка==(96/72) пкс</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinHeight">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinHeight">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinHeight">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.MinHeightProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.MinHeight" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.MinHeight" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.MinWidth">
          <source>Gets or sets the minimum width constraint of the element.</source>
          <target state="translated">Получение или установка минимально допустимой ширины элемента.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinWidth">
          <source>The minimum width of the element, in <ph id="ph1">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph>.</source>
          <target state="translated">Минимальная ширина элемента в <ph id="ph1">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinWidth">
          <source>The default value is 0.0.</source>
          <target state="translated">Значение по умолчанию — 0,0.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinWidth">
          <source>This value can be any value equal to or greater than 0.0.</source>
          <target state="translated">Это значение может быть больше или равно 0,0.</target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinWidth">
          <source>However, <ph id="ph1">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph> is not valid, nor is <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</source>
          <target state="translated">Однако константа <ph id="ph1">&lt;see cref="F:System.Double.PositiveInfinity" /&gt;</ph> допустимой не является, равно как и <ph id="ph2">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinWidth">
          <source>This is one of three properties on <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> that specify width information.</source>
          <target state="translated">Это один из трех свойств на <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> , укажите ширину сведения.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinWidth">
          <source>The other two are <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.MaxWidth%2A&gt;</ph>.</source>
          <target state="translated">Два других — <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.MaxWidth%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinWidth">
          <source>If there is a conflict between these values, the order of application for actual width determination is first <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MinWidth%2A&gt;</ph> must be honored, then <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.MaxWidth%2A&gt;</ph>, and finally if each of these are within bounds, <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph>.</source>
          <target state="translated">Если возникает конфликт между этими значениями, порядок приложения для определения фактическую ширину первый <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MinWidth%2A&gt;</ph> должен быть принят на обработку, затем <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.MaxWidth%2A&gt;</ph>и, наконец, если каждый из них находятся в пределах границ, <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinWidth">
          <source>The value restrictions on the <ph id="ph1">&lt;xref:System.Double&gt;</ph> value are enforced by a <ph id="ph2">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> mechanism.</source>
          <target state="translated">Значение ограничения <ph id="ph1">&lt;xref:System.Double&gt;</ph> определяется значение <ph id="ph2">&lt;xref:System.Windows.ValidateValueCallback&gt;</ph> механизм.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinWidth">
          <source>If you attempt to set an invalid value, a run-time exception is thrown.</source>
          <target state="translated">При попытке задать недопустимое значение, возникает исключение времени выполнения.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinWidth">
          <source>XAML Attribute Usage</source>
          <target state="translated">Использование атрибута XAML</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinWidth">
          <source>XAML Values</source>
          <target state="translated">Значения XAML</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinWidth">
          <source><bpt id="p1">*</bpt>double<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>double<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinWidth">
          <source>String representation of a <ph id="ph1">&lt;xref:System.Double&gt;</ph> value equal to or greater than 0.0.</source>
          <target state="translated">Строковое представление <ph id="ph1">&lt;xref:System.Double&gt;</ph> значение, равное или больше 0,0.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinWidth">
          <source>This is interpreted as a <ph id="ph1">[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]</ph> measurement.</source>
          <target state="translated">Это значение интерпретируется как <ph id="ph1">[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]</ph> измерения.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinWidth">
          <source>Strings need not explicitly include decimal points.</source>
          <target state="translated">Строки не нужно явно указывать десятичного разделителя.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinWidth">
          <source>For instance a value of <ph id="ph1">`1`</ph> is acceptable.</source>
          <target state="translated">Для экземпляра значение <ph id="ph1">`1`</ph> является допустимым.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinWidth">
          <source>The same <ph id="ph1">&lt;xref:System.Double&gt;</ph> range restrictions as mentioned in the Property Value section apply.</source>
          <target state="translated">Соответствует <ph id="ph1">&lt;xref:System.Double&gt;</ph> ограничения диапазона, как упоминалось в разделе "значение свойства".</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinWidth">
          <source><bpt id="p1">*</bpt>qualifiedDouble<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>qualifiedDouble<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinWidth">
          <source>A <bpt id="p1">*</bpt>double<ept id="p1">*</ept> value as described above, followed by one of the following unit declaration strings: <ph id="ph1">`px`</ph>, <ph id="ph2">`in`</ph>, <ph id="ph3">`cm`</ph>, <ph id="ph4">`pt`</ph>.</source>
          <target state="translated">Объект <bpt id="p1">*</bpt>двойные<ept id="p1">*</ept> значение как описано выше, за которым следует один из следующих строк объявления единицы измерения: <ph id="ph1">`px`</ph>, <ph id="ph2">`in`</ph>, <ph id="ph3">`cm`</ph>, <ph id="ph4">`pt`</ph>.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinWidth">
          <source><ph id="ph1">`px`</ph> (default) is <ph id="ph2">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph></source>
          <target state="translated"><ph id="ph1">`px`</ph> (по умолчанию) <ph id="ph2">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinWidth">
          <source><ph id="ph1">`in`</ph> is inches; 1in==96px</source>
          <target state="translated"><ph id="ph1">`in`</ph> дюймах; 1 дюйм == 96 точек</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinWidth">
          <source><ph id="ph1">`cm`</ph> is centimeters; 1cm==(96/2.54) px</source>
          <target state="translated"><ph id="ph1">`cm`</ph> сантиметрах; 1см==(96/2,54) пкс</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinWidth">
          <source><ph id="ph1">`pt`</ph> is points; 1pt==(96/72) px</source>
          <target state="translated"><ph id="ph1">`pt`</ph> точках; 1точка==(96/72) пкс</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinWidth">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinWidth">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.MinWidth">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.MinWidthProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.MinWidth" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.MinWidth" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source>The direction that focus is to be moved, as a value of the enumeration.</source>
          <target state="translated">Направление, в котором перемещается фокус, в виде значения перечисления.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source>Moves the keyboard focus away from this element and to another element in a provided traversal direction.</source>
          <target state="translated">Перемещает клавиатурный фокус от данного элемента на другой элемент в указанном направлении обхода.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if focus is moved successfully; <ph id="ph2">&lt;see langword="false" /&gt;</ph> if the target element in direction as specified does not exist or could not be keyboard focused.</source>
          <target state="translated">Возвращает значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если фокус успешно перемещен; <ph id="ph2">&lt;see langword="false" /&gt;</ph>, если целевого элемента в указанном направлении не существует или на него нельзя установить клавиатурный фокус.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source>This implementation overrides <ph id="ph1">&lt;xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=nameWithType&gt;</ph> and seals the method.</source>
          <target state="translated">Эта реализация переопределяет <ph id="ph1">&lt;xref:System.Windows.UIElement.MoveFocus%2A?displayProperty=nameWithType&gt;</ph> и запечатывает метод.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source>The following example implements a handler that handles several possible button inputs.</source>
          <target state="translated">В следующем примере реализуется обработчик, который обрабатывает несколько возможных вводов кнопок.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source>Each button represents a possible <ph id="ph1">&lt;xref:System.Windows.Input.FocusNavigationDirection&gt;</ph>.</source>
          <target state="translated">Каждая кнопка представляет возможного <ph id="ph1">&lt;xref:System.Windows.Input.FocusNavigationDirection&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)">
          <source>The handler tracks the element with current keyboard focus, and calls <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MoveFocus%2A&gt;</ph> on that element, by specifying the appropriate <ph id="ph2">&lt;xref:System.Windows.Input.FocusNavigationDirection&gt;</ph> as initialization for the <ph id="ph3">&lt;xref:System.Windows.Input.TraversalRequest&gt;</ph> type parameter provided.</source>
          <target state="translated">Обработчик отслеживает элемента с текущей фокус клавиатуры и вызовы <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MoveFocus%2A&gt;</ph> на этот элемент, указав соответствующую <ph id="ph2">&lt;xref:System.Windows.Input.FocusNavigationDirection&gt;</ph> для инициализации <ph id="ph3">&lt;xref:System.Windows.Input.TraversalRequest&gt;</ph> введите указанный параметр.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.Name">
          <source>Gets or sets the identifying name of the element.</source>
          <target state="translated">Возвращает или задает имя, обозначающее элемент.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.Name">
          <source>The name provides a reference so that code-behind, such as event handler code, can refer to a markup element after it is constructed during processing by a <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> processor.</source>
          <target state="translated">Имя позволяет обращаться из с выделенным кодом, например из кода обработчика событий, к элементу разметки после его создания в ходе обработки процессором <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>The name of the element.</source>
          <target state="translated">Имя элемента.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>The default is an empty string.</source>
          <target state="translated">Значение по умолчанию - пустая строка.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>The most common usage of this property is to specify a <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> element name as an attribute in markup.</source>
          <target state="translated">Наиболее распространенное использование этого свойства является указание <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> имя элемента как атрибут в разметке.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>This property essentially provides a WPF framework-level convenience property to set the <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> <bpt id="p1">[</bpt>x:Name Directive<ept id="p1">](~/docs/framework/xaml-services/x-name-directive.md)</ept>.</source>
          <target state="translated">По сути, это свойство предоставляет свойство удобства уровня платформы WPF для задания <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> <bpt id="p1">[</bpt>директива x: Name<ept id="p1">](~/docs/framework/xaml-services/x-name-directive.md)</ept>.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>Names must be unique within a namescope.</source>
          <target state="translated">Имена должны быть уникальными в пределах области видимости имен.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>For more information, see <bpt id="p1">[</bpt>WPF XAML Namescopes<ept id="p1">](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>области имен XAML WPF<ept id="p1">](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>Getting a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> if you are creating elements in code is not common.</source>
          <target state="translated">Получение <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> при создании элементов кода не так часто.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>If you have the appropriate reference in code already, you can just call methods and properties on the element reference and will not generally need the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph>.</source>
          <target state="translated">Если в коде уже присутствует соответствующая ссылка, может просто вызвать методы и свойства в элементе ссылки и не будет обычно необходимость <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>An exception to this is if the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> string has some overloaded meaning, for instance if it is useful to display that name in <ph id="ph2">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>.</source>
          <target state="translated">Исключение — если <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> строка имеет несколько перегруженных значение, например если полезно отображать это имя в <ph id="ph2">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>Setting a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> from code-behind if the original <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> was set from markup is also not recommended, and changing the property after loading the <ph id="ph3">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> will not change the original object reference.</source>
          <target state="translated">Установка <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> из кода если исходное <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> было задано из разметки также не рекомендуется использовать и изменение свойства после загрузки <ph id="ph3">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> ссылку на исходный объект не изменится.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>The object references are created only when the underlying namescopes are explicitly created during parsing.</source>
          <target state="translated">Ссылки на объекты создаются только в том случае, если основной области видимости имен явно создаются во время синтаксического анализа.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>You must specifically call <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.RegisterName%2A&gt;</ph> to make an effective change to the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> property of an already loaded element.</source>
          <target state="translated">Необходимо явно вызывать <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.RegisterName%2A&gt;</ph> действующие сделать для <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> свойства элемента уже загружен.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>One notable case where setting <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> from code is important is when registering names for elements that storyboards will run against, so that they can be referenced at run time.</source>
          <target state="translated">Важные один вариант, где параметр <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> из кода важно при регистрации имен для элементов, которые раскадровки будет выполняться, чтобы к ним могут обращаться во время выполнения.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>Before you can register a name, might also need to instantiate and assign a <ph id="ph1">&lt;xref:System.Windows.NameScope&gt;</ph> instance.</source>
          <target state="translated">Прежде чем выполнять регистрацию имени, может потребоваться создать и назначить <ph id="ph1">&lt;xref:System.Windows.NameScope&gt;</ph> экземпляра.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>See the Example section, or <bpt id="p1">[</bpt>Storyboards Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept>.</source>
          <target state="translated">См. в разделе, или <bpt id="p1">[</bpt>Общие<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>Setting <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> from code has limited applications, but getting an element by <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> is more common.</source>
          <target state="translated">Установка <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> из кода имеет ограниченные приложения, но Получение элемента с <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> чаще всего.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>One particular scenario is if your application supports a navigation model where pages reload into the application, and the run time code is not necessarily code-behind defined for that page.</source>
          <target state="translated">Один из сценариев является, если приложение поддерживает модель навигации, где перезагрузкой страниц в приложение, и код времени выполнения не обязательно является кода программной части, определенным для этой страницы.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>The utility method <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FindName%2A&gt;</ph>, which is available from any <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, can find any element by <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> in the logical tree for that element, searching the tree recursively as necessary.</source>
          <target state="translated">Вспомогательный метод <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FindName%2A&gt;</ph>, которое доступно из любого <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, можно найти любой элемент, <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> в логическом дереве для этого элемента, поиск рекурсивно дерева при необходимости.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>Or you can use the <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A&gt;</ph> static method of <ph id="ph2">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>, which also takes a <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> string as an argument.</source>
          <target state="translated">Или можно использовать <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.FindLogicalNode%2A&gt;</ph> статический метод <ph id="ph2">&lt;xref:System.Windows.LogicalTreeHelper&gt;</ph>, которая также принимает <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> строку в качестве аргумента.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>Typically used root elements (<ph id="ph1">&lt;xref:System.Windows.Window&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Controls.Page&gt;</ph> for example) implement the interface <ph id="ph3">&lt;xref:System.Windows.Markup.INameScope&gt;</ph>.</source>
          <target state="translated">Как правило, используется корневых элементов (<ph id="ph1">&lt;xref:System.Windows.Window&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Controls.Page&gt;</ph> например) реализуют интерфейс <ph id="ph3">&lt;xref:System.Windows.Markup.INameScope&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>Implementations of this interface are expected to enforce that names be unambiguous within their scope.</source>
          <target state="translated">Реализации этого интерфейса ожидается обеспечение однозначности имен в пределах их области.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>The root elements that define this interface also define the namescope behavior boundaries for all the related <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph>.</source>
          <target state="translated">Корневые элементы, определяющие этот интерфейс также определяют поведение границы области видимости имен для всех связанных <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> property also serves as an identifier for other processes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> Также служит в качестве идентификатора для других процессов.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>For instance, the <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> automation model will use <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> as the AutomationId for clients and providers.</source>
          <target state="translated">Например <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> будет использовать модель автоматизации <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> как AutomationId для клиентов и поставщиков.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>The string values used for <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> have some restrictions, as imposed by the underlying <bpt id="p1">[</bpt>x:Name Directive<ept id="p1">](~/docs/framework/xaml-services/x-name-directive.md)</ept> defined by the <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> specification.</source>
          <target state="translated">Строковые значения, используемые для <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> имеют некоторые ограничения, как основной, установленные <bpt id="p1">[</bpt>директива x: Name<ept id="p1">](~/docs/framework/xaml-services/x-name-directive.md)</ept> определяется <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> спецификации.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>Most notably, a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> must start with a letter or the underscore character (_), and must contain only letters, digits, or underscores.</source>
          <target state="translated">Прежде всего <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> должно начинаться с буквы или символа подчеркивания (_) и должно содержать только буквы, цифры или символы подчеркивания.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>For more information, see <bpt id="p1">[</bpt>WPF XAML Namescopes<ept id="p1">](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>области имен XAML WPF<ept id="p1">](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> is one of the very few dependency properties that cannot be animated (<ph id="ph2">&lt;xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A&gt;</ph> is <ph id="ph3">`true`</ph> in metadata), because the name itself is vital for targeting an animation.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> является одним из очень мало свойств зависимостей, которые невозможно анимировать (<ph id="ph2">&lt;xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A&gt;</ph> — <ph id="ph3">`true`</ph> в метаданных), так как само имя крайне важно для нацеливания на анимации.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>Data binding a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> is technically possible, but is an extremely uncommon scenario because a data-bound <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> cannot serve the main intended purpose of the property: to provide an identifier connection point for code-behind.</source>
          <target state="translated">Привязка данных <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> технически возможно, но встречается крайне редко, так как привязки к данным <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> не может служить главной назначение свойства: для предоставления идентификатор точки подключения для кода.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>The following example sets the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> property in code, and then registers the name into the newly created <ph id="ph2">&lt;xref:System.Windows.NameScope&gt;</ph> by calling <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.RegisterName%2A&gt;</ph>.</source>
          <target state="translated">В следующем примере задается <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph> свойства в коде, а затем регистрирует имя в только что созданный <ph id="ph2">&lt;xref:System.Windows.NameScope&gt;</ph> путем вызова <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.RegisterName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Name">
          <source>The technique illustrated here is a requirement for animating with storyboards, because storyboards require targeting by the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph>, and cannot be targeted by object reference.</source>
          <target state="translated">Показанный здесь прием является обязательным для анимации с помощью Storyboard, так как раскадровки требуют указания цели с <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Name%2A&gt;</ph>и не может обращаться по ссылке объекта.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.NameProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.Name" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.Name" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnApplyTemplate">
          <source>When overridden in a derived class, is invoked whenever application code or internal processes call <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkElement.ApplyTemplate" /&gt;</ph>.</source>
          <target state="translated">При переопределении в производном классе вызывается каждый раз, когда код приложения или внутренние процессы вызывают <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkElement.ApplyTemplate" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnApplyTemplate">
          <source>This method has no default implementation.</source>
          <target state="translated">У этого метода нет реализации по умолчанию.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnApplyTemplate">
          <source>Templates are the section of an element's completed visual tree that comes from the Template property of a <ph id="ph1">&lt;xref:System.Windows.Style&gt;</ph> that is applied for the element.</source>
          <target state="translated">Шаблоны представляют собой часть элемента визуального дерева, поступающие из свойства шаблона <ph id="ph1">&lt;xref:System.Windows.Style&gt;</ph> , применяемый для элемента.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnApplyTemplate">
          <source>For more information, see <bpt id="p1">[</bpt>Styling and Templating<ept id="p1">](~/docs/framework/wpf/controls/styling-and-templating.md)</ept>.</source>
          <target state="translated">Более подробную информацию см. в разделе <bpt id="p1">[</bpt>Стилизация и использование шаблонов<ept id="p1">](~/docs/framework/wpf/controls/styling-and-templating.md)</ept>.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnApplyTemplate">
          <source>Derived classes of <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> can use this method as a notification for a variety of possible scenarios:</source>
          <target state="translated">Классы, унаследованные от <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> можно использовать этот метод для уведомления о различных возможных сценариев:</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnApplyTemplate">
          <source>You can call your own implementation of code that builds the remainder of an element visual tree.</source>
          <target state="translated">Можно вызвать собственную реализацию кода, выполняющего построение оставшейся части визуального дерева элемента.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnApplyTemplate">
          <source>You can run code that relies on the visual tree from templates having been applied, such as obtaining references to named elements that came from a template.</source>
          <target state="translated">Можно запустить код, основанный на визуальное дерево из примененных шаблонов, например для получения ссылок на именованные элементы, полученные из шаблона.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnApplyTemplate">
          <source>You can introduce services that only make sense to exist after the visual tree from templates is complete.</source>
          <target state="translated">Можно внедрить службы, которые имеют смысл только существование после завершения визуального дерева с помощью шаблонов.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnApplyTemplate">
          <source>You can set states and properties of elements within the template that are dependent on other factors.</source>
          <target state="translated">Можно задать состояния и свойства элементов в шаблоне, зависящих от других факторов.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnApplyTemplate">
          <source>For instance, property values might only be discoverable by knowing the parent element, or when a specific derived class uses a common template.</source>
          <target state="translated">Для экземпляра значения свойств могут быть доступными только зная родительского элемента, или если конкретный производной класс использует общий шаблон.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnApplyTemplate">
          <source>Implementers should always call the base implementation before their own implementation.</source>
          <target state="translated">Исполнители должен всегда вызывать базовую реализацию перед свою собственную реализацию.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnApplyTemplate">
          <source><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> itself has no default implementation, but intervening classes might.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> сам не имеет стандартного реализации, но промежуточные классы могут.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnApplyTemplate">
          <source><ph id="ph1">&lt;see cref="T:System.Windows.Controls.Control" /&gt;</ph> offers a similar override, <ph id="ph2">&lt;see cref="M:System.Windows.Controls.Control.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.Controls.Control" /&gt;</ph> предоставляет аналогичные override, <ph id="ph2">&lt;see cref="M:System.Windows.Controls.Control.OnTemplateChanged(System.Windows.Controls.ControlTemplate,System.Windows.Controls.ControlTemplate)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Provides data about the event.</source>
          <target state="translated">Предоставляет данные о событии.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Invoked whenever an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /&gt;</ph> routed event reaches this class in its route.</source>
          <target state="translated">Вызывается, когда необработанное перенаправленное событие <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.ContextMenuClosing" /&gt;</ph> достигает этого класса на своем пути.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">У этого метода нет реализации по умолчанию.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.</source>
          <target state="translated">По-прежнему должен вызвать базовую реализацию, если промежуточный класс в цепочке наследования реализует данный метод.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>The purpose of this method is somewhat similar to <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</source>
          <target state="translated">Этот метод похож на <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> шаблона On * методы: она предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">В этом случае соответствующее событие является маршрутизируемым.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</source>
          <target state="translated">Шаблон реализации методов On * отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, не обязательно является элементом, вызывающим обработчики, так что реализации требуется выполнять источника аргументов события свойства в учетной записи (и не пытаться повторно вызвать событие в большинстве случаев).</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Subclasses of <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> could choose to call private class handler methods when the event is received along the route.</source>
          <target state="translated">Подклассы <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> может выбрать для вызова методов обработчика закрытый класс при получении события в маршруте.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnContextMenuClosing(System.Windows.Controls.ContextMenuEventArgs)">
          <source>One potential scenario is to take the arguments of the event and deliberately mark the event as handled.</source>
          <target state="translated">Одним из потенциальных сценариев является получение аргументов события и пометка его как обработанное.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">Объект класса <ph id="ph1">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph>, содержащий данные о событии.</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Invoked whenever an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /&gt;</ph> routed event reaches this class in its route.</source>
          <target state="translated">Вызывается, когда необработанное перенаправленное событие <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.ContextMenuOpening" /&gt;</ph> достигает этого класса на своем пути.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">У этого метода нет реализации по умолчанию.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.</source>
          <target state="translated">По-прежнему должен вызвать базовую реализацию, если промежуточный класс в цепочке наследования реализует данный метод.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>The purpose of this method is somewhat similar to <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</source>
          <target state="translated">Этот метод похож на <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> шаблона On * методы: она предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">В этом случае соответствующее событие является маршрутизируемым.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</source>
          <target state="translated">Шаблон реализации методов On * отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, не обязательно является элементом, вызывающим обработчики, так что реализации требуется выполнять источника аргументов события свойства в учетной записи (и не пытаться повторно вызвать событие в большинстве случаев).</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>Subclasses of <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> could choose to call private class handler methods when the event is received along the route.</source>
          <target state="translated">Подклассы <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> может выбрать для вызова методов обработчика закрытый класс при получении события в маршруте.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnContextMenuOpening(System.Windows.Controls.ContextMenuEventArgs)">
          <source>One potential scenario is to take the arguments of the event and deliberately mark the event as handled.</source>
          <target state="translated">Одним из потенциальных сценариев является получение аргументов события и пометка его как обработанное.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">Объект класса <ph id="ph1">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph>, содержащий данные о событии.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>Invoked whenever an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.GotFocus" /&gt;</ph> event reaches this element in its route.</source>
          <target state="translated">Вызывается, когда необработанное событие <ph id="ph1">&lt;see cref="E:System.Windows.UIElement.GotFocus" /&gt;</ph> достигает этого элемента на своем пути.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>Unlike some other On* methods exposed by the base elements, <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.OnGotFocus%2A&gt;</ph> does have a default implementation.</source>
          <target state="translated">В отличие от некоторых других на * методам, предоставляемым базовых элементах <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.OnGotFocus%2A&gt;</ph> имеет реализацию по умолчанию.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>Specifically, it has an implementation that overrides the null implementation in the next level of base element down, <ph id="ph1">&lt;xref:System.Windows.UIElement.OnGotFocus%2A&gt;</ph>.</source>
          <target state="translated">В частности, он имеет реализацию, переопределяет реализацию null на следующем уровне базового элемента вниз, <ph id="ph1">&lt;xref:System.Windows.UIElement.OnGotFocus%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>When invoked, <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.OnGotFocus%2A&gt;</ph> sets appropriate focus behavior on this element in cases where the event originated from the current element due to keyboard focus.</source>
          <target state="translated">При вызове <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.OnGotFocus%2A&gt;</ph> задает соответствующее поведение фокуса на этот элемент в случаях, источник события из текущего элемента из-за фокус клавиатуры.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.OnGotFocus%2A&gt;</ph> handler does not mark the event arguments as handled, even when focus is set to the current element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.OnGotFocus%2A&gt;</ph> Обработчик не помечает аргументы события как обработанное, даже если установить фокус на текущий элемент.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>If the event's source was another element in the tree (not the current element), the handler does nothing.</source>
          <target state="translated">Если источником события был другой элемент в дереве (а не текущего элемента), обработчик не выполняет никаких действий.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>You can override this method in order to change the default focus behavior on your element, but be aware that changing focus behavior in this way might be better accomplished by not allowing the element to be focusable at all (see <ph id="ph1">&lt;xref:System.Windows.UIElement.Focusable%2A&gt;</ph>).</source>
          <target state="translated">Можно переопределить этот метод, чтобы изменить поведение по умолчанию фокус на элемент, но имейте в виду, что изменение поведения фокуса таким способом можно реализовать лучше, не позволяя элемента вообще (см. <ph id="ph1">&lt;xref:System.Windows.UIElement.Focusable%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>If you intend to mark the event handled in the arguments, you should be aware of consequences on event handling in other parent elements in the element tree.</source>
          <target state="translated">Если планируется пометить событие как обработанное в аргументах следует учитывать последствия обработки события в других родительских элементов в дереве элементов.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>Because this handler acts on an event with a bubbling routing, setting the focus to the current <ph id="ph1">&lt;paramref name="sender" /&gt;</ph> per the event arguments may not be appropriate.</source>
          <target state="translated">Так как данный обработчик действует на событие с восходящей маршрутизацией, установка фокуса в текущий <ph id="ph1">&lt;paramref name="sender" /&gt;</ph> на событие аргументов может быть неприемлемо.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>Focus might need to go to either a composite child element or to a parent element, depending on the compositing of certain controls.</source>
          <target state="translated">Фокус может потребоваться перейти на составной дочерний элемент или родительский элемент, в зависимости от композиции определенных элементов управления.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnGotFocus(System.Windows.RoutedEventArgs)">
          <source>Therefore marking a focus event as handled is only recommended if the entirety of the visual tree that the event is routing through is part of compositing of a control that you authored.</source>
          <target state="translated">Поэтому помечать событие фокуса как обработанное рекомендуется только если во время всего визуального дерева, событием является частью композиции элемента управления, созданные.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph> that contains the event data.</source>
          <target state="translated">Объект класса <ph id="ph1">&lt;see cref="T:System.Windows.RoutedEventArgs" /&gt;</ph>, содержащий данные о событии.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)">
          <source>Raises the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.Initialized" /&gt;</ph> event.</source>
          <target state="translated">Вызывает событие <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.Initialized" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)">
          <source>This method is invoked whenever <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.IsInitialized" /&gt;</ph> is set to <ph id="ph2">&lt;see langword="true" /&gt;</ph> internally.</source>
          <target state="translated">Этот метод вызывается всякий раз, когда <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.IsInitialized" /&gt;</ph> имеет внутреннее значение <ph id="ph2">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)">
          <source>This particular On* method is not a class handler hook.</source>
          <target state="translated">Данный конкретный на * метод не является ловушкой обработчика класса.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)">
          <source>Nor does it exactly follow the established <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> On* method convention that the matching event could be suppressed by overriding this method and not calling the base implementation.</source>
          <target state="translated">Ни он точно следовать установленному <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> на * метод соглашение, соответствующее событие можно подавить путем переопределения этого метода и не вызывает базовую реализацию.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)">
          <source>Note that the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.IsInitialized%2A&gt;</ph> property is read-only, so you cannot set <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.IsInitialized%2A&gt;</ph> to force initialization behavior.</source>
          <target state="translated">Обратите внимание, что <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.IsInitialized%2A&gt;</ph> свойство только для чтения, поэтому нельзя задать <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.IsInitialized%2A&gt;</ph> на принудительную инициализацию.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)">
          <source>Setting the initialization state is intended to be done only by the <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> framework.</source>
          <target state="translated">Задание состояния инициализации должен выполняться только <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> framework.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)">
          <source>The default implementation of this virtual method raises the event as described above.</source>
          <target state="translated">Реализация по умолчанию данного виртуального метода вызывает вышеописанное событие.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)">
          <source>Overrides should call the base implementation to preserve this behavior.</source>
          <target state="translated">Для поддержания данного режима работы переопределение должно вызывать базовую реализацию.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnInitialized(System.EventArgs)">
          <source>If you fail to call the base implementation, not only will you not raise the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.Initialized" /&gt;</ph> event as is generally expected of a <ph id="ph2">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> derived class, but you will also suppress two important style and theme style initialization operations that are implemented by this base implementation.</source>
          <target state="translated">Если не удается вызвать базовую реализацию, не только вы не приведет к <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.Initialized" /&gt;</ph> события как обычно ожидается <ph id="ph2">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> производного класса, но также подавляет два важных стиль и тему стиль инициализации операции, которые будут реализован этой базовой реализации.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The event data that describes the property that changed, as well as old and new values.</source>
          <target state="translated">Данные события, описывающие измененное свойство, а также старое и новое значения.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Invoked whenever the effective value of any dependency property on this <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> has been updated.</source>
          <target state="translated">Вызывается всякий раз при обновлении действующего значения какого-либо свойства зависимостей относительно данного элемента <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The specific dependency property that changed is reported in the arguments parameter.</source>
          <target state="translated">Конкретное измененное свойство зависимостей сообщается в параметре аргументов.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Overrides <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /&gt;</ph>.</source>
          <target state="translated">Переопределяет свойство <ph id="ph1">&lt;see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This method is not intended to generally detect property changes or invalidations.</source>
          <target state="translated">Этот метод не предназначен для общего выявления изменений свойств или их недействительности.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>It is instead intended for modifications of the general invalidation pattern if certain information is known about wide classifications of properties.</source>
          <target state="translated">Он предназначен для изменения общего шаблона недействительности, если известна определенная информация о широких классификациях свойств.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>This method is potentially invoked many times during the life of an object.</source>
          <target state="translated">Этот метод потенциально вызывается несколько раз за время существования объекта.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Therefore, you can achieve better performance if you override the metadata of specific properties and then attach <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph> functions for individual properties.</source>
          <target state="translated">Таким образом, можно улучшить производительность, если переопределения метаданных свойств, а затем подключите <ph id="ph1">&lt;xref:System.Windows.CoerceValueCallback&gt;</ph> или <ph id="ph2">&lt;xref:System.Windows.PropertyChangedCallback&gt;</ph> функции для отдельных свойств.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>However, you would use this method if a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> includes a significant number of value-interrelated dependency properties, or if it includes logic such as rendering behavior that must be rerun for several related cases of property invalidations.</source>
          <target state="translated">Тем не менее, будет использовать этот метод, если <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> включает значительное количество свойств зависимостей с взаимосвязанными значениями, или если он содержит логику, например поведение отрисовки, необходимо повторно для нескольких связанных случаев недействительности свойств.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Note that there is an identically named <ph id="ph1">`OnPropertyChanged`</ph> method with a different signature (the parameter type is <ph id="ph2">&lt;xref:System.ComponentModel.PropertyChangedEventArgs&gt;</ph>) that can appear on a number of classes.</source>
          <target state="translated">Обратите внимание, что таким же именем <ph id="ph1">`OnPropertyChanged`</ph> метод с другой сигнатурой (тип параметра является <ph id="ph2">&lt;xref:System.ComponentModel.PropertyChangedEventArgs&gt;</ph>), которые могут возникнуть на несколько классов.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>That <ph id="ph1">`OnPropertyChanged`</ph> is used for data object notifications, and is part of the contract for <ph id="ph2">&lt;xref:System.ComponentModel.INotifyPropertyChanged&gt;</ph>.</source>
          <target state="translated">Что <ph id="ph1">`OnPropertyChanged`</ph> используется для уведомления объекта данных и является частью контракта для <ph id="ph2">&lt;xref:System.ComponentModel.INotifyPropertyChanged&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Always call the base implementation, as the first operation in your implementation.</source>
          <target state="translated">Всегда вызовите базовую реализацию в качестве первой операции в вашей реализации.</target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>Failure to do this will significantly disable the entire <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> property system, which causes incorrect values to be reported.</source>
          <target state="translated">В противном случае значительно отключит всего <ph id="ph1">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> системы свойств, вследствие чего будут сообщены неверные значения.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>The specific <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> implementation is also responsible for maintaining proper state for a variety of properties that affect the visible user interface.</source>
          <target state="translated">Конкретный <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> реализация также отвечает за поддержку надлежащего состояния различных свойств, влияющих на видимый пользовательский интерфейс.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)">
          <source>These include invalidating the visual tree based on changes to style at appropriate times.</source>
          <target state="translated">К ним относится недействительность визуального дерева в зависимости от изменений стиля в соответствующие моменты.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)">
          <source>Details of the old and new size involved in the change.</source>
          <target state="translated">Сведения о старом и новом размерах при изменении.</target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)">
          <source>Raises the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.SizeChanged" /&gt;</ph> event, using the specified information as part of the eventual event data.</source>
          <target state="translated">Инициирует событие <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.SizeChanged" /&gt;</ph>, используя указанную информацию как часть окончательных данных события.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)">
          <source>This method overrides <ph id="ph1">&lt;xref:System.Windows.UIElement.OnRenderSizeChanged%2A&gt;</ph>.</source>
          <target state="translated">Этот метод переопределяет метод <ph id="ph1">&lt;xref:System.Windows.UIElement.OnRenderSizeChanged%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)">
          <source>If you call this method you will reset the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ActualWidth%2A&gt;</ph> property, the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.ActualHeight%2A&gt;</ph> property, or both, depending on what is specified as changed in the supplied arguments, and will you always raise the event.</source>
          <target state="translated">Если вызвать этот метод будет заново <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ActualWidth%2A&gt;</ph> свойства <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.ActualHeight%2A&gt;</ph> свойства (или оба) в зависимости от того, что указано в качестве изменено в предоставленных аргументов, и вы всегда вызывает событие.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)">
          <source>Do not override this method for typical layout scenarios.</source>
          <target state="translated">Не следует переопределять этот метод для обычных сценариях структуры.</target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)">
          <source>The layout system operates in a deliberately asynchronous way to assure that all possible layout arrange and measure cases are accounted for.</source>
          <target state="translated">Система структуры работает в намеренно асинхронном режиме, чтобы обеспечить, упорядочить все возможные макета и случаев меры.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)">
          <source>The layout system override methods <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" /&gt;</ph> are usually sufficient for any required layout customization.</source>
          <target state="translated">Система макета переопределения методов <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /&gt;</ph> и <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" /&gt;</ph> обычно достаточно для настройки любой требуемый макет.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)">
          <source><ph id="ph1">&lt;see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /&gt;</ph> is exposed as a virtual.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /&gt;</ph> предоставляется виртуальным.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)">
          <source>You can override <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /&gt;</ph> to correct for exceptional cases where a run-time behavioral change related to input events combined with control recomposition in response might give inaccurate layout information.</source>
          <target state="translated">Можно переопределить <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)" /&gt;</ph> исправление в исключительных случаях, где изменение поведения во время выполнения, связанные с входными событиями, в сочетании с элементом управления рекомпозиции в ответ может предоставить сведения о макете неточной.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)">
          <source>You may still override this method in derived classes (it is protected but not sealed).</source>
          <target state="translated">Вы по-прежнему может переопределить этот метод в производных классах (он защищен, но не запечатан).</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)">
          <source>Always call the base implementation to preserve the behavior mentioned above, unless you have very specific reasons for disabling default WPF framework-level rendering behavior.</source>
          <target state="translated">Всегда вызовите базовую реализацию для сохранения поведение, описанное выше, если у вас нет особых причин для отключения поведение отрисовки уровня платформы WPF по умолчанию.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnRenderSizeChanged(System.Windows.SizeChangedInfo)">
          <source>Failing to raise the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.SizeChanged" /&gt;</ph> event will cause non-standard layout behavior if using the standard WPF framework-level layout system implementation.</source>
          <target state="translated">Сбой вызова <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.SizeChanged" /&gt;</ph> событий приведет к стандартным макетом поведение при использовании стандартной реализации системы макета уровня платформы WPF.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>The old style.</source>
          <target state="translated">Старый стиль.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>The new style.</source>
          <target state="translated">Новый стиль.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>Invoked when the style in use on this element changes, which will invalidate the layout.</source>
          <target state="translated">Вызывается при изменении текущего стиля данного элемента, что ведет к недействительности структуры.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>This method has a default implementation that sets an internal flag that notes the style changed condition.</source>
          <target state="translated">Этот метод имеет реализацию по умолчанию, которая устанавливает внутренний флаг, заметки о состоянии изменения стиля.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>You should not typically have to override this method.</source>
          <target state="translated">Вам не следует обычно переопределить этот метод.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>Any change to a style that involves a measure or arrange change would already trigger another render cycle, assuming a typical implementation of <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" /&gt;</ph><ph id="ph2"> / </ph><ph id="ph3">&lt;see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /&gt;</ph>, or the defaults.</source>
          <target state="translated">Любой изменить стиль, который включает в себя меру или упорядочивания, изменение приведет к запуску уже следующего цикла отрисовки, при условии, что типичная реализация <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" /&gt;</ph> <ph id="ph2"> / </ph> <ph id="ph3">&lt;see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /&gt;</ph>, или значения по умолчанию.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>Overrides of <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" /&gt;</ph> might be appropriate if your <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" /&gt;</ph><ph id="ph3"> / </ph><ph id="ph4">&lt;see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /&gt;</ph> implementations were deliberately optimizing or supporting partial updates, but still wanted to apply changes to styles more directly.</source>
          <target state="translated">Переопределений <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)" /&gt;</ph> может использоваться, если ваш <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" /&gt;</ph> <ph id="ph3"> / </ph> <ph id="ph4">&lt;see cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" /&gt;</ph> реализации были намеренно оптимизации или поддержки частичных обновлений, но по-прежнему необходимо было для применения изменений в стили напрямую.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnStyleChanged(System.Windows.Style,System.Windows.Style)">
          <source>(The partial updates would be an attempt to avoid multiple incremental calls to <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /&gt;</ph> on any child elements).</source>
          <target state="translated">(Частичное обновление будет предпринята во избежание нескольких вызовов добавочное <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.Measure(System.Windows.Size)" /&gt;</ph> и <ph id="ph2">&lt;see cref="M:System.Windows.UIElement.Arrange(System.Windows.Rect)" /&gt;</ph> на всех дочерних элементов).</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>Provides data about the event.</source>
          <target state="translated">Предоставляет данные о событии.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>Invoked whenever an unhandled <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.ToolTipClosing" /&gt;</ph> routed event reaches this class in its route.</source>
          <target state="translated">Вызывается, когда необработанное перенаправленное событие <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.ToolTipClosing" /&gt;</ph> достигает этого класса на своем пути.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">У этого метода нет реализации по умолчанию.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.</source>
          <target state="translated">По-прежнему должен вызвать базовую реализацию, если промежуточный класс в цепочке наследования реализует данный метод.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>The purpose of this method is somewhat similar to <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</source>
          <target state="translated">Этот метод похож на <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> шаблона On * методы: она предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">В этом случае соответствующее событие является маршрутизируемым.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</source>
          <target state="translated">Шаблон реализации методов On * отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, не обязательно является элементом, вызывающим обработчики, так что реализации требуется выполнять источника аргументов события свойства в учетной записи (и не пытаться повторно вызвать событие в большинстве случаев).</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>Subclasses of <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> could choose to call private class handler methods when the event is received along the route.</source>
          <target state="translated">Подклассы <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> может выбрать для вызова методов обработчика закрытый класс при получении события в маршруте.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnToolTipClosing(System.Windows.Controls.ToolTipEventArgs)">
          <source>One potential scenario is to take the arguments of the event and deliberately mark the event as handled.</source>
          <target state="translated">Одним из потенциальных сценариев является получение аргументов события и пометка его как обработанное.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>Provides data about the event.</source>
          <target state="translated">Предоставляет данные о событии.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>Invoked whenever the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.ToolTipOpening" /&gt;</ph> routed event reaches this class in its route.</source>
          <target state="translated">Вызывается, когда перенаправленное событие <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.ToolTipOpening" /&gt;</ph> достигает этого класса на своем пути.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>Implement this method to add class handling for this event.</source>
          <target state="translated">Реализуйте этот метод, чтобы добавить для класса обработчик данного события.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>This method has no default implementation.</source>
          <target state="translated">У этого метода нет реализации по умолчанию.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>You should still call the base implementation in case an intermediate class in the inheritance has implemented this method.</source>
          <target state="translated">По-прежнему должен вызвать базовую реализацию, если промежуточный класс в цепочке наследования реализует данный метод.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>The purpose of this method is somewhat similar to <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> event pattern On* methods: it provides the means to handle the matching event from derived classes with a class handler instead of an instance handler.</source>
          <target state="translated">Этот метод похож на <ph id="ph1">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> шаблона On * методы: она предоставляет средства для обработки соответствующего события из производных классов с помощью обработчика класса вместо обработчика экземпляра.</target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>In this case the matching event is a routed event.</source>
          <target state="translated">В этом случае соответствующее событие является маршрутизируемым.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>The implementation pattern of the On* methods is different for routed events because the routed event may have been raised by a child element, not necessarily the element that will invoke handlers, so your implementation will need to take the event arguments' source properties into account (and should not try to re-raise the event in most cases).</source>
          <target state="translated">Шаблон реализации методов On * отличается для перенаправленных событий, поскольку перенаправленное событие может генерироваться дочерним элементом, не обязательно является элементом, вызывающим обработчики, так что реализации требуется выполнять источника аргументов события свойства в учетной записи (и не пытаться повторно вызвать событие в большинстве случаев).</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>Subclasses of <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> could choose to call private class handler methods when the event is received along the route.</source>
          <target state="translated">Подклассы <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> может выбрать для вызова методов обработчика закрытый класс при получении события в маршруте.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnToolTipOpening(System.Windows.Controls.ToolTipEventArgs)">
          <source>One potential scenario is to take the arguments of the event and deliberately mark the event as handled to shorten the route.</source>
          <target state="translated">Одним из потенциальных сценариев является получение аргументов события и пометка его как обработанного для сокращения маршрута.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)">
          <source>The old parent element.</source>
          <target state="translated">Прежний родительский элемент.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)">
          <source>May be <ph id="ph1">&lt;see langword="null" /&gt;</ph> to indicate that the element did not have a visual parent previously.</source>
          <target state="translated">Может иметь значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>, указывающее, что до этого у элемента не было визуального родителя.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)">
          <source>Invoked when the parent of this element in the visual tree is changed.</source>
          <target state="translated">Вызывается при изменении родителя данного элемента в визуальном дереве.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)">
          <source>Overrides <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" /&gt;</ph>.</source>
          <target state="translated">Переопределяет свойство <ph id="ph1">&lt;see cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)">
          <source>The visual tree is potentially different from the logical tree because it omits elements that do not render visually, such as collections, and expands some elements on the basis of their theme and style compositing.</source>
          <target state="translated">Визуальное дерево потенциально отличается от логического дерева, так как он не содержит элементы, которые не отображаются визуально, таких как коллекции и раскрывает некоторые элементы на основе их темы и композиции стиля.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)">
          <source>For more information, see <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Деревья в WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)">
          <source>The default implementation of this virtual method queries for the new parent, raises various initialization events, and sets internal flags about initialization state of the <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> as appropriate.</source>
          <target state="translated">Реализация по умолчанию данного виртуального метода запрашивает нового родителя, инициирует различные события инициализации и устанавливает внутренние флаги состояния инициализации для <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> соответствующим образом.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)">
          <source>Finally, it calls the successive base implementations as declared by <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph>, which in turn calls its base in <ph id="ph2">&lt;see cref="T:System.Windows.Media.Visual" /&gt;</ph>.</source>
          <target state="translated">Наконец, он вызывает последовательных базовой реализации, объявленном с <ph id="ph1">&lt;see cref="T:System.Windows.UIElement" /&gt;</ph>, который в свою очередь вызывает базовую <ph id="ph2">&lt;see cref="T:System.Windows.Media.Visual" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)">
          <source>Always call the base implementation to preserve this behavior, otherwise the element tree behavior for this element when declared as a child of another element may not be as expected.</source>
          <target state="translated">Всегда вызовите базовую реализацию для сохранения этого поведения, в противном случае поведение дерева элементов для данного элемента, объявленного дочерним другого элемента, может отличаться от ожидаемого.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)">
          <source>A few existing <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> classes override this method, for example: <ph id="ph2">&lt;see cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Windows.Controls.ListBoxItem.OnVisualParentChanged(System.Windows.DependencyObject)" /&gt;</ph>.</source>
          <target state="translated">Несколько существующих <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> классы переопределять этот метод, например: <ph id="ph2">&lt;see cref="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Windows.Controls.ListBoxItem.OnVisualParentChanged(System.Windows.DependencyObject)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)">
          <source>The most common scenario is to enforce that the new parent must be a particular type.</source>
          <target state="translated">Наиболее распространенным сценарием является принудительное, что новый родительский объект должен быть определенного типа.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)">
          <source>This might involve throwing an exception if the new parent failed some manner of type test.</source>
          <target state="translated">Это может вызвать исключение, если новый родитель не пройдет определенную проверку типа.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)">
          <source>A specialized version of this scenario exists in implementations for list items and menu items, which do not make any sense outside a parent visual that owns an appropriate collection to store them in.</source>
          <target state="translated">Специализированная версия этого сценария существует в реализациях элементов списков и пунктов меню, которые не смысла за пределами родительского визуального, владеющего соответствующей коллекцией для их хранения.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)">
          <source>Note that these cases do not necessarily raise exceptions, because there might be designer scenarios that rely on reparenting elements that are momentarily without their "regular" parents.</source>
          <target state="translated">Обратите внимание, что эти случаи не обязательно вызывают исключения, так как может быть конструктора сценарии, основанные на Переподчинение элементы, которые являются моментально без родительских «стандартными».</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)">
          <source>This method is also overridden in certain elements that are typically the root element, such as  <ph id="ph1">&lt;see cref="T:System.Windows.Window" /&gt;</ph>.</source>
          <target state="translated">Этот метод также переопределяется в некоторых элементах, обычно являются корневого элемента, например <ph id="ph1">&lt;see cref="T:System.Windows.Window" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)">
          <source>Another case is elements that are the apparent root element in markup but which autogenerate a greater infrastructure in a compiled logical tree (such as <ph id="ph1">&lt;see cref="T:System.Windows.Controls.Page" /&gt;</ph>).</source>
          <target state="translated">Другим случаем являются элементы, которые являются очевидными корневой элемент в разметке, но который Автоформирование обширную инфраструктуру в скомпилированном логическом дереве (такие как <ph id="ph1">&lt;see cref="T:System.Windows.Controls.Page" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.OnVisualParentChanged(System.Windows.DependencyObject)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Windows.Window" /&gt;</ph> and <ph id="ph2">&lt;see cref="T:System.Windows.Controls.Page" /&gt;</ph> implementations deliberately seal the method.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Windows.Window" /&gt;</ph> И <ph id="ph2">&lt;see cref="T:System.Windows.Controls.Page" /&gt;</ph> реализации намеренно запечатать метод.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.OverridesDefaultStyle">
          <source>Gets or sets a value that indicates whether this element incorporates style properties from theme styles.</source>
          <target state="translated">Получение или установка значения, определяющего использование в элементе свойств стиля, заданных в стилях темы.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.OverridesDefaultStyle">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this element does not use theme style properties; all style-originating properties come from local application styles, and theme style properties do not apply.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если этот элемент не использует свойства стиля темы; все свойства, определяющие стиль, получаются из локальных стилей приложения, а свойства стиля темы не применяются.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.OverridesDefaultStyle">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if application styles apply first, and then theme styles apply for properties that were not specifically set in application styles.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="false" /&gt;</ph>, если сначала применяются стили приложения, а затем стили тем для свойств, которые не были явным образом заданы в стилях приложения.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.OverridesDefaultStyle">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию: <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.OverridesDefaultStyle">
          <source>The most common usage of this property is an indirect usage within the setter of a style that is supplying a themed style.</source>
          <target state="translated">Наиболее распространенное использование этого свойства является непрямое использование в переключателе стиля, который передает тематический стиль.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.OverridesDefaultStyle">
          <source>If you set <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A&gt;</ph> to <ph id="ph2">`true`</ph> on a control, you will be suppressing the default control template supplied by the theme styles.</source>
          <target state="translated">Если задать <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.OverridesDefaultStyle%2A&gt;</ph> для <ph id="ph2">`true`</ph> элемента управления будет подавление шаблон элемента управления по умолчанию, предоставляемые тематических стилей.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.OverridesDefaultStyle">
          <source>That control template typically includes the content presenter and other composited elements that provide basic <ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph> functionality and visualization for the control.</source>
          <target state="translated">Этот шаблон элемента управления обычно включает средство презентации содержимого и другие составные элементы, обеспечивающие основные <ph id="ph1">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph> функциональные возможности и визуализации для элемента управления.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.OverridesDefaultStyle">
          <source>If you want the control to continue to support the same features as the default theme styles, you must supply an alternate style with a control template that replicates the same structure.</source>
          <target state="translated">Если требуется установить элемент управления для поддержки тех же компонентов тематических стилей по умолчанию, вы должны предоставить альтернативный стиль с шаблоном элемента управления, которое реплицирует ту же структуру.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.OverridesDefaultStyle">
          <source>For more information, see <bpt id="p1">[</bpt>Control Authoring Overview<ept id="p1">](~/docs/framework/wpf/controls/control-authoring-overview.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Общие сведения о разработке элементов управления<ept id="p1">](~/docs/framework/wpf/controls/control-authoring-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.OverridesDefaultStyle">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.OverridesDefaultStyle">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.OverridesDefaultStyle">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.OverridesDefaultStyleProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.OverridesDefaultStyle" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.Parent">
          <source>Gets the logical parent  element of this element.</source>
          <target state="translated">Получает логический родительский элемент этого элемента.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Parent">
          <source>This element's logical parent.</source>
          <target state="translated">Логический родительский объект этого элемента.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Parent">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Parent%2A&gt;</ph> may be <ph id="ph2">`null`</ph> in cases where an element was instantiated, but is not attached to any logical tree that eventually connects to the page level root element, or the application object.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Parent%2A&gt;</ph> может быть <ph id="ph2">`null`</ph> в случаях, где был создан экземпляр элемента, но не подключен к логическому дереву, в конечном итоге подключается к уровня корневого элемента страницы или объекта приложения.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Parent">
          <source>Note that the logical parent of an element can potentially change depending on your application's functionality, and keeping the value of this property will not reflect that change.</source>
          <target state="translated">Обратите внимание, что логический родительский элемент может измениться в зависимости от функциональности приложения, и сохранение значения этого свойства не отражает такое изменение.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Parent">
          <source>You typically should get the value immediately before you need it.</source>
          <target state="translated">Обычно следует получать значение, непосредственно перед он нужен.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Parent">
          <source>See <bpt id="p1">[</bpt>Trees in WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept> for more information about logical tree  traversal, and the scenarios where using  <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Parent%2A&gt;</ph> as a technique of parent element discovery is appropriate.</source>
          <target state="translated">В разделе <bpt id="p1">[</bpt>деревьев в WPF<ept id="p1">](~/docs/framework/wpf/advanced/trees-in-wpf.md)</ept> случаях и Дополнительные сведения о логическом дереве обхода там, где с помощью <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Parent%2A&gt;</ph> как способ родительского элемента подходит обнаружения.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Parent">
          <source>The property engine will potentially recalculate all property values of an element when it is reparented, because some properties inherit values through the logical tree.</source>
          <target state="translated">Механизм свойств потенциально пересчитает все значения свойств элемента при изменении его родителя, так как некоторые свойства наследуют значения через логическое дерево.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Parent">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> that applies for bindings can also change when elements are reparented.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.DataContext%2A&gt;</ph> , Применяемый для привязки также можно изменить при изменении элементов родителя.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Parent">
          <source>Changing an element's parent is typically only done through manipulation of collections, by using dedicated add or remove methods, or through setting content properties of elements.</source>
          <target state="translated">Изменение родителя элемента обычно выполняется только через управление коллекциями, с использованием выделенных методов добавления и удаления, или путем задания свойств содержимого элементов.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Parent">
          <source>The most typical scenario for using the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Parent%2A&gt;</ph> property is to obtain a reference and then get various <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> property values from the parent.</source>
          <target state="translated">Наиболее типичный сценарий использования <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Parent%2A&gt;</ph> свойство является получить ссылку, а затем получить различные <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> значения свойств из родительского элемента.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Parent">
          <source>For templates, the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Parent%2A&gt;</ph> of the template eventually will be <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Для шаблонов <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Parent%2A&gt;</ph> шаблона в конечном итоге будет <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Parent">
          <source>To get past this point and extend into the logical tree where the template is actually applied, use <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.TemplatedParent%2A&gt;</ph>.</source>
          <target state="translated">Чтобы получить на этом этапе и расширить в логическом дереве, где фактически применяется шаблон, используйте <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.TemplatedParent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Parent">
          <source>Note that this property does not report visual tree parents in cases where these vary from the logical tree parents.</source>
          <target state="translated">Обратите внимание, что это свойство не сообщает о родительских элементов визуального дерева в случаях, когда они отличаются от родителей логического дерева.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Parent">
          <source>Visual tree parents are not typically important for general application cases but may be the desired parent elements for certain visual level cases.</source>
          <target state="translated">Родители визуального дерева обычно не важны в общих случаях приложений, но может быть целевыми родительскими элементами в некоторых случаях визуального уровня.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Parent">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph>.</source>
          <target state="translated">См. раздел <ph id="ph1">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Parent">
          <source>The following example shows code that checks for an element's parent, and then uses property values from the parent to set properties on the child element to match.</source>
          <target state="translated">В примере показан код, который проверяет наличие родительский элемент, а затем использует значения свойств из родительского элемента для задания свойств для дочернего элемента для сопоставления.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Parent">
          <source>In this case these are properties that affect the rendering size.</source>
          <target state="translated">В этом случае это свойства, которые влияют на размер отрисовки.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)">
          <source>The child element reporting the change.</source>
          <target state="translated">Дочерний элемент, сообщающий об изменении.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)">
          <source>Supports incremental layout implementations in specialized subclasses of <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph>.</source>
          <target state="translated">Поддерживает добавочные реализации структуры в специализированных подклассах <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)">
          <source><ph id="ph1">&lt;see cref="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" /&gt;</ph> is invoked when a child element has invalidated a property that is marked in metadata as affecting the parent's measure or arrange passes during layout.</source>
          <target state="translated">Метод <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)" /&gt;</ph> вызывается, когда дочерний элемент делает недействительным свойство, помеченное в метаданных как влияющее на проходы измерения или компоновки родительского элемента во время структурирования.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)">
          <source>If this element has a child element on which some property was invalidated and the property was marked as <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> in property metadata during registration, this method is invoked.</source>
          <target state="translated">Если этот элемент содержит дочерний элемент, на котором был объявлен недействительным, некоторые свойства, а свойство был помечен как <ph id="ph1">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A&gt;</ph> или <ph id="ph2">&lt;xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A&gt;</ph> свойства метаданных во время регистрации, этот метод вызывается.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)">
          <source>The method invocation notifies the parent element which particular child element must be re-measured if this element supports partial (incremental) update of layout.</source>
          <target state="translated">Вызов метода уведомляет родительский элемент, конкретный дочерний элемент которого необходимо подвергнуть повторному измерению, если этот элемент поддерживает частичное (добавочное) обновление макета.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)">
          <source>By default, <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> does not support incremental layout, and in the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> class this method has no default implementation.</source>
          <target state="translated">По умолчанию <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> не поддерживает последовательный макет и в <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> класса этот метод, у которого нет реализации по умолчанию.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)">
          <source>The scenario where overriding this method would be necessary is not common, because it requires you to modify the default layout system behavior.</source>
          <target state="translated">Сценарий, в котором было бы необходимо переопределение этого метода не так часто, поскольку для нее требуется возможность изменять поведение системы макета по умолчанию.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)">
          <source>An example implementation scenario might be if a class had type limitations for possible child elements that are significantly more restrictive than the WPF framework-level layout system.</source>
          <target state="translated">Пример сценария реализации может быть Если класс ограничения на тип возможных дочерних элементов, значительно более строгим, чем система макета уровня платформы WPF.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)">
          <source>Because of the nature of these custom elements, property changes could be deliberately deferred when you implement some custom layout behavior.</source>
          <target state="translated">Из-за особенностей данных пользовательских элементов изменения свойств могут быть намеренно отложены при реализации особого поведения структуры.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.ParentLayoutInvalidated(System.Windows.UIElement)">
          <source>For instance, measure/arrange method overrides, which try to optimize the child element render pass, could be deferred for certain types of changes that would ordinarily result in another layout pass.</source>
          <target state="translated">Например измерения или компоновки переопределения методов, которые пытаются оптимизировать дочерний элемент прохода отрисовки, могут быть отложены для некоторых типов изменений, которые обычно приводят к проходу структуры.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>The direction for which a prospective focus change should be determined.</source>
          <target state="translated">Направление, в котором следует определить перспективное изменение фокуса.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>Determines the next element that would receive focus relative to this element for a provided focus movement direction, but does not actually move the focus.</source>
          <target state="translated">Определяет следующий элемент, который получит фокус, относительно данного элемента для указанного направления движения фокуса, но реально фокус не перемещает.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>The next element that focus would move to if focus were actually traversed.</source>
          <target state="translated">Следующий элемент, на который будет перемещен фокус в случае фактического обхода фокуса.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>May return <ph id="ph1">&lt;see langword="null" /&gt;</ph> if focus cannot be moved relative to this element for the provided direction.</source>
          <target state="translated">Может возвращать значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>, если фокус нельзя переместить относительно данного элемента в указанном направлении.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MoveFocus%2A&gt;</ph> is the related method that actually does move focus.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MoveFocus%2A&gt;</ph> имеет связанный метод, который фактически перемещения фокуса.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>The following example implements a handler that handles several possible button inputs, each button representing a possible <ph id="ph1">&lt;xref:System.Windows.Input.FocusNavigationDirection&gt;</ph>.</source>
          <target state="translated">В следующем примере реализуется обработчик, который обрабатывает несколько возможных вводов кнопок, каждая кнопка представляет возможного <ph id="ph1">&lt;xref:System.Windows.Input.FocusNavigationDirection&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>The handler tracks the element with current keyboard focus, and calls <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.PredictFocus%2A&gt;</ph> on that element, and specifies the appropriate <ph id="ph2">&lt;xref:System.Windows.Input.FocusNavigationDirection&gt;</ph> as initialization for the <ph id="ph3">&lt;xref:System.Windows.Input.TraversalRequest&gt;</ph> type parameter provided.</source>
          <target state="translated">Обработчик отслеживает элемента с текущей фокус клавиатуры и вызовы <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.PredictFocus%2A&gt;</ph> на этот элемент и задает соответствующий <ph id="ph2">&lt;xref:System.Windows.Input.FocusNavigationDirection&gt;</ph> для инициализации <ph id="ph3">&lt;xref:System.Windows.Input.TraversalRequest&gt;</ph> введите указанный параметр.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>Instead of moving to that element as <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MoveFocus%2A&gt;</ph> would do, the handler changes the physical dimensions of the predicted focus destination for visualization purposes.</source>
          <target state="translated">Вместо перемещения на этот элемент как <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MoveFocus%2A&gt;</ph> делаете, обработчик изменяет размеры назначения прогнозируемое фокус в целях визуализации.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>Specified one of the following directions in the <ph id="ph1">&lt;see cref="T:System.Windows.Input.TraversalRequest" /&gt;</ph>: <ph id="ph2">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Next" /&gt;</ph>, <ph id="ph3">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" /&gt;</ph>, <ph id="ph4">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.First" /&gt;</ph>, <ph id="ph5">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Last" /&gt;</ph>.</source>
          <target state="translated">Одно из следующих направлений, указанное в <ph id="ph1">&lt;see cref="T:System.Windows.Input.TraversalRequest" /&gt;</ph>: <ph id="ph2">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Next" /&gt;</ph>, <ph id="ph3">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Previous" /&gt;</ph>, <ph id="ph4">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.First" /&gt;</ph>, <ph id="ph5">&lt;see cref="F:System.Windows.Input.FocusNavigationDirection.Last" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)">
          <source>These directions are not legal for <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /&gt;</ph> (but they are legal for <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" /&gt;</ph>).</source>
          <target state="translated">Эти направления недопустимы для метода <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkElement.PredictFocus(System.Windows.Input.FocusNavigationDirection)" /&gt;</ph> (однако допустимы для метода <ph id="ph2">&lt;see cref="M:System.Windows.FrameworkElement.MoveFocus(System.Windows.Input.TraversalRequest)" /&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)">
          <source>Name to use for the specified name-object mapping.</source>
          <target state="translated">Имя, используемое для сопоставления указанного имени с объектом.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)">
          <source>Object for the mapping.</source>
          <target state="translated">Объект для сопоставления.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)">
          <source>Provides an accessor that simplifies access to the <ph id="ph1">&lt;see cref="T:System.Windows.NameScope" /&gt;</ph> registration method.</source>
          <target state="translated">Предоставляет метод доступа, упрощающий доступ к методу регистрации <ph id="ph1">&lt;see cref="T:System.Windows.NameScope" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)">
          <source>This method is a convenience method for calling <ph id="ph1">&lt;xref:System.Windows.NameScope.RegisterName%2A&gt;</ph>.</source>
          <target state="translated">Этот метод является самым удобным для вызова <ph id="ph1">&lt;xref:System.Windows.NameScope.RegisterName%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)">
          <source>The implementation will check successive parent elements until it finds the applicable <ph id="ph1">&lt;xref:System.Windows.NameScope&gt;</ph> implementation, which is found by finding an element that implements <ph id="ph2">&lt;xref:System.Windows.Markup.INameScope&gt;</ph>.</source>
          <target state="translated">Реализация будет проверять последовательных родительских элементов, пока не найдет применимый <ph id="ph1">&lt;xref:System.Windows.NameScope&gt;</ph> реализации, в которой находится с помощью поиск элемента, который реализует <ph id="ph2">&lt;xref:System.Windows.Markup.INameScope&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)">
          <source>For more information about namescopes, see <bpt id="p1">[</bpt>WPF XAML Namescopes<ept id="p1">](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об области видимости имен см. в разделе <bpt id="p1">[</bpt>области имен XAML WPF<ept id="p1">](~/docs/framework/wpf/advanced/wpf-xaml-namescopes.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)">
          <source>Calling <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.RegisterName%2A&gt;</ph> is necessary in order to correctly hook up animation storyboards for applications when created in code.</source>
          <target state="translated">Вызов <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.RegisterName%2A&gt;</ph> необходим, чтобы правильно подключать анимации раскадровки для приложений, созданных в коде.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)">
          <source>This is because one of the key storyboard properties, <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard.TargetName%2A&gt;</ph>, uses a run-time name lookup instead of being able to take a reference to a target element.</source>
          <target state="translated">Это вызвано одно из ключевых раскадровки свойства, <ph id="ph1">&lt;xref:System.Windows.Media.Animation.Storyboard.TargetName%2A&gt;</ph>, выполняет поиск имени во время выполнения не предоставляется возможность указать ссылку на целевой элемент.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)">
          <source>This is true even if that element is accessible by reference from the code.</source>
          <target state="translated">Это верно, даже если этому элементу осуществляется по ссылке из кода.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.RegisterName(System.String,System.Object)">
          <source>For more information on why you need to register names for storyboard targets, see <bpt id="p1">[</bpt>Storyboards Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о том, почему необходимо зарегистрировать имена целей раскадровки см. в разделе <bpt id="p1">[</bpt>Общие<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)">
          <source>The element to remove.</source>
          <target state="translated">Подлежащий удалению элемент.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)">
          <source>Removes the provided object from this element's logical tree.</source>
          <target state="translated">Удаляет предоставленный объект из логического дерева этого элемента.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)">
          <source><ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> updates the affected logical tree parent pointers to keep in sync with this deletion.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> обновляет затронутые указатели родительских элементов в логическом дереве для поддержания синхронизации с данным удалением.</target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)">
          <source>Use this method for the implementation of collections on objects that represent logical children of an element.</source>
          <target state="translated">Этот метод используется для реализации коллекции объектов, представляющих логических дочерних элементов элемента.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)">
          <source>This might be done in property getters or setters, class handlers of <ph id="ph1">`Changed`</ph> events, constructors, or within the collection types themselves.</source>
          <target state="translated">Это можно сделать в методы получения свойств или методов задания, обработчиков класса <ph id="ph1">`Changed`</ph> события, конструкторы, или в коллекции типов сами.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)">
          <source>For control authors, manipulating the logical tree at this level is not the recommended practice, unless none of the provided base control class' content models are appropriate.</source>
          <target state="translated">Для разработчиков элементов управления обработка логического дерева на этом уровне не рекомендуется, если не подходит ни одна из моделей содержимого, предоставленный базового класса элемента управления.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)">
          <source>Consider subclassing at the level of <ph id="ph1">&lt;xref:System.Windows.Controls.ContentControl&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph>, and <ph id="ph3">&lt;xref:System.Windows.Controls.HeaderedItemsControl&gt;</ph>.</source>
          <target state="translated">Рассмотрите возможность создания подкласса на уровне <ph id="ph1">&lt;xref:System.Windows.Controls.ContentControl&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.Controls.ItemsControl&gt;</ph>, и <ph id="ph3">&lt;xref:System.Windows.Controls.HeaderedItemsControl&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)">
          <source>These classes provide a content model with particular enforcement of logical children through dedicated <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph>, as well as support for other features typically desirable in a <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> control such as styling through templates.</source>
          <target state="translated">Эти классы обеспечивают модель содержимого с конкретной реализацией средствами логических дочерних через выделенное <ph id="ph1">[!INCLUDE[TLA2#tla_api#plural](~/includes/tla2sharptla-apisharpplural-md.md)]</ph>, а также поддержку для других функций, как правило, желательно в <ph id="ph2">[!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)]</ph> управления, например стилей с помощью шаблонов.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)">
          <source>The following example implements a <ph id="ph1">`Child`</ph> property on a custom <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> that does its own visual layer implementation.</source>
          <target state="translated">В следующем примере реализуется <ph id="ph1">`Child`</ph> свойство в пользовательском <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> , который выполняет собственную реализацию визуального уровня.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)">
          <source>The property's setter is designed so that if the value changes, the old value is removed from the logical tree, as well as a class-specific visual collection.</source>
          <target state="translated">Метод задания свойства разработан, чтобы при изменении значения старое значение удаляется из логического дерева, а также коллекцию визуальных элементов данного класса.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.RemoveLogicalChild(System.Object)">
          <source>The values are cached, and then the new value is added to both the standard WPF framework level logical tree and the custom visual collection.</source>
          <target state="translated">Значения кэшируются, а затем новое значение добавляется стандартная WPF framework уровня логического дерева и коллекция пользовательских визуальных элементов.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkElement.RequestBringIntoView">
          <source>Occurs when <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" /&gt;</ph> is called on this element.</source>
          <target state="translated">Происходит при вызове метода <ph id="ph1">&lt;see cref="M:System.Windows.FrameworkElement.BringIntoView(System.Windows.Rect)" /&gt;</ph> в данном элементе.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.RequestBringIntoView">
          <source>This event indicates to a parent <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph> (or derived class) that the element that raises the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView&gt;</ph> event should be made visible within the scrollable region.</source>
          <target state="translated">Это событие показывает, к родительскому элементу <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph> (или производный класс), на элемент, который вызывает <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView&gt;</ph> событий следует сделать видимой в пределах области прокрутки.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.RequestBringIntoView">
          <source>The <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph> will then mark the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView&gt;</ph> event as handled, by using class handling of the event.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph> Затем будут отмечены как <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView&gt;</ph> событие как обработанное с помощью класса обработки события.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.RequestBringIntoView">
          <source>In general <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView&gt;</ph> event data should not be marked handled by any class that does control a scrolling region, or by any instance handler, because doing so would interfere with the intended goal of the element that called <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.BringIntoView%2A&gt;</ph>.</source>
          <target state="translated">В целом <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView&gt;</ph> события, данные не следует помечать обработанное классом, который управляет области прокрутки или каким-либо экземпляр обработчика, так как это может повлиять на целью элемента, который называется <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.BringIntoView%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.RequestBringIntoView">
          <source>Routed Event Information</source>
          <target state="translated">Сведения о маршрутизируемом событии</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.RequestBringIntoView">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.RequestBringIntoView">
          <source>Routing strategy</source>
          <target state="translated">Стратегия маршрутизации</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.RequestBringIntoView">
          <source>Bubbling</source>
          <target state="translated">Вверх</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.RequestBringIntoView">
          <source>Delegate</source>
          <target state="translated">делегат</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.RequestBringIntoViewEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /&gt;</ph> routed event.</source>
          <target state="translated">Идентифицирует направленное событие <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.Resources">
          <source>Gets or sets the locally-defined resource dictionary.</source>
          <target state="translated">Получает или задает локально определенный словарь ресурсов.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Resources">
          <source>The current locally-defined dictionary of resources, where each resource can be accessed by key.</source>
          <target state="translated">Текущий локально определенный словарь ресурсов, где доступ к каждому ресурсу может осуществляться по ключу.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Resources">
          <source>Resource dictionaries that can be defined completely or partially in <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> are typically created as a property element, and are typically on the root element for any individual page or for the application.</source>
          <target state="translated">Словари ресурсов, которые могут быть определены полностью или частично в <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> обычно создаются как элемент свойства и обычно представляют собой в корневом элементе любой отдельной страницы или приложения.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Resources">
          <source>Placing the resource dictionary at this level makes it easier to find from individual child elements in the page (or from any page, in the application case).</source>
          <target state="translated">Размещение словаря ресурсов на этом уровне облегчает поиск из отдельных дочерних элементов на странице (или на любой странице, в случае приложения).</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Resources">
          <source>In most application scenarios, we recommend that styles be defined as object elements within a resource dictionary, or be defined as external resources so that the entire style resource can be self-contained (this approach helps separate designer responsibilities from developer responsibilities by separating the physical files that need to be edited).</source>
          <target state="translated">В большинстве сценариев приложений, рекомендуется определить эти стили как элементы-объекты в словаре ресурсов или как внешние ресурсы, чтобы весь ресурс стиля мог быть автономным (этот подход помогает отдельный конструктор Ответственность от ответственности разработчика путем разделения физических файлов, которые нужно редактировать).</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Resources">
          <source>Note that this property returns only the resource dictionary declared directly within that element.</source>
          <target state="translated">Обратите внимание, что это свойство возвращает только словарь ресурсов, объявленный непосредственно внутри этого элемента.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Resources">
          <source>This is different than the actual resource lookup process, where a child element can access any of the resources defined in each parent element, searching recursively upwards.</source>
          <target state="translated">Это отличается от фактического процесса поиска ресурсов, где дочерний элемент можно использовать все ресурсы, определенные в каждом родительском элементе, выполняя рекурсивный восходящий поиск.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Resources">
          <source>Resources can also be referenced by code from within the collection, but be aware that resources created in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> will definitely not be accessible until after <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Loaded&gt;</ph> is raised by the element that declares the dictionary.</source>
          <target state="translated">Ресурсы также могут ссылаться с помощью кода из коллекции, но имейте в виду, что ресурсы, созданные в <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> определенно будут недоступны до после <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Loaded&gt;</ph> возникает для элемента, который объявляет словаря.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Resources">
          <source>In fact, resources are parsed asynchronously and not even the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Loaded&gt;</ph> event is an assurance that you can reference a <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> defined resource.</source>
          <target state="translated">На самом деле синтаксического анализа ресурсов асинхронно и не даже <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Loaded&gt;</ph> событий является гарантией того, можно ссылаться <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> определенных ресурсов.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Resources">
          <source>For this reason you should generally only access <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> defined resources as part of run-time code, or through other <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> techniques such as styles or resource extension references for attribute values.</source>
          <target state="translated">По этой причине следует обычно только обращаться к <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> определены ресурсы в рамках кода во время выполнения, или с помощью других <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> методы, такие как ссылки на расширение ресурса для значений атрибутов или стилей.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Resources">
          <source>When you access resources through code, it is essentially equivalent to a  reference made from <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</source>
          <target state="translated">При доступе к ресурсам через код, он фактически эквивалентна ссылку из <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Resources">
          <source>The underlying <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> supports the methods required to add, remove or query resources from within the collection by using code.</source>
          <target state="translated">Базовый <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> поддерживает методы, необходимые для добавления, удаления или запроса ресурсов из коллекции с помощью кода.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Resources">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Resources%2A&gt;</ph> property is settable to support the scenario of completely replacing the resources collection of an element to be a new or different <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Resources%2A&gt;</ph> Свойства можно настроить для поддержки полной замены коллекции ресурсов элемента как новый или другой сценарий <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Resources">
          <source>Notice that the <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> syntax shown does not include an element for the <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">Обратите внимание, что <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> синтаксис, показанный отсутствует элемент для <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Resources">
          <source>This is an example of implicit collection syntax; a tag representing the collection element can be omitted.</source>
          <target state="translated">Это пример неявного синтаксиса коллекции; можно опустить тег представляет элемент коллекции.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Resources">
          <source>The elements that are added as items to the collection are specified instead.</source>
          <target state="translated">Вместо этого указаны элементы, которые будут добавлены как элементы в коллекцию.</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Resources">
          <source>For more information about implicit collections and <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, see <bpt id="p1">[</bpt>XAML Syntax In Detail<ept id="p1">](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)</ept>.</source>
          <target state="translated">Дополнительные сведения о неявных коллекциях и <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, в разделе <bpt id="p1">[</bpt>XAML Syntax In Detail<ept id="p1">](~/docs/framework/wpf/advanced/xaml-syntax-in-detail.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Resources">
          <source>One case where a <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> is still specified explicitly as an element is if you are introducing a merged dictionary, in which case there are typically no child elements for that <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">Один вариант где <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> по-прежнему задается явным образом как элемент есть ли вы ввели объединенный словарь, в этом случае обычно нет дочерних элементов для этого <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Resources">
          <source>For details, see <bpt id="p1">[</bpt>Merged Resource Dictionaries<ept id="p1">](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>слияние словари ресурсов<ept id="p1">](~/docs/framework/wpf/advanced/merged-resource-dictionaries.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Resources">
          <source>XAML Property Element Usage</source>
          <target state="translated">Использование элемента свойства XAML</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Resources">
          <source>XAML Values</source>
          <target state="translated">Значения XAML</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Resources">
          <source><bpt id="p1">*</bpt>oneOrMoreResourceElements<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>oneOrMoreResourceElements<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Resources">
          <source>One or more object elements, each of which defines a resource.</source>
          <target state="translated">Один или несколько объектов элементов, каждый из которых определяет ресурс.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Resources">
          <source>Each resource property element within each <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> must have a unique value for the <bpt id="p1">[</bpt>x:Key Directive<ept id="p1">](~/docs/framework/xaml-services/x-key-directive.md)</ept>, which serves as the unique key when values are retrieved from the <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">Каждого элемента property ресурсов в каждом <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph> должен иметь уникальное значение для <bpt id="p1">[</bpt>директива x: Key<ept id="p1">](~/docs/framework/xaml-services/x-key-directive.md)</ept>, который используется в качестве уникального ключа при извлечении значений из <ph id="ph2">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" uid="T:System.Windows.FrameworkElement">
          <source>Attaches a binding to this element for the specified dependency property.</source>
          <target state="translated">Присоединяет привязку к этому элементу для указанного свойства зависимостей.</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>Identifies the destination property where the binding should be established.</source>
          <target state="translated">Идентифицирует свойство назначения, к которому следует установить привязку.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>The source property name or the path to the property used for the binding.</source>
          <target state="translated">Имя исходного свойства или путь к свойству, используемому для привязки.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>Attaches a binding to this element, based on the provided source property name as a path qualification to the data source.</source>
          <target state="translated">Прикрепляет привязку к данному элементу на основе указанного имени исходного свойства в виде классификационного пути к источнику данных.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>Records the conditions of the binding.</source>
          <target state="translated">Фиксирует состояния привязки.</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>This return value can be useful for error checking.</source>
          <target state="translated">Это возвращаемое значение можно использовать для проверки ошибок.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>This method is a convenience method for calling <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType&gt;</ph>, which passes the current instance as the <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>, and creates a new <ph id="ph3">&lt;xref:System.Windows.Data.Binding&gt;</ph> based on the provided <ph id="ph4">`path`</ph> parameter.</source>
          <target state="translated">Этот метод является самым удобным для вызова <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType&gt;</ph>, который передает текущего экземпляра в качестве <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>и создает новый <ph id="ph3">&lt;xref:System.Windows.Data.Binding&gt;</ph> на основе предоставленной <ph id="ph4">`path`</ph> параметра.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>This signature is more convenient if you are establishing a simple default binding.</source>
          <target state="translated">Эта подпись является более удобным в том случае, если устанавливается простой привязки по умолчанию.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>If you need to specify any binding properties to non-default conditions, or want to use a <ph id="ph1">&lt;xref:System.Windows.Data.MultiBinding&gt;</ph> or <ph id="ph2">&lt;xref:System.Windows.Data.PriorityBinding&gt;</ph>,you should use the <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29&gt;</ph> signature.</source>
          <target state="translated">Если вам нужно указать любые свойства привязки для нестандартных условий, или использовать <ph id="ph1">&lt;xref:System.Windows.Data.MultiBinding&gt;</ph> или <ph id="ph2">&lt;xref:System.Windows.Data.PriorityBinding&gt;</ph>, следует использовать <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.SetBinding%28System.Windows.DependencyProperty%2CSystem.Windows.Data.BindingBase%29&gt;</ph> подписи.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.String)">
          <source>The following example sets a binding using a specific path.</source>
          <target state="translated">В следующем примере задается привязка по определенному пути.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>Identifies the property where the binding should be established.</source>
          <target state="translated">Определяет свойство, которому следует установить привязку.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>Represents the specifics of the data binding.</source>
          <target state="translated">Представляет подробные сведения о привязки данных.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>Attaches a binding to this element, based on the provided binding object.</source>
          <target state="translated">Прикрепляет привязку к данному элементу на основе предоставленной привязки объекта.</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>Records the conditions of the binding.</source>
          <target state="translated">Фиксирует состояния привязки.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>This return value can be useful for error checking.</source>
          <target state="translated">Это возвращаемое значение можно использовать для проверки ошибок.</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.SetBinding(System.Windows.DependencyProperty,System.Windows.Data.BindingBase)">
          <source>This method is a convenience method for calling <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType&gt;</ph>, which passes the current instance as the <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>.</source>
          <target state="translated">Этот метод является самым удобным для вызова <ph id="ph1">&lt;xref:System.Windows.Data.BindingOperations.SetBinding%2A?displayProperty=nameWithType&gt;</ph>, который передает текущего экземпляра в качестве <ph id="ph2">&lt;xref:System.Windows.DependencyObject&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)">
          <source>The element that specifies a flow direction.</source>
          <target state="translated">Элемент, указывающий направление потока.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)">
          <source>A value of the enumeration, specifying the direction.</source>
          <target state="translated">Значение перечисления, указывающее направление.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)">
          <source>Sets the value of the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.FlowDirection" /&gt;</ph> attached property for the provided element.</source>
          <target state="translated">Задает значение присоединенного свойства <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.FlowDirection" /&gt;</ph> указанного элемента.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)">
          <source>This method supports attached property syntax for the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FlowDirection%2A&gt;</ph> property, therefore allowing child elements of a provided <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> to specify flow direction for the arrangement within their parent element.</source>
          <target state="translated">Этот метод поддерживает синтаксис присоединенного свойства для <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FlowDirection%2A&gt;</ph> свойство, таким образом позволяя дочерних элементов указанного <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> для указания направления потока для упорядочения в родительском элементе.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.SetFlowDirection(System.Windows.DependencyObject,System.Windows.FlowDirection)">
          <source>To set the value on the current <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, use the direct <ph id="ph2">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> accessor <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.FlowDirection%2A&gt;</ph>.</source>
          <target state="translated">Требуется задать значение в текущем <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph>, использовать прямые <ph id="ph2">[!INCLUDE[TLA#tla_clr](~/includes/tlasharptla-clr-md.md)]</ph> доступа <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.FlowDirection%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>The property to which the resource is bound.</source>
          <target state="translated">Свойство, к которому привязан ресурс.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>The name of the resource.</source>
          <target state="translated">Имя ресурса.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>Searches for a resource with the specified name and sets up a resource reference to it for the specified property.</source>
          <target state="translated">Выполняет поиск ресурса по указанному имени и устанавливает ссылку на этот ресурс для указанного свойства.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>A resource reference is similar to the use of a <bpt id="p1">[</bpt>DynamicResource Markup Extension<ept id="p1">](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)</ept> in markup.</source>
          <target state="translated">Ссылка на ресурс похож на использование <bpt id="p1">[</bpt>DynamicResource Markup Extension<ept id="p1">](~/docs/framework/wpf/advanced/dynamicresource-markup-extension.md)</ept> в разметке.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>The resource reference creates an internal expression that supplies the value of the specified property on a run-time deferred basis.</source>
          <target state="translated">Ссылка на ресурс создает внутреннее выражение, содержащий значение заданного свойства на основе отложенного выполнения.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.SetResourceReference(System.Windows.DependencyProperty,System.Object)">
          <source>The expression will be re-evaluated whenever the resource dictionary indicates a changed value through internal events, or whenever the current element is reparented (a parent change would change the dictionary lookup path).</source>
          <target state="translated">Выражение будет повторно вычисляться каждый раз, когда словарем ресурсов измененного значения через внутренние события или при изменении родителя текущего элемента (родителя изменяется путь для поиска словаря).</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.ShouldSerializeResources">
          <source>Returns whether serialization processes should serialize the contents of the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.Resources" /&gt;</ph> property.</source>
          <target state="translated">Возвращает логическое значение, указывающее, следует ли процессам сериализации сериализировать содержимое свойства <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.Resources" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.ShouldSerializeResources">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkElement.Resources" /&gt;</ph> property value should be serialized; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если значение свойства <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkElement.Resources" /&gt;</ph> подлежит сериализации, в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.ShouldSerializeResources">
          <source>This will return <ph id="ph1">`true`</ph> as long as there is at least one keyed resource in the local <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Resources%2A&gt;</ph>.</source>
          <target state="translated">Будет возвращен <ph id="ph1">`true`</ph> при условии, что имеется по крайней мере один ресурс с ключом в локальной <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Resources%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.ShouldSerializeStyle">
          <source>Returns whether serialization processes should serialize the contents of the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.Style" /&gt;</ph> property.</source>
          <target state="translated">Возвращает логическое значение, указывающее, следует ли процессам сериализации сериализировать содержимое свойства <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.Style" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.ShouldSerializeStyle">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkElement.Style" /&gt;</ph> property value should be serialized; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если значение свойства <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkElement.Style" /&gt;</ph> подлежит сериализации, в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.ShouldSerializeStyle">
          <source>This will return <ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph> is locally set.</source>
          <target state="translated">Будет возвращен <ph id="ph1">`true`</ph> Если <ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph> установлено локально.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.ShouldSerializeTriggers">
          <source>Returns whether serialization processes should serialize the contents of the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.Triggers" /&gt;</ph> property.</source>
          <target state="translated">Возвращает логическое значение, указывающее, следует ли процессам сериализации сериализировать содержимое свойства <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.Triggers" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.ShouldSerializeTriggers">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkElement.Triggers" /&gt;</ph> property value should be serialized; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если значение свойства <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkElement.Triggers" /&gt;</ph> подлежит сериализации, в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.ShouldSerializeTriggers">
          <source>This method returns <ph id="ph1">`true`</ph> if the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Triggers%2A&gt;</ph> property is locally set.</source>
          <target state="translated">Этот метод возвращает <ph id="ph1">`true`</ph> Если <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Triggers%2A&gt;</ph> свойству локально.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkElement.SizeChanged">
          <source>Occurs when either the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.ActualHeight" /&gt;</ph> or the <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkElement.ActualWidth" /&gt;</ph> properties change value on this element.</source>
          <target state="translated">Происходит при изменении значения любого из свойств <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.ActualHeight" /&gt;</ph> или <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkElement.ActualWidth" /&gt;</ph> данного элемента.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.SizeChanged">
          <source>Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</source>
          <target state="translated">События с прямой маршрутизацией не следуют по маршруту, они обрабатываются только внутри элемента, на котором они вызываются.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.SizeChanged">
          <source>Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style.</source>
          <target state="translated">Прямые перенаправленные события поддерживают другое поведение перенаправленных событий: они поддерживают коллекцию доступных обработчиков и могут использоваться как <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> в стиле.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.SizeChanged">
          <source>The layout system reads properties within the <ph id="ph1">&lt;xref:System.Windows.SizeChangedEventArgs&gt;</ph> argument class of this event, to  determine whether the reported size changes should be considered significant.</source>
          <target state="translated">Система макета считывает свойства <ph id="ph1">&lt;xref:System.Windows.SizeChangedEventArgs&gt;</ph> класс аргументов этого события, чтобы определить, является ли сообщенные изменения размера должно считаться важным.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.SizeChanged">
          <source>This allows the layout system or your control-specific layout implementations to avoid forcing a layout change due to visually imperceptible differences between old and new height or width values.</source>
          <target state="translated">Это позволяет системе структуры или реализации макет элемента управления, чтобы избежать принудительного обновления структуры из-за визуально незаметной различия между значениями старой и новой высоты или ширины.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.SizeChanged">
          <source>The imperceptible differences might be due to rounding or same-result calculations of a floating-point data types.</source>
          <target state="translated">Из-за округления или одинаковых результатов вычислений типов данных с плавающей запятой может быть незаметным различия.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.SizeChanged">
          <source>Routed Event Information</source>
          <target state="translated">Сведения о маршрутизируемом событии</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.SizeChanged">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.SizeChanged">
          <source>Routing strategy</source>
          <target state="translated">Стратегия маршрутизации</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.SizeChanged">
          <source>Direct</source>
          <target state="translated">Direct</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.SizeChanged">
          <source>Delegate</source>
          <target state="translated">делегат</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.SizeChangedEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.SizeChanged" /&gt;</ph> routed event.</source>
          <target state="translated">Идентифицирует направленное событие <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.SizeChanged" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.SizeChangedEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Идентификаторы перенаправленных событий создаются при их регистрации.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.SizeChangedEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.SizeChangedEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Эти идентификаторы можно использовать для добавления обработчиков классов.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.SizeChangedEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.SizeChangedEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkElement.SourceUpdated">
          <source>Occurs when the source value changes for any existing property binding on this element.</source>
          <target state="translated">Происходит при изменении исходного значения любого существующего свойства, привязанного к данному элементу.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.SourceUpdated">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Data.Binding.SourceUpdated&gt;</ph> event that is raised by any <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> associated with this element.</source>
          <target state="translated">Это событие создается псевдоним для <ph id="ph1">&lt;xref:System.Windows.Data.Binding.SourceUpdated&gt;</ph> событие, возникающее по любому <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> связанные с данным элементом.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.SourceUpdated">
          <source>XAML Attribute Usage</source>
          <target state="translated">Использование атрибута XAML</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.Style">
          <source>Gets or sets the style used by this element when it is rendered.</source>
          <target state="translated">Получает или задает стиль, который должен использоваться этим элементом при его отрисовке.</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>The applied, nondefault style for the element, if present.</source>
          <target state="translated">Примененный стиль не по умолчанию для элемента, если присутствует.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>Otherwise, <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">В противном случае — значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>The default for a default-constructed <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию для созданного по умолчанию объекта <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph> — <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>For controls, the current style is often provided by a default style from control theming, or from styles generally applied to controls of that type by resources at page or application level (an implicit style).</source>
          <target state="translated">Для элементов управления текущий стиль часто предоставляемые стиль по умолчанию из темы элементов управления или из стилей обычно применяется к элементам управления этого типа ресурсами на уровне страницы или приложения (неявный стиль).</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>This property does not set or return default (theme) styles, but it does return either an implicit style or an explicit style that is acting on the element.</source>
          <target state="translated">Данное свойство не устанавливает и не возвращает по умолчанию стили (тема), но возвращает неявный стиль или явный стиль, действующий на элемент.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>In the case of implicit or explicit styles, it does not matter whether the style is specified as a resource or defined locally.</source>
          <target state="translated">В случае неявных или явных стилей не проверяются ли стиль указан в качестве ресурса или определен локально.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>Setting the styles has some restrictions.</source>
          <target state="translated">Задание стилей имеет некоторые ограничения.</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>You can reset the entire <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Style%2A&gt;</ph> property to a new <ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph> at any time, which will force a layout recomposition.</source>
          <target state="translated">Вы можете сбросить всего <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Style%2A&gt;</ph> для нового <ph id="ph2">&lt;xref:System.Windows.Style&gt;</ph> в любое время, который выполняет принудительное рекомпозиции макета.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>However, as soon as that style is placed in use by a loaded element, the <ph id="ph1">&lt;xref:System.Windows.Style&gt;</ph> should be considered sealed.</source>
          <target state="translated">Тем не менее, как можно раньше этим стилем помещается используется загруженным элементом <ph id="ph1">&lt;xref:System.Windows.Style&gt;</ph> следует учитывать sealed.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>Attempting to make a change to any individual property of an in-use style (such as anything within the collection of <ph id="ph1">&lt;xref:System.Windows.Style.Setters%2A&gt;</ph>) causes an exception to be thrown.</source>
          <target state="translated">Попытка внести изменение любое отдельное свойство для используемого стиля (такие как что-либо из коллекции <ph id="ph1">&lt;xref:System.Windows.Style.Setters%2A&gt;</ph>) приводит к созданию исключения.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>A style that is defined in markup is considered to be in use as soon as it is loaded from a resource dictionary (for resources), or the page it is contained within is loaded (for inline styles).</source>
          <target state="translated">Стиль, определенный в разметке считается используется сразу после ее загрузки из словаря ресурсов (для ресурсов) или загрузки страницы, в которой он содержится в (для встроенные стили).</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Style%2A&gt;</ph> is a dependency property with special precedence.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Style%2A&gt;</ph> — Это свойство зависимостей с специальные приоритетом.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>The locally set style generally operates at the highest precedence in the property system.</source>
          <target state="translated">Локально заданное стиль обычно действует с более высоким приоритетом в системе свойств.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>If the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Style%2A&gt;</ph> is null at this point, during loading the property system checks for implicit styles in local or application resources that specify that type.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Style%2A&gt;</ph> имеет значение null в этот момент во время загрузки в системе свойств проверяет наличие неявных стилей в ресурсах локального или приложения, которые указания этого типа.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>If the style is still null after this step, then the acting style for presentation purposes generally comes from the default (theme) style, but the default style is not returned in the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Style%2A&gt;</ph> property value.</source>
          <target state="translated">Если стиль равен null после выполнения этого шага, то действующий стиль для целей презентации обычно поступает из стиля по умолчанию (тема), но стиль по умолчанию не возвращается в <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Style%2A&gt;</ph> значение свойства.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>See <bpt id="p1">[</bpt>Dependency Property Value Precedence<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept> or <bpt id="p2">[</bpt>Styling and Templating<ept id="p2">](~/docs/framework/wpf/controls/styling-and-templating.md)</ept>.</source>
          <target state="translated">В разделе <bpt id="p1">[</bpt>приоритет значения свойства зависимости<ept id="p1">](~/docs/framework/wpf/advanced/dependency-property-value-precedence.md)</ept> или <bpt id="p2">[</bpt>Стилизация и использование шаблонов<ept id="p2">](~/docs/framework/wpf/controls/styling-and-templating.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>XAML Attribute Usage</source>
          <target state="translated">Использование атрибута XAML</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>XAML Property Element Usage</source>
          <target state="translated">Использование элемента свойства XAML</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>XAML Values</source>
          <target state="translated">Значения XAML</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>resourceExtension<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>One of the following: , or .</source>
          <target state="translated">Одно из следующих:, или.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>See <bpt id="p1">[</bpt>XAML Resources<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</source>
          <target state="translated">В разделе <bpt id="p1">[</bpt>ресурсов XAML<ept id="p1">](~/docs/framework/wpf/advanced/xaml-resources.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source><bpt id="p1">*</bpt>styleResourceKey<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>styleResourceKey<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>The key that identifies the style being requested.</source>
          <target state="translated">Ключ, идентифицирующий запрашиваемый стиль.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>The key refers to an existing resource in a <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</source>
          <target state="translated">Ключ ссылается на существующий ресурс в <ph id="ph1">&lt;xref:System.Windows.ResourceDictionary&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>Property element syntax is technically possible, but not recommended for most style scenarios.</source>
          <target state="translated">Синтаксис элемента свойства технически возможно, но не рекомендуется для большинства сценариев стилей.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>See <bpt id="p1">[</bpt>Inline Styles and Templates<ept id="p1">](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)</ept>.</source>
          <target state="translated">В разделе <bpt id="p1">[</bpt>встроенные стили и шаблоны<ept id="p1">](~/docs/framework/wpf/advanced/inline-styles-and-templates.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>A binding reference using  or <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> is also possible, but uncommon.</source>
          <target state="translated">Ссылка привязки с помощью или <ph id="ph1">&lt;xref:System.Windows.Data.Binding&gt;</ph> также является, возможно, но встречается редко.</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Style">
          <source>The following example defines a style in a resource dictionary.</source>
          <target state="translated">В следующем примере определяется стиль в словаре ресурсов.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.StyleProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.Style" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.Style" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source>The name of the requested ambient property.</source>
          <target state="translated">Имя запрошенного внешнего свойства.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source>For a description of this member, see the <ph id="ph1">&lt;see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /&gt;</ph> method.</source>
          <target state="translated">Описание этого элемента содержится в методе <ph id="ph1">&lt;see cref="M:System.Windows.Markup.IQueryAmbient.IsAmbientPropertyAvailable(System.String)" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="propertyName" /&gt;</ph> is available; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если свойство с именем в параметре <ph id="ph2">&lt;paramref name="propertyName" /&gt;</ph> доступно; в противном случае — значение <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source>This member is an explicit interface member implementation.</source>
          <target state="translated">Этот член представляет собой явную реализацию члена интерфейса.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.System#Windows#Markup#IQueryAmbient#IsAmbientPropertyAvailable(System.String)">
          <source>It can be used only when the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> instance is cast to an <ph id="ph2">&lt;xref:System.Windows.Markup.IQueryAmbient&gt;</ph> interface.</source>
          <target state="translated">Он может использоваться, только если экземпляр <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> приведен к типу интерфейса <ph id="ph2">&lt;xref:System.Windows.Markup.IQueryAmbient&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.Tag">
          <source>Gets or sets an arbitrary object value that can be used to store custom information about this element.</source>
          <target state="translated">Получение или установка произвольного значения объекта, которое может использоваться для хранения особых сведений об этом элементе.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Tag">
          <source>The intended value.</source>
          <target state="translated">Целевое значение.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Tag">
          <source>This property has no default value.</source>
          <target state="translated">Это свойство не имеет значения по умолчанию.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Tag">
          <source>This property is analogous to Tag properties in other <ph id="ph1">[!INCLUDE[TLA#tla_ms](~/includes/tlasharptla-ms-md.md)]</ph> programming models, such as <ph id="ph2">[!INCLUDE[TLA#tla_vba](~/includes/tlasharptla-vba-md.md)]</ph> or <ph id="ph3">[!INCLUDE[TLA#tla_winforms](~/includes/tlasharptla-winforms-md.md)]</ph>.</source>
          <target state="translated">Это свойство является аналогом тег свойства в других <ph id="ph1">[!INCLUDE[TLA#tla_ms](~/includes/tlasharptla-ms-md.md)]</ph> моделях программирования, таких как <ph id="ph2">[!INCLUDE[TLA#tla_vba](~/includes/tlasharptla-vba-md.md)]</ph> или <ph id="ph3">[!INCLUDE[TLA#tla_winforms](~/includes/tlasharptla-winforms-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Tag">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Tag%2A&gt;</ph> is intended to provide a pre-existing property location where you can store some basic custom information about any <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> without requiring you to subclass an element.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Tag%2A&gt;</ph> предназначен для предоставления существующие свойства расположению, где можно хранить базовой пользовательской информации о каких-либо <ph id="ph2">&lt;xref:System.Windows.FrameworkElement&gt;</ph> без необходимости создать подкласс элемента.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Tag">
          <source>Because this property takes an object, you would need to use the property element usage in order to set the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Tag%2A&gt;</ph> property in <ph id="ph2">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> to anything other than an object with a known and built-in type converter, such as a string.</source>
          <target state="translated">Так как это свойство принимает объект, необходимо использовать использование элемента свойства, чтобы задать <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Tag%2A&gt;</ph> свойство в <ph id="ph2">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> только на объект с известным и встроенным преобразователя, такие как строка.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Tag">
          <source>Objects used in this manner are typically not within the standard <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> namespaces and therefore may require namespace mapping to the external namespace in order to be introduced as <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> elements.</source>
          <target state="translated">Объекты, используемые таким образом, обычно не входят в стандартные <ph id="ph1">[!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)]</ph> пространства имен и поэтому может потребоваться сопоставление пространства имен с внешним пространством имен для новых <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> элементов.</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Tag">
          <source>For details, see <bpt id="p1">[</bpt>XAML Namespaces and Namespace Mapping for WPF XAML<ept id="p1">](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)</ept> and <bpt id="p2">[</bpt>XAML and Custom Classes for WPF<ept id="p2">](~/docs/framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>пространства имен XAML и сопоставление пространства имен WPF XAML<ept id="p1">](~/docs/framework/wpf/advanced/xaml-namespaces-and-namespace-mapping-for-wpf-xaml.md)</ept> и <bpt id="p2">[</bpt>XAML и пользовательские классы для WPF<ept id="p2">](~/docs/framework/wpf/advanced/xaml-and-custom-classes-for-wpf.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Tag">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Tag">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Tag">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Tag">
          <source>None</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.TagProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.Tag" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.Tag" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkElement.TargetUpdated">
          <source>Occurs when the target value changes for any property binding on this element.</source>
          <target state="translated">Происходит при изменении целевого значения для любого свойства, привязанного к этому элементу.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.TargetUpdated">
          <source>This event creates an alias for the <ph id="ph1">&lt;xref:System.Windows.Data.Binding.TargetUpdated&gt;</ph> event that is raised by any <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> associated with this element.</source>
          <target state="translated">Это событие создается псевдоним для <ph id="ph1">&lt;xref:System.Windows.Data.Binding.TargetUpdated&gt;</ph> событие, возникающее по любому <ph id="ph2">&lt;xref:System.Windows.Data.Binding&gt;</ph> связанные с данным элементом.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.TargetUpdated">
          <source>This usually means that the binding in question is a two-way binding, and that the bound  dependency property affirms that the previous property value is now invalid according to any validation or caching scheme that the property or the data source support.</source>
          <target state="translated">Обычно это означает, что рассматриваемая является двусторонней привязкой и что свойства привязанного зависимостей подтверждает, что предыдущее значение свойства теперь является недопустимым в соответствии с любой схемой валидации или кэширования, свойство или источник данных поддерживает.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.TargetUpdated">
          <source>Use the event data of the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.TargetUpdated&gt;</ph> event to determine the specific property that is reporting the target value update.</source>
          <target state="translated">Использовать данные события из <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.TargetUpdated&gt;</ph> событий для определения нужного сообщает обновления значение целевого свойства.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.TargetUpdated">
          <source>XAML Attribute Usage</source>
          <target state="translated">Использование атрибута XAML</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.TemplatedParent">
          <source>Gets a reference to the template parent of this element.</source>
          <target state="translated">Получает ссылку на родительский объект шаблона данного элемента.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.TemplatedParent">
          <source>This property is not relevant if the element was not created through a template.</source>
          <target state="translated">Это свойство не актуально, если элемент не был создан с помощью шаблона.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.TemplatedParent">
          <source>The element whose <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkTemplate" /&gt;</ph><ph id="ph2">&lt;see cref="P:System.Windows.FrameworkTemplate.VisualTree" /&gt;</ph> caused this element to be created.</source>
          <target state="translated">Элемент, свойство <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkTemplate" /&gt;</ph> шаблона <ph id="ph2">&lt;see cref="P:System.Windows.FrameworkTemplate.VisualTree" /&gt;</ph>  которого вызвало создание данного элемента.</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.TemplatedParent">
          <source>This value is frequently <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Это значение часто равно <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.TemplatedParent">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.TemplatedParent%2A&gt;</ph> is frequently <ph id="ph2">`null`</ph> for objects that are created in your application markup or code.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.TemplatedParent%2A&gt;</ph> часто <ph id="ph2">`null`</ph> для объектов, создаваемых в разметке приложения или код.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.TemplatedParent">
          <source>This is because you create those objects directly, not via a template.</source>
          <target state="translated">Это так, как непосредственно, создания этих объектов не с помощью шаблона.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.TemplatedParent">
          <source>Object references obtained by walking the logical tree from the root, or by typical name references, do not come from a template.</source>
          <target state="translated">Получен путем прохода логического дерева начиная с корневого или по ссылкам типичное имя ссылки на объекты, не исходят из шаблона.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.TemplatedParent">
          <source>Cases where <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.TemplatedParent%2A&gt;</ph> might not be <ph id="ph2">`null`</ph> include operations such as hit-testing, event handling for certain low-level input events, walking the visual tree with <ph id="ph3">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph>, or working with enumerators, which might return elements that came from templates.</source>
          <target state="translated">Ситуации, когда <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.TemplatedParent%2A&gt;</ph> не может быть <ph id="ph2">`null`</ph> включает операции, такие как проверка нажатия, обработка событий для определенных низкоуровневых событий ввода, обход визуального дерева с <ph id="ph3">&lt;xref:System.Windows.Media.VisualTreeHelper&gt;</ph>, или работа с перечислителями, могут возвращать элементы, поступившие с помощью шаблонов.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.TemplatedParent">
          <source>Another case is if you specifically call <ph id="ph1">&lt;xref:System.Windows.FrameworkTemplate.FindName%2A&gt;</ph> against an existing <ph id="ph2">&lt;xref:System.Windows.FrameworkTemplate&gt;</ph> and are work with the returned object.</source>
          <target state="translated">Другой случай, если явно вызывать <ph id="ph1">&lt;xref:System.Windows.FrameworkTemplate.FindName%2A&gt;</ph> от существующего <ph id="ph2">&lt;xref:System.Windows.FrameworkTemplate&gt;</ph> и работа с возвращаемого объекта.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.TemplatedParent">
          <source>Templates are actually shared objects, where the contents of the template are created only once.</source>
          <target state="translated">Шаблоны являются фактически общие объекты, в котором содержимое шаблона создаются только один раз.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.TemplatedParent">
          <source>Therefore, if you obtain an object reference to an element that came from a template, you may find that the apparent logical tree does not reach to the page root.</source>
          <target state="translated">Таким образом Если получить ссылку на элемент, поступивший из шаблона, может оказаться очевидной логического дерева не достигает корня страницы.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.TemplatedParent">
          <source>In order to connect such a template reference to the page's logical tree, you should get the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.TemplatedParent%2A&gt;</ph> value and continue to navigate that element tree as desired.</source>
          <target state="translated">Чтобы подключить такая ссылка шаблона в дереве логической страницы, вы должны получить <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.TemplatedParent%2A&gt;</ph> значения и продолжить для перемещения этого элемента дерева в случае необходимости.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.ToolTip">
          <source>Gets or sets the tool-tip object that is displayed for this element in the <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.</source>
          <target state="translated">Получает или задает объект подсказки, отображаемый для данного элемента в <ph id="ph1">[!INCLUDE[TLA#tla_ui](~/includes/tlasharptla-ui-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ToolTip">
          <source>The tooltip object.</source>
          <target state="translated">Объект подсказки.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ToolTip">
          <source>If the value of this property is of type <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>, then that value is the tool-tip that will be used in the <ph id="ph2">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>.</source>
          <target state="translated">Если значение этого свойства имеет тип <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>, то это значение будет всплывающей подсказки, будет использоваться в <ph id="ph2">[!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ToolTip">
          <source>If the value is of any other type, then that value will be used as the <bpt id="p1">*</bpt>content<ept id="p1">*</ept> for a <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph> provided (constructed) by the system.</source>
          <target state="translated">Если значение любого другого типа, то это значение будет использоваться в качестве <bpt id="p1">*</bpt>содержимого<ept id="p1">*</ept> для <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph> указано (создан) системой.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ToolTip">
          <source>For more information, see <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTipService&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTipService&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ToolTip">
          <source>The service class provides attached properties that can be used to further customize a <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>.</source>
          <target state="translated">Служебный класс предоставляет вложенные свойства, которые могут использоваться для дальнейшей настройки <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ToolTip">
          <source>XAML Attribute Usage</source>
          <target state="translated">Использование атрибута XAML</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ToolTip">
          <source>XAML Property Element Usage</source>
          <target state="translated">Использование элемента свойства XAML</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ToolTip">
          <source>XAML Values</source>
          <target state="translated">Значения XAML</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ToolTip">
          <source><bpt id="p1">*</bpt>toolTipContent<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>toolTipContent<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ToolTip">
          <source>A string that becomes the display text for the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ToolTip%2A&gt;</ph>.</source>
          <target state="translated">Строка, которая становится отображаемый текст для <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ToolTip%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ToolTip">
          <source><bpt id="p1">*</bpt>toolTipObjectContent<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>toolTipObjectContent<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ToolTip">
          <source>Some object, provided in object element form, that should be used as the content for the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> .</source>
          <target state="translated">Некоторые объектом, указанным в форме элемента объекта, который должен использоваться в качестве содержимого для <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> .</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ToolTip">
          <source>Typically this would be a <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> or some other element that creates layout compositing for the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.ToolTip%2A&gt;</ph>, eventually containing text content within the compositing.</source>
          <target state="translated">Обычно это было бы <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> или другой элемент, создающий композиции макета для <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.ToolTip%2A&gt;</ph>, в конечном итоге содержащий текстового содержимого в композиции.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ToolTip">
          <source>In this usage, the <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph> element is created implicitly from the parsed <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>, and the <bpt id="p1">*</bpt>toolTipObjectContent<ept id="p1">*</ept> content is set as its <ph id="ph3">&lt;xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">При таком использовании <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph> создается элемент неявно из проанализированный <ph id="ph2">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph>и <bpt id="p1">*</bpt>toolTipObjectContent<ept id="p1">*</ept> содержимое задано как его <ph id="ph3">&lt;xref:System.Windows.Controls.ContentControl.Content%2A?displayProperty=nameWithType&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ToolTip">
          <source><ph id="ph1">&lt;</ph><ph id="ph2">`ToolTip`</ph> .../&gt;</source>
          <target state="translated"><ph id="ph1">&lt;</ph><ph id="ph2">`ToolTip`</ph> .../&gt;</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ToolTip">
          <source>See <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>.</source>
          <target state="translated">См. раздел <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ToolTip">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ToolTip">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ToolTip">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ToolTip">
          <source>None</source>
          <target state="translated">Нет</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.ToolTip">
          <source>The following example creates a <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph> in code and then sets the <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.ToolTip%2A&gt;</ph> property on a <ph id="ph3">&lt;xref:System.Windows.Controls.Primitives.StatusBar&gt;</ph> control.</source>
          <target state="translated">В следующем примере создается <ph id="ph1">&lt;xref:System.Windows.Controls.ToolTip&gt;</ph> в коде, а затем устанавливает <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.ToolTip%2A&gt;</ph> свойства <ph id="ph3">&lt;xref:System.Windows.Controls.Primitives.StatusBar&gt;</ph> элемента управления.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkElement.ToolTipClosing">
          <source>Occurs just before any tooltip on the element is closed.</source>
          <target state="translated">Происходит непосредственно перед закрытием какой-либо подсказки в элементе.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ToolTipClosing">
          <source>Marking the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ToolTipClosing&gt;</ph> event as handled does not cancel closing the tooltip.</source>
          <target state="translated">Пометка <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ToolTipClosing&gt;</ph> событие как обработанное не отменяет закрытие подсказки.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ToolTipClosing">
          <source>Once the tooltip is displayed, closing the tooltip is done only in response to user interaction with the UI.</source>
          <target state="translated">Если подсказка отображается, закрытие подсказки выполняется только в ответ на взаимодействие пользователя с помощью пользовательского интерфейса.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ToolTipClosing">
          <source>This event cannot be an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style.</source>
          <target state="translated">Это событие не может быть <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> в стиле.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ToolTipClosing">
          <source>This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove event methods for the service-level event.</source>
          <target state="translated">Это потому, что поле идентификатора данного события повторно использует реализацию из службы, которая не предоставляет методы добавления и удаления событий для события уровня службы.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ToolTipClosing">
          <source>Routed Event Information</source>
          <target state="translated">Сведения о маршрутизируемом событии</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ToolTipClosing">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ToolTipClosing">
          <source>Routing strategy</source>
          <target state="translated">Стратегия маршрутизации</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ToolTipClosing">
          <source>Direct</source>
          <target state="translated">Direct</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ToolTipClosing">
          <source>Delegate</source>
          <target state="translated">делегат</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ToolTipClosing">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.OnToolTipClosing%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Переопределить <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.OnToolTipClosing%2A&gt;</ph> реализации класса обработчик данного события в производных классах.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.ToolTipClosingEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.ToolTipClosing" /&gt;</ph> routed event.</source>
          <target state="translated">Идентифицирует направленное событие <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.ToolTipClosing" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.ToolTipClosingEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Идентификаторы перенаправленных событий создаются при их регистрации.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.ToolTipClosingEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.ToolTipClosingEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Эти идентификаторы можно использовать для добавления обработчиков классов.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.ToolTipClosingEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.ToolTipClosingEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkElement.ToolTipOpening">
          <source>Occurs when any tooltip on the element is opened.</source>
          <target state="translated">Происходит при открытии любой всплывающей подсказки к элементу.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ToolTipOpening">
          <source>To prevent a tooltip from appearing in the UI, your handler for <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ToolTipOpening&gt;</ph> can mark the <ph id="ph2">&lt;xref:System.Windows.Controls.ToolTipEventArgs&gt;</ph> event data handled.</source>
          <target state="translated">Чтобы предотвратить появление в пользовательском Интерфейсе обработчиком для всплывающей подсказки <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ToolTipOpening&gt;</ph> можно пометить <ph id="ph2">&lt;xref:System.Windows.Controls.ToolTipEventArgs&gt;</ph> обрабатывать данные события.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ToolTipOpening">
          <source>Otherwise, the tooltip is displayed, using the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ToolTip%2A&gt;</ph> property as the tooltip content.</source>
          <target state="translated">В противном случае отображается всплывающая подсказка, с использованием значения <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ToolTip%2A&gt;</ph> свойство в качестве содержимого всплывающей подсказки.</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ToolTipOpening">
          <source>Another possible scenario is that you could write a handler that resets the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ToolTip%2A&gt;</ph> property for the element that is the event source, just before the tooltip is displayed.</source>
          <target state="translated">Другой возможный сценарий заключается в том, что можно написать обработчик, который сбрасывает значение <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ToolTip%2A&gt;</ph> свойства для элемента, который является источником события, непосредственно перед отображением подсказки.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ToolTipOpening">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ToolTipOpening&gt;</ph> will not be raised if the value of <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.ToolTip%2A&gt;</ph> is <ph id="ph3">`null`</ph> or otherwise unset.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ToolTipOpening&gt;</ph> не будет вызываться, если значение <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.ToolTip%2A&gt;</ph> — <ph id="ph3">`null`</ph> или в противном случае значение не задано.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ToolTipOpening">
          <source>Do not deliberately set <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ToolTip%2A&gt;</ph> to <ph id="ph2">`null`</ph> while a tooltip is open or opening; this will not have the effect of closing the tooltip, and will instead create an undesirable visual artifact in the UI.</source>
          <target state="translated">Не устанавливайте намеренно <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ToolTip%2A&gt;</ph> для <ph id="ph2">`null`</ph> пока открыт всплывающей подсказки или открыв; это не будет иметь эффекта закрытия подсказки и создаст нежелательный визуальный артефакт в пользовательском Интерфейсе.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ToolTipOpening">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ToolTipOpening&gt;</ph> event cannot be an <ph id="ph2">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ToolTipOpening&gt;</ph> Событие не может быть <ph id="ph2">&lt;xref:System.Windows.EventTrigger&gt;</ph> в стиле.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ToolTipOpening">
          <source>This is because the identifier field of this event re-uses an implementation from a service that does not expose add/remove event methods for the service-level event.</source>
          <target state="translated">Это потому, что поле идентификатора данного события повторно использует реализацию из службы, которая не предоставляет методы добавления и удаления событий для события уровня службы.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ToolTipOpening">
          <source>Routed Event Information</source>
          <target state="translated">Сведения о маршрутизируемом событии</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ToolTipOpening">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ToolTipOpening">
          <source>Routing strategy</source>
          <target state="translated">Стратегия маршрутизации</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ToolTipOpening">
          <source>Direct</source>
          <target state="translated">Direct</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ToolTipOpening">
          <source>Delegate</source>
          <target state="translated">делегат</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.ToolTipOpening">
          <source>Override <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.OnToolTipClosing%2A&gt;</ph> to implement class handling for this event in derived classes.</source>
          <target state="translated">Переопределить <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.OnToolTipClosing%2A&gt;</ph> реализации класса обработчик данного события в производных классах.</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.ToolTipOpeningEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.ToolTipOpening" /&gt;</ph> routed event.</source>
          <target state="translated">Идентифицирует направленное событие <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.ToolTipOpening" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.ToolTipOpeningEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Идентификаторы перенаправленных событий создаются при их регистрации.</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.ToolTipOpeningEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.ToolTipOpeningEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Эти идентификаторы можно использовать для добавления обработчиков классов.</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.ToolTipOpeningEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.ToolTipOpeningEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.ToolTipProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.ToolTip" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.ToolTip" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.Triggers">
          <source>Gets the collection of triggers established directly on this element, or in child elements.</source>
          <target state="translated">Получает коллекцию триггеров, установленных непосредственно в этом элементе или в его дочерних элементах.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Triggers">
          <source>A strongly typed collection of <ph id="ph1">&lt;see cref="T:System.Windows.Trigger" /&gt;</ph> objects.</source>
          <target state="translated">Строго типизированная коллекция объектов <ph id="ph1">&lt;see cref="T:System.Windows.Trigger" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Triggers">
          <source>This property can only be set in <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> through the collection syntax shown, or by accessing the collection object and using its various methods such as Add.</source>
          <target state="translated">Это свойство может быть задано только в <ph id="ph1">[!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]</ph> через показанного синтаксиса коллекции или путем доступа к объекту коллекции и использования его различных методов, например Add.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Triggers">
          <source>The property to access the collection object itself is read-only, the collection itself is read-write.</source>
          <target state="translated">Свойство для доступа к объекту коллекции доступно только для чтения, сама коллекция доступна для чтения и записи.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Triggers">
          <source>The property only exists on root elements; attempting to find it or set it elsewhere will cause an exception to be thrown.</source>
          <target state="translated">Свойство существует только в корневых элементах; Попытка найти или задать в другом месте приведет к созданию исключения.</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Triggers">
          <source>This property does not enable you to examine triggers that exist as part of styles in use on this element.</source>
          <target state="translated">Это свойство позволяет проверять триггеры, существующие как часть стилей, используемых для этого элемента.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Triggers">
          <source>It only reports the collection of triggers that are literally added to the collection, either in markup or code.</source>
          <target state="translated">Он только сообщает коллекцию триггеров, которые буквально добавляются в коллекцию, либо в разметке или коде.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Triggers">
          <source>Elements do not typically have such elements existing by default (through a template for instance); it is more common for triggers that come from control compositing to be established in styles instead.</source>
          <target state="translated">Элементы обычно не имеют таких элементов по умолчанию (через шаблон для экземпляра); Это чаще используются триггеры, поступающие из композиции элементов управления, чтобы установить его в стилях.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Triggers">
          <source>In terms of behavior (and trying to establish which effect came from which element's declared <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Triggers%2A&gt;</ph> collection), both the triggering condition and the trigger effect might be on this element, or might be on its child elements in the logical tree.</source>
          <target state="translated">С точки зрения поведения (и устанавливается, какой эффект поступил из объявленного элемента <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Triggers%2A&gt;</ph> коллекции), условие триггера и его эффект может быть на этот элемент, или его дочерних элементов в логическом дереве.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Triggers">
          <source>Note that if you use lifetime events such as <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Loaded&gt;</ph> to get this collection, the child element's triggers might not yet be fully loaded, and the collection will be smaller than it would truly be at run time.</source>
          <target state="translated">Обратите внимание, что при использовании события времени жизни <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Loaded&gt;</ph> для получения этой коллекции, триггеры дочернего элемента могут еще не быть полной загрузки и коллекция будет меньше, чем было бы действительно во время выполнения.</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Triggers">
          <source>Note that the collection of triggers established on an element only supports <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph>, not property triggers (<ph id="ph2">&lt;xref:System.Windows.Trigger&gt;</ph>).</source>
          <target state="translated">Обратите внимание, что коллекция триггеров, установленных на элементе поддерживает только <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph>, не триггеры свойств (<ph id="ph2">&lt;xref:System.Windows.Trigger&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Triggers">
          <source>If you require property triggers, you must place these within a style or template and then assign that style or template to the element either directly through the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Style%2A&gt;</ph> property, or indirectly through an implicit style reference.</source>
          <target state="translated">Если требуются триггеры свойств, необходимо разместить их в стиле или шаблоне и затем назначить этот стиль или шаблон элемента либо напрямую с помощью <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Style%2A&gt;</ph> свойства, либо косвенно через неявную ссылку на стиль.</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Triggers">
          <source>XAML Property Element Usage</source>
          <target state="translated">Использование элемента свойства XAML</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Triggers">
          <source>XAML Values</source>
          <target state="translated">Значения XAML</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Triggers">
          <source><bpt id="p1">*</bpt>oneOrMoreTriggers<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>oneOrMoreTriggers<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Triggers">
          <source>One or more defined <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> elements.</source>
          <target state="translated">Один или несколько определенных <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> элементов.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Triggers">
          <source>Each such trigger is expected to contain valid storyboard actions and references.</source>
          <target state="translated">Каждый такой триггер должен содержать допустимые действия раскадровки и ссылки.</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Triggers">
          <source>Note that this collection can only be established on the root element of a page.</source>
          <target state="translated">Обратите внимание, что эта коллекция может быть установлено только в корневом элементе страницы.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Triggers">
          <source>For more information, see <bpt id="p1">[</bpt>Storyboards Overview<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept>.</source>
          <target state="translated">Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>Общие сведения о Storyboard<ept id="p1">](~/docs/framework/wpf/graphics-multimedia/storyboards-overview.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.TryFindResource(System.Object)">
          <source>The key identifier of the resource to be found.</source>
          <target state="translated">Ключевой идентификатор искомого ресурса.</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.TryFindResource(System.Object)">
          <source>Searches for a resource with the specified key, and returns that resource if found.</source>
          <target state="translated">Ищет ресурс с указанным ключом и возвращает его, если он найден.</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.TryFindResource(System.Object)">
          <source>The found resource, or <ph id="ph1">&lt;see langword="null" /&gt;</ph> if no resource with the provided <ph id="ph2">&lt;paramref name="key" /&gt;</ph> is found.</source>
          <target state="translated">Найденный ресурс или значение <ph id="ph1">&lt;see langword="null" /&gt;</ph>, если ресурс с указанным <ph id="ph2">&lt;paramref name="key" /&gt;</ph> не обнаружен.</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.TryFindResource(System.Object)">
          <source>If the resource is not found on the calling element, the parent resource tree is searched upward through the logical tree, in the same way that the tree would be searched if a resource were requested by key at run time.</source>
          <target state="translated">Если ресурс не найден в вызывающем элементе, выполняется поиск в дереве ресурсов родительского вверх по дереву логических, таким же образом, что было бы дереве поисковое Если ресурс был запрошен по ключу во время выполнения.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.TryFindResource(System.Object)">
          <source>The method returns <ph id="ph1">`null`</ph> only if no resource of that key existed anywhere in the resource tree, per the existing conditions of the tree at the time that <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.TryFindResource%2A&gt;</ph> is called.</source>
          <target state="translated">Метод возвращает <ph id="ph1">`null`</ph> только в том случае, если ресурс этого ключа не существует в любом месте в дереве ресурсов на существующих условий дерева во время, <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.TryFindResource%2A&gt;</ph> вызывается.</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.TryFindResource(System.Object)">
          <source>Typically you would immediately cast the return value to the type of the property that you were attempting to set with the returned resource value.</source>
          <target state="translated">Обычно вы сразу же привести возвращаемое значение к типу свойства, которое вы пытаетесь набор с возвращенным значением ресурса.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.TryFindResource(System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FindResource%2A&gt;</ph> method has similar behavior, except that it throws an exception if no resource with the provided key was returned.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.FindResource%2A&gt;</ph> Метод имеет аналогичное поведение, за исключением того, метод создает исключение, если ресурс с указанным ключом не был возвращен.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.TryFindResource(System.Object)">
          <source>The following example is implemented as a button handler, where the button being clicked sets its background to a resource-defined brush obtained by calling <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.TryFindResource%2A&gt;</ph> on itself.</source>
          <target state="translated">Следующий пример реализуется как обработчик кнопки, где кнопке выбираемой наборов его фоновой кисти ресурс определен получается вызовом <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.TryFindResource%2A&gt;</ph> на себя.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.TryFindResource(System.Object)">
          <source>This walks the element tree and finds the resource (the resource itself is defined in <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> and is not shown).</source>
          <target state="translated">Это обходит дерево элементов и поиск ресурса (сам ресурс определен в <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> и не отображается).</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" uid="E:System.Windows.FrameworkElement.Unloaded">
          <source>Occurs when the element is removed from within an element tree of loaded elements.</source>
          <target state="translated">Происходит при удалении элемента из дерева с загруженными элементами.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Unloaded">
          <source>Direct routed events do not follow a route, they are only handled within the same element on which they are raised.</source>
          <target state="translated">События с прямой маршрутизацией не следуют по маршруту, они обрабатываются только внутри элемента, на котором они вызываются.</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Unloaded">
          <source>Direct routed events do support other routed event behavior: they support an accessible handlers collection, and can be used as an <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> in a style.</source>
          <target state="translated">Прямые перенаправленные события поддерживают другое поведение перенаправленных событий: они поддерживают коллекцию доступных обработчиков и могут использоваться как <ph id="ph1">&lt;xref:System.Windows.EventTrigger&gt;</ph> в стиле.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Unloaded">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Loaded&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Unloaded&gt;</ph> might both be raised on controls as a result of user-initiated system theme changes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Loaded&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Unloaded&gt;</ph> и может быть вызвано в элементе управления, в результате изменения темы инициированной пользователем системы.</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Unloaded">
          <source>A theme change causes an invalidation of the control template and the contained visual tree, which in turn causes the entire control to unload and reload.</source>
          <target state="translated">Изменение темы делает недействительность шаблон элемента управления и автономной визуального дерева, который в свою очередь вызывает выгрузке и повторной загрузке всего элемента управления.</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Unloaded">
          <source>Therefore <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Unloaded&gt;</ph> cannot be assumed to occur only on navigation away from the page.</source>
          <target state="translated">Поэтому <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Unloaded&gt;</ph> не может предположить, что возникают только при навигации страницы на другую.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Unloaded">
          <source>Note that the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Unloaded&gt;</ph> event is not raised after an application begins shutting down.</source>
          <target state="translated">Обратите внимание, что <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Unloaded&gt;</ph> событие не происходит после начала приложение завершает работу.</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Unloaded">
          <source>Application shutdown occurs when the condition defined by the <ph id="ph1">&lt;xref:System.Windows.Application.ShutdownMode%2A&gt;</ph> property occurs.</source>
          <target state="translated">Выключение приложения выполняется, если условие предиката <ph id="ph1">&lt;xref:System.Windows.Application.ShutdownMode%2A&gt;</ph> происходит свойство.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Unloaded">
          <source>If you place cleanup code within a handler for the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Unloaded&gt;</ph> event, such as for a <ph id="ph2">&lt;xref:System.Windows.Window&gt;</ph> or a <ph id="ph3">&lt;xref:System.Windows.Controls.UserControl&gt;</ph>, it may not be called as expected.</source>
          <target state="translated">Если поместить код очистки в обработчик <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Unloaded&gt;</ph> событий, таких как <ph id="ph2">&lt;xref:System.Windows.Window&gt;</ph> или <ph id="ph3">&lt;xref:System.Windows.Controls.UserControl&gt;</ph>, он не может вызываться должным образом.</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Unloaded">
          <source>Routed Event Information</source>
          <target state="translated">Сведения о маршрутизируемом событии</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Unloaded">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Unloaded">
          <source>Routing strategy</source>
          <target state="translated">Стратегия маршрутизации</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Unloaded">
          <source>Direct</source>
          <target state="translated">Direct</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" extradata="MT" uid="E:System.Windows.FrameworkElement.Unloaded">
          <source>Delegate</source>
          <target state="translated">делегат</target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.UnloadedEvent">
          <source>Identifies the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.Unloaded" /&gt;</ph> routed event.</source>
          <target state="translated">Идентифицирует направленное событие <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.Unloaded" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.UnloadedEvent">
          <source>Routed event identifiers are created when routed events are registered.</source>
          <target state="translated">Идентификаторы перенаправленных событий создаются при их регистрации.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.UnloadedEvent">
          <source>These identifiers contain an identifying name, owner type, handler type, routing strategy, and utility method for adding owners for the event.</source>
          <target state="translated">Эти идентификаторы содержат идентификационное имя, тип владельца, тип обработчика, стратегию маршрутизации и служебный метод добавления владельцев события.</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.UnloadedEvent">
          <source>You can use these identifiers to add class handlers.</source>
          <target state="translated">Эти идентификаторы можно использовать для добавления обработчиков классов.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.UnloadedEvent">
          <source>For more information about registering routed events, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения о регистрации маршрутизированных событий см. в разделе <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterRoutedEvent%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="F:System.Windows.FrameworkElement.UnloadedEvent">
          <source>For more information about using routed event identifiers to add class handlers, see <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</source>
          <target state="translated">Дополнительные сведения об использовании идентификаторов маршрутизируемых событий для добавления обработчиков класса см. в описании метода <ph id="ph1">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.UnregisterName(System.String)">
          <source>Name of the name-object pair to remove from the current scope.</source>
          <target state="translated">Имя пары имя-объект, которую необходимо удалить из текущей области видимости.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.UnregisterName(System.String)">
          <source>Simplifies access to the <ph id="ph1">&lt;see cref="T:System.Windows.NameScope" /&gt;</ph> de-registration method.</source>
          <target state="translated">Упрощает доступ к методу отмены регистрации <ph id="ph1">&lt;see cref="T:System.Windows.NameScope" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Windows.FrameworkElement.UnregisterName(System.String)">
          <source>You only need to un-register names if you intend to re-register another element with that same name.</source>
          <target state="translated">Только необходимо отменить регистрацию имен Если предполагается повторно зарегистрировать другой элемент с таким же именем.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" uid="M:System.Windows.FrameworkElement.UpdateDefaultStyle">
          <source>Reapplies the default style to the current <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph>.</source>
          <target state="translated">Повторно применяет стиль по умолчанию к текущему объекту <ph id="ph1">&lt;see cref="T:System.Windows.FrameworkElement" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.UseLayoutRounding">
          <source>Gets or sets a value that indicates whether layout rounding should be applied to this element's size and position during layout.</source>
          <target state="translated">Получает или задает значение, указывающее, должно ли применяться округление макета для размера и позиции данного элемента во время структурирования.</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.UseLayoutRounding">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if layout rounding is applied; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;see langword="true" /&gt;</ph>, если округление структуры применяется; в противном случае — значение <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.UseLayoutRounding">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию: <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.UseLayoutRounding">
          <source>When the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.UseLayoutRounding%2A&gt;</ph> property for an element is <ph id="ph2">`true`</ph>, all non-integral pixel values that are calculated during the <ph id="ph3">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> passes are rounded to whole pixel values.</source>
          <target state="translated">Когда <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.UseLayoutRounding%2A&gt;</ph> свойство элемента является <ph id="ph2">`true`</ph>, все пикселей не целочисленного значения, которые вычисляются во время <ph id="ph3">&lt;xref:System.Windows.UIElement.Measure%2A&gt;</ph> и <ph id="ph4">&lt;xref:System.Windows.UIElement.Arrange%2A&gt;</ph> передает округляются до целых значений пикселей.</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.UseLayoutRounding">
          <source>This property is inherited by child elements.</source>
          <target state="translated">Данное свойство наследуется дочерними элементами.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.UseLayoutRounding">
          <source>You should set <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.UseLayoutRounding%2A&gt;</ph> to <ph id="ph2">`true`</ph> on the root element.</source>
          <target state="translated">Необходимо задать <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.UseLayoutRounding%2A&gt;</ph> для <ph id="ph2">`true`</ph> для корневого элемента.</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.UseLayoutRounding">
          <source>The layout system adds child coordinates to the parent coordinates; therefore, if the parent coordinates are not on a pixel boundary, the child coordinates are also not on a pixel boundary.</source>
          <target state="translated">Система макета добавляет координаты дочернего координатам родительского; Таким образом Если координаты родительского элемента не на границе пикселов, координаты дочернего, также не на границе пикселов.</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.UseLayoutRounding">
          <source>If <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.UseLayoutRounding%2A&gt;</ph> cannot be set at the root, set <ph id="ph2">&lt;xref:System.Windows.UIElement.SnapsToDevicePixels%2A&gt;</ph> on the child to obtain the effect that you want.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.UseLayoutRounding%2A&gt;</ph> нельзя задать в корне, установите <ph id="ph2">&lt;xref:System.Windows.UIElement.SnapsToDevicePixels%2A&gt;</ph> для дочернего элемента для получения необходимого эффекта.</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.UseLayoutRounding">
          <source>Drawing objects on pixel boundaries eliminates the semi-transparent edges that are produced by anti-aliasing, when an edge falls in the middle of a device pixel.</source>
          <target state="translated">Графические объекты на границах пикселей устраняет полупрозрачные края, производимые сглаживания, когда граница попадает на середину пикселя устройства.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.UseLayoutRounding">
          <source>The following illustration shows the output of a single pixel-width line that falls in the middle of a device pixel.</source>
          <target state="translated">Ниже показан результат выполнения одного пикселя ширины строки, приходится на середину пикселя устройства.</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.UseLayoutRounding">
          <source>The line on the left does not use layout rounding and is anti-aliased.</source>
          <target state="translated">Строки в левой части не использует округление макета и является значение свойства.</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.UseLayoutRounding">
          <source>The line on the right uses layout rounding.</source>
          <target state="translated">Строка справа использует округление макета.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.UseLayoutRounding">
          <source><bpt id="p1">![</bpt>Anti&amp;#45;aliased line compared to single pixel line.<ept id="p1">]</ept><bpt id="p2">(~/add/media/pixelsnaplinecompare.PNG "</bpt>Anti-aliased line compared to single pixel line.<ept id="p2">")</ept></source>
          <target state="translated"><bpt id="p1">![</bpt>Приложения для защиты&amp;#45;псевдоним линия в сравнении с одного пикселя в высоту строки. <ept id="p1">]</ept> <bpt id="p2">(~/add/media/pixelsnaplinecompare.PNG "</bpt>Сглаженная линия в сравнении с линией из одного пикселя в высоту.<ept id="p2">")</ept></target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.UseLayoutRounding">
          <source>When you use layout rounding and <ph id="ph1">&lt;xref:System.Windows.GridUnitType.Star&gt;</ph> sizing, the layout system creates small variations in the column or row measurements to avoid subpixel rendering.</source>
          <target state="translated">При использовании округление макета и <ph id="ph1">&lt;xref:System.Windows.GridUnitType.Star&gt;</ph> изменения размера, система макета создает небольшие вариации в измерениях столбцов или строк во избежание субпиксельной визуализации.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.UseLayoutRounding">
          <source>For example, if a grid has a total width of 100 with 3 columns each of size <ph id="ph1">&lt;xref:System.Windows.GridUnitType.Star&gt;</ph>, instead of creating three columns that have an equal width of 33.3, the layout system creates 2 columns that have a width of 33 and one that has a width of 34.</source>
          <target state="translated">Например, если сетка содержит общая ширина 100 с 3 столбцами размера <ph id="ph1">&lt;xref:System.Windows.GridUnitType.Star&gt;</ph>, вместо создания трех столбцов, имеющих ширину 33,3, система макета создает 2 столбца, имеющих ширину 33 и один шириной 34.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.UseLayoutRounding">
          <source>In .NET 4.6 changes were made to layout rounding to reduce instances of clipping in controls with borders.</source>
          <target state="translated">В .NET 4.6 для снижения числа вхождений обрезки в элементах управления с границами округление макетов внесены изменения.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.UseLayoutRounding">
          <source>By default, this feature is enabled if your Target Framework is .NET Framework 4.6 or higher.</source>
          <target state="translated">По умолчанию эта функция включена, если свою целевую платформу .NET Framework 4.6 или более поздней версии.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.UseLayoutRounding">
          <source>Applications that target earlier versions of the framework can opt in into the new behavior by adding the following setting to an app.config file: <ph id="ph1">`&lt;runtime&gt;&lt;AppContextSwitchOverrides value="Switch.MS.Internal.DoNotApplyLayoutRoundingToMarginsAndBorderThickness=false"/&gt;&lt;/runtime&gt;`</ph> The setting only takes effect when the application is running on the .NET Framework 4.6.</source>
          <target state="translated">Приложения, которые предназначены для более ранних версий платформы, можно выбрать в новое поведение, добавив следующий параметр в файл app.config: <ph id="ph1">`&lt;runtime&gt;&lt;AppContextSwitchOverrides value="Switch.MS.Internal.DoNotApplyLayoutRoundingToMarginsAndBorderThickness=false"/&gt;&lt;/runtime&gt;`</ph> параметр вступает в силу только при запуске приложения на платформе .NET Framework 4.6.</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.UseLayoutRounding">
          <source>The following example demonstrates the effect that the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.UseLayoutRounding%2A&gt;</ph> property has on a single pixel-width line.</source>
          <target state="translated">В следующем примере демонстрируется эффект, <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.UseLayoutRounding%2A&gt;</ph> свойство имеет на один пиксель ширины строки.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.UseLayoutRounding">
          <source>The line on the left does not use layout rounding and the line on the right uses layout rounding.</source>
          <target state="translated">Строки в левой части не использует округление макета и строка справа использует округление макета.</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.UseLayoutRounding">
          <source>If you slowly resize the window, you can see the difference that layout rounding makes.</source>
          <target state="translated">Если медленно изменять размер окна, можно увидеть разницу, создаваемую округлением макета.</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.UseLayoutRoundingProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.UseLayoutRounding" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.UseLayoutRounding" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.VerticalAlignment">
          <source>Gets or sets the vertical alignment characteristics applied to this element when it is composed within a parent element such as a panel or items control.</source>
          <target state="translated">Получает или задает характеристики выравнивания по вертикали, применяемые к этому элементу при его размещении в родительском элементе, например в панели или элементе управления элементами.</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.VerticalAlignment">
          <source>A vertical alignment setting.</source>
          <target state="translated">Настройка вертикального выравнивания.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.VerticalAlignment">
          <source>The default is <ph id="ph1">&lt;see cref="F:System.Windows.VerticalAlignment.Stretch" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию: <ph id="ph1">&lt;see cref="F:System.Windows.VerticalAlignment.Stretch" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.VerticalAlignment">
          <source>When <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph> properties are explicitly set on an element, these measurements take layout precedent and cancel the regular effects of setting this property to <ph id="ph3">&lt;xref:System.Windows.VerticalAlignment.Stretch&gt;</ph>.</source>
          <target state="translated">Когда <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Height%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph> от элемента явно заданы свойства, этих измерений имеют приоритет и отменяют обычный эффект от присвоить этому свойству значение <ph id="ph3">&lt;xref:System.Windows.VerticalAlignment.Stretch&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.VerticalAlignment">
          <source><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.VerticalAlignment%2A&gt;</ph> is the <ph id="ph2">[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]</ph> property accessor for what is in reality a dependency property.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement.VerticalAlignment%2A&gt;</ph> — <ph id="ph2">[!INCLUDE[TLA#tla_net](~/includes/tlasharptla-net-md.md)]</ph> доступа свойства для Какова на самом деле свойство зависимостей.</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.VerticalAlignment">
          <source>This particular dependency property quite frequently has its apparent "default" value set differently in derived element classes, particularly controls.</source>
          <target state="translated">Это свойство определенная зависимость довольно часто имеет значение «по умолчанию» по-разному в производных классах элементов, особенно элементов управления.</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.VerticalAlignment">
          <source>This generally occurs in one of two ways: the dependency property is re-registered to a particular  derived class, but with different metadata for setting its defaults; or there is a default style being applied that sets that dependency property value differently.</source>
          <target state="translated">Обычно такая ситуация возникает в одном из двух способов: свойство зависимостей повторно зарегистрирован для определенного производного класса, но с другой метаданных для задания значения по умолчанию; либо стиль по умолчанию применяется, который задает это значение свойства зависимостей по-разному.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.VerticalAlignment">
          <source>For example, the apparent "default" of <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.VerticalAlignment%2A&gt;</ph> for a <ph id="ph2">&lt;xref:System.Windows.Controls.ComboBoxItem&gt;</ph> control will be <ph id="ph3">&lt;xref:System.Windows.VerticalAlignment.Center&gt;</ph>, even though <ph id="ph4">&lt;xref:System.Windows.Controls.ComboBoxItem&gt;</ph> inherits <ph id="ph5">&lt;xref:System.Windows.FrameworkElement.VerticalAlignment%2A&gt;</ph> direct from <ph id="ph6">&lt;xref:System.Windows.FrameworkElement&gt;</ph>.</source>
          <target state="translated">Например, «по умолчанию» для <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.VerticalAlignment%2A&gt;</ph> для <ph id="ph2">&lt;xref:System.Windows.Controls.ComboBoxItem&gt;</ph> элемент управления будет <ph id="ph3">&lt;xref:System.Windows.VerticalAlignment.Center&gt;</ph>, даже если <ph id="ph4">&lt;xref:System.Windows.Controls.ComboBoxItem&gt;</ph> наследует <ph id="ph5">&lt;xref:System.Windows.FrameworkElement.VerticalAlignment%2A&gt;</ph> непосредственно от <ph id="ph6">&lt;xref:System.Windows.FrameworkElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.VerticalAlignment">
          <source>This is because that value was reset within the default style of <ph id="ph1">&lt;xref:System.Windows.Controls.ComboBoxItem&gt;</ph>, within the style's control template.</source>
          <target state="translated">Это, поскольку это значение было сброшено в качестве стиля по умолчанию <ph id="ph1">&lt;xref:System.Windows.Controls.ComboBoxItem&gt;</ph>, в шаблоне элемента управления стилем.</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.VerticalAlignment">
          <source><ph id="ph1">&lt;xref:System.Windows.Controls.Canvas&gt;</ph> does not use <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.VerticalAlignment%2A&gt;</ph> when composing layout, because <ph id="ph3">&lt;xref:System.Windows.Controls.Canvas&gt;</ph> is based on absolute positioning.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.Controls.Canvas&gt;</ph> не используйте <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.VerticalAlignment%2A&gt;</ph> при создании макета, так как <ph id="ph3">&lt;xref:System.Windows.Controls.Canvas&gt;</ph> основывающаяся на абсолютном позиционировании.</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.VerticalAlignment">
          <source>When inherited by <ph id="ph1">&lt;xref:System.Windows.Controls.ComboBoxItem&gt;</ph> or any derived classes, <ph id="ph2">&lt;xref:System.Windows.Controls.ComboBoxItem&gt;</ph> redefines the default value of this property to be <ph id="ph3">&lt;xref:System.Windows.VerticalAlignment.Center&gt;</ph>.</source>
          <target state="translated">Если наследуемые <ph id="ph1">&lt;xref:System.Windows.Controls.ComboBoxItem&gt;</ph> или любых производных классов, <ph id="ph2">&lt;xref:System.Windows.Controls.ComboBoxItem&gt;</ph> переопределяет значение по умолчанию этого свойства было <ph id="ph3">&lt;xref:System.Windows.VerticalAlignment.Center&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.VerticalAlignment">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.VerticalAlignment">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.VerticalAlignment">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.VerticalAlignmentProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.VerticalAlignment" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.VerticalAlignment" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.VisualChildrenCount">
          <source>Gets the number of visual child elements within this element.</source>
          <target state="translated">Получает количество визуальных дочерних элементов внутри этого элемента.</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.VisualChildrenCount">
          <source>The number of visual child elements for this element.</source>
          <target state="translated">Количество визуальных дочерних элементов для этого элемента.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.VisualChildrenCount">
          <source>The <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> implementation of <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.VisualChildrenCount%2A&gt;</ph> always returns either zero or one.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> Реализация <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.VisualChildrenCount%2A&gt;</ph> всегда возвращает 0 или 1.</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.VisualChildrenCount">
          <source>Classes that maintain a visual child collection that might exceed one must override both this property and <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.GetVisualChild%2A&gt;</ph>.</source>
          <target state="translated">Классы, которые поддерживают, может превышать одну коллекцию визуальных дочерних необходимо переопределить и это свойство и <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.GetVisualChild%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.VisualChildrenCount">
          <source>This property is generally used to determine the upper bounds of the current child collection for purposes of implementing the layout overrides (<ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MeasureOverride%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.ArrangeOverride%2A&gt;</ph>).</source>
          <target state="translated">Это свойство обычно используется для определения верхней границы в текущей коллекции дочерних для целей реализации переопределений макета (<ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MeasureOverride%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.ArrangeOverride%2A&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.VisualChildrenCount">
          <source>The following example shows how a custom adorner uses the values declared by a <ph id="ph1">&lt;xref:System.Windows.Media.VisualCollection&gt;</ph> that it maintains for its multiple visual children and reports these values through overrides of <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.VisualChildrenCount%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.GetVisualChild%2A&gt;</ph>.</source>
          <target state="translated">В следующем примере показано, как пользовательский графический элемент использует значения, объявленные с <ph id="ph1">&lt;xref:System.Windows.Media.VisualCollection&gt;</ph> он поддерживает для множества визуальных дочерних элементов и сообщает эти значения через переопределения <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.VisualChildrenCount%2A&gt;</ph> и <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.GetVisualChild%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.VisualChildrenCount">
          <source>If your class supports more than one visual child in a child element collection, override this property to return the count of elements in that collection.</source>
          <target state="translated">Если ваш класс поддерживает более одного визуального дочернего элемента в коллекцию дочерних элементов, переопределите это свойство, чтобы возвращать число элементов в этой коллекции.</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.VisualChildrenCount">
          <source>You must do this even if the collection object itself returns a count.</source>
          <target state="translated">Это необходимо выполнить, даже если сам объект коллекции возвращает счетчик.</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.VisualChildrenCount">
          <source>Element layout logic at the WPF framework level presumes that all elements will return a valid count through their <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" /&gt;</ph> property.</source>
          <target state="translated">Логику макета элемента на уровне WPF framework предполагает, что все элементы будут возвращать допустимое значение счетчика через их <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.VisualChildrenCount" /&gt;</ph> свойство.</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" uid="P:System.Windows.FrameworkElement.Width">
          <source>Gets or sets the width of the element.</source>
          <target state="translated">Получение или установка ширины элемента.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>The width of the element, in <ph id="ph1">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph>.</source>
          <target state="translated">Ширина элемента в <ph id="ph1">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph>.</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>The default value is <ph id="ph1">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</source>
          <target state="translated">Значение по умолчанию — <ph id="ph1">&lt;see cref="F:System.Double.NaN" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>This value must be equal to or greater than 0.0.</source>
          <target state="translated">Это значение должно быть не меньше 0,0.</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>See Remarks for upper bound information.</source>
          <target state="translated">Сведения о верхней границе см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>This is one of three properties on <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> that specify width information.</source>
          <target state="translated">Это один из трех свойств на <ph id="ph1">&lt;xref:System.Windows.FrameworkElement&gt;</ph> , укажите ширину сведения.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>The other two are <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MinWidth%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.MaxWidth%2A&gt;</ph>.</source>
          <target state="translated">Два других — <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MinWidth%2A&gt;</ph> и <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.MaxWidth%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>If there is a conflict between these values, the order of application for actual width determination is first <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MinWidth%2A&gt;</ph> must be honored, then <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.MaxWidth%2A&gt;</ph>, and finally if each of these are within bounds, <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph>.</source>
          <target state="translated">Если возникает конфликт между этими значениями, порядок приложения для определения фактическую ширину первый <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.MinWidth%2A&gt;</ph> должен быть принят на обработку, затем <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.MaxWidth%2A&gt;</ph>и, наконец, если каждый из них находятся в пределах границ, <ph id="ph3">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>The return value of this property is always the same as any value that was set to it.</source>
          <target state="translated">Возвращаемое значение этого свойства всегда является таким же, как любое значение, которое было задано.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>In contrast, the value of the <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ActualWidth%2A&gt;</ph> may vary.</source>
          <target state="translated">Напротив, значение <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.ActualWidth%2A&gt;</ph> могут различаться.</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>The layout may have rejected the suggested size for some reason.</source>
          <target state="translated">Макет может отклонить предполагаемый размер по некоторым причинам.</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>Also, the layout system itself works asynchronously relative to the property system set of <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph> and may not have processed that particular sizing property change yet.</source>
          <target state="translated">Кроме того, сама система структуры работает асинхронно относительно набора системных свойств <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph> и может не обработать конкретное изменение свойства размера еще.</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>In addition to acceptable <ph id="ph1">&lt;xref:System.Double&gt;</ph> values, this property can also be <ph id="ph2">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">В дополнение к допустимого <ph id="ph1">&lt;xref:System.Double&gt;</ph> значения, это свойство также может быть <ph id="ph2">&lt;xref:System.Double.NaN?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>This is how you specify auto sizing behavior.</source>
          <target state="translated">Это показано, как указать поведение автоматического изменения размеров.</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>In <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> you set the value to the string "Auto" (case insensitive) to enable the auto sizing behavior.</source>
          <target state="translated">В <ph id="ph1">[!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)]</ph> значение в строку «Auto» (без учета регистра) чтобы включить автоматическое изменение размеров.</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>Auto sizing behavior implies that the element will fill the width available to it.</source>
          <target state="translated">Автоматическое изменение размеров предполагает, что элемент заполнит доступную ему ширину.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>Note however that specific controls frequently supply default values in their default styles that will disable the auto sizing behavior unless it is specifically re-enabled.</source>
          <target state="translated">Обратите внимание, что определенные элементы управления передают значения по умолчанию в их стили по умолчанию, которые отключают автоматическое изменение размеров, если он не является специально не включить повторно.</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>In addition to the validation check, there is a nondeterministic upper value bound for <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph> that is enforced by the layout system (this is a very large number, larger than <ph id="ph2">&lt;xref:System.Single.MaxValue?displayProperty=nameWithType&gt;</ph> but smaller than <ph id="ph3">&lt;xref:System.Double.MaxValue?displayProperty=nameWithType&gt;</ph>).</source>
          <target state="translated">В дополнение к проверке подлинности является недетерминированной наибольшее значение, привязанное к <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph> , обеспечивается системой макета (это очень большое число, большее, чем <ph id="ph2">&lt;xref:System.Single.MaxValue?displayProperty=nameWithType&gt;</ph> но меньше, чем <ph id="ph3">&lt;xref:System.Double.MaxValue?displayProperty=nameWithType&gt;</ph>).</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>If you exceed this bound, the element will not render, and no exception is thrown.</source>
          <target state="translated">Если превысить это ограничение, элемент не будет отображаться, и исключение не возникает.</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>Do not set <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph> to a value that is significantly larger than the maximum size of any possible visual display, or you may exceed this nondeterministic upper bound.</source>
          <target state="translated">Не устанавливайте <ph id="ph1">&lt;xref:System.Windows.FrameworkElement.Width%2A&gt;</ph> значение значительно больше, чем максимальный размер любого возможного визуального дисплея, или может превысить эту недетерминированную верхнюю границу.</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>XAML Attribute Usage</source>
          <target state="translated">Использование атрибута XAML</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>XAML Values</source>
          <target state="translated">Значения XAML</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source><bpt id="p1">*</bpt>double<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>double<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>String representation of a <ph id="ph1">&lt;xref:System.Double&gt;</ph> value equal to or greater than 0.0.</source>
          <target state="translated">Строковое представление <ph id="ph1">&lt;xref:System.Double&gt;</ph> значение, равное или больше 0,0.</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>See Remarks for upper bound information.</source>
          <target state="translated">Сведения о верхней границе см. в разделе "Примечания".</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>This value is interpreted as a <ph id="ph1">[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]</ph> measurement.</source>
          <target state="translated">Это значение интерпретируется как <ph id="ph1">[!INCLUDE[TLA#tla_dipixel](~/includes/tlasharptla-dipixel-md.md)]</ph> измерения.</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>Strings need not explicitly include decimal points.</source>
          <target state="translated">Строки не нужно явно указывать десятичного разделителя.</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>For instance a value of <ph id="ph1">`1`</ph> is acceptable.</source>
          <target state="translated">Для экземпляра значение <ph id="ph1">`1`</ph> является допустимым.</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source><bpt id="p1">*</bpt>qualifiedDouble<ept id="p1">*</ept></source>
          <target state="translated"><bpt id="p1">*</bpt>qualifiedDouble<ept id="p1">*</ept></target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>A <bpt id="p1">*</bpt>double<ept id="p1">*</ept> value as described above, followed by one of the following unit declaration strings: <ph id="ph1">`px`</ph>, <ph id="ph2">`in`</ph>, <ph id="ph3">`cm`</ph>, <ph id="ph4">`pt`</ph>.</source>
          <target state="translated">Объект <bpt id="p1">*</bpt>двойные<ept id="p1">*</ept> значение как описано выше, за которым следует один из следующих строк объявления единицы измерения: <ph id="ph1">`px`</ph>, <ph id="ph2">`in`</ph>, <ph id="ph3">`cm`</ph>, <ph id="ph4">`pt`</ph>.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source><ph id="ph1">`px`</ph> (default) is <ph id="ph2">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph></source>
          <target state="translated"><ph id="ph1">`px`</ph> (по умолчанию) <ph id="ph2">[!INCLUDE[TLA#tla_dipixel#plural](~/includes/tlasharptla-dipixelsharpplural-md.md)]</ph></target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source><ph id="ph1">`in`</ph> is inches; 1in==96px</source>
          <target state="translated"><ph id="ph1">`in`</ph> дюймах; 1 дюйм == 96 точек</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source><ph id="ph1">`cm`</ph> is centimeters; 1cm==(96/2.54) px</source>
          <target state="translated"><ph id="ph1">`cm`</ph> сантиметрах; 1см==(96/2,54) пкс</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source><ph id="ph1">`pt`</ph> is points; 1pt==(96/72) px</source>
          <target state="translated"><ph id="ph1">`pt`</ph> точках; 1точка==(96/72) пкс</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>Enables autosizing behavior.</source>
          <target state="translated">Включает автоматическое определение размера.</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>See Remarks.</source>
          <target state="translated">См. заметки.</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>Dependency Property Information</source>
          <target state="translated">Сведения о свойстве зависимостей</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>Identifier field</source>
          <target state="translated">Поле идентификатора</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Windows.FrameworkElement.Width">
          <source>Metadata properties set to <ph id="ph1">`true`</ph></source>
          <target state="translated">Значение свойства метаданных <ph id="ph1">`true`</ph></target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" uid="F:System.Windows.FrameworkElement.WidthProperty">
          <source>Identifies the <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.Width" /&gt;</ph> dependency property.</source>
          <target state="translated">Идентифицирует свойство зависимостей <ph id="ph1">&lt;see cref="P:System.Windows.FrameworkElement.Width" /&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>