<Type Name="FrameworkPropertyMetadata" FullName="System.Windows.FrameworkPropertyMetadata">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c70304d7b52b8f4e76c37fd1e35de0928f9619c7" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30680548" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FrameworkPropertyMetadata : System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit FrameworkPropertyMetadata extends System.Windows.UIPropertyMetadata" />
  <TypeSignature Language="DocId" Value="T:System.Windows.FrameworkPropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class FrameworkPropertyMetadata&#xA;Inherits UIPropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class FrameworkPropertyMetadata : System::Windows::UIPropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.UIPropertyMetadata</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Сообщает или применяет метаданные для свойства зависимостей, добавляя характеристики системы свойств, специфичные для платформы.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот класс является производным от <xref:System.Windows.PropertyMetadata> (через <xref:System.Windows.UIPropertyMetadata>). Для большинства целей разработки приложений уровня платформы WPF <xref:System.Windows.FrameworkPropertyMetadata> является типом, используемым для метаданные свойства зависимостей, а не типы базовых метаданных <xref:System.Windows.PropertyMetadata> или <xref:System.Windows.UIPropertyMetadata>. Это верно как для существующих свойств зависимостей, так и для большинства настраиваемых сценариев свойств зависимостей.  
  
 Члены, объявленные в этом классе, дополнения <xref:System.Windows.PropertyMetadata> базового класса включает множество логических свойств, задающих или поведение системы свойства уровня платформы WPF, таких как наследование, привязка данных и макет отчета.  
  
 Несколько сигнатур конструкторов для создания <xref:System.Windows.FrameworkPropertyMetadata> принимают экземпляр <xref:System.Windows.FrameworkPropertyMetadataOptions> параметра. <xref:System.Windows.FrameworkPropertyMetadataOptions> Перечисления используется только для указания начальной поведения в конструкторе и после не предоставляется <xref:System.Windows.FrameworkPropertyMetadata> создается. Созданного экземпляра можно получить или задать соответствующую информацию через различные свойства, которые имеют имена значений перечисления, используемых в вызове конструктора.  
  
<a name="xamlTextUsage_FrameworkPropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Этот класс обычно не используется в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Следующий пример получает метаданные для свойства зависимостей для определенного владельца как начальный базовый <xref:System.Windows.PropertyMetadata> типа. Эти метаданные, приводится к <xref:System.Windows.FrameworkPropertyMetadata>. Если приведение возвращается допустимый <xref:System.Windows.FrameworkPropertyMetadata>, а затем различные <xref:System.Windows.FrameworkPropertyMetadata> свойство значения передаются через простой пользовательский Интерфейс (не показано).  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Windows.PropertyMetadata" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</summary>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта подпись инициализирует все значения <xref:System.Windows.FrameworkPropertyMetadata.%23ctor%2A> по умолчанию для свойства. <xref:System.Windows.PropertyMetadata.DefaultValue%2A> будет `null`и различных <xref:System.Windows.FrameworkPropertyMetadata> логических свойств будет `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой значение определенного типа.</param>
        <summary>Выполняет инициализацию нового экземпляра класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с заданным по умолчанию значением.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, заданного для `defaultValue` должны соответствовать или относиться к типу, заданному в исходной регистрации применяются эти метаданные свойства зависимостей. Несоответствие между типом значений метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживать, из-за рассогласования не удается обнаружить во время компиляции. В системе свойств не оценивает значение свойства до времени выполнения, поэтому результат несоответствие типов типа или свойства по умолчанию значение — ошибка времени выполнения.  
  
 Значение <xref:System.Windows.DependencyProperty.UnsetValue> имеет особое значение в системе свойств и не может использоваться как значение по умолчанию свойства зависимостей.  
  
   
  
## Examples  
 В следующем примере вызывается следующую сигнатуру конструктора:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Параметру <paramref name="defaultValue" /> задается значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с указанным ответом <see cref="T:System.Windows.PropertyChangedCallback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере вызывается следующую сигнатуру конструктора:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object, flags As FrameworkPropertyMetadataOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой значение определенного типа.</param>
        <param name="flags">Параметры флагов метаданных (комбинация значений <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Данные параметры определяют характеристики свойства зависимостей, взаимодействующего с системой, такие как структура и привязка данных.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с указанным значением по умолчанию и параметрами метаданных уровня платформы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, заданного для `defaultValue` должны соответствовать или относиться к типу, заданному в исходной регистрации применяются эти метаданные свойства зависимостей. Несоответствие между типом значений метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживать, из-за рассогласования не удается обнаружить во время компиляции. В системе свойств не оценивает значение свойства до времени выполнения, поэтому результат несоответствие типов типа или свойства по умолчанию значение — ошибка времени выполнения.  
  
 Значение <xref:System.Windows.DependencyProperty.UnsetValue> имеет особое значение в системе свойств и не может использоваться как значение по умолчанию свойства зависимостей.  
  
 Значения, помеченных как набор флагов в `flags` параметр задает логическое значение <xref:System.Windows.FrameworkPropertyMetadata> свойства, которые соответствуют, <xref:System.Windows.FrameworkPropertyMetadataOptions> имя флага `true`. Впоследствии можно изменить значения свойств в метаданных, при условии, что метаданные не были применены к определенной операции системы.  
  
   
  
## Examples  
 В следующем примере вызывается следующую сигнатуру конструктора:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Параметру <paramref name="defaultValue" /> задается значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой значение определенного типа.</param>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с заданными значением по умолчанию и ответом <see cref="T:System.Windows.PropertyChangedCallback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, заданного для `defaultValue` должны соответствовать или относиться к типу, заданному в исходной регистрации применяются эти метаданные свойства зависимостей. Несоответствие между типом значений метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживать, из-за рассогласования не удается обнаружить во время компиляции. В системе свойств не оценивает значение свойства до времени выполнения, поэтому результат несоответствие типов типа или свойства по умолчанию значение — ошибка времени выполнения.  
  
 Значение <xref:System.Windows.DependencyProperty.UnsetValue> имеет особое значение в системе свойств и не может использоваться как значение по умолчанию свойства зависимостей.  
  
   
  
## Examples  
 В следующем примере вызывается следующую сигнатуру конструктора:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Параметру <paramref name="defaultValue" /> задается значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</param>
        <param name="coerceValueCallback">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом вызове <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> для данного свойства.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с указанными ответами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта реализация вызывает базовый инициализатор, а затем добавляет `coerceValueCallback` , задав свойство в базовом экземпляре.  
  
   
  
## Examples  
 В следующем примере вызывается следующую сигнатуру конструктора:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой значение определенного типа.</param>
        <param name="flags">Параметры флагов метаданных (комбинация значений <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Данные параметры определяют характеристики свойства зависимостей, взаимодействующего с системой, такие как структура и привязка данных.</param>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с указанным значением по умолчанию, параметрами метаданных платформы и ответами <see cref="T:System.Windows.PropertyChangedCallback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, заданного для `defaultValue` должны соответствовать или относиться к типу, заданному в исходной регистрации применяются эти метаданные свойства зависимостей. Несоответствие между типом значений метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживать, из-за рассогласования не удается обнаружить во время компиляции. В системе свойств не оценивает значение свойства до времени выполнения, поэтому результат несоответствие типов типа или свойства по умолчанию значение — ошибка времени выполнения.  
  
 Значение <xref:System.Windows.DependencyProperty.UnsetValue> имеет особое значение в системе свойств и не может использоваться как значение по умолчанию свойства зависимостей.  
  
 Значения, помеченных как набор флагов в `flags` параметр задает логическое значение <xref:System.Windows.FrameworkPropertyMetadata> свойства, которые соответствуют, <xref:System.Windows.FrameworkPropertyMetadataOptions> имя флага `true`. По-прежнему можно изменить значения свойств в метаданных, при условии, что метаданные не были применены к определенной операции системы.  
  
   
  
## Examples  
 В следующем примере вызывается следующую сигнатуру конструктора:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Параметру <paramref name="defaultValue" /> задается значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой определенный тип.</param>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</param>
        <param name="coerceValueCallback">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом вызове <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> для данного свойства.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с заданными значением по умолчанию и ответами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, заданного для `defaultValue` должны соответствовать или относиться к типу, заданному в исходной регистрации применяются эти метаданные свойства зависимостей. Несоответствие между типом значений метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживать, из-за рассогласования не удается обнаружить во время компиляции. В системе свойств не оценивает значение свойства до времени выполнения, поэтому результат несоответствие типов типа или свойства по умолчанию значение — ошибка времени выполнения.  
  
 Значение <xref:System.Windows.DependencyProperty.UnsetValue> имеет особое значение в системе свойств и не может использоваться как значение по умолчанию свойства зависимостей.  
  
   
  
## Examples  
 В следующем примере вызывается следующую сигнатуру конструктора:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Параметру <paramref name="defaultValue" /> задается значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой определенный тип.</param>
        <param name="flags">Параметры флагов метаданных (комбинация значений <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Данные параметры определяют характеристики свойства зависимостей, взаимодействующего с системой, такие как структура и привязка данных.</param>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</param>
        <param name="coerceValueCallback">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом вызове <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> против данного свойства.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с указанным значением по умолчанию, параметрами метаданных платформы и ответами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, заданного для `defaultValue` должны соответствовать или относиться к типу, заданному в исходной регистрации применяются эти метаданные свойства зависимостей. Несоответствие между типом значений метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживать, из-за рассогласования не удается обнаружить во время компиляции. В системе свойств не оценивает значение свойства до времени выполнения, поэтому результат несоответствие типов типа или свойства по умолчанию значение — ошибка времени выполнения.  
  
 Значение <xref:System.Windows.DependencyProperty.UnsetValue> имеет особое значение в системе свойств и не может использоваться как значение по умолчанию свойства зависимостей.  
  
 Значения, помеченных как набор флагов в `flags` параметр задает логическое значение <xref:System.Windows.FrameworkPropertyMetadata> свойства, которые соответствуют, <xref:System.Windows.FrameworkPropertyMetadataOptions> имя флага `true`. По-прежнему можно изменить значения свойств в метаданных, при условии, что метаданные не были применены к определенной операции системы.  
  
   
  
## Examples  
 В следующем примере вызывается следующую сигнатуру конструктора:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Параметру <paramref name="defaultValue" /> задается значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой определенный тип.</param>
        <param name="flags">Параметры флагов метаданных (комбинация значений <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Данные параметры определяют характеристики свойства зависимостей, взаимодействующего с системой, такие как структура и привязка данных.</param>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</param>
        <param name="coerceValueCallback">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом вызове <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> данного свойства.</param>
        <param name="isAnimationProhibited">
          Чтобы запретить системе управления свойствами воспроизводить анимацию для свойства, относящегося к данным метаданным, установите <see langword="true" />. Подобные свойства вызывают исключения во время выполнения, проистекающие из системы управления свойствами при попытке применения к ним анимаций. Для разрешения анимации свойства следует установить значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с указанным значением по умолчанию и установками метаданных платформы, указанными ответами и логическим значением, которое может быть использовано для предотвращения анимации свойства.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, заданного для `defaultValue` должны соответствовать или относиться к типу, заданному в исходной регистрации применяются эти метаданные свойства зависимостей. Несоответствие между типом значений метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживать, из-за рассогласования не удается обнаружить во время компиляции. В системе свойств не оценивает значение свойства до времени выполнения, поэтому результат несоответствие типов типа или свойства по умолчанию значение — ошибка времени выполнения.  
  
 Значение <xref:System.Windows.DependencyProperty.UnsetValue> имеет особое значение в системе свойств и не может использоваться как значение по умолчанию свойства зависимостей.  
  
 `isAnimationProhibited` Параметр задает начальное значение <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> свойство объявлено с помощью интерпретации базового <xref:System.Windows.UIPropertyMetadata> класса.  
  
 Значения, помеченных как набор флагов в `flags` параметр задает логическое значение <xref:System.Windows.FrameworkPropertyMetadata> свойства, которые соответствуют, <xref:System.Windows.FrameworkPropertyMetadataOptions> имя флага `true`. По-прежнему можно изменить значения свойств в метаданных, при условии, что метаданные не были применены к определенной операции системы.  
  
   
  
## Examples  
 В следующем примере вызывается следующую сигнатуру конструктора:  
  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Параметру <paramref name="defaultValue" /> задается значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FrameworkPropertyMetadata (object defaultValue, System.Windows.FrameworkPropertyMetadataOptions flags, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, valuetype System.Windows.FrameworkPropertyMetadataOptions flags, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback, bool isAnimationProhibited, valuetype System.Windows.Data.UpdateSourceTrigger defaultUpdateSourceTrigger) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.#ctor(System.Object,System.Windows.FrameworkPropertyMetadataOptions,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback,System.Boolean,System.Windows.Data.UpdateSourceTrigger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FrameworkPropertyMetadata(System::Object ^ defaultValue, System::Windows::FrameworkPropertyMetadataOptions flags, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback, bool isAnimationProhibited, System::Windows::Data::UpdateSourceTrigger defaultUpdateSourceTrigger);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="flags" Type="System.Windows.FrameworkPropertyMetadataOptions" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
        <Parameter Name="isAnimationProhibited" Type="System.Boolean" />
        <Parameter Name="defaultUpdateSourceTrigger" Type="System.Windows.Data.UpdateSourceTrigger" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой определенный тип.</param>
        <param name="flags">Параметры флагов метаданных (комбинация значений <see cref="T:System.Windows.FrameworkPropertyMetadataOptions" />). Данные параметры определяют характеристики свойства зависимостей, взаимодействующего с системой, такие как структура и привязка данных.</param>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика, который система управления свойствами будет вызывать при изменении значения этого свойства.</param>
        <param name="coerceValueCallback">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом вызове <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> против данного свойства.</param>
        <param name="isAnimationProhibited">
          Чтобы запретить системе управления свойствами воспроизводить анимацию для свойства, относящегося к данным метаданным, установите <see langword="true" />. Подобные свойства вызывают исключения во время выполнения, проистекающие из системы управления свойствами при попытке применения к ним анимаций. Значение по умолчанию: <see langword="false" />.</param>
        <param name="defaultUpdateSourceTrigger">
          <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> для использования, когда привязки, примененные к данному свойству имеют <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> со значением <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.FrameworkPropertyMetadata" /> с указанным значением по умолчанию и установками метаданных платформы, указанными ответами, логическим значением, которое может быть использовано для предотвращения анимации свойства и триггером обновления привязки данных по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, заданного для `defaultValue` должны соответствовать или относиться к типу, заданному в исходной регистрации применяются эти метаданные свойства зависимостей. Несоответствие между типом значений метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживать, из-за рассогласования не удается обнаружить во время компиляции. В системе свойств не оценивает значение свойства до времени выполнения, поэтому результат несоответствие типов типа или свойства по умолчанию значение — ошибка времени выполнения.  
  
 Значение <xref:System.Windows.DependencyProperty.UnsetValue> имеет особое значение в системе свойств и не может использоваться как значение по умолчанию свойства зависимостей.  
  
 `isAnimationProhibited` Параметр задает начальное значение <xref:System.Windows.UIPropertyMetadata.IsAnimationProhibited%2A> свойство объявлено с помощью интерпретации базового <xref:System.Windows.UIPropertyMetadata> класса.  
  
 Дополнительные сведения об обновлении поведения источника привязки см. в разделе [Общие сведения о привязке данных](~/docs/framework/wpf/data/data-binding-overview.md).  
  
 Значения, помеченных как набор флагов в `flags` параметр задает логическое значение <xref:System.Windows.FrameworkPropertyMetadata> свойства, которые соответствуют, <xref:System.Windows.FrameworkPropertyMetadataOptions> имя флага `true`. По-прежнему можно изменить значения свойств в метаданных, при условии, что метаданные не были применены к определенной операции системы.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initfpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initfpm)]  
[!code-csharp[PropertyMetadataAPIs#FPMCtor_DV_FPMO_PCC_CVC_IAP_DUST](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#fpmctor_dv_fpmo_pcc_cvc_iap_dust)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Параметру <paramref name="defaultValue" /> задается значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
        <altmember cref="T:System.Windows.PropertyMetadata" />
      </Docs>
    </Member>
    <Member MemberName="AffectsArrange">
      <MemberSignature Language="C#" Value="public bool AffectsArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsArrange { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, может ли свойство зависимостей влиять на порядок размещения во время операций обработчика макета.</summary>
        <value>
          Значение <see langword="true" />, если свойство зависимостей, в котором существуют эти метаданные, может влиять на порядок размещения; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> и <xref:System.Windows.FrameworkContentElement> включает реализацию <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> , отслеживает изменения действующего значения все свойства зависимости, к элементу. В составе этой логики свойств зависимостей, которые изменяют действующее значение и иметь метаданные с <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> значение `true` инициирует запрос отложенное переводимого визуальных элементов для этого элемента (вызов <xref:System.Windows.UIElement.InvalidateArrange%2A>). Так как эта реализация уровня инфраструктуры WPF уже, обычно не требуется искать свойств зависимостей с <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> Если значительно замены или изменения поведения уровня платформы WPF.  
  
 Настраиваемый <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> реализации может выбрать возможность аналогичное поведение для изменения свойств зависимостей где <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> — `true`.  
  
 Свойства классов, производных от <xref:System.Windows.PropertyMetadata> обычно определяются в объектной модели для чтения записи. Это так, что их можно изменить после инициализации экземпляра. Однако после метаданные используются как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, в системе свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми. Попытка задать это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> — `true` на эти метаданные экземпляра вызовет исключение.  
  
<a name="xamlTextUsage_AffectsArrange"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Следующий пример получает метаданные по умолчанию из различных зависимостей поля свойств, значения различных <xref:System.Windows.FrameworkPropertyMetadata> свойства и использует сведения для заполнения таблицы и реализации «обозревателя метаданных».  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsMeasure { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, может ли свойство зависимостей влиять на передачу измерения во время операций обработчика макета.</summary>
        <value>
          Значение <see langword="true" />, если свойство зависимостей, в котором существуют эти метаданные, может влиять на передачу измерения; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> и <xref:System.Windows.FrameworkContentElement> включает реализацию <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> , отслеживает изменения действующего значения все свойства зависимости, к элементу. В составе этой логики свойств зависимостей, которые изменяют действующее значение и иметь метаданные с <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> значение `true` будет инициировать запрос отложенное переводимого визуальных элементов для этого элемента. Так как эта реализация уровня инфраструктуры WPF уже, обычно не требуется искать свойств зависимостей с <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> Если значительно замены или изменения поведения уровня платформы WPF.  
  
 Настраиваемый <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> реализации может выбрать возможность аналогичное поведение для изменения свойств зависимостей где <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> — `true`.  
  
 Свойства классов, производных от <xref:System.Windows.PropertyMetadata> обычно определяются в объектной модели для чтения записи. Это так, что их можно изменить после инициализации экземпляра. Однако после метаданные используются как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, в системе свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми. Попытка задать это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> — `true` на эти метаданные экземпляра вызовет исключение.  
  
<a name="xamlTextUsage_AffectsMeasure"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Следующий пример получает метаданные по умолчанию из различных зависимостей поля свойств, значения различных <xref:System.Windows.FrameworkPropertyMetadata> свойства и использует сведения для заполнения таблицы и реализации «обозревателя метаданных».  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentArrange">
      <MemberSignature Language="C#" Value="public bool AffectsParentArrange { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentArrange" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentArrange As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentArrange { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, может ли свойство зависимостей влиять на передачу размещения разметки родительского элемента во время операций обработчика разметки.</summary>
        <value>
          Значение <see langword="true" />, если свойство зависимостей, в котором существуют метаданные, влияет на передачу размещения непосредственно в родительском элементе; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> и <xref:System.Windows.FrameworkContentElement> включает реализацию <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> , отслеживает изменения действующего значения все свойства зависимости, к элементу. В составе этой логики свойств зависимостей, которые изменяют действующее значение и иметь метаданные с <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> значение `true` будет инициировать запрос отложенное переводимого визуальных элементов для родительского элемента.  
  
 Как правило, не требуется для изменения отчета <xref:System.Windows.FrameworkElement> свойство с родительским элементом с помощью <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> поскольку сам элемент должен уже иметь свой собственный <xref:System.Windows.FrameworkPropertyMetadata.AffectsArrange%2A> как `true`. Обычно этого достаточно, поскольку изменения в дочернем элементе инициируют в родительском, когда это необходимо. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> Иногда используются для <xref:System.Windows.FrameworkContentElement> производного класса. В этом случае элемент дочерние наборы свойство, но элемент <xref:System.Windows.FrameworkContentElement> производного класса не контролирует собственное воспроизведение. Выполняет отрисовку <xref:System.Windows.FrameworkElement> родительского элемента, который служит в качестве узла содержимого. Например, изменение значения из <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> делает недействительными вложенное свойство дочерним элементом упорядочивания родительского элемента, поскольку необходимо изменить позицию дочернего элемента в родительском объекте. Таким образом <xref:System.Windows.Documents.FixedPage.Left%2A?displayProperty=nameWithType> присоединенное свойство имеет метаданных где <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> — `true`. Еще один пример — <xref:System.Windows.Controls.Control.Padding%2A>; при изменении этого свойства, родительский может изменить позицию дочернего элемента, в зависимости от доступного пространства.  
  
 Так как эта реализация уровня инфраструктуры WPF уже, обычно не требуется искать свойств зависимостей с <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> Если значительно замены или изменения поведения уровня платформы WPF.  
  
 Настраиваемый <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> реализации может выбрать возможность аналогичное поведение для изменения свойств зависимостей где <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentArrange%2A> — `true`.  
  
 Свойства для какого-либо классы, унаследованные от <xref:System.Windows.PropertyMetadata> обычно определяются в объектной модели для чтения записи. Это так, что их можно изменить после инициализации экземпляра. Однако после метаданные используются как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, в системе свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми. Попытка задать это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> — `true` на эти метаданные экземпляра вызовет исключение.  
  
<a name="xamlTextUsage_AffectsParentArrange"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsParentMeasure">
      <MemberSignature Language="C#" Value="public bool AffectsParentMeasure { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsParentMeasure" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsParentMeasure As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsParentMeasure { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, может ли свойство зависимостей потенциально влиять на передачу показателей разметки родительского элемента во время операций обработчика разметки.</summary>
        <value>
          Значение <see langword="true" />, если свойство зависимостей, в котором существуют метаданные, влияет на передачу измерений непосредственно на родительском элементе; в противном случае — значение <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> и <xref:System.Windows.FrameworkContentElement> включает реализацию <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> , отслеживает изменения действующего значения все свойства зависимости, к элементу. В составе этой логики свойств зависимостей, которые изменяют действующее значение и иметь метаданные с <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> значение `true` будет инициировать запрос отложенное переводимого визуальных элементов для родительского элемента. Так как эта реализация уровня инфраструктуры WPF уже, обычно не требуется искать свойств зависимостей с <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> Если значительно замены или изменения поведения уровня платформы WPF.  
  
 Как правило, не требуется для изменения отчета <xref:System.Windows.FrameworkElement> свойство с родительским элементом с помощью <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> поскольку сам элемент должен уже иметь свой собственный <xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A> как `true`. Это обычно достаточно, поскольку изменения в дочернем элементе инициируют меру передачи в родительском, когда это необходимо. <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> Иногда используются для <xref:System.Windows.FrameworkContentElement> производного класса. В этом случае элемент дочерние наборы свойство, но элемент <xref:System.Windows.FrameworkContentElement> производного класса не контролирует собственное воспроизведение. Выполняет отрисовку <xref:System.Windows.FrameworkElement> родительского элемента, который служит в качестве узла содержимого. Например, изменение значения из <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> свойство дочерним элементом делает недействительными измерения родительского элемента, поскольку относительные интервалы абзацев может изменять и может увеличить или уменьшить размер содержимого узла. Таким образом <xref:System.Windows.Documents.Paragraph.KeepWithNext%2A?displayProperty=nameWithType> свойство имеет метаданных где <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> — `true`.  
  
 Элементы содержимого узла также часто поиск изменений в свойствах зависимостей где <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> — `true`, как часть логики отрисовки содержимого узла. Например <xref:System.Windows.Controls.TextBox> элемент должен отвечать на определенных изменений в текст, который может оказаться необходимым, ограничивающего прямоугольника <xref:System.Windows.Controls.TextBox> изменить сам.  
  
 Настраиваемый <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> реализации может выбрать возможность аналогичное поведение для изменения свойств зависимостей где <xref:System.Windows.FrameworkPropertyMetadata.AffectsParentMeasure%2A> — `true`.  
  
 Свойства для какого-либо классы, унаследованные от <xref:System.Windows.PropertyMetadata> обычно определяются в объектной модели для чтения записи. Это так, что их можно изменить после инициализации экземпляра. Однако после метаданные используются как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, в системе свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми. Попытка задать это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> — `true` на эти метаданные экземпляра вызовет исключение.  
  
<a name="xamlTextUsage_AffectsParentMeasure"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="AffectsRender">
      <MemberSignature Language="C#" Value="public bool AffectsRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AffectsRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" />
      <MemberSignature Language="VB.NET" Value="Public Property AffectsRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AffectsRender { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, может ли свойство зависимостей влиять на общий макет таким способом, который не оказывает специального воздействия на расположение или размеры, но требует перерисовку.</summary>
        <value>
          <see langword="true" /> если свойство зависимостей, содержащие эти метаданные, влияет на отрисовку; иначе — <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.FrameworkElement> и <xref:System.Windows.FrameworkContentElement> включает реализацию <xref:System.Windows.FrameworkElement.OnPropertyChanged%2A> , отслеживает изменения действующего значения все свойства зависимости, к элементу. В составе этой логики свойств зависимостей, которые изменяют действующее значение и иметь метаданные с <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> значение `true` будет инициировать запрос отложенное переводимого визуальных элементов для этого элемента. Так как эта реализация уровня инфраструктуры WPF уже, обычно не требуется искать свойств зависимостей с <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> Если значительно замены или изменения поведения уровня платформы WPF.  
  
 Настраиваемый <xref:System.Windows.DependencyObject.OnPropertyChanged%2A> реализации может выбрать возможность аналогичное поведение для изменения свойств зависимостей где <xref:System.Windows.FrameworkPropertyMetadata.AffectsRender%2A> — `true`.  
  
 Свойства для какого-либо классы, унаследованные от <xref:System.Windows.PropertyMetadata> обычно определяются в объектной модели для чтения записи. Это так, что их можно изменить после инициализации экземпляра. Однако после метаданные используются как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, в системе свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми. Попытка задать это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> — `true` на эти метаданные экземпляра вызовет исключение.  
  
<a name="xamlTextUsage_AffectsRender"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Следующий пример получает метаданные по умолчанию из различных зависимостей поля свойств, значения различных <xref:System.Windows.FrameworkPropertyMetadata> свойства и использует сведения для заполнения таблицы и реализации «обозревателя метаданных».  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="BindsTwoWayByDefault">
      <MemberSignature Language="C#" Value="public bool BindsTwoWayByDefault { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool BindsTwoWayByDefault" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault" />
      <MemberSignature Language="VB.NET" Value="Public Property BindsTwoWayByDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool BindsTwoWayByDefault { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, создает ли свойство двухсторонние привязки по умолчанию.</summary>
        <value>
          <see langword="true" /> Если свойство зависимостей, в котором существуют эти метаданные, создает двухсторонние привязки по умолчанию. в противном случае <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В отсутствие того, что это свойство `true`, обновления привязки являются односторонними по умолчанию, в зависимости от поведения по умолчанию <xref:System.Windows.Data.Binding> конструкторы или аналогичной [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] синтаксиса.  
  
 В существующих элементов, обычно можно найти это свойство установлено в `true` в метаданных для свойства зависимостей, что отчет состояния и могут быть изменены с помощью пользователя, например <xref:System.Windows.Controls.Primitives.Selector.IsSelected%2A?displayProperty=nameWithType>.  
  
 Это свойство сообщает только об характеристиках обновления привязки по умолчанию для свойства зависимостей в целом. Любая привязка, значение этого свойства в экземпляре локально можно задать <xref:System.Windows.Data.Binding.Mode%2A> свойства привязки и изменить параметры по умолчанию.  
  
 Свойства для какого-либо классы, унаследованные от <xref:System.Windows.PropertyMetadata> обычно определяются в объектной модели для чтения записи. Это так, что их можно изменить после инициализации экземпляра. Однако после метаданные используются как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, в системе свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми. Попытка задать это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> — `true` на эти метаданные экземпляра вызовет исключение.  
  
<a name="xamlTextUsage_BindsTwoWayByDefault"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Следующий пример получает метаданные по умолчанию из различных зависимостей поля свойств, значения различных <xref:System.Windows.FrameworkPropertyMetadata> свойства и использует сведения для заполнения таблицы и реализации «обозревателя метаданных».  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="DefaultUpdateSourceTrigger">
      <MemberSignature Language="C#" Value="public System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Data.UpdateSourceTrigger DefaultUpdateSourceTrigger" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.DefaultUpdateSourceTrigger" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultUpdateSourceTrigger As UpdateSourceTrigger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Data::UpdateSourceTrigger DefaultUpdateSourceTrigger { System::Windows::Data::UpdateSourceTrigger get(); void set(System::Windows::Data::UpdateSourceTrigger value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Data.UpdateSourceTrigger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение по умолчанию для <see cref="T:System.Windows.Data.UpdateSourceTrigger" />, который используется при привязке свойства к которому применены данные метаданные, с <see cref="T:System.Windows.Data.UpdateSourceTrigger" /> имеющими значение <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</summary>
        <value>Значение перечисления, кроме как <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойства классов, производных от <xref:System.Windows.PropertyMetadata> обычно определяются в объектной модели для чтения записи. Это так, что их можно изменить после инициализации экземпляра. Однако после метаданные используются как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, в системе свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми. Попытка задать это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> — `true` на эти метаданные экземпляра вызовет исключение.  
  
<a name="xamlTextUsage_DefaultUpdateSourceTrigger"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Данному свойству присвоено значение <see cref="F:System.Windows.Data.UpdateSourceTrigger.Default" />; указанное значение будет считаться значением по умолчанию при получении запросов от привязок.</exception>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
      </Docs>
    </Member>
    <Member MemberName="Inherits">
      <MemberSignature Language="C#" Value="public bool Inherits { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Inherits" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Inherits" />
      <MemberSignature Language="VB.NET" Value="Public Property Inherits As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Inherits { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, которое указывает, наследуется ли значение свойства зависимостей.</summary>
        <value>
          Значение <see langword="true" />, если значение свойства может быть унаследовано; в противном случае — <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Наследование значения свойства — это функция [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] системы свойств на уровне framework WPF, при котором некоторые свойства зависимостей можно локально установлены на элементе близка к корневой [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] элемент дерева и их показатель наследуются все элементы в логическом дереве дочерние элементы, которые также обладают этим свойством. Наследование значения свойства не включен по умолчанию, и его подключение имеет некоторые последствия для производительности. Подробнее см. в разделе [Наследование значения свойства](~/docs/framework/wpf/advanced/property-value-inheritance.md).  
  
> [!NOTE]
>  Несмотря на то, что наследование значения свойства могут быть выполнены для неприсоединенных свойств зависимости, поведение наследования для неприсоединенного свойства в определенных разделов объект в дереве среды выполнения не определено. Всегда используйте <xref:System.Windows.DependencyProperty.RegisterAttached%2A> для регистрации свойства, где указываются <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> в метаданных.  
  
 Свойства классов, производных от <xref:System.Windows.PropertyMetadata> обычно определяются в объектной модели для чтения записи. Это так, что их можно изменить после инициализации экземпляра. Однако после метаданные используются как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, в системе свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми. Попытка задать это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> — `true` на эти метаданные экземпляра вызовет исключение.  
  
<a name="xamlTextUsage_Inherits"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Следующий пример получает метаданные по умолчанию из различных зависимостей поля свойств, значения различных <xref:System.Windows.FrameworkPropertyMetadata> свойства и использует сведения для заполнения таблицы и реализации «обозревателя метаданных».  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsDataBindingAllowed">
      <MemberSignature Language="C#" Value="public bool IsDataBindingAllowed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDataBindingAllowed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDataBindingAllowed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDataBindingAllowed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, поддерживается ли привязка данных для свойства зависимостей.</summary>
        <value>
          <see langword="true" /> если привязка данных поддерживается для свойства зависимостей, к которому применяются эти метаданные; иначе — <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство сообщает `false` для одного из двух возможных условий: привязка данных к свойству зависимостей запрещено, так как свойство зависимостей является доступным только для чтения (как указано в идентификатор свойства зависимостей не метаданных), либо значение другое свойство метаданных, <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>, равно `true` в метаданных. Это свойство предоставляется для удобства, чтобы вызывающие объекты не нужно проверять оба <xref:System.Windows.DependencyProperty.ReadOnly%2A> и <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>.  
  
 Если вы пытаетесь создать метаданные, указывающее, что в противном случае свойство чтения/записи не должны поддерживать привязку данных, укажите флаг <xref:System.Windows.FrameworkPropertyMetadataOptions.NotDataBindable> (Обратите внимание, небольшая разница соглашение об именовании и <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>).  
  
<a name="xamlTextUsage_IsDataBindingAllowed"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
   
  
## Examples  
 Следующий пример получает метаданные по умолчанию из различных зависимостей поля свойств, значения различных <xref:System.Windows.FrameworkPropertyMetadata> свойства и использует сведения для заполнения таблицы и реализации «обозревателя метаданных».  
  
 [!code-csharp[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#dpgetmetadatasingle)]
 [!code-vb[PropertySystemEsoterics#DPGetMetadataSingle](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#dpgetmetadatasingle)]  
[!code-csharp[PropertySystemEsoterics#FPMProperties](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertySystemEsoterics/CSharp/XAMLAPP/page2.xaml.cs#fpmproperties)]
[!code-vb[PropertySystemEsoterics#FPMProperties](~/samples/snippets/visualbasic/VS_Snippets_Wpf/PropertySystemEsoterics/visualbasic/xamlapp/page2.xaml.vb#fpmproperties)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="IsNotDataBindable">
      <MemberSignature Language="C#" Value="public bool IsNotDataBindable { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotDataBindable" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable" />
      <MemberSignature Language="VB.NET" Value="Public Property IsNotDataBindable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotDataBindable { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, которое указывает, поддерживает ли свойство зависимостей привязку данных.</summary>
        <value>
          Значение <see langword="true" />, если свойство поддерживает привязку данных; в противном случае — <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что это свойство метаданных имеет значение `true` для свойств, которые не должны поддерживать привязку данных, вне зависимости от свойств чтения и записи. Ожидается, что в большинстве случаев, где объявлен свойство зависимостей привязку данных требуется, так как привязка данных является одним из основных сценариев, когда полезно свойством зависимостей. В отличие от <xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>, при этом не меняется только значение по умолчанию, можно изменить позже на конкретной привязки. Задание этого свойства `true` в метаданных для свойства зависимостей метаданных отключит все привязки применение значений посредством выражений к свойству зависимостей.  
  
 Свойства зависимости только для чтения не поддерживают привязку данных (из-за наличия нет метода задания свойства, можно применить измененные значения), но отчет будет по-прежнему `false` для <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A>. Это так, как свойства, которые соответствуют <xref:System.Windows.FrameworkPropertyMetadataOptions> сообщают четность с как метаданные были фактически установлены, вместо того чтобы всегда reporting результирующем поведении, именование свойство может подразумеваться значения. Чтобы определить, допускает ли указанному свойству зависимостей привязку данных, обычно следует проверить <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> вместо него. <xref:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed%2A> — удобный метод для проверки и <xref:System.Windows.DependencyProperty.ReadOnly%2A> и <xref:System.Windows.FrameworkPropertyMetadata.IsNotDataBindable%2A> в ходе одной операции, возвращая ожидаемый результат.  
  
 Свойства классов, производных от <xref:System.Windows.PropertyMetadata> обычно определяются в объектной модели для чтения записи. Это так, что их можно изменить после инициализации экземпляра. Однако после метаданные используются как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, в системе свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми. Попытка задать это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> — `true` на эти метаданные экземпляра вызовет исключение.  
  
<a name="xamlTextUsage_IsNotDataBindable"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="P:System.Windows.FrameworkPropertyMetadata.IsDataBindingAllowed" />
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="Journal">
      <MemberSignature Language="C#" Value="public bool Journal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Journal" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.Journal" />
      <MemberSignature Language="VB.NET" Value="Public Property Journal As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Journal { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, содержит ли это свойство сведения о ведении журнала, которые приложения могут или должны хранить как часть реализации процесса ведения журнала.</summary>
        <value>
          <see langword="true" /> Если ведение журнала, которые следует выполнить для свойства зависимостей, к которому применяются эти метаданные в противном случае <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Свойства классов, производных от <xref:System.Windows.PropertyMetadata> обычно определяются в объектной модели для чтения записи. Это так, что их можно изменить после инициализации экземпляра. Однако после метаданные используются как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, в системе свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми. Попытка задать это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> — `true` на эти метаданные экземпляра вызовет исключение.  
  
<a name="xamlTextUsage_Journal"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
        <altmember cref="T:System.Windows.Navigation.JournalEntry" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected override void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">Базовые метаданные для слияния.</param>
        <param name="dp">Свойство зависимостей, к которому применяются эти метаданные.</param>
        <summary>Обеспечивает слияние исходных метаданных с базовыми.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется внутренне при переопределении метаданных.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Классы, производные от <see cref="T:System.Windows.PropertyMetadata" /> (или данный класс в особенности) должны переопределять этот метод для учетной записи для всех свойств метаданных, добавленных в их реализации. Например, для реализации могут быть добавлены новое значение флагового перечисления и <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> реализации должна быть возможность правильно объединить эти флаги.  
  
 Всегда вызовите базовую реализацию до свою собственную реализацию, так как базовая реализация берет на себя все свойства, которые уже определены на предыдущих типов в иерархии.  
  
 Поведение, добавленные <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> реализацию в <see cref="T:System.Windows.FrameworkPropertyMetadata" /> том, что определенные свойства уровня платформы WPF в метаданных, таких как <see cref="P:System.Windows.FrameworkPropertyMetadata.AffectsRender" /> объединяются в побитовой операции или операции.  
  
 <see cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> Поведение также реализует поведение при переопределении метаданные свойства для существующего свойства зависимостей, вызвав <see cref="M:System.Windows.DependencyProperty.OverrideMetadata(System.Type,System.Windows.PropertyMetadata)" />., с помощью переопределения метаданных, <see cref="T:System.Windows.FrameworkPropertyMetadata" />.</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected override void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.FrameworkPropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">Свойство зависимостей, к которому были применены эти метаданные.</param>
        <param name="targetType">Тип, связанный с этими метаданными, если это метаданные зависящие от типа. В случае с метаданными по умолчанию, значение может быть <see langword="null" />.</param>
        <summary>Вызывается после применения данных метаданных к свойству, указывая на запечатывание метаданных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все изменения структуры данных <xref:System.Windows.FrameworkPropertyMetadata> экземпляр должен быть помечен как неизменяемое при вызове этого метода.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.FrameworkPropertyMetadata" /> Реализация этого метода не выполняет никаких действий после вызова базовой реализации.</para>
        </block>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
        <altmember cref="P:System.Windows.PropertyMetadata.IsSealed" />
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OverridesInheritanceBehavior">
      <MemberSignature Language="C#" Value="public bool OverridesInheritanceBehavior { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool OverridesInheritanceBehavior" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior" />
      <MemberSignature Language="VB.NET" Value="Public Property OverridesInheritanceBehavior As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool OverridesInheritanceBehavior { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, должно ли вычисление наследования значения свойства охватывать определенные границы содержимого в логическом дереве элементов.</summary>
        <value>
          <see langword="true" /> если наследование значения свойства распространяться по определенным вместителям содержимого; иначе — <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эти метаданные сообщают редких изменениях поведения наследования значения свойства через границы элемента специальный родительский элемент потомок. Типичный пример таких границы — содержимое <xref:System.Windows.Controls.Frame>, где <xref:System.Windows.Controls.Frame> содержимое может получить перезагружен независимо от наличия <xref:System.Windows.Controls.Frame>. Поведение системы нужного свойства заключается в том, что наследование значения свойства следует не передаются в содержимое <xref:System.Windows.Controls.Frame>, так как им могут быть элементы, которые размещения фрейма приложения не владеете или управляете. Указывать метаданные с <xref:System.Windows.FrameworkPropertyMetadata.OverridesInheritanceBehavior%2A> значение `true`, а также как указание <xref:System.Windows.FrameworkPropertyMetadata.Inherits%2A> как `true`, приведет к свойство, к которому применяется метаданные к наследуемому даже через <xref:System.Windows.Controls.Frame> границ или аналогичные границы.  
  
 Свойства классов, производных от <xref:System.Windows.PropertyMetadata> обычно определяются в объектной модели для чтения записи. Это так, что их можно изменить после инициализации экземпляра. Однако после метаданные используются как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, в системе свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми. Попытка задать это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> — `true` на эти метаданные экземпляра вызовет исключение.  
  
<a name="xamlTextUsage_OverridesInheritanceBehavior"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.FrameworkPropertyMetadataOptions" />
      </Docs>
    </Member>
    <Member MemberName="SubPropertiesDoNotAffectRender">
      <MemberSignature Language="C#" Value="public bool SubPropertiesDoNotAffectRender { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="DocId" Value="P:System.Windows.FrameworkPropertyMetadata.SubPropertiesDoNotAffectRender" />
      <MemberSignature Language="VB.NET" Value="Public Property SubPropertiesDoNotAffectRender As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool SubPropertiesDoNotAffectRender { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, влияют ли подсвойства свойства зависимостей на отрисовку вмещающего объекта.</summary>
        <value>
          <see langword="true" /> в случае, если изменения в подсвойствах не влияют на отрисовку; иначе — <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот параметр метаданные относятся к свойствам зависимостей, которые являются ссылочными типами, где тип имеет собственные значения свойств. Как правило логика системы структуры — предполагается, что любое свойство зависимостей с подсвойств потенциально влияет на структуру, так как проверка всех подсвойств изменения занимает больше времени чем другой прохода отрисовки. Установка данного параметра равным `true` полезен для оптимизации производительности реализации системы макета уровня платформы WPF.  
  
 Свойства классов, производных от <xref:System.Windows.PropertyMetadata> обычно определяются в объектной модели для чтения записи. Это так, что их можно изменить после инициализации экземпляра. Тем не менее когда метаданные используются как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, в системе свойств будет запечатать этот экземпляр метаданных и свойств, которые передают особенности метаданные теперь считаются неизменяемыми. Попытка задать это свойство после <xref:System.Windows.PropertyMetadata.IsSealed%2A> — `true` на эти метаданные экземпляра вызовет исключение.  
  
<a name="xamlTextUsage_SubPropertiesDoNotAffectRender"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого класса обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Метаданные уже применены к операции свойства зависимостей. Поэтому метаданные запечатаны, а их свойства нельзя задать.</exception>
        <altmember cref="T:System.Windows.Freezable" />
      </Docs>
    </Member>
  </Members>
</Type>