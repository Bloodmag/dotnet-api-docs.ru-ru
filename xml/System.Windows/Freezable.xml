<Type Name="Freezable" FullName="System.Windows.Freezable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c125d54ad21fa44be59bb03c1e4d67d257a48fed" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30680388" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Freezable : System.Windows.DependencyObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Freezable extends System.Windows.DependencyObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Freezable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Freezable&#xA;Inherits DependencyObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class Freezable abstract : System::Windows::DependencyObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.DependencyObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Определяет объект, имеющий изменяемое состояние и состояние только для чтения (зафиксированное). Классы, которые являются производными от класса <see cref="T:System.Windows.Freezable" />, создают подробные уведомления об изменениях, могут быть фиксированными, а также могут копировать себя.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable> Класс предоставляет специальные функции, которые могут помочь повысить производительность приложений при работе с объектами, которые трудно изменить или скопировать. Примеры <xref:System.Windows.Freezable> объектам относятся следующие:  
  
-   <xref:System.Windows.Media.Brush>  
  
-   <xref:System.Windows.Media.Pen>  
  
-   <xref:System.Windows.Media.Geometry>  
  
-   <xref:System.Windows.Media.Transform>  
  
-   <xref:System.Windows.Media.Animation.AnimationTimeline>  
  
## <a name="deriving-from-freezable"></a>Наследование от Freezable  
 Класс, производный от <xref:System.Windows.Freezable> поддерживает следующие функции:  
  
-   Особые состояния: состояние только для чтения (фиксированное) и состояние для записи.  
  
-   Потокобезопасность: зафиксированный <xref:System.Windows.Freezable> объект может использоваться несколькими потоками.  
  
-   Подробные уведомления об изменениях: в отличие от других <xref:System.Windows.DependencyObject> объектов, <xref:System.Windows.Freezable> объект предоставляет уведомления об изменениях в случае изменения значений подсвойств.  
  
-   Удобное клонирование: класс Freezable уже реализован несколько методов, которые обеспечивают большую глубину клонирования.  
  
 Дополнительные сведения об использовании и создание собственных <xref:System.Windows.Freezable> объектов, в разделе [Freezable Общие сведения об объектах](~/docs/framework/wpf/advanced/freezable-objects-overview.md).  
  
 ]]></format>
    </remarks>
    <threadsafe>Любые открытые <see langword="static" /> члены этого типа являются потокобезопасными. Потокобезопасность членов экземпляров не гарантируется.  
  
 Когда <see cref="P:System.Windows.Freezable.IsFrozen" /> свойство <see langword="false" />, <see cref="T:System.Windows.Freezable" /> объектов может осуществляться только из потока, в котором он был создан. Попытка доступа к нему из другой поток вызывает исключение <see cref="T:System.InvalidOperationException" />. <see cref="Overload:System.Windows.Threading.Dispatcher.Invoke" /> И <see cref="Overload:System.Windows.Threading.Dispatcher.BeginInvoke" /> методы обеспечивают поддержку маршалинга в нужный поток.  
  
 При их <see cref="P:System.Windows.Freezable.IsFrozen" /> свойство <see langword="true" />, <see cref="T:System.Windows.Freezable" /> объекты, в режиме свободного потока.  Дополнительные сведения см. в разделе [Общие сведения об объектах класса Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).</threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Freezable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Freezable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр производного класса <see cref="T:System.Windows.Freezable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это защищенный конструктор абстрактного класса.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CanFreeze">
      <MemberSignature Language="C#" Value="public bool CanFreeze { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanFreeze" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.CanFreeze" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CanFreeze As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool CanFreeze { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, которое указывает, можно ли сделать объект неизменяемым.</summary>
        <value>
          Значение <see langword="true" />, если текущий объект можно сделать нередактируемым или он уже является нередактируемым. В противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>В этой реализации метода используется <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> метод с <paramref name="isChecking" /> значение <see langword="true" /> для определения ли <see cref="T:System.Windows.Freezable" /> можно сделать неизменяемым. Чтобы изменить способ, это свойство действует в производном классе, переопределять <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> метод.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Changed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Freezable.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Changed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда изменяется класс <see cref="T:System.Windows.Freezable" /> или объект, который входит в его состав.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При попытке добавления или удаления обработчиков событий, если текущий объект не является изменяемым (когда <xref:System.Windows.Freezable.IsFrozen%2A> свойство `true`), создается исключение.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ Clone();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает редактируемую копию объекта <see cref="T:System.Windows.Freezable" />, что позволяет выполнить глубокое копирование значений объекта. При копировании свойств зависимостей объекта этот метод копирует выражения (которые могут уже не быть разрешимыми), но не копирует анимации и их текущие значения.</summary>
        <returns>Изменяемая копия текущего объекта. Свойство <see cref="P:System.Windows.Freezable.IsFrozen" /> клонированного объекта имеет значение <see langword="false" />, даже если свойство <see cref="P:System.Windows.Freezable.IsFrozen" /> исходного объекта имеет значение <see langword="true." />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable.Clone%2A> И <xref:System.Windows.Freezable.CloneCurrentValue%2A> методы производят изменяемые клоны замороженный <xref:System.Windows.Freezable> объектов (методы также клонировать <xref:System.Windows.Freezable> объекты, которые не зафиксированы). Копия является глубокую копию текущего объекта.  
  
 В следующей таблице приведены различия между <xref:System.Windows.Freezable.Clone%2A> и <xref:System.Windows.Freezable.CloneCurrentValue%2A> методы.  
  
|Действие|Поведение методов клонирования|Поведение методов CloneCurrentValue|  
|------------|---------------------------|---------------------------------------|  
|Копирует свойство зависимостей, которое содержит выражение|Выражение копируется, но больше не может разрешить. Дополнительные сведения см. в разделе [Общие сведения об объектах класса Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|Копируется текущее значение выражения, но не само выражение.|  
|Копирование анимированное свойство зависимостей|Копируются базовые (без анимации) значения этого свойства. Анимации не копируются.|Копируется текущее значение анимируемого свойства. Анимации не копируются.|  
  
 Обратите внимание, что неопределенные свойства не копируются. Если не задано свойство имеет значение по умолчанию, который является замороженный <xref:System.Windows.Freezable>, что значение свойства остается фиксированным, в противном случае редактируется.  
  
## <a name="move-a-freezable-between-threads"></a>Перемещение фиксированного объекта между потоками  
 Этот метод можно использовать для перемещения <xref:System.Windows.Freezable> между потоками. Во-первых, <xref:System.Windows.Freezable> неизменяемым путем вызова его <xref:System.Windows.Freezable.Freeze%2A> метод. Теперь можно получить доступ к другим потоком <xref:System.Windows.Freezable> и сделать локальным <xref:System.Windows.Freezable.Clone%2A> , можно получить доступ.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Этот метод использует <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> для создания клона. Чтобы изменить поведение этого метода в производном классе, переопределять <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" /> метод.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Объект, используемый для клонирования.</param>
        <summary>Делает экземпляр клоном (глубокой копией) указанного объекта <see cref="T:System.Windows.Freezable" />, используя базовые (без анимации) значения свойств.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается методом <xref:System.Windows.Freezable.Clone%2A> метода и не должен вызываться напрямую из кода приложения, за исключением того, при вызове базовой реализации при переопределении этого метода. Чтобы создать изменяемую копию текущего объекта, вызовите <xref:System.Windows.Freezable.Clone%2A> вместо непосредственного вызова данного метода.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Если вы наследуете от <see cref="T:System.Windows.Freezable" />, может потребоваться переопределить этот метод. Возможны следующие причины для переопределения:  
  
-   Производный класс включает данные, которые не предоставляются через свойства зависимостей.  
  
-   Производный класс должен работать дополнительную инициализацию, не могут быть реализованы путем простого переопределения <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Например, это происходит, если производный класс реализует <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
 Классы, сохранять все свои данные в свойствах зависимостей и, не обязательно для выполнения дополнительных инициализации не обязательно должны переопределить <see cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />.  
  
 Очень важно, что все реализации вызывать базовую реализацию этого метода. Реализации должны выполнять работу, выполняемую с помощью реализации по умолчанию не только. Реализация по умолчанию создает глубокие копии все записи, локально заданного свойства, включая внутренние выражения.  
  
 Если объект имеет свойства зависимостей, связанные с данными, выражения копируются, но могут уже не быть разрешимыми. Дополнительные сведения о клонировании объектов с привязкой к данным см. в разделе [Freezable Общие сведения об объектах](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Если объект имеет анимированные свойства зависимостей, копируется базовое значение этих свойств (без анимации). Анимации не копируются.  
  
 Обратите внимание, что неопределенные свойства не копируются, а также доступны только для чтения. Если это свойство имеет значение по умолчанию, которое является замороженный <see cref="T:System.Windows.Freezable" />, что значение свойства остается фиксированным, в противном случае редактируется.  
  
 В следующем списке перечислены ожидаемое поведение данного метода:  
  
-   Создается копия содержит копии всех <see cref="T:System.Windows.Freezable" /> подчиненных объектах.  
  
-   Свойства не задано и только для чтения, не копируются.  
  
-   Выражения копируются.  
  
-   Ни один из этих вложенных объектов не является фиксированным при создании.  
  
-   Сама копия не является фиксированной.  
  
-   Анимации не копируются.  
  
-   Только базовые значения свойств, скопированной, а не текущие анимированные значения.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValue">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable CloneCurrentValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable CloneCurrentValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValue" />
      <MemberSignature Language="VB.NET" Value="Public Function CloneCurrentValue () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ CloneCurrentValue();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает редактируемую копию (глубокую копию) объекта <see cref="T:System.Windows.Freezable" /> с использованием его текущих значений.</summary>
        <returns>Изменяемая копия текущего объекта. Свойство <see cref="P:System.Windows.Freezable.IsFrozen" /> клонированного объекта имеет значение <see langword="false" />, даже если свойство <see cref="P:System.Windows.Freezable.IsFrozen" /> исходного объекта имеет значение <see langword="true." />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Freezable.Clone%2A> И <xref:System.Windows.Freezable.CloneCurrentValue%2A> методы производят изменяемые клоны замороженный <xref:System.Windows.Freezable> объектов (методы также клонировать <xref:System.Windows.Freezable> объекты, которые не зафиксированы). Копия является глубокую копию текущего объекта.  
  
 В следующей таблице приведены различия между <xref:System.Windows.Freezable.Clone%2A> и <xref:System.Windows.Freezable.CloneCurrentValue%2A> методы.  
  
|Действие|Поведение методов клонирования|Поведение методов CloneCurrentValue|  
|------------|---------------------------|---------------------------------------|  
|Копирует свойство зависимостей, которое содержит выражение|Выражение копируется, но больше не может разрешить. Дополнительные сведения см. в разделе [Общие сведения об объектах класса Freezable](~/docs/framework/wpf/advanced/freezable-objects-overview.md).|Копируется текущее значение выражения, но не само выражение.|  
|Копирование анимированное свойство зависимостей|Копируются базовые (без анимации) значения этого свойства. Анимации не копируются.|Копируется текущее значение анимируемого свойства. Анимации не копируются.|  
  
 Обратите внимание, что неопределенные свойства не копируются. Если не задано свойство имеет значение по умолчанию, который является замороженный <xref:System.Windows.Freezable>, что значение свойства остается фиксированным, в противном случае редактируется.  
  
## <a name="move-a-freezable-between-threads"></a>Перемещение фиксированного объекта между потоками  
 Этот метод можно использовать для перемещения <xref:System.Windows.Freezable> между потоками. Во-первых, <xref:System.Windows.Freezable> неизменяемым с помощью его <xref:System.Windows.Freezable.Freeze%2A> метод. Теперь можно получить доступ к другим потоком <xref:System.Windows.Freezable> и сделать локальный клон, можно получить доступ.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Этот метод использует <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> метод для создания клона; <see cref="T:System.Windows.Freezable" /> разработчиков, переопределите <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" /> необходимо убедиться, что копия не зафиксировано в момент создания.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="CloneCurrentValueCore">
      <MemberSignature Language="C#" Value="protected virtual void CloneCurrentValueCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void CloneCurrentValueCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub CloneCurrentValueCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void CloneCurrentValueCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Элемент привязки <see cref="T:System.Windows.Freezable" />, точную копию которого необходимо создать.</param>
        <summary>Создает экземпляр редактируемой копии (глубокой копии) заданного объекта <see cref="T:System.Windows.Freezable" />, используя текущие значения свойства.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается методом <xref:System.Windows.Freezable.CloneCurrentValue%2A> метода и не должен вызываться напрямую из кода приложения, за исключением того, при вызове базовой реализации при переопределении этого метода. Чтобы создать изменяемую копию текущего объекта, вызовите <xref:System.Windows.Freezable.CloneCurrentValue%2A> вместо непосредственного вызова данного метода.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Если вы наследуете от <see cref="T:System.Windows.Freezable" />, может потребоваться переопределить этот метод. Возможны следующие причины для переопределения:  
  
-   Производный класс включает данные, которые не предоставляются через свойства зависимостей.  
  
-   Производный класс должен работать дополнительную инициализацию, не могут быть реализованы путем простого переопределения <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Например, это происходит, если производный класс реализует <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
 Классы, сохранять все свои данные в свойствах зависимостей и, не обязательно для выполнения дополнительных инициализации не обязательно должны переопределить <see cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />.  
  
 Очень важно, что все реализации вызывать базовую реализацию этого метода. Реализации должны выполнять работу, выполняемую с помощью реализации по умолчанию не только. Реализация по умолчанию создает глубокие копии все записи, локально заданного свойства. Если объект содержит свойства зависимостей с выражениями (например, привязка данных), но не само выражение копируется текущее значение выражения.  
  
 Если объект имеет анимированные свойства зависимостей, копируется текущее значение анимируемого этих свойств, но не сами анимации.  
  
 Обратите внимание, что неопределенные свойства не копируются, а также доступны только для чтения. Если это свойство имеет значение по умолчанию, которое является замороженный <see cref="T:System.Windows.Freezable" />, что значение свойства остается фиксированным, в противном случае редактируется.  
  
 В следующем списке перечислены ожидаемое поведение данного метода.  
  
-   Создается копия содержит копии всех <see cref="T:System.Windows.Freezable" /> подчиненных объектах.  
  
-   Свойства не задано и только для чтения, не копируются.  
  
-   Если свойство будет определено, его текущее значение копируется, но не сама анимация.  
  
-   Ни один из этих вложенных объектов не является фиксированным при создании.  
  
-   Сама копия не является фиксированной.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="protected System.Windows.Freezable CreateInstance ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance class System.Windows.Freezable CreateInstance() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstance" />
      <MemberSignature Language="VB.NET" Value="Protected Function CreateInstance () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Windows::Freezable ^ CreateInstance();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Freezable" />.</summary>
        <returns>Новый экземпляр.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это защищенный метод, и фактические реализации отдельных объектов для поведения, зависящих от переопределения <xref:System.Windows.Freezable.CreateInstanceCore%2A> метод, который внутренним образом вызывает этот метод.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected abstract System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Если реализуется в производном классе, создает новый экземпляр производного класса <see cref="T:System.Windows.Freezable" />.</summary>
        <returns>Новый экземпляр.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не вызывайте этот метод напрямую (за исключением случаев вызова базового метода в реализации). Этот метод вызывается внутренним образом <xref:System.Windows.Freezable.CreateInstance%2A> метод всякий раз, когда новый экземпляр <xref:System.Windows.Freezable> создается.  
  
   
  
## Examples  
 Пример типичной реализации <xref:System.Windows.Freezable.CreateInstanceCore%2A>.  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Каждый <see cref="T:System.Windows.Freezable" /> производный класс должен реализовать этот метод. Типичная реализация является просто вызвать конструктор по умолчанию и возвращается результат.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CreateInstance" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Freeze">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Делает объект <see cref="T:System.Windows.Freezable" /> нередактируемым и определяет для его свойства <see cref="P:System.Windows.Freezable.IsFrozen" /> значение <see langword="true" /> или проверяет, можно ли объект <see cref="T:System.Windows.Freezable" /> сделать нередактируемым.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="public void Freeze ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Freeze() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze" />
      <MemberSignature Language="VB.NET" Value="Public Sub Freeze ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Freeze();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Делает текущий объект нередактируемым и определяет для его свойства <see cref="P:System.Windows.Freezable.IsFrozen" /> значение <see langword="true" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы защититься от <xref:System.InvalidOperationException> при вызове этого метода, проверьте <xref:System.Windows.Freezable.CanFreeze%2A> свойства, чтобы определить ли <xref:System.Windows.Freezable> можно сделать неизменяемым перед вызовом этого метода.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Windows.Freezable" /> нельзя сделать нередактируемым.</exception>
        <block subset="none" type="overrides">
          <para>Этот метод использует <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> метод для приготовления <see cref="T:System.Windows.Freezable" /> неизменяемым. Чтобы изменить поведение закрепление, переопределите <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> метод.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Freeze">
      <MemberSignature Language="C#" Value="protected internal static bool Freeze (System.Windows.Freezable freezable, bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblystatic hidebysig bool Freeze(class System.Windows.Freezable freezable, bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; static bool Freeze(System::Windows::Freezable ^ freezable, bool isChecking);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="freezable" Type="System.Windows.Freezable" />
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="freezable">Объект, который необходимо проверить или сделать нередактируемым. Если параметр <c>isChecking</c> имеет значение <see langword="true" />, объект проверяется, чтобы определить, можно ли его сделать нередактируемым. Если параметр <c>isChecking</c> имеет значение <see langword="false" />, объект делается нередактируемым, если это возможно.</param>
        <param name="isChecking">
          Значение <see langword="true" /> показывает, что объект можно заморозить (замораживание на самом деле не выполняется); значение <see langword="false" /> показывает, что объект замораживается на самом деле.</param>
        <summary>Если параметр <paramref name="isChecking" /> имеет значение <see langword="true" />, данный метод показывает, можно ли сделать заданный объект <see cref="T:System.Windows.Freezable" /> нередактируемым. Если параметр <paramref name="isChecking" /> имеет значение <see langword="false" />, данный метод пытается сделать заданный объект <see cref="T:System.Windows.Freezable" /> нередактируемым и показывает, была ли операция успешной.</summary>
        <returns>Если параметр <paramref name="isChecking" /> имеет значение <see langword="true" />, этот метод возвращает значение <see langword="true" />, если заданный объект <see cref="T:System.Windows.Freezable" /> можно сделать нередактируемым, или значение <see langword="false" />, если такая возможность отсутствует. Если параметр <paramref name="isChecking" /> имеет значение <see langword="false" />, этот метод возвращает значение <see langword="true" />, если заданный объект <see cref="T:System.Windows.Freezable" /> сейчас является нередактируемым, или значение <see langword="false" />, если его нельзя сделать нередактируемым.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не вызывайте этот метод, если вы создаете производные типы от <xref:System.Windows.Freezable> и переопределение <xref:System.Windows.Freezable.FreezeCore%2A> метод.  Этот метод может использоваться в <xref:System.Windows.Freezable.FreezeCore%2A> метод закрепление членов класса данных, которые сами являются <xref:System.Windows.Freezable> объектов.  
  
 Можно снова вызвать этот метод для <xref:System.Windows.Freezable> объекта, который уже заморожен (неизменяемым).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Если параметр <paramref name="isChecking" /> имеет значение <see langword="false" />, это показывает, что попытка сделать объект <paramref name="freezable" /> была безуспешной; теперь объект имеет неизвестное состояние (он может быть частично заморожен).</exception>
        <block subset="none" type="overrides">
          <para>Этот метод использует <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> метод для приготовления <see cref="T:System.Windows.Freezable" /> неизменяемым. Чтобы изменить поведение закрепление, переопределите <see cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" /> метод.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected virtual bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool FreezeCore(bool isChecking);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">
          Значение <see langword="true" /> показывает, что объект можно заморозить (замораживание на самом деле не выполняется); значение <see langword="false" /> показывает, что объект замораживается на самом деле.</param>
        <summary>Делает объект <see cref="T:System.Windows.Freezable" /> нередактируемым или проверяет, можно ли его сделать нередактируемым.</summary>
        <returns>Если параметр <paramref name="isChecking" /> имеет значение <see langword="true" />, этот метод возвращает значение <see langword="true" />, если данный объект <see cref="T:System.Windows.Freezable" /> можно сделать нередактируемым, или значение <see langword="false" />, если такая возможность отсутствует. Если параметр <paramref name="isChecking" /> имеет значение <see langword="false" />, этот метод возвращает значение <see langword="true" />, если заданный объект <see cref="T:System.Windows.Freezable" /> сейчас является нередактируемым, или значение <see langword="false" />, если его нельзя сделать нередактируемым.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Не вызывайте этот метод напрямую (за исключением случаев вызова базового метода в реализации). Этот метод вызывается внутренним образом <xref:System.Windows.Freezable.CanFreeze%2A> свойств (с `isChecking` равно `true`) и <xref:System.Windows.Freezable.Freeze%2A> метод (с `isChecking` равно `false`).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="T:System.Windows.Freezable" /> исполнители должны переопределять этот метод, если класс содержит данные, которые не хранятся с использованием свойств зависимостей.  
  
 Типичная реализация будет вызывать базовый, а затем вызовите статический <see cref="M:System.Windows.Freezable.Freeze(System.Windows.Freezable,System.Boolean)" /> метод на всех <see cref="T:System.Windows.Freezable" /> типизированные свойства, которые содержит класс, возвращая <see langword="true" /> только в том случае, если все свойства были заморожены (или может заморожена, в случае указания <see langword="true" /> для <paramref name="isChecking" />).</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.Freeze" />
        <altmember cref="P:System.Windows.Freezable.CanFreeze" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetAsFrozen();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает фиксированную копию объекта <see cref="T:System.Windows.Freezable" />, используя базовые (не анимационные) значения свойств. Так как копия является фиксированной, копируются только ссылки на фиксированные вложенные объекты.</summary>
        <returns>Фиксированная копия объекта <see cref="T:System.Windows.Freezable" />. Свойство копии <see cref="P:System.Windows.Freezable.IsFrozen" /> имеет значение <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вы должны проверить <xref:System.Windows.Freezable.CanFreeze%2A> свойство перед вызовом этого метода, чтобы убедиться, что <xref:System.Windows.Freezable> можно приостановить. С помощью этого метода аналогично созданию копии с помощью <xref:System.Windows.Freezable.Clone%2A> и затем зафиксировать этот объект с <xref:System.Windows.Freezable.Freeze%2A> метод.  
  
 <xref:System.Windows.Freezable.GetAsFrozen%2A> И <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> методов повышает производительность копирования, так как они не клонируйте <xref:System.Windows.Freezable> подчиненных объектах, уже заморожена; они копировать только их по ссылке.  
  
 В следующей таблице приведены различия между <xref:System.Windows.Freezable.GetAsFrozen%2A> и <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> методы.  
  
|Действие|Поведение методов GetAsFrozen|Поведение методов GetCurrentValueAsFrozen|  
|------------|---------------------------------|---------------------------------------------|  
|Копирует свойство зависимостей, которое содержит выражение|Метод создает <xref:System.InvalidOperationException> , так как он не может <xref:System.Windows.Freezable.Freeze%2A> свойство.|Копируется текущее значение выражения, но не само выражение.|  
|Копирование анимированное свойство зависимостей|Копируются базовые (без анимации) значения этого свойства. Анимации не копируются.|Копируется текущее значение анимируемого свойства. Анимации не копируются.|  
  
 Обратите внимание, что неопределенные свойства не копируются, а также доступны только для чтения.  
  
 Чтобы создать копию <xref:System.Windows.Freezable> , не зафиксированный используйте <xref:System.Windows.Freezable.Clone%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Объект <see cref="T:System.Windows.Freezable" /> нельзя заморозить, так как он включает выражения или анимационные свойства.</exception>
        <block subset="none" type="overrides">
          <para>Этот метод использует виртуальный <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" /> метод для создания клона.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Копируемый экземпляр.</param>
        <summary>Создает экземпляр фиксированной копии заданного объекта <see cref="T:System.Windows.Freezable" />, используя базовые (не анимационные) значения свойства.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается методом <xref:System.Windows.Freezable.GetAsFrozen%2A> метода и не должен вызываться напрямую из кода приложения, за исключением того, при вызове базовой реализации при переопределении этого метода. Чтобы создать зафиксированной копией текущего объекта, вызовите <xref:System.Windows.Freezable.GetAsFrozen%2A> вместо непосредственного вызова данного метода.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Если вы наследуете от <see cref="T:System.Windows.Freezable" /> необходимо переопределить этот метод. Возможны следующие причины для переопределения:  
  
-   Производный класс включает данные, которые не предоставляются через свойства зависимостей.  
  
-   Производный класс должен работать дополнительную инициализацию, не могут быть реализованы путем простого переопределения <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Например, это происходит, если производный класс реализует <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
 Классы, сохранять все свои данные в свойствах зависимостей и, не обязательно для выполнения дополнительных инициализации не обязательно должны переопределить <see cref="M:System.Windows.Freezable.GetAsFrozenCore(System.Windows.Freezable)" />.  
  
 Очень важно, что все реализации вызывать базовую реализацию этого метода. Реализации должны выполнять работу, выполняемую с помощью реализации по умолчанию не только. Реализация по умолчанию создает глубокие копии любой нефиксированного объектов Freezable и неполные копии всех остальных, локально набор свойств, содержащихся в нем. Если объект имеет свойства зависимостей, связанные с данными, выражения копируются, но могут уже не быть разрешимыми; Дополнительные сведения о клонировании объектов с привязкой к данным см. в разделе [Freezable Общие сведения об объектах](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Если объект имеет анимированные свойства зависимостей, копируются базовые (без анимации) значения этих свойств. Анимации не копируются.  
  
 Обратите внимание, что неопределенные свойства не копируются, а также доступны только для чтения.  
  
 При переопределении этого метода необходимо вызвать базовую реализацию.  
  
 Не обязательно должны <see cref="M:System.Windows.Freezable.Freeze" /> значения, они копируются.  Результат заморожен <see cref="M:System.Windows.Freezable.GetAsFrozen" /> перед возвращением.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetAsFrozen" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozen">
      <MemberSignature Language="C#" Value="public System.Windows.Freezable GetCurrentValueAsFrozen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Freezable GetCurrentValueAsFrozen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentValueAsFrozen () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Freezable ^ GetCurrentValueAsFrozen();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает фиксированную копию объекта <see cref="T:System.Windows.Freezable" /> с использованием текущих значений свойств. Так как копия является фиксированной, копируются только ссылки на фиксированные вложенные объекты.</summary>
        <returns>Фиксированная копия объекта <see cref="T:System.Windows.Freezable" />. Свойство копии <see cref="P:System.Windows.Freezable.IsFrozen" /> имеет значение <see langword="true" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 С помощью этого метода аналогично созданию копии с помощью <xref:System.Windows.Freezable.CloneCurrentValue%2A> и затем зафиксировать этот объект с <xref:System.Windows.Freezable.Freeze%2A> метод.  
  
 <xref:System.Windows.Freezable.GetAsFrozen%2A> И <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> методов повышает производительность копирования, так как они не клонируйте <xref:System.Windows.Freezable> подчиненных объектах, уже заморожена; они копировать только их по ссылке.  
  
 В следующей таблице приведены различия между <xref:System.Windows.Freezable.GetAsFrozen%2A> и <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> методы.  
  
|Действие|Поведение методов GetAsFrozen|Поведение методов GetCurrentValueAsFrozen|  
|------------|---------------------------------|---------------------------------------------|  
|Копирует свойство зависимостей, которое содержит выражение|Метод создает <xref:System.InvalidOperationException> , так как он не может <xref:System.Windows.Freezable.Freeze%2A> свойство.|Копируется текущее значение выражения, но не само выражение.|  
|Копирование анимированное свойство зависимостей|Копируются базовые (без анимации) значения этого свойства. Анимации не копируются.|Копируется текущее значение анимируемого свойства. Анимации не копируются.|  
  
 Обратите внимание, что неопределенные свойства не копируются, а также доступны только для чтения.  
  
 Чтобы создать копию <xref:System.Windows.Freezable> , не зафиксированный используйте <xref:System.Windows.Freezable.CloneCurrentValue%2A> метод.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Этот метод использует виртуальный <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" /> метод для создания клона.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValue" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentValueAsFrozenCore">
      <MemberSignature Language="C#" Value="protected virtual void GetCurrentValueAsFrozenCore (System.Windows.Freezable sourceFreezable);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void GetCurrentValueAsFrozenCore(class System.Windows.Freezable sourceFreezable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub GetCurrentValueAsFrozenCore (sourceFreezable As Freezable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void GetCurrentValueAsFrozenCore(System::Windows::Freezable ^ sourceFreezable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceFreezable" Type="System.Windows.Freezable" />
      </Parameters>
      <Docs>
        <param name="sourceFreezable">Объект <see cref="T:System.Windows.Freezable" />, который необходимо скопировать и заморозить.</param>
        <summary>Создает текущий экземпляр замороженной копии указанного объекта <see cref="T:System.Windows.Freezable" />. Если объект имеет анимированные свойства зависимостей, копируются их текущие анимированные значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается методом <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> метода и не должен вызываться напрямую из кода приложения, за исключением того, при вызове базовой реализации при переопределении этого метода. Чтобы создать зафиксированной копией текущего объекта, вызовите <xref:System.Windows.Freezable.GetCurrentValueAsFrozen%2A> вместо непосредственного вызова данного метода.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Если вы наследуете от <see cref="T:System.Windows.Freezable" />, может потребоваться переопределить этот метод. Возможны следующие причины для переопределения:  
  
-   Производный класс включает данные, которые не предоставляются через свойства зависимостей.  
  
-   Производный класс должен работать дополнительную инициализацию, не могут быть реализованы путем простого переопределения <see cref="M:System.Windows.Freezable.CreateInstanceCore" />. Например, это происходит, если производный класс реализует <see cref="T:System.ComponentModel.ISupportInitialize" />.  
  
 Классы, сохранять все свои данные в свойствах зависимостей и, не обязательно для выполнения дополнительных инициализации не обязательно должны переопределить <see cref="M:System.Windows.Freezable.GetCurrentValueAsFrozenCore(System.Windows.Freezable)" />.  
  
 Очень важно, что все реализации вызывать базовую реализацию этого метода. Реализации должны выполнять работу, выполняемую с помощью реализации по умолчанию не только. Реализация по умолчанию создает новый <see cref="T:System.Windows.Freezable" /> с помощью <see cref="M:System.Windows.Freezable.CreateInstance" /> метод и делает глубокие копии объектов Freezable нефиксированного и неполные копии всех остальных, локально установить свойства, он содержит. Если объект имеет свойства зависимостей с привязкой к данным, привязки данных копируются, но могут уже не быть разрешимыми; Дополнительные сведения о клонировании объектов с привязкой к данным см. в разделе [Freezable Общие сведения об объектах](~/docs/framework/wpf/advanced/freezable-objects-overview.md). Если объект имеет анимированные свойства зависимостей, копируется текущее значение анимируемого этих свойств, но не сами анимации.  
  
 Свойства зависимости только для чтения в <see cref="T:System.Windows.Freezable" /> не копируются в данной реализации по умолчанию.  
  
 При переопределении этого метода необходимо вызвать базовую реализацию.  
  
 Не обязательно должны <see cref="M:System.Windows.Freezable.Freeze" /> значения, они копируются.  Результат заморожен <see cref="M:System.Windows.Freezable.GetAsFrozen" /> перед возвращением.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCurrentValueCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="IsFrozen">
      <MemberSignature Language="C#" Value="public bool IsFrozen { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFrozen" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Freezable.IsFrozen" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFrozen As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFrozen { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, доступен ли объект для изменения в настоящее время.</summary>
        <value>
          Значение <see langword="true" />, если объект заморожен и его нельзя редактировать; значение <see langword="false" />, если объект можно редактировать.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Предпринимается попытка изменить объект при его <xref:System.Windows.Freezable.IsFrozen%2A> свойство `true` вызывает <xref:System.InvalidOperationException>.  
  
 Это свойство доступно только для чтения с точки зрения объектной модели. Документации о <xref:System.Windows.Freezable> поведения могут содержать «задает <xref:System.Windows.Freezable.IsFrozen%2A> для `true`» или подобный язык при обсуждении поведение других методов <xref:System.Windows.Freezable>, но внутренним образом происходит это поведение в экземпляры классов, Если методы экземпляра манипулировать закрытые переменные, которые существуют в абстрактный класс. Чтобы задать значение этого свойства, необходимо вызвать <xref:System.Windows.Freezable.Freeze%2A>. Фактически это одноразовая операция для изменения <xref:System.Windows.Freezable.IsFrozen%2A> свойство из начальное значение по умолчанию `false` состояние `true` состояние. Доступные способы задать значение определяется обратно `false`. Вместо этого можно изменить любой глубокой копией из исходного (см. <xref:System.Windows.Freezable.Clone%2A> метода). Это сделано намеренно, поведение при применении к вариантам любой производный класс где <xref:System.Windows.Freezable> можно использовать шаблон.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnChanged ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnChanged() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnChanged" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnChanged ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnChanged();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывается при изменении текущего объекта <see cref="T:System.Windows.Freezable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается каждый раз, когда <xref:System.Windows.Freezable.Changed> событием.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При реализации класса, производного от <see cref="T:System.Windows.Freezable" />, могут переопределять этот метод для выполнения задачи.</para>
        </block>
        <altmember cref="E:System.Windows.Freezable.Changed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OnFreezablePropertyChanged">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Обеспечивает создание соответствующих указателей контекста для элемента данных типа <see cref="T:System.Windows.DependencyObject" />, который был изменен.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldValue">Предыдущее значение элемента данных.</param>
        <param name="newValue">Текущее значение элемента данных.</param>
        <summary>Обеспечивает создание соответствующих указателей контекста для элемента данных типа <see cref="T:System.Windows.DependencyObjectType" />, который был только что задан.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод должен вызываться <xref:System.Windows.Freezable> наследники каждый раз <xref:System.Windows.DependencyObject> член данных, не хранятся в виде <xref:System.Windows.DependencyProperty> имеет значение.  
  
 Этот метод не должен вызываться для <xref:System.Windows.DependencyObject> элементов данных, которые хранятся с использованием <xref:System.Windows.DependencyProperty>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnFreezablePropertyChanged">
      <MemberSignature Language="C#" Value="protected void OnFreezablePropertyChanged (System.Windows.DependencyObject oldValue, System.Windows.DependencyObject newValue, System.Windows.DependencyProperty property);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnFreezablePropertyChanged(class System.Windows.DependencyObject oldValue, class System.Windows.DependencyObject newValue, class System.Windows.DependencyProperty property) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnFreezablePropertyChanged(System.Windows.DependencyObject,System.Windows.DependencyObject,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnFreezablePropertyChanged (oldValue As DependencyObject, newValue As DependencyObject, property As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnFreezablePropertyChanged(System::Windows::DependencyObject ^ oldValue, System::Windows::DependencyObject ^ newValue, System::Windows::DependencyProperty ^ property);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="newValue" Type="System.Windows.DependencyObject" />
        <Parameter Name="property" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="oldValue">Предыдущее значение элемента данных.</param>
        <param name="newValue">Текущее значение элемента данных.</param>
        <param name="property">Измененное свойство.</param>
        <summary>Этот член поддерживает инфраструктуру [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] и не предназначен для непосредственного использования из кода.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnPropertyChanged">
      <MemberSignature Language="C#" Value="protected override void OnPropertyChanged (System.Windows.DependencyPropertyChangedEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnPropertyChanged(valuetype System.Windows.DependencyPropertyChangedEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnPropertyChanged (e As DependencyPropertyChangedEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnPropertyChanged(System::Windows::DependencyPropertyChangedEventArgs e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.DependencyPropertyChangedEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Данные события, содержащие сведения об изменении свойства и его старое и новое значения.</param>
        <summary>Переопределяет реализацию <see cref="T:System.Windows.DependencyObject" /> для <see cref="M:System.Windows.DependencyObject.OnPropertyChanged(System.Windows.DependencyPropertyChangedEventArgs)" />, чтобы также вызвать любой обработчик <see cref="E:System.Windows.Freezable.Changed" /> в ответ на изменение свойства зависимостей типа <see cref="T:System.Windows.Freezable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данные о событии содержат сведения о только <xref:System.Windows.Freezable> сам. Любые сведения подсвойств должен быть получен с помощью <xref:System.Windows.Freezable.Changed> обработчиков.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadPreamble">
      <MemberSignature Language="C#" Value="protected void ReadPreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ReadPreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.ReadPreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ReadPreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ReadPreamble();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Обеспечивает доступ к <see cref="T:System.Windows.Freezable" /> из допустимого потока. Наследники объекта <see cref="T:System.Windows.Freezable" /> должны вызывать данный метод в начале любого [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)], который считывает элементы данных, не являющиеся свойствами зависимостей.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Классы, производные от <see cref="T:System.Windows.Freezable" /> следует вызывать <see cref="M:System.Windows.Freezable.ReadPreamble" /> метод перед тем как пытаться доступ к любым элементам, которые не являются свойствами зависимости. <see cref="M:System.Windows.Freezable.WritePreamble" /> Метод должен вызываться перед записью таких членов.  
  
 Этот метод фактически ничего не делает больше, чем вызов <see cref="M:System.Windows.Threading.DispatcherObject.VerifyAccess" />.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.WritePreamble" />
      </Docs>
    </Member>
    <Member MemberName="WritePostscript">
      <MemberSignature Language="C#" Value="protected void WritePostscript ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePostscript() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePostscript" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePostscript ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePostscript();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вызывает событие <see cref="E:System.Windows.Freezable.Changed" /> для объекта <see cref="T:System.Windows.Freezable" /> и вызывает его метод <see cref="M:System.Windows.Freezable.OnChanged" />. Классы, производные от <see cref="T:System.Windows.Freezable" />, должны вызывать этот метод в конце любого API, который изменяет члены класса, не сохраненные в виде свойств зависимостей.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Классы, производные от <see cref="T:System.Windows.Freezable" /> должен вызывать этот метод в конце любого API, который изменяет член класса, который не хранятся в виде <see cref="T:System.Windows.DependencyProperty" />.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="WritePreamble">
      <MemberSignature Language="C#" Value="protected void WritePreamble ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void WritePreamble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Freezable.WritePreamble" />
      <MemberSignature Language="VB.NET" Value="Protected Sub WritePreamble ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void WritePreamble();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Проверяет, что объект <see cref="T:System.Windows.Freezable" /> не заморожен и доступ к нему осуществляется из допустимого контекста потока. Наследники объекта <see cref="T:System.Windows.Freezable" /> должны вызывать данный метод в начале любого [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)], который выполняет запись в элементах данных, не являющихся свойствами зависимостей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывает метод <xref:System.Windows.Threading.DispatcherObject.VerifyAccess%2A> для проверки доступности контекста потока, а вызывает исключение, если <xref:System.Windows.Freezable> экземпляр уже закреплен.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Экземпляр <see cref="T:System.Windows.Freezable" /> заморожен, и запись в его члены невозможна.</exception>
        <block subset="none" type="overrides">
          <para>Классы, производные от <see cref="T:System.Windows.Freezable" /> следует вызвать <see cref="M:System.Windows.Freezable.WritePreamble" /> перед попыткой записи к любым элементам, которые не являются свойствами зависимости. При вызове метода <see cref="M:System.Windows.Freezable.WritePreamble" /> в [!INCLUDE[TLA#tla_api](~/includes/tlasharptla-api-md.md)], можно опустить вызова <see cref="M:System.Windows.Freezable.ReadPreamble" />.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.ReadPreamble" />
      </Docs>
    </Member>
  </Members>
</Type>