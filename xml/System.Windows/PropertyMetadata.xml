<Type Name="PropertyMetadata" FullName="System.Windows.PropertyMetadata">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5c5dfef7a02e9b858a22854c1ef79b198ef1d9bc" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30680018" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class PropertyMetadata" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit PropertyMetadata extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Windows.PropertyMetadata" />
  <TypeSignature Language="VB.NET" Value="Public Class PropertyMetadata" />
  <TypeSignature Language="C++ CLI" Value="public ref class PropertyMetadata" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Определяет некоторые аспекты поведения свойства зависимостей применительно к определенному типу, включая условия, в которых оно было зарегистрировано.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метаданные свойства могут быть определены и используется во время регистрации свойства зависимостей, при вызове <xref:System.Windows.DependencyProperty.Register%2A> метод (или вариантов для присоединенных свойств или свойств зависимостей только для чтения) или после исходной регистрации владельца при вызове <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A> метод. <xref:System.Windows.DependencyProperty.AddOwner%2A> Кроме того, принимает метаданные свойства.  
  
 Этот класс является конкретного базового класса, который может использоваться в каждом из этих вызовов. Однако это очень часто, чтобы указать метаданные с помощью одного из производных классов, например <xref:System.Windows.FrameworkPropertyMetadata>. Эти производные классы поддерживают более подробные метаданные, передающиеся как логические значения свойств, которые полезны для определения или некоторые свойства системы и макет поведения, реализованных в [!INCLUDE[TLA2#tla_winclient](~/includes/tla2sharptla-winclient-md.md)] уровня структуры.  
  
 Некоторые свойства этого класса, чтения и записи к объектной модели, но можно записать только до экземпляра, используемых в операции системы свойств, таких как <xref:System.Windows.DependencyProperty.Register%2A> или <xref:System.Windows.DependencyPropertyKey.OverrideMetadata%2A>. Каждое из этих свойств может также быть заданы с помощью конструктора, а предоставляются, чтобы <xref:System.Windows.PropertyMetadata.Merge%2A> реализации методов можно задать их.  
  
<a name="xamlTextUsage_PropertyMetadata"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Данный тип и его члены этого типа обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.PropertyMetadata" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.PropertyMetadata" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (defaultValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию, указанное для свойства зависимостей, представляет собой значение определенного типа.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.PropertyMetadata" /> с указанным значением по умолчанию для свойства зависимостей, к которому будут применены метаданные.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, заданного для `defaultValue` должен соответствовать или относиться к типу, заданному в исходной регистрации применяются эти метаданные свойства зависимостей. Несоответствие между типом значений метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживать, из-за рассогласования не удается обнаружить во время компиляции (несовпадение вызовет исключение во время выполнения).  
  
 Несмотря на то, что он подразумевается по умолчанию на конструктор без параметров, `defaultValue` из <xref:System.Windows.DependencyProperty.UnsetValue> не может быть указан. Попытка выполнить такую операцию вызовет исключение.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> не может иметь значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом изменении значения свойства.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.PropertyMetadata" /> с указанной ссылкой реализации <see cref="T:System.Windows.PropertyChangedCallback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor1paramcallback](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor1paramcallback)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой значение определенного типа.</param>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом изменении значения свойства.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.PropertyMetadata" /> с указанным значением по умолчанию и ссылкой на реализацию <see cref="T:System.Windows.PropertyChangedCallback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Тип значения, заданного `defaultValue` должен соответствовать или относиться к типу, заданному в исходной регистрации применяются эти метаданные свойства зависимостей. Несоответствие между типом значений метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживать, из-за рассогласования не удается обнаружить во время компиляции (несовпадение вызовет исключение во время выполнения).  
  
 Несмотря на то, что он подразумевается по умолчанию на конструктор без параметров, `defaultValue` из <xref:System.Windows.DependencyProperty.UnsetValue> не может быть указан. Попытка выполнить такую операцию вызовет исключение.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor2param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor2param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> не может иметь значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public PropertyMetadata (object defaultValue, System.Windows.PropertyChangedCallback propertyChangedCallback, System.Windows.CoerceValueCallback coerceValueCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(object defaultValue, class System.Windows.PropertyChangedCallback propertyChangedCallback, class System.Windows.CoerceValueCallback coerceValueCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.#ctor(System.Object,System.Windows.PropertyChangedCallback,System.Windows.CoerceValueCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; PropertyMetadata(System::Object ^ defaultValue, System::Windows::PropertyChangedCallback ^ propertyChangedCallback, System::Windows::CoerceValueCallback ^ coerceValueCallback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="defaultValue" Type="System.Object" />
        <Parameter Name="propertyChangedCallback" Type="System.Windows.PropertyChangedCallback" />
        <Parameter Name="coerceValueCallback" Type="System.Windows.CoerceValueCallback" />
      </Parameters>
      <Docs>
        <param name="defaultValue">Как правило, значение по умолчанию свойства зависимостей представляет собой значение определенного типа.</param>
        <param name="propertyChangedCallback">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом изменении значения свойства.</param>
        <param name="coerceValueCallback">Ссылка на реализацию обработчика вызывается системой управления свойствами при каждом вызове <see cref="M:System.Windows.DependencyObject.CoerceValue(System.Windows.DependencyProperty)" /> против данного свойства.</param>
        <summary>Инициализирует новый экземпляр <see cref="T:System.Windows.PropertyMetadata" /> класса с заданными значением по умолчанию и ответами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы хотите указать <xref:System.Windows.CoerceValueCallback> , но не <xref:System.Windows.PropertyChangedCallback>, можно передать `null` для `propertyChangedCallback` параметра.  
  
 Тип значения, заданного для `defaultValue` должен соответствовать или относиться к типу, заданному в исходной регистрации применяются эти метаданные свойства зависимостей. Несоответствие между типом значений метаданных по умолчанию и типом свойства зависимостей, к которому он применяется к может быть трудно отлаживать, из-за рассогласования не удается обнаружить во время компиляции (несовпадение вызовет исключение во время выполнения).  
  
 Несмотря на то, что он подразумевается по умолчанию на конструктор без параметров, `defaultValue` из <xref:System.Windows.DependencyProperty.UnsetValue> не может быть указан. Попытка выполнить такую операцию вызовет исключение.  
  
   
  
## Examples  
 [!code-csharp[PropertyMetadataAPIs#Initpm](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#initpm)]  
[!code-csharp[PropertyMetadataAPIs#PMCtor3param](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#pmctor3param)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="defaultValue" /> не может иметь значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CoerceValueCallback">
      <MemberSignature Language="C#" Value="public System.Windows.CoerceValueCallback CoerceValueCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.CoerceValueCallback CoerceValueCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.CoerceValueCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property CoerceValueCallback As CoerceValueCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::CoerceValueCallback ^ CoerceValueCallback { System::Windows::CoerceValueCallback ^ get(); void set(System::Windows::CoerceValueCallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.CoerceValueCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает ссылку на реализацию <see cref="T:System.Windows.CoerceValueCallback" /> указанную в этих метаданных.</summary>
        <value>Ссылка реализации <see cref="T:System.Windows.CoerceValueCallback" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ответы свойства метаданных не являются обычно открытых членов в содержащем типе, поэтому значение этого свойства не является важным для большинства сценариев, которые просто поглощают метаданные существующего свойства зависимостей. Является одной из причин этого свойства предоставляется, чтобы подклассы метаданных могут осуществлять необходимую логику совмещения, если основные метаданные и переопределение Добавление метаданные указывают <xref:System.Windows.CoerceValueCallback>. Тем не менее, значение по умолчанию слияния логику для <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> замените предыдущий.  
  
 <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> определяется в объектной модели для чтения записи. Да <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> можно изменить после инициализации <xref:System.Windows.PropertyMetadata> сам объект. Тем не менее когда метаданные используются как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, в системе свойств будет запечатать этот экземпляр метаданных и свойств теперь считаются неизменяемыми. Попытка задать <xref:System.Windows.PropertyMetadata.CoerceValueCallback%2A> после <xref:System.Windows.PropertyMetadata.IsSealed%2A> — `true` на эти метаданные экземпляра вызовет исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Невозможно задать свойство метаданных после того, как оно применено к ориентации свойства зависимостей.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefaultValue">
      <MemberSignature Language="C#" Value="public object DefaultValue { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object DefaultValue" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.DefaultValue" />
      <MemberSignature Language="VB.NET" Value="Public Property DefaultValue As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ DefaultValue { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение по умолчанию свойства зависимостей.</summary>
        <value>Значение свойства по умолчанию. Значение по умолчанию <see cref="T:System.Windows.PropertyMetadata" /> экземпляр, созданный с помощью конструктора без параметров будет <see cref="F:System.Windows.DependencyProperty.UnsetValue" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.PropertyMetadata.DefaultValue%2A> определяется в объектной модели для чтения записи. Да <xref:System.Windows.PropertyMetadata.DefaultValue%2A> можно изменить после инициализации <xref:System.Windows.PropertyMetadata> сам объект. Тем не менее когда метаданные используются как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, в системе свойств будет запечатать этот экземпляр метаданных и свойств теперь считаются неизменяемыми. Попытка задать <xref:System.Windows.PropertyMetadata.DefaultValue%2A> после <xref:System.Windows.PropertyMetadata.IsSealed%2A> — `true` на эти метаданные экземпляра вызовет исключение.  
  
 Несмотря на то, что он подразумевается по умолчанию на конструктор без параметров, `defaultValue` из <xref:System.Windows.DependencyProperty.UnsetValue> нельзя задать с помощью <xref:System.Windows.PropertyMetadata.DefaultValue%2A> или конструктора. Попытка выполнить такую операцию вызовет исключение.  
  
<a name="xamlTextUsage_PropertyChangedCallback"></a>   
## <a name="xaml-text-usage"></a>Использование текста XAML  
 Члены этого типа обычно не используются в [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Невозможно задать значение <see cref="F:System.Windows.DependencyProperty.UnsetValue" /> после создания.</exception>
        <exception cref="T:System.InvalidOperationException">Невозможно задать свойство метаданных после того, как оно применено к ориентации свойства зависимостей.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="protected bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool IsSealed { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, определяющее, были ли применены метаданные к свойству, что привело к запрету изменений экземпляра метаданных.</summary>
        <value>
          <see langword="true" />, если экземпляр метаданных не подлежит изменениям; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Различные свойства <xref:System.Windows.PropertyMetadata>, такие как <xref:System.Windows.PropertyMetadata.DefaultValue%2A>, определенных в модели объектов чтения и записи. Поэтому эти свойства можно изменить после инициализации <xref:System.Windows.PropertyMetadata> сам объект. Тем не менее после применения метаданные свойства зависимостей в рамках вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, в системе свойств будет запечатать этот экземпляр метаданных и свойств теперь считаются неизменяемыми. Во время этих вызовов <xref:System.Windows.PropertyMetadata.OnApply%2A> вызывается, и значение этого свойства равно `true`.  
  
   
  
## Examples  
 В следующем примере проверяется <xref:System.Windows.PropertyMetadata.IsSealed%2A> до операции задания пользовательских метаданных свойства.  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="Merge">
      <MemberSignature Language="C#" Value="protected virtual void Merge (System.Windows.PropertyMetadata baseMetadata, System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Merge(class System.Windows.PropertyMetadata baseMetadata, class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Merge (baseMetadata As PropertyMetadata, dp As DependencyProperty)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Merge(System::Windows::PropertyMetadata ^ baseMetadata, System::Windows::DependencyProperty ^ dp);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="baseMetadata" Type="System.Windows.PropertyMetadata" />
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="baseMetadata">Основные метаданные, с которыми следует совместить значения экземпляра.</param>
        <param name="dp">Свойство зависимостей, к которому применяются данные метаданные.</param>
        <summary>Совмещает эти метаданные с основными.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод используется внутренне при переопределении метаданных (<xref:System.Windows.DependencyProperty.OverrideMetadata%2A> метода).  
  
   
  
## Examples  
 В следующем примере реализуется слияния для типа пользовательских метаданных, который добавляет дополнительное свойство в метаданных свойства.  
  
 [!code-csharp[PropertyMetadataAPIs#MergeImpl](~/samples/snippets/csharp/VS_Snippets_Wpf/PropertyMetadataAPIs/CSharp/Class1.cs#mergeimpl)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Класс реализации, которые являются производными от <see cref="T:System.Windows.PropertyMetadata" /> следует переопределить этот метод для учетной записи для всех свойств метаданных, добавленных в их реализации. Например, для реализации могут быть добавлены новое значение флагового перечисления и <see cref="M:System.Windows.PropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" /> реализации должна быть возможность правильно объединить эти флаги.  
  
 Всегда вызывать базовую реализацию до код реализации, так как базовая реализация берет на себя все свойства, которые уже определены на <see cref="T:System.Windows.PropertyMetadata" /> типа.  
  
 Точное поведение объединения возлагается. Можно иметь объединенные значения, возвращаются к базовое значение, если производные метаданные не были удалены на значение по умолчанию или многие другие поведения, основанное на типах свойств, которые вы добавили в класс метаданных и их значения.</para>
        </block>
        <altmember cref="M:System.Windows.FrameworkPropertyMetadata.Merge(System.Windows.PropertyMetadata,System.Windows.DependencyProperty)" />
      </Docs>
    </Member>
    <Member MemberName="OnApply">
      <MemberSignature Language="C#" Value="protected virtual void OnApply (System.Windows.DependencyProperty dp, Type targetType);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnApply(class System.Windows.DependencyProperty dp, class System.Type targetType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.PropertyMetadata.OnApply(System.Windows.DependencyProperty,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnApply (dp As DependencyProperty, targetType As Type)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnApply(System::Windows::DependencyProperty ^ dp, Type ^ targetType);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="targetType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="dp">Свойство зависимостей, к которому были применены эти метаданные.</param>
        <param name="targetType">Тип, связанный с этими метаданными, если это метаданные зависящие от типа. Если это метаданные по умолчанию, значением будет нулевая ссылка.</param>
        <summary>Вызывается после применения данных метаданных к свойству, указывая на запечатывание метаданных.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Подклассы должны убедиться, что все изменения структуры данных <xref:System.Windows.PropertyMetadata> подкласс должен быть помечен как неизменяемое один раз <xref:System.Windows.PropertyMetadata.OnApply%2A> вызывается. Вызывается после применения метаданных операции системы свойств (регистрация, добавление владельца, переопределения метаданных).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PropertyChangedCallback">
      <MemberSignature Language="C#" Value="public System.Windows.PropertyChangedCallback PropertyChangedCallback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.PropertyChangedCallback PropertyChangedCallback" />
      <MemberSignature Language="DocId" Value="P:System.Windows.PropertyMetadata.PropertyChangedCallback" />
      <MemberSignature Language="VB.NET" Value="Public Property PropertyChangedCallback As PropertyChangedCallback" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::PropertyChangedCallback ^ PropertyChangedCallback { System::Windows::PropertyChangedCallback ^ get(); void set(System::Windows::PropertyChangedCallback ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyChangedCallback</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает ссылку на реализацию <see cref="T:System.Windows.PropertyChangedCallback" /> указанную в этих метаданных.</summary>
        <value>Ссылка реализации <see cref="T:System.Windows.PropertyChangedCallback" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратные вызовы свойства метаданных не обычно открытых членов, определяющего типа, поэтому значение этого свойства не является важным для большинства сценариев, которые просто поглощают метаданные существующего свойства зависимостей. Является одной из причин этого свойства предоставляется, чтобы классы метаданных могут осуществлять необходимую логику совмещения, если основные метаданные и переопределение Добавление метаданные указывают <xref:System.Windows.PropertyChangedCallback>. Логика слияния по умолчанию является поддержание всех <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> реализации таблицы и вызовите метод из них с глубокой классом в иерархии, запуск первого установления обратных вызовов.  
  
 <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> определяется в объектной модели для чтения записи. Да <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> можно изменить после инициализации <xref:System.Windows.PropertyMetadata> сам объект. Тем не менее когда метаданные используются как часть вызова <xref:System.Windows.DependencyProperty.Register%2A>, <xref:System.Windows.DependencyProperty.AddOwner%2A>, или <xref:System.Windows.DependencyProperty.OverrideMetadata%2A>, в системе свойств будет запечатать этот экземпляр метаданных и свойств теперь считаются неизменяемыми. Попытка задать <xref:System.Windows.PropertyMetadata.PropertyChangedCallback%2A> после <xref:System.Windows.PropertyMetadata.IsSealed%2A> — `true` на эти метаданные экземпляра вызовет исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Невозможно задать свойство метаданных после того, как оно применено к ориентации свойства зависимостей.</exception>
      </Docs>
    </Member>
  </Members>
</Type>