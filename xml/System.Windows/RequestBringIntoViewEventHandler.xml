<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="RequestBringIntoViewEventHandler.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5cda95cbf8cf82761ed796773cf82db1b1779f599.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">cda95cbf8cf82761ed796773cf82db1b1779f599</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>The object where the event handler is attached.</source>
          <target state="translated">Объект, к которому присоединен обработчик событий.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>The event data.</source>
          <target state="translated">Данные события.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>Represents the method that will handle the <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /&gt;</ph> routed event.</source>
          <target state="translated">Представляет метод обработки перенаправленного события <ph id="ph1">&lt;see cref="E:System.Windows.FrameworkElement.RequestBringIntoView" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>Handling this event is typically only done within elements that support a scrollable region, or otherwise deliberately set their rendering size smaller than the combined desired size of their child element content, and is only done by deliberately handling the event once it has routed upwards in the element tree and has reached the first parent that offers scrolling region support.</source>
          <target state="translated">Обработка этого события обычно только в элементах, поддерживающих прокручиваемую область, или не намеренно установлен их подготовки к просмотру размер меньше, чем объединенным желаемый размер их дочернего содержимого элемента и выполняется только с помощью намеренно обработки событие после его направил вверх в дереве элементов и был достигнут первый родительский элемент, который обеспечивает поддержку прокрутки области.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>An existing implementation that handles scrolling regions in a manner that is typically desirable for user controls is <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>.</source>
          <target state="translated">— Существующая реализация, обрабатывающей прокручиваемые области таким образом, требуемого для пользовательских элементов управления <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>If you derive from <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>, you can register a class handler for <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType&gt;</ph> and supplement the base class handling of the event.</source>
          <target state="translated">Если вы наследуете от <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>, можно зарегистрировать обработчик класса для <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType&gt;</ph> и дополнять обработку базового класса события.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>You should also consider using or class-handling the class-defined <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer.ScrollChanged&gt;</ph> event instead of <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Также можно с помощью или определен класс обработку класса <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer.ScrollChanged&gt;</ph> события вместо <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>Alternatively, if you create an entirely custom class that does not derive from <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>, you can still add class handling by calling <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A?displayProperty=nameWithType&gt;</ph> in your class instantiation.</source>
          <target state="translated">Кроме того при создании полностью пользовательский класс, который является производным от <ph id="ph1">&lt;xref:System.Windows.Controls.ScrollViewer&gt;</ph>, можно добавить обработку путем вызова класса <ph id="ph2">&lt;xref:System.Windows.EventManager.RegisterClassHandler%2A?displayProperty=nameWithType&gt;</ph> в вашей экземпляра класса.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>For details on class handling, see <bpt id="p1">[</bpt>Marking Routed Events as Handled, and Class Handling<ept id="p1">](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)</ept>.</source>
          <target state="translated">Дополнительные сведения об обработке классов см. в разделе <bpt id="p1">[</bpt>как Handled и обработка класса<ept id="p1">](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md)</ept>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>Content elements can cause the event to be raised by their content hosts (through calling <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BringIntoView%2A&gt;</ph> and raising <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType&gt;</ph> from the content host).</source>
          <target state="translated">Элементы содержимого может вызвать событие, которое инициируется их содержимого узлами (через вызов метода <ph id="ph1">&lt;xref:System.Windows.FrameworkContentElement.BringIntoView%2A&gt;</ph> и вызов <ph id="ph2">&lt;xref:System.Windows.FrameworkElement.RequestBringIntoView?displayProperty=nameWithType&gt;</ph> от узла содержимого).</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>Similarly, you can request logical tree elements to be brought into view with the helper method <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.BringIntoView%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Аналогичным образом, можно запросить логическое дерево элементов можно сделать с помощью вспомогательного метода <ph id="ph1">&lt;xref:System.Windows.LogicalTreeHelper.BringIntoView%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Windows.RequestBringIntoViewEventHandler">
          <source>A <ph id="ph1">&lt;xref:System.Windows.Controls.ListBox&gt;</ph> implements a related but different method <ph id="ph2">&lt;xref:System.Windows.Controls.ListBox.ScrollIntoView%2A&gt;</ph>.</source>
          <target state="translated">Объект <ph id="ph1">&lt;xref:System.Windows.Controls.ListBox&gt;</ph> реализует метод связанных, но различные <ph id="ph2">&lt;xref:System.Windows.Controls.ListBox.ScrollIntoView%2A&gt;</ph>.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>