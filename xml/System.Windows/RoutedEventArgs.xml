<Type Name="RoutedEventArgs" FullName="System.Windows.RoutedEventArgs">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8f6112c09b1f961b689a530d29b65eeca46e3156" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30679768" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class RoutedEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit RoutedEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.Windows.RoutedEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class RoutedEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class RoutedEventArgs : EventArgs" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Содержит информацию о состоянии и данные события, связанные с перенаправленным событием.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Различные <xref:System.Windows.RoutedEventArgs> может использоваться с одним <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>. Этот класс отвечает за упаковку данных события для <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A>, предоставляя информацию о состоянии дополнительные события и используется системой событий для вызова обработчика, связанного с перенаправленного события.  
  
 ]]></format>
    </remarks>
    <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
    <altmember cref="T:System.Windows.EventManager" />
    <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании этого конструктора без параметров, все открытые свойства нового <xref:System.Windows.RoutedEventArgs> экземпляр предполагают следующие значения по умолчанию:  
  
-   <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> по умолчанию используется значение `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> по умолчанию `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> по умолчанию используется значение `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> по умолчанию используется значение `null`.  
  
 Значения NULL для <xref:System.Windows.RoutedEventArgs.Source%2A> и <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> означает, что только <xref:System.Windows.RoutedEventArgs> данных не предпринимает для указания источника. При использовании данного экземпляра в вызове <xref:System.Windows.UIElement.RaiseEvent%2A>, <xref:System.Windows.RoutedEventArgs.Source%2A> и <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> значения заполняются на основе элемента, вызвавшего событие, а передаются прослушиватели по маршрутизация.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Идентификатор маршрутизируемого события для данного экземпляра класса <see cref="T:System.Windows.RoutedEventArgs" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.RoutedEventArgs" /> с помощью переданного идентификатора маршрутизируемого события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании этого перегруженного конструктора, не указан свойства нового <xref:System.Windows.RoutedEventArgs> экземпляр предполагают следующие значения по умолчанию:  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> по умолчанию `false`  
  
-   <xref:System.Windows.RoutedEventArgs.Source%2A> по умолчанию используется значение `null`.  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> по умолчанию используется значение `null`.  
  
 Значения NULL для <xref:System.Windows.RoutedEventArgs.Source%2A> и <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> только означает, что это <xref:System.Windows.RoutedEventArgs> не предпринимает для указания источника. При использовании данного экземпляра в вызове <xref:System.Windows.UIElement.RaiseEvent%2A>, <xref:System.Windows.RoutedEventArgs.Source%2A> и <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> значения заполняются на основе элемента, вызвавшего событие, а передаются прослушиватели по маршрутизация.  
  
   
  
## Examples  
 В следующем примере создается новый <xref:System.Windows.RoutedEventArgs> для использования в вызове <xref:System.Windows.UIElement.RaiseEvent%2A>.  
  
 [!code-csharp[RoutedEventCustom#RaiseEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/RoutedEventCustom/CSharp/SDKSampleLibrary/class1.cs#raiseevent)]
 [!code-vb[RoutedEventCustom#RaiseEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/RoutedEventCustom/VB/SDKSampleLibrary/Class1.vb#raiseevent)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.UIElement.RaiseEvent(System.Windows.RoutedEventArgs)" />
        <altmember cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public RoutedEventArgs (System.Windows.RoutedEvent routedEvent, object source);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Windows.RoutedEvent routedEvent, object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.#ctor(System.Windows.RoutedEvent,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; RoutedEventArgs(System::Windows::RoutedEvent ^ routedEvent, System::Object ^ source);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="routedEvent" Type="System.Windows.RoutedEvent" />
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="routedEvent">Идентификатор маршрутизируемого события для данного экземпляра класса <see cref="T:System.Windows.RoutedEventArgs" />.</param>
        <param name="source">Альтернативный источник, который будет сообщен при обработке события. Предварительно заполняет свойство <see cref="P:System.Windows.RoutedEventArgs.Source" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.RoutedEventArgs" /> с помощью переданного идентификатора маршрутизируемого события, предоставляя возможность объявить другой источник события.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При использовании этого перегруженного конструктора, не указан свойства нового <xref:System.Windows.RoutedEventArgs> экземпляр предполагают следующие значения по умолчанию:  
  
-   <xref:System.Windows.RoutedEventArgs.Handled%2A> по умолчанию `false`  
  
-   <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> по умолчанию используется значение `null`.  
  
 Значения NULL для <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> заполняются на основе элемента, вызвавшего событие и передать маршрутизации, но будет считывать `null` до вызова.  
  
 Использовать следующую сигнатуру при передаче <xref:System.Windows.RoutedEventArgs> для виртуальных функций, таких как <xref:System.Windows.Controls.Primitives.TextBoxBase.OnSelectionChanged%2A>, в котором аргументы используются для вызова <xref:System.Windows.UIElement.RaiseEvent%2A> внутренним образом.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Handled">
      <MemberSignature Language="C#" Value="public bool Handled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Handled" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Handled" />
      <MemberSignature Language="VB.NET" Value="Public Property Handled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Handled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, обозначающее текущее состояние обработки перенаправленного события при перемещении по маршруту.</summary>
        <value>При настройке задайте <see langword="true" /> быть пометить как обработанное; в противном случае если событие <see langword="false" />. При считывании данного значения <see langword="true" /> указывает, что обработчик класса или некоторые обработчик экземпляра на маршруте уже пометил это событие как обработанное. Значение <see langword="false" /> указывает, что ни один из обработчиков не пометил событие как обработанное.  
  
 Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пометка события как обработанного ограничивает видимость перенаправленного события прослушиватели на маршруте события. Событие по-прежнему командировках оставшейся части маршрута, но только обработчики специально добавлены с классом `HandledEventsToo` `true` в <xref:System.Windows.UIElement.AddHandler%28System.Windows.RoutedEvent%2CSystem.Delegate%2CSystem.Boolean%29> вызов метода будет вызываться в ответ. Обработчики в прослушиватели экземпляров по умолчанию (например, те, выраженное в [!INCLUDE[TLA#tla_xaml](~/includes/tlasharptla-xaml-md.md)]) не будет вызываться. Обработка событий, помеченных как обработанные не является распространенным сценарием.  
  
 Если вы являетесь автором управления определение собственных событий принятые решения относительно событий обработки на уровне класса повлияет пользователям элемента управления, а также все пользователи производных элементов управления, а потенциально другие элементы, которые могут быть содержатся в элемент управления или его содержат. Дополнительные сведения см. в разделе [Маркировка перенаправленных событий как обработанных и обработка классов](~/docs/framework/wpf/advanced/marking-routed-events-as-handled-and-class-handling.md).  
  
 В очень редких случаях это подходит для обработки событий, где <xref:System.Windows.RoutedEventArgs.Handled%2A> помечен `true`и внесите аргументы события, изменив <xref:System.Windows.RoutedEventArgs.Handled%2A> для `false`. Это может потребоваться в некоторых областях событий ввода данных управления, такие как обработка ключа <xref:System.Windows.UIElement.KeyDown> и <xref:System.Windows.UIElement.TextInput> где низкий уровень и конкурируют высокоуровневая входных событий для обработки каждого предпринимается попытка работы с другую стратегию маршрутизации.  
  
   
  
## Examples  
 Следующий пример реализует обработчик событий, помечающий событие как обработанное.  
  
 [!code-csharp[ClassHandling#OnStarClassHandler](~/samples/snippets/csharp/VS_Snippets_Wpf/ClassHandling/CSharp/SDKSampleLibrary/class1.cs#onstarclasshandler)]
 [!code-vb[ClassHandling#OnStarClassHandler](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ClassHandling/visualbasic/sdksamplelibrary/class1.vb#onstarclasshandler)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InvokeEventHandler">
      <MemberSignature Language="C#" Value="protected virtual void InvokeEventHandler (Delegate genericHandler, object genericTarget);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void InvokeEventHandler(class System.Delegate genericHandler, object genericTarget) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.InvokeEventHandler(System.Delegate,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub InvokeEventHandler (genericHandler As Delegate, genericTarget As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void InvokeEventHandler(Delegate ^ genericHandler, System::Object ^ genericTarget);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="genericHandler" Type="System.Delegate" />
        <Parameter Name="genericTarget" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="genericHandler">Универсальная реализация обработчика или делегата для вызова.</param>
        <param name="genericTarget">Целевой объект, для которого нужно вызвать предоставленный обработчик.</param>
        <summary>При переопределении в производном классе предоставляет способ вызова обработчиков событий в зависимости от конкретного типа, что может повысить эффективность по сравнению с базовой реализацией.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Базовая реализация содержит отражение для определения правильного обработчика в любом случае, когда обработчик не буквально <xref:System.Windows.RoutedEventHandler>, и этот этап отражения влияние на производительность. Вызовы могут выполняться эффективнее, не полагаясь на отражение. Это скрипт мотивирует сделать доступным для любого класса маршрутизируемого события, который сможет его переопределить данный метод. Реализации не должны вызывать базовый этот метод, так как ваша реализация уже должна отвечать за вызов типобезопасных обработчиков.  
  
   
  
## Examples  
 Ниже приведен псевдокод, иллюстрирующий базовый шаблон, который может использоваться для реализации. Здесь `MyRoutedEventHandler` является подклассом <xref:System.Windows.RoutedEventHandler>.  
  
 [!code-csharp[CorePseudocode#RoutedEventArgs](~/samples/snippets/csharp/VS_Snippets_Wpf/CorePseudocode/CSharp/corepseudocode.cs#routedeventargs)]
 [!code-vb[CorePseudocode#RoutedEventArgs](~/samples/snippets/visualbasic/VS_Snippets_Wpf/CorePseudocode/visualbasic/corepseudocode.vb#routedeventargs)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Этот метод предназначен для переопределения классами данных производного события для обеспечения более эффективного вызова их делегатов. Реализация необходимо привести указанных <paramref name="genericHandler" /> для конкретного типа делегата, а затем вызвать этот обработчик.  
  
 Реализация по умолчанию будет пытаться вызвать предоставленный обработчик, попытка привести ее к <see cref="T:System.Windows.RoutedEventHandler" />. Если параметр <paramref name="genericHandler" /> или <paramref name="genericTarget" /> предоставляется как <see langword="null" />, будет вызываться исключения.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSetSource">
      <MemberSignature Language="C#" Value="protected virtual void OnSetSource (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSetSource(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSetSource (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSetSource(System::Object ^ source);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">Новое значение, которое задается для <see cref="P:System.Windows.RoutedEventArgs.Source" />.</param>
        <summary>При переопределении в производном классе предоставляет точку входа обратного вызова для уведомления в случае изменения значения свойства <see cref="P:System.Windows.RoutedEventArgs.Source" /> в экземпляре.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>Изменение сообщаемого источника события программным путем потенциально может требовать обновления определенных типов данных в событии. По этой причине <see cref="M:System.Windows.RoutedEventArgs.OnSetSource(System.Object)" /> метод является защищенным виртуального и должен быть переопределен в подклассах из <see cref="T:System.Windows.RoutedEventArgs" />.  
  
 У этого метода нет реализации по умолчанию.</para>
        </block>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="OriginalSource">
      <MemberSignature Language="C#" Value="public object OriginalSource { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object OriginalSource" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.OriginalSource" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OriginalSource As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ OriginalSource { System::Object ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает исходный источник отчетов, определяемый чистой проверкой нажатия до какой-либо возможной корректировки <see cref="P:System.Windows.RoutedEventArgs.Source" /> родительским классом.</summary>
        <value>Исходный сообщающий источник, перед любой возможной корректировкой <see cref="P:System.Windows.RoutedEventArgs.Source" />, осуществляемой при обработке класса, что может быть сделано для выравнивания составных деревьев элементов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство получает свое значение один раз, перед классом вызываются обработчики событий и обработчиков экземпляров и никогда не корректируется на этом этапе. Информация об исходном источнике обработчики класса или класса реализации, только для чтения, так же, как сообщается в данных события.  
  
 Случаи, где можно менять источник включают элементы содержимого внутри модели содержимого для элемента управления (содержимое элемента списка, например, будут передавать элемента списка, как <xref:System.Windows.RoutedEventArgs.Source%2A> и фактический элемент внутри элемента списка будет <xref:System.Windows.RoutedEventArgs.OriginalSource%2A>.  
  
 Корректировка источника различными элементами и моделями содержимого зависит от класса к классу. Каждый класс, корректирующий источники событий пытается предугадать, какой источник наиболее полезен для сообщения в большинстве сценариев ввода и сценариев, для которых предназначен класса, а затем наборы, источник в качестве <xref:System.Windows.RoutedEventArgs.Source%2A>. Если этот источник не имеет значения для конкретной обработки события, попробуйте проверить <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> вместо этого он сообщает о другой, более подходящий источник. Дополнительные сведения о событиях ввода см. в разделе [ввода Обзор](~/docs/framework/wpf/advanced/input-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.Source" />
      </Docs>
    </Member>
    <Member MemberName="RoutedEvent">
      <MemberSignature Language="C#" Value="public System.Windows.RoutedEvent RoutedEvent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.RoutedEvent RoutedEvent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.RoutedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Property RoutedEvent As RoutedEvent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::RoutedEvent ^ RoutedEvent { System::Windows::RoutedEvent ^ get(); void set(System::Windows::RoutedEvent ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает свойство <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" />, связанное с экземпляром <see cref="T:System.Windows.RoutedEventArgs" />.</summary>
        <value>Идентификатор вызванного события.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Нельзя задать это значение на <xref:System.Windows.RoutedEventArgs> , уже был перенаправлен (например, если вы приобрели аргументы через обработчик). Попытка сделать это приведет к ошибке. Можно задать только его в экземпляре, который еще не использовался для генерирования вызова события.  
  
 Значение <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> не может быть `null` в любое время.  
  
   
  
## Examples  
 Следующий пример создает новые данные о событии с начальной конструктором, а затем присваивает <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> свойство как последующие операции. Необходимо иметь <xref:System.Windows.RoutedEventArgs.RoutedEvent%2A> задать до перенаправленного события.  
  
 [!code-csharp[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/csharp/VS_Snippets_Wpf/ColorPicker_v2/CSharp/ColorPicker.cs#routedeventargsroutedevent)]
 [!code-vb[ColorPicker_v2#RoutedEventArgsRoutedEvent](~/samples/snippets/visualbasic/VS_Snippets_Wpf/ColorPicker_v2/visualbasic/colorpicker.vb#routedeventargsroutedevent)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Попытка изменить значение <see cref="P:System.Windows.RoutedEventArgs.RoutedEvent" /> во время маршрутизации события.</exception>
      </Docs>
    </Member>
    <Member MemberName="Source">
      <MemberSignature Language="C#" Value="public object Source { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Source" />
      <MemberSignature Language="DocId" Value="P:System.Windows.RoutedEventArgs.Source" />
      <MemberSignature Language="VB.NET" Value="Public Property Source As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Source { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает ссылку на объект, создавший событие.</summary>
        <value>Объект, создавший событие.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для любого восходящей маршрутизируемого события, которое фактически прошло маршрут после элемента, вызвавшего его и для любого туннелирование маршрутизируемого события, который не имеет еще проводном вниз до элемента, вызвавшего его значение <xref:System.Windows.RoutedEventArgs.Source%2A> будет отличаться от значения `sender` илинастроек параметр класс аргументов события. Какой из двух элементов, участвующее в событии является наиболее важной в любой заданный обработчик (<xref:System.Windows.RoutedEventArgs.Source%2A>, создавший его, элемент или `sender`, элемент, который в настоящее время обрабатывает его) зависит от логики приложения, которая является обработчиком адресация.  
  
 Задание этого свойства обычно выполняется только при переопределении или при реализации других [!INCLUDE[TLA#tla_api#plural](~/includes/tlasharptla-apisharpplural-md.md)] , настройте источники событий, например, если обработчик события класса. Сбрасывать видимых источников событий с обработчиков экземпляров не рекомендуется, особенно в том случае, если обработчик не помечает событие как обработанное.  
  
 При сбросе <xref:System.Windows.RoutedEventArgs.Source%2A> сообщить источнику другое событие <xref:System.Windows.RoutedEventArgs.OriginalSource%2A> продолжит создавать отчеты, вызванные исходной источнику как первый <xref:System.Windows.UIElement.RaiseEvent%2A> вызова.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.RoutedEventArgs.OriginalSource" />
      </Docs>
    </Member>
  </Members>
</Type>