<Type Name="WeakEventManager" FullName="System.Windows.WeakEventManager">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8241e2ff47b51e906cfa1cf3ca25aac03e6ca974" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37489334" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class WeakEventManager : System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract WeakEventManager extends System.Windows.Threading.DispatcherObject" />
  <TypeSignature Language="DocId" Value="T:System.Windows.WeakEventManager" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class WeakEventManager&#xA;Inherits DispatcherObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class WeakEventManager abstract : System::Windows::Threading::DispatcherObject" />
  <TypeSignature Language="F#" Value="type WeakEventManager = class&#xA;    inherit DispatcherObject" />
  <AssemblyInfo>
    <AssemblyName>WindowsBase</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Threading.DispatcherObject</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Provides a base class for the event manager that is used in the *weak event pattern*. The manager adds and removes listeners for events (or callbacks) that also use the pattern.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Шаблон слабых событий обычно используется, когда источник событий имеет времени жизни объекта, который является независимым от прослушивателей событий. С помощью центра события диспетчеризации возможность <xref:System.Windows.WeakEventManager> позволяет обработчики прослушивателей мусора, даже если исходного объекта. И наоборот регулярное событие подключения с помощью `+=` оператор вызывает потенциально отключенный источник для хранения ссылки в прослушиватели. Это не позволяет получателю сборщику мусора своевременно.  
  
 Одна из распространенных ситуаций где следует использовать время существования связи между источниками и прослушивателями шаблона слабых событий, является обработка событий обновления, поступающих от привязки данных.  
  
 Шаблон слабых событий может также использоваться для обратных вызовов и обычным событиями.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Пример настраиваемого <see cref="T:System.Windows.WeakEventManager" />, см. в разделе [Patterns](~/docs/framework/wpf/advanced/weak-event-patterns.md) слабых событий.</para>
    </block>
    <altmember cref="T:System.Windows.IWeakEventListener" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected WeakEventManager ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; WeakEventManager();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes base class values when it is used as the initializer by the constructor of a derived class.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DeliverEvent">
      <MemberSignature Language="C#" Value="protected void DeliverEvent (object sender, EventArgs args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEvent(object sender, class System.EventArgs args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEvent (sender As Object, args As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DeliverEvent(System::Object ^ sender, EventArgs ^ args);" />
      <MemberSignature Language="F#" Value="member this.DeliverEvent : obj * EventArgs -&gt; unit" Usage="weakEventManager.DeliverEvent (sender, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="sender">The object on which the event is being handled.</param>
        <param name="args">An <see cref="T:System.EventArgs" /> that contains the event data for the event to deliver.</param>
        <summary>Delivers the event being managed to each listener.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите <xref:System.Windows.WeakEventManager.DeliverEvent%2A> метода в обработчики событий, добавляются или удаляются с <xref:System.Windows.WeakEventManager.StartListening%2A> и <xref:System.Windows.WeakEventManager.StopListening%2A> реализаций из подклассов.  
  
 При вызове метода <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> метод в вашей `AddListener` реализации этого класса в список прослушивателей, получающего событие сохраняется в базовой коллекции. (`AddListener` не является частью контракта интерфейса или класса. `AddListener` предлагаемое имя для метода классе диспетчера, который вызывает <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> и добавляет прослушиватели шаблон слабых событий для события.)  
  
 <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> Добавляет один список прослушивателей. Если ваша реализация диспетчера поддерживает более одного списка прослушивателей каждого события, не используйте <xref:System.Windows.WeakEventManager.DeliverEvent%2A> или <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>. Вместо этого реализация следует создавать собственную <xref:System.Windows.WeakEventManager.ListenerList> экземпляров, `AddListener` необходимо добавить прослушиватели в соответствующий список, причем доставки событий соответствующий прослушиватель в список путем вызова <xref:System.Windows.WeakEventManager.DeliverEventToList%2A>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
      </Docs>
    </Member>
    <Member MemberName="DeliverEventToList">
      <MemberSignature Language="C#" Value="protected void DeliverEventToList (object sender, EventArgs args, System.Windows.WeakEventManager.ListenerList list);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void DeliverEventToList(object sender, class System.EventArgs args, class System.Windows.WeakEventManager/ListenerList list) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub DeliverEventToList (sender As Object, args As EventArgs, list As WeakEventManager.ListenerList)" />
      <MemberSignature Language="F#" Value="member this.DeliverEventToList : obj * EventArgs * System.Windows.WeakEventManager.ListenerList -&gt; unit" Usage="weakEventManager.DeliverEventToList (sender, args, list)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void DeliverEventToList(System::Object ^ sender, EventArgs ^ args, System::Windows::WeakEventManager::ListenerList ^ list);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
        <Parameter Name="args" Type="System.EventArgs" />
        <Parameter Name="list" Type="System.Windows.WeakEventManager+ListenerList" />
      </Parameters>
      <Docs>
        <param name="sender">The object on which the event is being handled.</param>
        <param name="args">An <see cref="T:System.EventArgs" /> that contains the event data.</param>
        <param name="list">The provided <see cref="T:System.Windows.WeakEventManager.ListenerList" />.</param>
        <summary>Delivers the event being managed to each listener in the provided list.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод необходим в том случае, если ваша реализация диспетчера поддерживает отдельные списки прослушивателей на основе сведений, собранных в данных события. Если вы используете это сложная процедура, необходимо создать и поддерживать отдельные списки как часть своей реализации диспетчера, и необходимо указать способ добавления прослушивателей в определенный список. Свою реализацию обработчика, который прослушивает необработанных событий необходимо фиксировать условие, используйте для дифференциации списков и доставить событие только один или несколько соответствующих списков.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentManager">
      <MemberSignature Language="C#" Value="protected static System.Windows.WeakEventManager GetCurrentManager (Type managerType);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig class System.Windows.WeakEventManager GetCurrentManager(class System.Type managerType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Function GetCurrentManager (managerType As Type) As WeakEventManager" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static System::Windows::WeakEventManager ^ GetCurrentManager(Type ^ managerType);" />
      <MemberSignature Language="F#" Value="static member GetCurrentManager : Type -&gt; System.Windows.WeakEventManager" Usage="System.Windows.WeakEventManager.GetCurrentManager managerType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="managerType">The type to obtain the <see cref="T:System.Windows.WeakEventManager" /> for.</param>
        <summary>Returns the <see cref="T:System.Windows.WeakEventManager" /> implementation that is used for the provided type.</summary>
        <returns>The matching <see cref="T:System.Windows.WeakEventManager" /> implementation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.IWeakEventListener.ReceiveWeakEvent%2A> реализации вызывать этот метод, с помощью их переданного `managerType`. Возвращенный <xref:System.Windows.WeakEventManager> используется в качестве отличие, которое определяет, какое событие было получено и какой закрытый обработчик класса для вызова.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="protected object this[object source] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(object)" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.Item(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Default Protected Property Item(source As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Object ^ default[System::Object ^] { System::Object ^ get(System::Object ^ source); void set(System::Object ^ source, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(obj) : obj with get, set" Usage="System.Windows.WeakEventManager.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">The zero-based index of the requested source.</param>
        <summary>Gets or sets the data being stored for the specified source.</summary>
        <value>Сохраняемых диспетчером для этого источника данных.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Производные классы могут выбрать, какие данные и тип для хранения в этот индексатор. Обычно это реализуется как <xref:System.Windows.WeakEventManager.ListenerList>, которой приведен список слабых ссылок на прослушиватели. Вы бы только для изменения этого типа, если <xref:System.Windows.WeakEventManager.ListenerList> тип не может содержать необходимые сведения. Если таким образом, необходимо переопределить <xref:System.Windows.WeakEventManager.Purge%2A> метод таким образом, чтобы правильно выполнить очистку базового типа.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="NewListenerList">
      <MemberSignature Language="C#" Value="protected virtual System.Windows.WeakEventManager.ListenerList NewListenerList ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Windows.WeakEventManager/ListenerList NewListenerList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.NewListenerList" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function NewListenerList () As WeakEventManager.ListenerList" />
      <MemberSignature Language="F#" Value="abstract member NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList&#xA;override this.NewListenerList : unit -&gt; System.Windows.WeakEventManager.ListenerList" Usage="weakEventManager.NewListenerList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WeakEventManager+ListenerList</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a new object to contain listeners to an event.</summary>
        <returns>A new object to contain listeners to an event.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedAddHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedAddHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">The source object that the handler delegate subscribes to.</param>
        <param name="handler">The delegate that handles the event that is raised by <c>source</c>.</param>
        <summary>Adds the specified delegate as an event handler of the specified source.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedAddListener">
      <MemberSignature Language="C#" Value="protected void ProtectedAddListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedAddListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedAddListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedAddListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedAddListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedAddListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">The source to attach listeners to.</param>
        <param name="listener">The listening class (which must implement <see cref="T:System.Windows.IWeakEventListener" />).</param>
        <summary>Adds the provided listener to the provided source for the event being managed.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод в классе диспетчера `AddListener` методы <xref:System.Windows.WeakEventManager> реализаций. `AddListener` предлагаемое имя для статического метода, определяемого в классе диспетчера, чтобы позволить другим классам для этого добавьте прослушиватель для шаблона слабых событий. `AddListener` должен принимать два параметра: `source` там, где прослушиватель подключен и `listener` экземпляра. Для вашего `AddListener` реализации, вызов <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> метод на текущий диспетчер и передайте эти же параметры.  
  
 Если ранее пусто, в список прослушивателей <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> вызовы <xref:System.Windows.WeakEventManager.StartListening%2A> метод внутренне, который будет вызывать конкретными <xref:System.Windows.WeakEventManager.StartListening%2A> переопределить через полиморфизм.  
  
 <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A> Добавляет один внутренний прослушиватели <xref:System.Windows.WeakEventManager.ListenerList> на `source`. Если ваша реализация диспетчера поддерживает более одного списка прослушивателей для каждой комбинации источника событий, не используйте <xref:System.Windows.WeakEventManager.ProtectedAddListener%2A>. Вместо этого реализация следует создавать собственную <xref:System.Windows.WeakEventManager.ListenerList> экземпляров, `AddListener` необходимо добавить прослушиватели в соответствующий список, причем доставки событий соответствующий прослушиватель в список путем вызова <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> события вместо <xref:System.Windows.WeakEventManager.DeliverEvent%2A> метод.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveHandler">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveHandler (object source, Delegate handler);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveHandler(object source, class System.Delegate handler) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveHandler(System.Object,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveHandler (source As Object, handler As Delegate)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveHandler(System::Object ^ source, Delegate ^ handler);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveHandler : obj * Delegate -&gt; unit" Usage="weakEventManager.ProtectedRemoveHandler (source, handler)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="handler" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">The source to remove the handler from.</param>
        <param name="handler">The delegate to remove from <c>source</c>.</param>
        <summary>Removes the previously added handler from the specified source.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ProtectedRemoveListener">
      <MemberSignature Language="C#" Value="protected void ProtectedRemoveListener (object source, System.Windows.IWeakEventListener listener);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ProtectedRemoveListener(object source, class System.Windows.IWeakEventListener listener) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ProtectedRemoveListener (source As Object, listener As IWeakEventListener)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ProtectedRemoveListener(System::Object ^ source, System::Windows::IWeakEventListener ^ listener);" />
      <MemberSignature Language="F#" Value="member this.ProtectedRemoveListener : obj * System.Windows.IWeakEventListener -&gt; unit" Usage="weakEventManager.ProtectedRemoveListener (source, listener)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="listener" Type="System.Windows.IWeakEventListener" />
      </Parameters>
      <Docs>
        <param name="source">The source to remove listeners from.</param>
        <param name="listener">The listening class (which must implement <see cref="T:System.Windows.IWeakEventListener" />).</param>
        <summary>Removes a previously added listener from the provided source.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите этот метод в классе диспетчера `RemoveListener` методы <xref:System.Windows.WeakEventManager> реализаций. `RemoveListener` предлагаемое имя для статического метода, определяемого в классе диспетчера, чтобы позволить другим классам, следует удалить прослушиватель для шаблона слабых событий. `RemoveListener` должен принимать два параметра: `source` там, где удаляется прослушиватель и `listener` класса. Для вашего `RemoveListener` реализации, вызов <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> метод на текущий диспетчер и передайте эти же параметры.  
  
 Если в вызове <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> удаляет последнего прослушивателя в списке <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> вызовы <xref:System.Windows.WeakEventManager.StopListening%2A> метод внутренне, который будет вызывать конкретными <xref:System.Windows.WeakEventManager.StopListening%2A> переопределить через полиморфизм.  
  
 <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A> Удаляет прослушиватели с одного внутреннего <xref:System.Windows.WeakEventManager.ListenerList> на `source`. Если ваша реализация диспетчера поддерживает более одного списка прослушивателей для каждой комбинации источника событий, не используйте <xref:System.Windows.WeakEventManager.ProtectedRemoveListener%2A>. Вместо этого реализация следует создавать собственную <xref:System.Windows.WeakEventManager.ListenerList> экземпляров, `RemoveListener` следует удалить прослушивателей из соответствующего списка и доставки событий соответствующий прослушиватель в список путем вызова <xref:System.Windows.WeakEventManager.DeliverEventToList%2A> вместо метода <xref:System.Windows.WeakEventManager.DeliverEvent%2A> метод.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedAddListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="Purge">
      <MemberSignature Language="C#" Value="protected virtual bool Purge (object source, object data, bool purgeAll);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool Purge(object source, object data, bool purgeAll) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Purge (source As Object, data As Object, purgeAll As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool Purge(System::Object ^ source, System::Object ^ data, bool purgeAll);" />
      <MemberSignature Language="F#" Value="abstract member Purge : obj * obj * bool -&gt; bool&#xA;override this.Purge : obj * obj * bool -&gt; bool" Usage="weakEventManager.Purge (source, data, purgeAll)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="purgeAll" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="source">The source for events being listened to.</param>
        <param name="data">The data to check. This object is expected to be a <see cref="T:System.Windows.WeakEventManager.ListenerList" /> implementation.</param>
        <param name="purgeAll">
          <see langword="true" /> to stop listening to <c>source</c>, and completely remove all entries from <c>data</c>.</param>
        <summary>Removes inactive listener entries from the data list for the provided source. Returns <see langword="true" /> if some entries were actually removed from the list.</summary>
        <returns>
          <see langword="true" /> if some entries were actually removed; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.WeakEventManager.Purge%2A> Метод имеет реализацию по умолчанию, будут удалены все записи, когда данные <xref:System.Windows.WeakEventManager.ListenerList>.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Если базовый тип для <see cref="P:System.Windows.WeakEventManager.Item(System.Object)" /> -то отличное от <see cref="T:System.Windows.WeakEventManager.ListenerList" />, или содержит данные, которые превышают <see cref="T:System.Windows.WeakEventManager.ListenerList" />, необходимо переопределить <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" /> метод. Переопределение должна обеспечивать поведение очистки для альтернативный тип элементов списка. Как правило переопределение должно обеспечить поведение без вызова базовой реализации. Если определенный <see cref="T:System.Windows.WeakEventManager.ListenerList" /> по-прежнему требуется очистка, вызов <see cref="M:System.Windows.WeakEventManager.ListenerList.Purge" />.</para>
        </block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
      </Docs>
    </Member>
    <Member MemberName="ReadLock">
      <MemberSignature Language="C#" Value="protected IDisposable ReadLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable ReadLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.ReadLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property ReadLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ ReadLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadLock : IDisposable" Usage="System.Windows.WeakEventManager.ReadLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Establishes a read-lock on the underlying data table, and returns an <see cref="T:System.IDisposable" />.</summary>
        <value>Объект, который может использоваться для блокировки членов таблицы данных и затем корректно удален с <see langword="using" /> построения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В производных классах, отправляет запрос к таблице, содержащейся в <xref:System.Windows.WeakEventManager.Item%2A> должно всегда выполняться в пределах `using (ReadLock) { ... }` предложение, за исключением запросов, которые уже находятся в пределах блокировку записи. Эти запросы, может потребоваться в том случае, если ваш класс поддерживает более сложные `AddListener` реализация, которая требует дополнительные данные, которые превышают `source` и `listener`и использует <xref:System.Windows.WeakEventManager.Item%2A> коллекцию для хранения дополнительных сведений.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.WriteLock" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="protected void Remove (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void Remove(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.Remove(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub Remove (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void Remove(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="member this.Remove : obj -&gt; unit" Usage="weakEventManager.Remove source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">The source to remove listener information for.</param>
        <summary>Removes all listeners for the specified source.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="M:System.Windows.WeakEventManager.ProtectedRemoveListener(System.Object,System.Windows.IWeakEventListener)" />
      </Docs>
    </Member>
    <Member MemberName="ScheduleCleanup">
      <MemberSignature Language="C#" Value="protected void ScheduleCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void ScheduleCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.ScheduleCleanup" />
      <MemberSignature Language="VB.NET" Value="Protected Sub ScheduleCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void ScheduleCleanup();" />
      <MemberSignature Language="F#" Value="member this.ScheduleCleanup : unit -&gt; unit" Usage="weakEventManager.ScheduleCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Requests that a purge of unused entries in the underlying listener list be performed on a lower priority thread.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов <xref:System.Windows.WeakEventManager.ScheduleCleanup%2A> аналогично вызову метода <xref:System.Windows.WeakEventManager.Purge%2A> метод в списке текущий диспетчер на низком уровне приоритета потока с `purgeAll` параметру присвоить `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="SetCurrentManager">
      <MemberSignature Language="C#" Value="protected static void SetCurrentManager (Type managerType, System.Windows.WeakEventManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method familystatic hidebysig void SetCurrentManager(class System.Type managerType, class System.Windows.WeakEventManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.SetCurrentManager(System.Type,System.Windows.WeakEventManager)" />
      <MemberSignature Language="VB.NET" Value="Protected Shared Sub SetCurrentManager (managerType As Type, manager As WeakEventManager)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; static void SetCurrentManager(Type ^ managerType, System::Windows::WeakEventManager ^ manager);" />
      <MemberSignature Language="F#" Value="static member SetCurrentManager : Type * System.Windows.WeakEventManager -&gt; unit" Usage="System.Windows.WeakEventManager.SetCurrentManager (managerType, manager)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="managerType" Type="System.Type" />
        <Parameter Name="manager" Type="System.Windows.WeakEventManager" />
      </Parameters>
      <Docs>
        <param name="managerType">The type to set the new event manager.</param>
        <param name="manager">The new event manager.</param>
        <summary>Sets the current manager for the specified manager type.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызовите <xref:System.Windows.WeakEventManager.SetCurrentManager%2A> метод для инициализации руководителем, если это требуется с помощью вызова вашего `CurrentManager` свойство <xref:System.Windows.WeakEventManager> реализации.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StartListening">
      <MemberSignature Language="C#" Value="protected abstract void StartListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StartListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StartListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StartListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StartListening : obj -&gt; unit" Usage="weakEventManager.StartListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">The source to begin listening on.</param>
        <summary>When overridden in a derived class, starts listening for the event being managed. After the <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> method is first called, the manager should be in the state of calling <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> or <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" /> whenever the relevant event from the provided source is handled.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> переопределения должны добавить обработчик к предоставленному <paramref name="source" />. Обработчик объявляется самим диспетчером. Обработчик класса не должен быть открытым и должен вызываться только в ответ на управляемое событие. Обработчик класса следует вызывать <see cref="M:System.Windows.WeakEventManager.DeliverEvent(System.Object,System.EventArgs)" /> метод или <see cref="M:System.Windows.WeakEventManager.DeliverEventToList(System.Object,System.EventArgs,System.Windows.WeakEventManager.ListenerList)" /> метод соответствующим образом.</para>
        </block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.GetCurrentManager(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="StopListening">
      <MemberSignature Language="C#" Value="protected abstract void StopListening (object source);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void StopListening(object source) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.WeakEventManager.StopListening(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub StopListening (source As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void StopListening(System::Object ^ source);" />
      <MemberSignature Language="F#" Value="abstract member StopListening : obj -&gt; unit" Usage="weakEventManager.StopListening source" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="source">The source to stop listening on.</param>
        <summary>When overridden in a derived class, stops listening on the provided source for the event being managed.</summary>
        <remarks>To be added.</remarks>
        <block subset="none" type="overrides">
          <para>
            <see cref="M:System.Windows.WeakEventManager.StopListening(System.Object)" /> реализации следует удалить обработчик класса, как добавленные <see cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" /> метод. Удаление прослушивателя не сбросит прослушиватель в список. Вместо этого он должен только отключить обработчик класса (возможно, временно). Другие методы будут доступны для очистки всего списка, таких как <see cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" /> метод с <paramref name="purgeAll" /> параметру присвоить <see langword="true" />.</para>
        </block>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="M:System.Windows.WeakEventManager.StartListening(System.Object)" />
        <altmember cref="M:System.Windows.WeakEventManager.Purge(System.Object,System.Object,System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLock">
      <MemberSignature Language="C#" Value="protected IDisposable WriteLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.IDisposable WriteLock" />
      <MemberSignature Language="DocId" Value="P:System.Windows.WeakEventManager.WriteLock" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property WriteLock As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property IDisposable ^ WriteLock { IDisposable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.WriteLock : IDisposable" Usage="System.Windows.WeakEventManager.WriteLock" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>WindowsBase</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Establishes a write-lock on the underlying data table, and returns an <see cref="T:System.IDisposable" />.</summary>
        <value>Объект, который может использоваться для блокировки членов таблицы данных и затем корректно удален с <see langword="using" /> построения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В производных классах, все изменения в базовую таблицу данных должно выполняться в пределах `using (WriteLock) { ... }` предложение. Эти изменения может потребоваться в том случае, если ваш класс поддерживает более сложные `AddListener` реализация, которая требует дополнительные данные, которые превышают `source` и `listener`и использует <xref:System.Windows.WeakEventManager.Item%2A> коллекцию для хранения дополнительных сведений.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.IWeakEventListener" />
        <altmember cref="T:System.Windows.WeakEventManager.ListenerList" />
        <altmember cref="P:System.Windows.WeakEventManager.ReadLock" />
      </Docs>
    </Member>
  </Members>
</Type>