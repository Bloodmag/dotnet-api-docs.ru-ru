<Type Name="Window" FullName="System.Windows.Window">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="f805a8dedd189924a31c53379179c725286ba810" />
    <Meta Name="ms.sourcegitcommit" Value="cc0c87a2e12b0fb9ba9ecdd3d4950f0572524db8" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="05/03/2018" />
    <Meta Name="ms.locfileid" Value="32695014" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Window : System.Windows.Controls.ContentControl" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Window extends System.Windows.Controls.ContentControl" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Window" />
  <TypeSignature Language="VB.NET" Value="Public Class Window&#xA;Inherits ContentControl" />
  <TypeSignature Language="C++ CLI" Value="public ref class Window : System::Windows::Controls::ContentControl" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Controls.ContentControl</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Ignore)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет возможность создавать, настраивать, показывать обычные и диалоговые окна, а также управлять временем их существования.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Точка взаимодействия между пользователем и автономное приложение — это окно. Объект [!INCLUDE[TLA#tla_winclient](~/includes/tlasharptla-winclient-md.md)] окно состоит из двух различных областей:  
  
-   Неклиентская область, которая содержит элементы оформления окна, включая значок, заголовок, системное меню «свернуть», максимизировать кнопки, восстановления, кнопку закрытия и границу.  
  
-   Клиентская область, в котором размещается содержимое для конкретного приложения.  
  
 Стандартное окно показано на следующем рисунке:  
  
 ![Элементы окна](~/add/media/windowoverviewfigure1.PNG "элементы окна")  
  
 <xref:System.Windows.Window> Инкапсулирует возможность создавать, настраивать, показывать и управлять временем жизни и диалоговые окна и предоставляет следующие ключевые службы:  
  
 **Управление временем существования**: <xref:System.Windows.Window.Activate%2A>, <xref:System.Windows.Window.Activated>, <xref:System.Windows.Window.Close%2A>, <xref:System.Windows.Window.Closed>, <xref:System.Windows.Window.Closing>, <xref:System.Windows.Window.Deactivated>, <xref:System.Windows.Window.Hide%2A>, <xref:System.Windows.Window.IsActive%2A>, <xref:System.Windows.Window.Show%2A>, <xref:System.Windows.Window.SourceInitialized>.  
  
 **Управление окнами**: <xref:System.Windows.Window.GetWindow%2A>, <xref:System.Windows.Window.OwnedWindows%2A>, <xref:System.Windows.Window.Owner%2A>.  
  
 **Внешний вид и поведение**: <xref:System.Windows.Window.AllowsTransparency%2A>, <xref:System.Windows.Window.ContentRendered>, <xref:System.Windows.Window.DragMove%2A>, <xref:System.Windows.Window.Icon%2A>, <xref:System.Windows.Window.Left%2A>, <xref:System.Windows.Window.LocationChanged>, <xref:System.Windows.Window.ResizeMode%2A>, <xref:System.Windows.Window.RestoreBounds%2A>, <xref:System.Windows.Window.ShowActivated%2A>, <xref:System.Windows.Window.ShowInTaskbar%2A>, <xref:System.Windows.Window.SizeToContent%2A>, <xref:System.Windows.Window.StateChanged>, <xref:System.Windows.Window.Title%2A>, <xref:System.Windows.Window.Top%2A>, <xref:System.Windows.Window.Topmost%2A>, <xref:System.Windows.Window.WindowStartupLocation%2A>, <xref:System.Windows.Window.WindowState%2A>, <xref:System.Windows.Window.WindowStyle%2A>  
  
 **Диалоговые окна**: <xref:System.Windows.Window.DialogResult%2A>, <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Кроме того <xref:System.Windows.Application> предоставляет специальную поддержку для управления все окна в приложении:  
  
-   Приложение поддерживает список всех окон, которые в данный момент созданы в приложении. Этот список предоставляется <xref:System.Windows.Application.Windows%2A> свойство.  
  
-   По умолчанию <xref:System.Windows.Application.MainWindow%2A> автоматически устанавливается со ссылкой на первый <xref:System.Windows.Window> , создается в приложении. Это делая окна главного окна приложения.  
  
 Объект <xref:System.Windows.Window> может осуществляться с помощью разметки, разметки и кода или кода.  
  
 <xref:System.Windows.Window> в основном используется для отображения окна и диалоговые окна для автономных приложений. Однако для приложений, требующих навигации на уровне окна, например мастера, можно использовать <xref:System.Windows.Navigation.NavigationWindow> вместо; <xref:System.Windows.Navigation.NavigationWindow> является производным от <xref:System.Windows.Window> и расширяет его с поддержкой навигации в стиле браузера.  
  
> [!NOTE]
>  Острова содержимого с поддержкой навигации могут включаться в другие содержимое и контейнеры с помощью <xref:System.Windows.Controls.Frame>.  
  
 <xref:System.Windows.Window> требуется `UnmanagedCode` создания разрешения безопасности. Это приводит к следующим последствиям:  
  
-   [!INCLUDE[TLA#tla_clickonce](~/includes/tlasharptla-clickonce-md.md)]-развернутой отдельные приложения запросят повышения разрешений при запуске из зон Интернета или локальной интрасети.  
  
-   [!INCLUDE[TLA2#tla_xbap#plural](~/includes/tla2sharptla-xbapsharpplural-md.md)] запрашивающие меньше, чем полные права доступа не будет иметь возможность создать экземпляр windows или диалоговым окнам.  
  
 Сведения о автономное развертывание приложений и рекомендации по безопасности см. в разделе [стратегия безопасности WPF — безопасность платформы](~/docs/framework/wpf/wpf-security-strategy-platform-security.md).  
  
 Объект <xref:System.Windows.Window> является <xref:System.Windows.Controls.ContentControl>, означающее, что она может содержать один объект любого типа (например, строки, изображения или панели). Дополнительные сведения см. в описании класса <xref:System.Windows.Controls.ContentControl>. Кроме того <xref:System.Windows.Window> является корневым элементом, и, следовательно, не может быть частью содержимого другого элемента.  
  
> [!NOTE]
>  <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.Window.Top%2A>, И <xref:System.Windows.Window.Left%2A> свойства, заданные <xref:System.Windows.Window> через стиль не будут применяться во время выполнения.  
  
## <a name="customizing-the-window-control"></a>Настройка элементов управления в окно  
 Чтобы применить к нескольким значения свойств <xref:System.Windows.Window> использовать элементы управления <xref:System.Windows.FrameworkElement.Style%2A> свойство. Можно изменить значение по умолчанию <xref:System.Windows.Controls.ControlTemplate> для предоставления уникального внешнего вида элемента управления. Дополнительные сведения о создании <xref:System.Windows.Controls.ControlTemplate>, в разделе [Настройка внешнего вида существующего элемента управления путем создания объекта ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  Чтобы увидеть части и состояния, которые относятся к <xref:System.Windows.Window>, в разделе [окна Стили и шаблоны](~/docs/framework/wpf/controls/window-styles-and-templates.md).  
  
 Свойства зависимостей для этого элемента управления могут быть заданы посредством стиля элемента управления по умолчанию.  Если свойство задано стилем по умолчанию, когда элемент управления появится в приложении свойство может изменять значения по умолчанию. Стиль по умолчанию определяется по какая тема рабочего стола используется при запуске приложения.  Дополнительные сведения см. в разделе [темы по умолчанию WPF](http://go.microsoft.com/fwlink/?LinkID=158252).  
  
> [!NOTE]
>  Установка visual свойства будет действовать только если это свойство является одновременно присутствуют в <xref:System.Windows.Window> элемента управления, шаблон по умолчанию и устанавливается с помощью. Список визуальных свойств можно найти в разделе «Изменение Visual структуры управления» в [Настройка внешнего вида существующего элемента управления путем создания объекта ControlTemplate](~/docs/framework/wpf/controls/customizing-the-appearance-of-an-existing-control.md).  
  
   
  
## Examples  
 В следующем примере показано, как стандартное окно — с использованием одной разметки:  
  
 [!code-xaml[WindowSnippets#WindowMARKUPONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MarkupOnlyWindow.xaml#windowmarkuponly)]  
  
 В следующем примере показан как стандартное окно определяется с использованием только кода:  
  
 [!code-csharp[WindowSnippets#WindowCODEONLY](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/CodeOnlyWindow.cs#windowcodeonly)]
 [!code-vb[WindowSnippets#WindowCODEONLY](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/codeonlywindow.vb#windowcodeonly)]  
  
 В следующем примере показано, как стандартное окно — с использованием комбинации разметки и кода.  
  
 [!code-xaml[WindowSnippets#WindowXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml#windowxaml)]  
  
 [!code-csharp[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowSnippets/CSharp/MainWindow.xaml.cs#windowcodebehind)]
 [!code-vb[WindowSnippets#WindowCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowSnippets/visualbasic/mainwindow.xaml.vb#windowcodebehind)]  
  
 ]]></format>
    </remarks>
    <altmember cref="M:System.Windows.Window.Show" />
    <altmember cref="M:System.Windows.Window.ShowDialog" />
    <altmember cref="P:System.Windows.Window.DialogResult" />
    <altmember cref="T:System.Windows.Application" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Window ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Window();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Windows.Window" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Конструктор инициализирует <xref:System.Windows.FrameworkElement.Width%2A>, <xref:System.Windows.FrameworkElement.Height%2A>, <xref:System.Windows.Window.Top%2A>, и <xref:System.Windows.Window.Left%2A> свойства по умолчанию <xref:System.Windows.Window> значения.  
  
 Если окно создается в пределах <xref:System.AppDomain> с <xref:System.Windows.Application> объекта конструктор добавляет <xref:System.Windows.Window> объекта в набор <xref:System.Windows.Application>-управляемых windows через <xref:System.Windows.Application.Windows%2A> свойство <xref:System.Windows.Application> объекта.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для разрешения для этого объекта вызов небезопасных собственных методов. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Activate">
      <MemberSignature Language="C#" Value="public bool Activate ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Activate() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Activate" />
      <MemberSignature Language="VB.NET" Value="Public Function Activate () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Activate();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Пытается переместить окно на передний план и активирует его.</summary>
        <returns>
          <see langword="true" />, если окно <see cref="T:System.Windows.Window" /> было успешно активировано; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Правила, определяющие, имеет ли окно активироваться совпадают с используемыми [!INCLUDE[TLA2#tla_win32](~/includes/tla2sharptla-win32-md.md)] `SetForegroundWindow` функции (User32.dll).  
  
 Если окно активируется в приложении Windows Presentation Foundation, которое не является приложением пользователя переднего плана, <xref:System.Windows.Application.Activated> событие.  
  
> [!NOTE]
>  Этот метод не может вызываться, когда окно размещается в браузере.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для разрешения на активацию окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="Activated">
      <MemberSignature Language="C#" Value="public event EventHandler Activated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Activated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Activated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Activated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Activated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при выведении окна на передний план.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Окно активируется (попадает на передний план) при:  
  
-   Сначала открывается окно.  
  
-   Пользователь переключается на окно, выбрав его с помощью мыши, нажав клавиши ALT + TAB или из диспетчера задач.  
  
-   Пользователь нажимает кнопку панели задач.  
  
 Операционная система, необходимо обнаружить, когда они становятся активировать обрабатывает <xref:System.Windows.Window.Activated> событий.  
  
 После активации окна он может деактивировать и повторно много раз за время своего существования. Если поведение или состояние приложения зависит от состояния его активации, можно изучить <xref:System.Windows.Window.IsActive%2A> для определения каком он находится в состоянии активации.  
  
 Приложение также может быть <xref:System.Windows.Application.Activated>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Deactivated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparency">
      <MemberSignature Language="C#" Value="public bool AllowsTransparency { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool AllowsTransparency" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.AllowsTransparency" />
      <MemberSignature Language="VB.NET" Value="Public Property AllowsTransparency As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool AllowsTransparency { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, поддерживает ли клиентская область окна прозрачность.</summary>
        <value>
          <see langword="true" />, если окно поддерживает прозрачность; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Windows.Controls.Control.Background%2A> окна свойству прозрачного цвета, с помощью <xref:System.Windows.Media.Brushes.Transparent%2A> к примеру, окно остается непрозрачным. Это означает, что отображается рабочий стол и любые выполняемые операции «под окном». Чтобы разрешить такой тип прозрачности, <xref:System.Windows.Window.AllowsTransparency%2A> должно быть присвоено `true`.  
  
 <xref:System.Windows.Window.AllowsTransparency%2A> существует позволяет создавать непрямоугольные окна и, следовательно, при <xref:System.Windows.Window.AllowsTransparency%2A> равно `true`, окна <xref:System.Windows.Window.WindowStyle%2A> свойству необходимо присвоить значение <xref:System.Windows.WindowStyle.None>.  
  
<a name="dependencyPropertyInfo_WindowAllowsTransparency"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Window.AllowsTransparencyProperty>|  
|Значение свойства метаданных `true`|Нет|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Окно, значение свойства <see cref="P:System.Windows.Window.WindowStyle" /> которого отлично от <see cref="F:System.Windows.WindowStyle.None" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="AllowsTransparencyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty AllowsTransparencyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty AllowsTransparencyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.AllowsTransparencyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AllowsTransparencyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ AllowsTransparencyProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.AllowsTransparency" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ArrangeOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size ArrangeOverride (System.Windows.Size arrangeBounds);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size ArrangeOverride(valuetype System.Windows.Size arrangeBounds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function ArrangeOverride (arrangeBounds As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size ArrangeOverride(System::Windows::Size arrangeBounds);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arrangeBounds" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="arrangeBounds">Объект <see cref="T:System.Windows.Size" />, отражающий окончательный размер, который следует использовать окну для упорядочения себя и своих дочерних окон.</param>
        <summary>Переопределив данный метод, можно упорядочить окно и его дочерние элементы, а также изменить их размер.</summary>
        <returns>Объект <see cref="T:System.Windows.Size" />, отражающий фактический размер, который использовался.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.ArrangeOverride%2A> не вызывается, когда <xref:System.Windows.UIElement.Visibility%2A> свойство имеет значение <xref:System.Windows.Visibility.Collapsed>. Если значение <xref:System.Windows.UIElement.Visibility%2A> равно либо <xref:System.Windows.Visibility.Hidden> или <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.ArrangeOverride%2A> вызывается.  
  
> [!NOTE]
>  Когда либо <xref:System.Windows.Window.Show%2A> или <xref:System.Windows.Window.ShowDialog%2A> , называются <xref:System.Windows.UIElement.Visibility%2A> свойство <xref:System.Windows.Window> равно <xref:System.Windows.Visibility.Visible>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Вручную закрывает окно <see cref="T:System.Windows.Window" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Объект <xref:System.Windows.Window> может быть закрыто с помощью одного из нескольких хорошо известных, системных механизмов, расположенных в его заголовке, включая:  
  
-   ALT + F4.  
  
-   Системное меню &#124; **закрыть**.  
  
-   **Закрыть** кнопки.  
  
 Объект <xref:System.Windows.Window> может быть закрыто с помощью одного из нескольких хорошо известных механизмов в клиентской области, предоставляемых разработчиками, включая:  
  
-   **Файл** &#124; **выхода** в главном окне.  
  
-   **Файл** &#124; **закрыть** или **закрыть** кнопки для дочернего окна.  
  
> [!NOTE]
>  **ОК** и **отменить** предоставляются для разработчиков, кнопок в диалоговом окне, также несмотря на то что будет вероятный набор <xref:System.Windows.Window.DialogResult%2A>, который автоматически закрывает окно, которое было открыто посредством вызова <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Эти механизмы необходимо явным образом вызвать <xref:System.Windows.Window.Close%2A> для закрытия окна.  
  
> [!NOTE]
>  Если открыть окно путем вызова <xref:System.Windows.Window.ShowDialog%2A>и с <xref:System.Windows.Controls.Button> с его <xref:System.Windows.Controls.Button.IsCancel%2A> свойству задано значение true, автоматически закроется при нажатии кнопки либо или нажатия клавиши ESC. Если окно было открыто с помощью <xref:System.Windows.Window.Show%2A>, но при этом <xref:System.Windows.Window.Close%2A> должно быть явно вызываемые, например, в <xref:System.Windows.Controls.Primitives.ButtonBase.Click> обработчик событий для <xref:System.Windows.Controls.Button>.  
  
 Закрытие окна вызывает <xref:System.Windows.Window.Closing> вызова события. Если <xref:System.Windows.Window.Closing> событий не отменяется, то происходит следующее:  
  
-   <xref:System.Windows.Window> Удаляется из <xref:System.Windows.Application.Windows%2A?displayProperty=nameWithType> (если <xref:System.Windows.Application> объект существует).  
  
-   <xref:System.Windows.Window> Удаляется из владельца <xref:System.Windows.Window> , если было установлено связь владелец/собственное перед принадлежащие <xref:System.Windows.Window> рассмотренному и после владельца <xref:System.Windows.Window> был открыт.  
  
-   Возникает событие <xref:System.Windows.Window.Closed>.  
  
-   Неуправляемые ресурсы, созданные <xref:System.Windows.Window> удаляются.  
  
-   Если <xref:System.Windows.Window.ShowDialog%2A> был вызван для отображения <xref:System.Windows.Window>, <xref:System.Windows.Window.ShowDialog%2A> возвращает.  
  
 Закрытие <xref:System.Windows.Window> предписывает принадлежащих ему будет закрыта. Кроме того, закрытие <xref:System.Windows.Window> может привести к остановке выполнения в зависимости от того как приложение <xref:System.Windows.Application.ShutdownMode%2A?displayProperty=nameWithType> свойству.  
  
> [!NOTE]
>  Этот метод не может вызываться, когда окно размещается в браузере.  
  
   
  
## Examples  
 В следующем примере показан **файл** &#124; **выхода** меню обрабатываемых для явного вызова <xref:System.Windows.Window.Close%2A>.  
  
 [!code-xaml[WindowCloseSnippets#WindowCloseXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml#windowclosexaml)]  
  
 [!code-csharp[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowCloseSnippets/CSharp/MainWindow.xaml.cs#windowclosecodebehind)]
 [!code-vb[WindowCloseSnippets#WindowCloseCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowCloseSnippets/visualbasic/mainwindow.xaml.vb#windowclosecodebehind)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для разрешения использования все окна и события пользовательского ввода без ограничений. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="P:System.Windows.Window.DialogResult" />
        <altmember cref="P:System.Windows.Window.Owner" />
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="Closed">
      <MemberSignature Language="C#" Value="public event EventHandler Closed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Closed" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closed As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Closed;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда окно готово к закрытию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После данного события, не может быть закрытие окна предотвратить.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          Задано свойство <see cref="P:System.Windows.UIElement.Visibility" /> либо вызван один из методов <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" /> или <see cref="M:System.Windows.Window.Hide" /> во время закрытия окна.</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closing" />
        <altmember cref="M:System.Windows.Application.Shutdown" />
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="E:System.Windows.Application.SessionEnding" />
      </Docs>
    </Member>
    <Member MemberName="Closing">
      <MemberSignature Language="C#" Value="public event System.ComponentModel.CancelEventHandler Closing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ComponentModel.CancelEventHandler Closing" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Closing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Closing As CancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::ComponentModel::CancelEventHandler ^ Closing;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.CancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит непосредственно после вызова метода <see cref="M:System.Windows.Window.Close" /> и может быть обработано с отменой закрытия окна.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.Closing> может использоваться для обнаружения при закрытии окна (например, в том случае, когда <xref:System.Windows.Window.Close%2A> вызывается). Кроме того <xref:System.Windows.Window.Closing> может использоваться для предотвращения закрытия окна. Для предотвращения закрытия окна, можно задать <xref:System.ComponentModel.CancelEventArgs.Cancel%2A> свойство <xref:System.ComponentModel.CancelEventArgs> аргумент `true`.  
  
 <xref:System.Windows.Window.Closing> Событие возникает при <xref:System.Windows.Window.Close%2A> вызывается, если щелкнуть кнопку закрытия окна или при нажатии клавиш ALT + F4.  
  
 Если собственное окно был открыт с помощью окна его владельца <xref:System.Windows.Window.Show%2A>и владелец закрытия окна, принадлежащие окна <xref:System.Windows.Window.Closing> событие не происходит. Если владелец окна закрывается (см. <xref:System.Windows.Window.Owner%2A>), <xref:System.Windows.Window.Closing> не возникает для собственного окна.  
  
 Если <xref:System.Windows.Application.Shutdown%2A> вызове <xref:System.Windows.Window.Closing> событие для каждого окна. Тем не менее если <xref:System.Windows.Window.Closing> будет отменена, отмены игнорируется.  
  
 При завершении сеанса, так как пользователь выходит из системы или завершает работу, <xref:System.Windows.Window.Closing> не возникает; обработка <xref:System.Windows.Application.SessionEnding> реализовать код, который отменяет закрытия приложения.  
  
 Если нужно показать или скрыть окно несколько раз в течение жизненного цикла приложения и вы не хотите повторного создания окна каждый раз, можно отобразить, можно обрабатывать <xref:System.Windows.Window.Closing> событий, отменить его, а также вызвать <xref:System.Windows.Window.Hide%2A> метод. Затем можно вызвать <xref:System.Windows.Window.Show%2A> на том же экземпляре, чтобы снова открыть его.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Windows.Window> , определяющее, когда требуется вмешательство пользователя для закрытия.  
  
 [!code-xaml[WindowClosingSnippets#WindowClosingXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml#windowclosingxaml1)]  
  
 [!code-csharp[WindowClosingSnippets](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowClosingSnippets/CSharp/DataWindow.xaml.cs)]
 [!code-vb[WindowClosingSnippets](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowClosingSnippets/visualbasic/datawindow.xaml.vb)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          Задано свойство <see cref="P:System.Windows.UIElement.Visibility" /> либо вызван один из методов <see cref="M:System.Windows.Window.Show" />, <see cref="M:System.Windows.Window.ShowDialog" /> или <see cref="M:System.Windows.Window.Close" /> во время закрытия окна.</exception>
        <altmember cref="P:System.Windows.Application.ShutdownMode" />
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="E:System.Windows.Window.Closed" />
      </Docs>
    </Member>
    <Member MemberName="ContentRendered">
      <MemberSignature Language="C#" Value="public event EventHandler ContentRendered;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ContentRendered" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.ContentRendered" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ContentRendered As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ContentRendered;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после завершения отображения содержимого окна.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если окно не имеет содержимого, это событие не возникает.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Controls.ContentControl.Content" />
        <altmember cref="E:System.Windows.FrameworkElement.Loaded" />
      </Docs>
    </Member>
    <Member MemberName="Deactivated">
      <MemberSignature Language="C#" Value="public event EventHandler Deactivated;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler Deactivated" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.Deactivated" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Deactivated As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ Deactivated;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при перемещении окна на задний план.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Окно деактивируется (попадает на задний план) при:  
  
-   Пользователь переключается на другое окно в текущем приложении.  
  
-   Пользователь переключается на окно в другом приложении, с помощью клавиш ALT + TAB или с помощью диспетчера задач.  
  
-   Пользователь нажимает кнопку панели задач для окна в другое приложение.  
  
 Windows, которые необходимо обнаружить, когда они становятся деактивированный обработки <xref:System.Windows.Window.Deactivated> событий.  
  
 После деактивации окна его повторной активации и деактивации множество раз за время существования. Если поведение или состояние приложения зависит от состояния его активации, можно изучить <xref:System.Windows.Window.IsActive%2A> для определения каком он находится в состоянии активации.  
  
 Приложение также может быть <xref:System.Windows.Application.Deactivated>.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="P:System.Windows.Window.IsActive" />
      </Docs>
    </Member>
    <Member MemberName="DialogResult">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; DialogResult { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Nullable`1&lt;bool&gt; DialogResult" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.DialogResult" />
      <MemberSignature Language="VB.NET" Value="Public Property DialogResult As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Nullable&lt;bool&gt; DialogResult { Nullable&lt;bool&gt; get(); void set(Nullable&lt;bool&gt; value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter(typeof(System.Windows.DialogResultConverter))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает результирующее значение диалоговое окна, то есть значение, которое будет возвращено методом <see cref="M:System.Windows.Window.ShowDialog" />.</summary>
        <value>Значение <see cref="T:System.Nullable`1" /> типа <see cref="T:System.Boolean" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.DialogResult%2A> может использоваться из кода, в который было показано диалоговое окно для определения того, приняты ли пользователь (`true`) или отменена (`false`) диалоговое окно. Если диалоговое окно было принято, это означает для кода, который открывается диалоговое окно для получения данных, собранных с пользователем и его. Если диалоговое окно было отменено, однако это означает, что вызывающему коду следует прекратить дальнейшую обработку.  
  
 По умолчанию диалоговое окно отменяется, когда пользователь выполняет одно из следующих:  
  
-   PressesALT + F4.  
  
-   Щелкает **закрыть** кнопки.  
  
-   Выбирает **закрыть** в системном меню.  
  
 Во всех этих случаях <xref:System.Windows.Window.DialogResult%2A> — `false` по умолчанию.  
  
 Диалоговое окно обычно предоставляет отдельную кнопку, чтобы закрыть диалоговое окно, который является кнопкой которого <xref:System.Windows.Controls.Button.IsCancel%2A> свойству `true`. Кнопка, настроенная таким образом автоматически закроется окно при нажатии или при нажатии клавиши ESC. В любом из этих случаев <xref:System.Windows.Window.DialogResult%2A> остается `false`.  
  
 Диалоговое окно также обычно предоставляет кнопки «принять», который является кнопкой которого <xref:System.Windows.Controls.Button.IsDefault%2A> свойству `true`. Кнопка, настроенная таким образом будет вызывать его <xref:System.Windows.Controls.Primitives.ButtonBase.Click> событие при нажатии ее или клавишу ВВОД. Однако он не будет автоматически закрыто диалоговым окном, нельзя будет задать <xref:System.Windows.Window.DialogResult%2A> для `true`. Необходимо вручную записать этот код, обычно из <xref:System.Windows.Controls.Primitives.ButtonBase.Click> обработчик событий для кнопки по умолчанию.  
  
 <xref:System.Windows.Window.DialogResult%2A> — `null` при отображении диалогового окна но принятые ни отменена.  
  
 После закрытия диалогового окна можно получить результат диалогового окна из значения, возвращенного <xref:System.Windows.Window.ShowDialog%2A> метод, или путем проверки <xref:System.Windows.Window.DialogResult%2A> свойство.  
  
 <xref:System.Windows.Window.DialogResult%2A> можно задать только при <xref:System.Windows.Window> открытия путем вызова его <xref:System.Windows.Window.ShowDialog%2A> метод.  
  
> [!NOTE]
>  Не удается задать или получить значение этого свойства, если окно размещено в браузере.  
  
   
  
## Examples  
 Приведенный ниже показано, как настроить кнопку "ОК" и "Отмена" для возврата соответствующего <xref:System.Windows.Window.DialogResult%2A>.  
  
 [!code-xaml[WindowDialogResultSnippets#WindowDialogResultXAML](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml#windowdialogresultxaml)]  
  
 [!code-csharp[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDialogResultSnippets/CSharp/DialogBox.xaml.cs#windowdialogresultcodebehind)]
 [!code-vb[WindowDialogResultSnippets#WindowDialogResultCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDialogResultSnippets/visualbasic/dialogbox.xaml.vb#windowdialogresultcodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <see cref="P:System.Windows.Window.DialogResult" /> задан, до того как окно открывается путем вызова <see cref="M:System.Windows.Window.ShowDialog" />.  
  
 - или -  
  
 <see cref="P:System.Windows.Window.DialogResult" /> задан для окна, которое открывается путем вызова <see cref="M:System.Windows.Window.Show" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DpiChanged">
      <MemberSignature Language="C#" Value="public event System.Windows.DpiChangedEventHandler DpiChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Windows.DpiChangedEventHandler DpiChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.DpiChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DpiChanged As DpiChangedEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event System::Windows::DpiChangedEventHandler ^ DpiChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DpiChangedEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит после изменения значения DPI для экрана, на котором отображается Window.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DpiChangedEvent">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.RoutedEvent DpiChangedEvent;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.RoutedEvent DpiChangedEvent" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.DpiChangedEvent" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly DpiChangedEvent As RoutedEvent " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::RoutedEvent ^ DpiChangedEvent;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.RoutedEvent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <see cref="T:System.Windows.RoutedEvent" />, если разрешение (DPI) экрана Window изменяется.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DragMove">
      <MemberSignature Language="C#" Value="public void DragMove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DragMove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.DragMove" />
      <MemberSignature Language="VB.NET" Value="Public Sub DragMove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DragMove();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Позволяет перетаскивать окно мышью с зажатой левой кнопкой над открытой частью клиентской области окна.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Левая кнопка мыши должна быть отключена при <xref:System.Windows.Window.DragMove%2A> вызывается. Является одним из способов определить при нажатии левой кнопки мыши для обработки <xref:System.Windows.UIElement.MouseLeftButtonDown> событий.  
  
 Когда <xref:System.Windows.Window.DragMove%2A> вызывается влево должен нажата кнопка мыши над открытой клиентской области окна.  
  
> [!NOTE]
>  Этот метод не может вызываться, когда окно размещается в браузере.  
  
   
  
## Examples  
 В следующем примере показан способ переопределения <xref:System.Windows.UIElement.OnMouseLeftButtonDown%2A> для вызова <xref:System.Windows.Window.DragMove%2A>.  
  
 [!code-csharp[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowDragMoveSnippets/CSharp/MainWindow.xaml.cs#callwindowdragmovecodebehind)]
 [!code-vb[WindowDragMoveSnippets#CallWindowDragMoveCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowDragMoveSnippets/visualbasic/mainwindow.xaml.vb#callwindowdragmovecodebehind)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Левая кнопка мыши не нажата.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для разрешения на перетаскивание окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="E:System.Windows.Window.LocationChanged" />
      </Docs>
    </Member>
    <Member MemberName="GetWindow">
      <MemberSignature Language="C#" Value="public static System.Windows.Window GetWindow (System.Windows.DependencyObject dependencyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.Window GetWindow(class System.Windows.DependencyObject dependencyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.GetWindow(System.Windows.DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::Window ^ GetWindow(System::Windows::DependencyObject ^ dependencyObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dependencyObject" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="dependencyObject">Объект зависимостей.</param>
        <summary>Возвращает ссылку на объект <see cref="T:System.Windows.Window" />, содержащий дерево содержимого, в котором расположен объект зависимостей.</summary>
        <returns>Ссылка <see cref="T:System.Windows.Window" /> на окно-хранилище.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="dependencyObject" /> имеет значение null.</exception>
      </Docs>
    </Member>
    <Member MemberName="Hide">
      <MemberSignature Language="C#" Value="public void Hide ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Hide() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Hide" />
      <MemberSignature Language="VB.NET" Value="Public Sub Hide ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Hide();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Делает окно невидимым.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Окно не закрывается после скрыта и ни <xref:System.Windows.Window.Closing> , ни <xref:System.Windows.Window.Closed> события. Вместо этого окна <xref:System.Windows.UIElement.Visibility%2A> свойству <xref:System.Windows.Visibility.Hidden?displayProperty=nameWithType>.  
  
 Если окно приложения <xref:System.Windows.Application.MainWindow%2A> и приложения <xref:System.Windows.Application.ShutdownMode%2A> — <xref:System.Windows.ShutdownMode.OnMainWindowClose>, приложение не завершает работу. Аналогичным образом, приложения не завершена, если окно является окном только и режим завершения работы приложения — <xref:System.Windows.ShutdownMode.OnLastWindowClose>.  
  
 Если нужно показать или скрыть окно несколько раз в течение жизненного цикла приложения, и вы не хотите повторно создать экземпляр окна при каждом его открыть, можно обработать <xref:System.Windows.Window.Closing> событий, отменить его, а также вызвать <xref:System.Windows.Window.Hide%2A> метод. Затем можно вызвать <xref:System.Windows.Window.Show%2A> на том же экземпляре, чтобы снова открыть его.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          Метод <see cref="M:System.Windows.Window.Hide" /> вызывается для окна, которое закрывается (<see cref="E:System.Windows.Window.Closing" />) или закрыто (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <altmember cref="M:System.Windows.Window.Show" />
        <altmember cref="M:System.Windows.Window.ShowDialog" />
        <altmember cref="M:System.Windows.Window.Close" />
      </Docs>
    </Member>
    <Member MemberName="Icon">
      <MemberSignature Language="C#" Value="public System.Windows.Media.ImageSource Icon { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Media.ImageSource Icon" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Icon" />
      <MemberSignature Language="VB.NET" Value="Public Property Icon As ImageSource" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Media::ImageSource ^ Icon { System::Windows::Media::ImageSource ^ get(); void set(System::Windows::Media::ImageSource ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.ImageSource</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка значка окна.</summary>
        <value>Объект <see cref="T:System.Windows.Media.ImageSource" />, представляющий значок.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Автономные приложения Windows Presentation Foundation (WPF) имеет два типа значков:  
  
-   Значок одной сборки, который задается с помощью `<ApplicationIcon>` файл сборки свойство в проекте приложения. Этот значок используется на рабочем столе для сборки.  
  
    > [!NOTE]
    >  При отладке в Visual Studio значка вашего могут не отображаться из-за процесса размещения. При запуске исполняемого файла, то появляется значок. Дополнительные сведения см. в статье [Ведущий процесс (vshost.exe)](http://msdn.microsoft.com/library/c6b9e2be-f18d-4d75-ac52-56d55784734b).  
  
-   Один значок каждого окна, который задается параметром <xref:System.Windows.Window.Icon%2A>. Для каждого окна этот значок используется в строке заголовка кнопке панели задач и его элемент списка выбора приложения ALT TAB.  
  
 Окна WPF всегда отображается значок. Если значение не указано, задав <xref:System.Windows.Window.Icon%2A>, WPF выбирает значок для отображения на основе следующих правил:  
  
1.  Используйте значок сборки, если указан.  
  
2.  Если значок сборки не указан, используется значок по умолчанию Microsoft Windows.  
  
 Если вы используете <xref:System.Windows.Window.Icon%2A> Чтобы задать значок пользовательского окна, можно восстановить значок приложения по умолчанию, установив <xref:System.Windows.Window.Icon%2A> для `null`.  
  
 Один значок может использоваться различными способами в Windows, включая отображение в строке заголовка окна, на панели задач для окна, список выбора файлов ALT + TAB. Каждый из них будет отображаться значок разного размера; значок 16 x 16 пикселей отображается в строке заголовка окна и на панели задач, а значок 32 x 32 пикселей в списке выбора файлов ALT + TAB. Некоторые приложения, например [!INCLUDE[TLA#tla_winexpl](~/includes/tlasharptla-winexpl-md.md)], предоставляют **представление** меню, в котором можно выбрать размер значка, который вы хотите просмотреть.  
  
 Чтобы ориентироваться на различные размеры, файл значка состоит из одного или нескольких реальных значков, каждый из которых представляет версии значка, который предназначен для определенной глубины размер и цвет. Например один значок может иметь только один значок 16 x 16 точек с 16 цветами, а другой — 16 x 16 точек и 32 x 32 пикселя значков с 16 цветами и 256 цветов.  
  
 Если существуют значки всех возможных размеров и цветов в файл значка <xref:System.Windows.Window> будет использовать соответствующий значок. Если файл значка содержит только подмножество всех возможных значков <xref:System.Windows.Window> использует Далее наиболее соответствующий значок в порядке уменьшения размеров и цветов.  
  
 Результатом является то, что значок будет всегда использоваться <xref:System.Windows.Window>, несмотря на то, что значок, используемый целевыми могут быть не требуется глубину размер и цвет. Значок 16 x 16 точек с 16 цветами может использоваться для отображения как значок 32 x 32 точки с 256 цветами. Это может вызвать нежелательные визуальные эффекты, такие как пиксиляцию, но можно избежать, создавая значки всех целевых размеров и цветов.  
  
> [!NOTE]
>  Не удается задать или получить значение этого свойства, если окно размещено в браузере.  
  
<a name="dependencyPropertyInfo_WindowIcon"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Window.IconProperty>|  
|Значение свойства метаданных `true`|Нет|  
  
   
  
## Examples  
 В следующем примере показано, как задать значок окна.  
  
 [!code-xaml[WindowIconSnippets#WindowIconSetXAML](~/samples/snippets/xaml/VS_Snippets_Wpf/WindowIconSnippets/XAML/MainWindow.xaml#windowiconsetxaml)]  
  
 [!code-csharp[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowIconSnippets/CSharp/MainWindow.xaml.cs#setwindowiconincode)]
 [!code-vb[WindowIconSnippets#SetWindowIconInCode](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowIconSnippets/visualbasic/mainwindow.xaml.vb#setwindowiconincode)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для разрешения для выбора значка. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IconProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IconProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IconProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IconProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IconProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IconProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.Icon" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsActive">
      <MemberSignature Language="C#" Value="public bool IsActive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsActive" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.IsActive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsActive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsActive { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, активно ли окно.</summary>
        <value>
          <see langword="true" />, если окно активно; в противном случае — <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Активное окно пользователя текущее окно переднего плана и имеет фокус, принятое active внешний вид заголовка окна. Активного окна также будет самый верхний всех окон верхнего уровня, в которых не задано явно <xref:System.Windows.Window.Topmost%2A> свойство.  
  
<a name="dependencyPropertyInfo_WindowIsActive"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Window.IsActiveProperty>|  
|Значение свойства метаданных `true`|Нет|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.Activate" />
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="IsActiveProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty IsActiveProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty IsActiveProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.IsActiveProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly IsActiveProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ IsActiveProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.IsActive" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Left">
      <MemberSignature Language="C#" Value="public double Left { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Left" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Left" />
      <MemberSignature Language="VB.NET" Value="Public Property Left As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Left { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает позицию левого края окна относительно рабочего стола.</summary>
        <value>Позиция левого края окна в логических единицах (1/96 дюйма).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Windows.Window> свернуто или развернуто, это значение соответствует левого края восстановления точка для <xref:System.Windows.Window>.  
  
 Это свойство нельзя задать с помощью стиля.  
  
 Если вы не укажете значение, <xref:System.Windows.Window.Left%2A> присвоено значение по умолчанию. Можно также указать значение по умолчанию, задав <xref:System.Windows.Window.Left%2A> для <xref:System.Double.NaN>. Ни <xref:System.Double.NegativeInfinity> , ни <xref:System.Double.PositiveInfinity> является допустимым значением для <xref:System.Windows.Window.Left%2A>.  
  
> [!NOTE]
>  Не удается задать или получить значение этого свойства, если окно размещено в браузере.  
  
<a name="dependencyPropertyInfo_WindowLeft"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Window.LeftProperty>|  
|Значение свойства метаданных `true`|Нет|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="LeftProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty LeftProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty LeftProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.LeftProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly LeftProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ LeftProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.Left" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocationChanged">
      <MemberSignature Language="C#" Value="public event EventHandler LocationChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler LocationChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.LocationChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event LocationChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ LocationChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении местоположения окна.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Расположение окна изменяется, когда:  
  
-   Пользователь перемещает окно, перетащив заголовок окна.  
  
-   Окно перемещается после <xref:System.Windows.Window.DragMove%2A> вызывается.  
  
-   Либо <xref:System.Windows.Window.Left%2A> или <xref:System.Windows.Window.Top%2A> свойству программными средствами.  
  
-   **Переместить** выбранного пункта меню окна системного меню.  
  
-   <xref:System.Windows.Window.WindowState%2A> Изменить свойство.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="LogicalChildren">
      <MemberSignature Language="C#" Value="protected internal override System.Collections.IEnumerator LogicalChildren { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.IEnumerator LogicalChildren" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.LogicalChildren" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides ReadOnly Property LogicalChildren As IEnumerator" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual property System::Collections::IEnumerator ^ LogicalChildren { System::Collections::IEnumerator ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает перечислитель для логических дочерних элементов окна.</summary>
        <value>Перечислитель <see cref="T:System.Collections.IEnumerator" /> для логических дочерних элементов окна.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.FrameworkElement.LogicalChildren" />
      </Docs>
    </Member>
    <Member MemberName="MeasureOverride">
      <MemberSignature Language="C#" Value="protected override System.Windows.Size MeasureOverride (System.Windows.Size availableSize);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance valuetype System.Windows.Size MeasureOverride(valuetype System.Windows.Size availableSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function MeasureOverride (availableSize As Size) As Size" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Size MeasureOverride(System::Windows::Size availableSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Size</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="availableSize" Type="System.Windows.Size" />
      </Parameters>
      <Docs>
        <param name="availableSize">Объект <see cref="T:System.Windows.Size" />, отражающий доступный размер, который данное окно может выделить своим дочерним окнам. Можно задать бесконечное значение, указав, что окно будет масштабироваться в соответствии с любым содержимым.</param>
        <summary>Переопределив данный метод, можно измерить размер окна.</summary>
        <returns>Объект <see cref="T:System.Windows.Size" />, отражающий размер, потребности в котором данное окно определяет во время структурирования, основываясь на вычисленных размерах дочерних окон.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.MeasureOverride%2A> не вызывается, когда <xref:System.Windows.UIElement.Visibility%2A> свойство имеет значение <xref:System.Windows.Visibility.Collapsed>. Если значение <xref:System.Windows.UIElement.Visibility%2A> равно либо <xref:System.Windows.Visibility.Hidden> или <xref:System.Windows.Visibility.Visible>, <xref:System.Windows.Window.MeasureOverride%2A> вызывается.  
  
> [!NOTE]
>  Когда либо <xref:System.Windows.Window.Show%2A> или <xref:System.Windows.Window.ShowDialog%2A> , называются <xref:System.Windows.UIElement.Visibility%2A> свойство <xref:System.Windows.Window> равно <xref:System.Windows.Visibility.Visible>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.FrameworkElement.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
      </Docs>
    </Member>
    <Member MemberName="OnActivated">
      <MemberSignature Language="C#" Value="protected virtual void OnActivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnActivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnActivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnActivated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Window.Activated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Window.OnActivated%2A> формирует событие <xref:System.Windows.Window.Activated>.  
  
 Тип, производный от <xref:System.Windows.Window> могут переопределять <xref:System.Windows.Window.OnActivated%2A>. Переопределенный метод должен вызвать метод <xref:System.Windows.Window.OnActivated%2A> базового класса, если <xref:System.Windows.Window.Activated> должен вызываться.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosed">
      <MemberSignature Language="C#" Value="protected virtual void OnClosed (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosed(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosed (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosed(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Window.Closed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Window.OnClosed%2A> формирует событие <xref:System.Windows.Window.Closed>.  
  
 Тип, производный от <xref:System.Windows.Window> могут переопределять <xref:System.Windows.Window.OnClosed%2A>. Переопределенный метод должен вызвать метод <xref:System.Windows.Window.OnClosed%2A> базового класса, если <xref:System.Windows.Window.Closed> должен вызываться.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnClosing">
      <MemberSignature Language="C#" Value="protected virtual void OnClosing (System.ComponentModel.CancelEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnClosing(class System.ComponentModel.CancelEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnClosing(System.ComponentModel.CancelEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnClosing (e As CancelEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnClosing(System::ComponentModel::CancelEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.ComponentModel.CancelEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект <see cref="T:System.ComponentModel.CancelEventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Window.Closing" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Window.OnClosing%2A> формирует событие <xref:System.Windows.Window.Closing>.  
  
 Тип, производный от <xref:System.Windows.Window> могут переопределять <xref:System.Windows.Window.OnClosing%2A>. Переопределенный метод должен вызвать метод <xref:System.Windows.Window.OnClosing%2A> базового класса, если <xref:System.Windows.Window.Closing> должен вызываться.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnClosed(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnContentChanged">
      <MemberSignature Language="C#" Value="protected override void OnContentChanged (object oldContent, object newContent);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnContentChanged(object oldContent, object newContent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentChanged(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnContentChanged (oldContent As Object, newContent As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnContentChanged(System::Object ^ oldContent, System::Object ^ newContent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldContent" Type="System.Object" />
        <Parameter Name="newContent" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="oldContent">Ссылка на корневой элемент старого дерева содержимого.</param>
        <param name="newContent">Ссылка на корневой элемент нового дерева содержимого.</param>
        <summary>Вызывается при изменении свойства <see cref="P:System.Windows.Controls.ContentControl.Content" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnContentRendered">
      <MemberSignature Language="C#" Value="protected virtual void OnContentRendered (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnContentRendered(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnContentRendered(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnContentRendered (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnContentRendered(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Window.ContentRendered" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Window.OnContentRendered%2A> формирует событие <xref:System.Windows.Window.ContentRendered>.  
  
 Тип, производный от <xref:System.Windows.Window> могут переопределять <xref:System.Windows.Window.OnContentRendered%2A>. Переопределенный метод должен вызвать метод <xref:System.Windows.Window.OnContentRendered%2A> базового класса, если <xref:System.Windows.Window.ContentRendered> должен вызываться.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnCreateAutomationPeer">
      <MemberSignature Language="C#" Value="protected override System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Automation.Peers.AutomationPeer OnCreateAutomationPeer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnCreateAutomationPeer" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function OnCreateAutomationPeer () As AutomationPeer" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Automation::Peers::AutomationPeer ^ OnCreateAutomationPeer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Automation.Peers.AutomationPeer</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает и возвращает объект <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> для этого объекта <see cref="T:System.Windows.Window" />.</summary>
        <returns>Объект <see cref="T:System.Windows.Automation.Peers.WindowAutomationPeer" /> для этого объекта <see cref="T:System.Windows.Window" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод переопределяет метод <xref:System.Windows.ContentElement.OnCreateAutomationPeer%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnDeactivated">
      <MemberSignature Language="C#" Value="protected virtual void OnDeactivated (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnDeactivated(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDeactivated(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnDeactivated (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnDeactivated(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Window.Deactivated" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Window.OnDeactivated%2A> формирует событие <xref:System.Windows.Window.Deactivated>.  
  
 Тип, производный от <xref:System.Windows.Window> могут переопределять <xref:System.Windows.Window.OnDeactivated%2A>. Переопределенный метод должен вызвать метод <xref:System.Windows.Window.OnDeactivated%2A> базового класса, если <xref:System.Windows.Window.Deactivated> должен вызываться.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.OnActivated(System.EventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="OnDpiChanged">
      <MemberSignature Language="C#" Value="protected override void OnDpiChanged (System.Windows.DpiScale oldDpi, System.Windows.DpiScale newDpi);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnDpiChanged(valuetype System.Windows.DpiScale oldDpi, valuetype System.Windows.DpiScale newDpi) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnDpiChanged(System.Windows.DpiScale,System.Windows.DpiScale)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnDpiChanged (oldDpi As DpiScale, newDpi As DpiScale)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnDpiChanged(System::Windows::DpiScale oldDpi, System::Windows::DpiScale newDpi);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldDpi" Type="System.Windows.DpiScale" />
        <Parameter Name="newDpi" Type="System.Windows.DpiScale" />
      </Parameters>
      <Docs>
        <param name="oldDpi">Предыдущий параметр масштабирования.</param>
        <param name="newDpi">Новый параметр масштабирования.</param>
        <summary>Вызывается, когда изменяется параметр "точек на дюйм", по которому определяется разрешение окна.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnLocationChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnLocationChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnLocationChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnLocationChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnLocationChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnLocationChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Window.LocationChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Window.OnLocationChanged%2A> формирует событие <xref:System.Windows.Window.LocationChanged>.  
  
 Тип, производный от <xref:System.Windows.Window> могут переопределять <xref:System.Windows.Window.OnLocationChanged%2A>. Переопределенный метод должен вызвать метод <xref:System.Windows.Window.OnLocationChanged%2A> базового класса, если <xref:System.Windows.Window.LocationChanged> должен вызываться.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
        <altmember cref="P:System.Windows.Window.Top" />
      </Docs>
    </Member>
    <Member MemberName="OnManipulationBoundaryFeedback">
      <MemberSignature Language="C#" Value="protected override void OnManipulationBoundaryFeedback (System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnManipulationBoundaryFeedback(class System.Windows.Input.ManipulationBoundaryFeedbackEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnManipulationBoundaryFeedback (e As ManipulationBoundaryFeedbackEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnManipulationBoundaryFeedback(System::Windows::Input::ManipulationBoundaryFeedbackEventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Windows.Input.ManipulationBoundaryFeedbackEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Данные для события.</param>
        <summary>Вызывается, когда происходит событие <see cref="E:System.Windows.UIElement.ManipulationBoundaryFeedback" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта реализация не изменяет состояние обработки ( <xref:System.Windows.RoutedEventArgs.Handled%2A> свойство) из <xref:System.Windows.UIElement.ManipulationBoundaryFeedback> данные события.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>При переопределении <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" />, всегда вызывать базовую реализацию вашей <see cref="M:System.Windows.Window.OnManipulationBoundaryFeedback(System.Windows.Input.ManipulationBoundaryFeedbackEventArgs)" /> реализации. Не удалось вызвать базовую реализацию базовые классы не смогут обрабатывать событие, которое может изменить поведение во время выполнения конечного класса. В зависимости от требований, можно вызвать базовую реализацию до или после специальной обработки.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="OnSourceInitialized">
      <MemberSignature Language="C#" Value="protected virtual void OnSourceInitialized (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnSourceInitialized(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnSourceInitialized(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnSourceInitialized (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnSourceInitialized(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Window.SourceInitialized" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Window.OnSourceInitialized%2A> формирует событие <xref:System.Windows.Window.SourceInitialized>.  
  
 Тип, производный от <xref:System.Windows.Window> могут переопределять <xref:System.Windows.Window.OnSourceInitialized%2A>. Переопределенный метод должен вызвать метод <xref:System.Windows.Window.OnSourceInitialized%2A> базового класса, если <xref:System.Windows.Window.SourceInitialized> должен вызываться.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnStateChanged">
      <MemberSignature Language="C#" Value="protected virtual void OnStateChanged (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnStateChanged(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnStateChanged(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnStateChanged (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnStateChanged(EventArgs ^ e);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Объект класса <see cref="T:System.EventArgs" />, содержащий данные события.</param>
        <summary>Вызывает событие <see cref="E:System.Windows.Window.StateChanged" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод <xref:System.Windows.Window.OnStateChanged%2A> формирует событие <xref:System.Windows.Window.StateChanged>.  
  
 Тип, производный от <xref:System.Windows.Window> могут переопределять <xref:System.Windows.Window.OnStateChanged%2A>. Переопределенный метод должен вызвать метод <xref:System.Windows.Window.OnStateChanged%2A> базового класса, если <xref:System.Windows.Window.StateChanged> должен вызываться.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnVisualParentChanged">
      <MemberSignature Language="C#" Value="protected internal override sealed void OnVisualParentChanged (System.Windows.DependencyObject oldParent);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig virtual instance void OnVisualParentChanged(class System.Windows.DependencyObject oldParent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.OnVisualParentChanged(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overrides NotOverridable Sub OnVisualParentChanged (oldParent As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; override void OnVisualParentChanged(System::Windows::DependencyObject ^ oldParent);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="oldParent" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="oldParent">Предыдущий родительский элемент. Устанавливается на null, если у объекта <see cref="T:System.Windows.DependencyObject" /> не было предыдущего родителя.</param>
        <summary>Вызывается при изменении родителя окна.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Windows.UIElement.OnVisualParentChanged(System.Windows.DependencyObject)" />
      </Docs>
    </Member>
    <Member MemberName="OwnedWindows">
      <MemberSignature Language="C#" Value="public System.Windows.WindowCollection OwnedWindows { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.WindowCollection OwnedWindows" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.OwnedWindows" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OwnedWindows As WindowCollection" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowCollection ^ OwnedWindows { System::Windows::WindowCollection ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowCollection</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает коллекцию окон, владельцем которых является данное окно.</summary>
        <value>Коллекция <see cref="T:System.Windows.WindowCollection" />, содержащая ссылки на окна, владельцем которых является данное окно.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Собственное окно — это которого <xref:System.Windows.Window.Owner%2A> свойству со ссылкой на другое окно, которая называется окна-владельца. Чтобы найти все окна, которыми владеет окно-владелец, можно перечислить <xref:System.Windows.WindowCollection> , возвращаемый <xref:System.Windows.Window.OwnedWindows%2A> свойство.  
  
   
  
## Examples  
 В следующем примере показано, как перечислить <xref:System.Windows.Window.OwnedWindows%2A>.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#getwindowownedwindowscode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#GetWindowOwnedWindowsCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#getwindowownedwindowscode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Owner">
      <MemberSignature Language="C#" Value="public System.Windows.Window Owner { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Window Owner" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Owner" />
      <MemberSignature Language="VB.NET" Value="Public Property Owner As Window" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Window ^ Owner { System::Windows::Window ^ get(); void set(System::Windows::Window ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(null)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Window</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает окно <see cref="T:System.Windows.Window" />, которое владеет данным окном <see cref="T:System.Windows.Window" />.</summary>
        <value>Объект <see cref="T:System.Windows.Window" />, представляющий владельца данного объекта <see cref="T:System.Windows.Window" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При открытии дочернего окна родительское окно, вызвав <xref:System.Windows.Window.ShowDialog%2A>, явную связь устанавливается между родительским и дочерним окнами. Эта связь накладывает определенное поведение, в том числе по отношению к минимуму, разворачивания и восстановления.  
  
 При создании дочернего окна родительское окно, вызвав <xref:System.Windows.Window.Show%2A>, однако, дочернее окно не имеет связи с родительским окном. Это означает следующее.  
  
-   Дочернее окно не имеет ссылки на родительском окне.  
  
-   Поведение дочернего окна не зависит от поведения родительского окна. либо окна может охватывать другого или свести к минимуму, разворачиваться и восстанавливаться независимо от другого.  
  
 Чтобы можно было создать связь между дочерним и родительского окна, <xref:System.Windows.Window> поддерживает понятие владения. Владение устанавливается при <xref:System.Windows.Window.Owner%2A> окна (собственного окна) является свойство со ссылкой на другое окно (окно-владелец).  
  
 После установления этой связи проявляется следующее поведение:  
  
-   Если окно-владелец сворачивается, все его собственные окна также сворачиваются.  
  
-   Если собственное окно сворачивается, его владелец не сводится к минимуму.  
  
-   Если окно-владелец развернуто, окна-владельца и его собственные окна восстанавливаются.  
  
-   Окно-владелец никогда не может перекрывать собственное окно.  
  
-   Принадлежащий windows, которые не были открыты с помощью <xref:System.Windows.Window.ShowDialog%2A> не модальным. Пользователь по-прежнему могут взаимодействовать с окна-владельца.  
  
-   Если закрыть окно-владелец, его собственные окна также будут закрыты.  
  
-   Если собственное окно был открыт с помощью окна его владельца <xref:System.Windows.Window.Show%2A>и владелец закрытия окна, принадлежащие окна <xref:System.Windows.Window.Closing> событие не происходит.  
  
 При открытии дочернего окна, вызвав <xref:System.Windows.Window.ShowDialog%2A>, также следует задать <xref:System.Windows.Window.Owner%2A> свойство дочернего окна. Если этого не сделать, пользователи не будет доступной для восстановления дочернее окно и родительское окно, нажав кнопку панели задач. Вместо этого нажав кнопку панели задач даст список окон, включая, дочерние и родительские окна для них требуется выделить; восстанавливается только выбранный период.  
  
> [!IMPORTANT]
>  Также следует задать <xref:System.Windows.Window.Owner%2A> свойства в окне, который открывается путем вызова <xref:System.Windows.Window.ShowDialog%2A> для обеспечения правильного поведения с.  
  
> [!NOTE]
>  Не удается задать или получить значение этого свойства, если окно размещено в браузере.  
  
   
  
## Examples  
 Приведенный ниже показано, как для установления связи или принадлежащим владельца.  
  
 [!code-csharp[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/CSharp/MainWindow.xaml.cs#setwindowownercode)]
 [!code-vb[WindowOwnerOwnedWindowsSnippets#SetWindowOwnerCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowOwnerOwnedWindowsSnippets/visualbasic/mainwindow.xaml.vb#setwindowownercode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Окно пытается стать владельцем самого себя  
  
 - или -  
  
 Два окна пытаются стать владельцами друг друга.</exception>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Windows.Window.Owner" /> установлено на видимое окно, отображенное методом <see cref="M:System.Windows.Window.ShowDialog" />  
  
 - или -  
  
 Свойство <see cref="P:System.Windows.Window.Owner" /> установлено на окно, которое ранее не отображалось.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для разрешения использования все окна и события пользовательского ввода без ограничений. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="P:System.Windows.Window.OwnedWindows" />
      </Docs>
    </Member>
    <Member MemberName="ResizeMode">
      <MemberSignature Language="C#" Value="public System.Windows.ResizeMode ResizeMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.ResizeMode ResizeMode" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ResizeMode" />
      <MemberSignature Language="VB.NET" Value="Public Property ResizeMode As ResizeMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::ResizeMode ResizeMode { System::Windows::ResizeMode get(); void set(System::Windows::ResizeMode value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.ResizeMode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает режим изменения размеров.</summary>
        <value>Значение <see cref="T:System.Windows.ResizeMode" />, задающее режим изменения размеров.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Существует четыре варианта:  
  
-   **NoResize**. Пользователь не может изменять размеры окна. Развернуть и свернуть поля не отображаются.  
  
-   **CanMinimize**. Пользователь может только свернуть окно и восстановите ее из панели задач. Свернуть и развернуть отображаются, но включена только кнопка "Свернуть".  
  
-   **CanResize**. Пользователь имеет возможность полного размера окна, с помощью свернуть и развернуть, а также перетаскиваемый контур вокруг окна. Свернуть и развернуть отображаются и включены. (По умолчанию).  
  
-   **CanResizeWithGrip**. Этот параметр может иметь ту же функциональность, что <xref:System.Windows.ResizeMode.CanResize>, но добавляет «захват для изменения размера» в правом нижнем углу окна.  
  
> [!NOTE]
>  Не удается задать или получить значение этого свойства, если окно размещено в браузере.  
  
<a name="dependencyPropertyInfo_WindowResizeMode"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Window.ResizeModeProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.AffectsMeasure%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Controls.Primitives.ResizeGrip" />
      </Docs>
    </Member>
    <Member MemberName="ResizeModeProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ResizeModeProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ResizeModeProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ResizeModeProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ResizeModeProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ResizeModeProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.ResizeMode" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="RestoreBounds">
      <MemberSignature Language="C#" Value="public System.Windows.Rect RestoreBounds { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.Rect RestoreBounds" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.RestoreBounds" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RestoreBounds As Rect" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Rect RestoreBounds { System::Windows::Rect get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Rect</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает размер и расположение окна перед сворачиванием либо разворачиванием.</summary>
        <value>Объект <see cref="T:System.Windows.Rect" />, задающий размер и расположение окна перед сворачиванием либо разворачиванием.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Прямоугольник восстановления — область, занятая окном до его сворачивания или разворачивания. Можно использовать <xref:System.Windows.Window.RestoreBounds%2A> для сохранения последний размер и расположение окна перед закрытием приложения и получить эти значения при очередном запуске приложения, чтобы восстановить окно, так как пользователь остался.  
  
 Если вы запрашиваете <xref:System.Windows.Window.RestoreBounds%2A> перед показали окна или после его закрытия <xref:System.Windows.Rect.Empty%2A> возвращается.  
  
> [!NOTE]
>  Не удается получить это свойство при размещении окна в браузере.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Windows.Window.RestoreBounds%2A> и изолированное хранилище, чтобы размер и расположение окна такие же, как они были в предыдущий раз, отображения окна.  
  
 [!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml1)]  
[!code-xaml[WindowRestoreBoundsSnippets#WindowRestoreBoundsXAML2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml#windowrestoreboundsxaml2)]  
  
 [!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind1)]
 [!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND1](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind1)]  
[!code-csharp[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/CSharp/MainWindow.xaml.cs#windowrestoreboundscodebehind2)]
[!code-vb[WindowRestoreBoundsSnippets#WindowRestoreBoundsCODEBEHIND2](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowRestoreBoundsSnippets/visualbasic/mainwindow.xaml.vb#windowrestoreboundscodebehind2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для разрешения на запрос размера и расположения окна ограничивающего прямоугольника. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Show">
      <MemberSignature Language="C#" Value="public void Show ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Show() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.Show" />
      <MemberSignature Language="VB.NET" Value="Public Sub Show ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Show();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Открывает окно и возвращается без ожидания закрытия нового открытого окна.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Windows.Window> создается экземпляр класса, она не отображается по умолчанию. <xref:System.Windows.Window.Show%2A> Отображает окно и возврат немедленно, без ожидания окна будет закрыта. Следовательно открытое окно не запрещает пользователям взаимодействовать с другими окнами в приложении. Этот тип окна называется *немодальное* окна. Распространенными примерами немодальных окон являются свойства окон, панелей инструментов и палитры. Чтобы ограничить пользователя для взаимодействия с конкретным окном, окно должно быть установлено путем вызова <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Окно, которое открывается вызовом <xref:System.Windows.Window.Show%2A> does автоматически не имеют связи с окном, которое он открыт; в частности, открытого окна не знает, какое окно он открыт. Эту связь можно установить с помощью <xref:System.Windows.Window.Owner%2A> свойство и управляемых с помощью <xref:System.Windows.Window.OwnedWindows%2A> свойство.  
  
 Вызов <xref:System.Windows.Window.Show%2A> обеспечивает такой же результат окончания как параметр <xref:System.Windows.UIElement.Visibility%2A> свойство <xref:System.Windows.Window> объект <xref:System.Windows.Visibility.Visible>. Тем не менее есть различие между ними с точки зрения времени.  
  
 Вызов <xref:System.Windows.Window.Show%2A> выполняется в синхронном режиме, который возвращает только после <xref:System.Windows.FrameworkElement.Loaded> события на дочернее окно:  
  
 [!code-csharp[WindowShowTimingSnippets#ShowSync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showsync)]
 [!code-vb[WindowShowTimingSnippets#ShowSync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showsync)]  
  
 Параметр <xref:System.Windows.UIElement.Visibility%2A>, однако является асинхронной операцией, немедленно возвращает:  
  
 [!code-csharp[WindowShowTimingSnippets#ShowASync](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowTimingSnippets/CSharp/Window1.xaml.cs#showasync)]
 [!code-vb[WindowShowTimingSnippets#ShowASync](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowTimingSnippets/visualbasic/window1.xaml.vb#showasync)]  
  
 При задании <xref:System.Windows.UIElement.Visibility%2A>, перед настройкой регистрации событий окна <xref:System.Windows.UIElement.Visibility%2A> не будут вызываться до и после метода, в котором заданы <xref:System.Windows.UIElement.Visibility%2A> завершила выполнение.  
  
   
  
## Examples  
 В следующем образце показано, как открыть немодальное окно.  
  
 [!code-csharp[WindowShowSnippets#WindowShowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowSnippets/CSharp/MainWindow.xaml.cs#windowshowcode)]
 [!code-vb[WindowShowSnippets#WindowShowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowSnippets/visualbasic/mainwindow.xaml.vb#windowshowcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          Метод <see cref="M:System.Windows.Window.Show" /> вызывается для окна, которое закрывается (<see cref="E:System.Windows.Window.Closing" />) или закрыто (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="M:System.Windows.Window.Hide" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowActivated">
      <MemberSignature Language="C#" Value="public bool ShowActivated { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowActivated" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowActivated" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowActivated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowActivated { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, активировано ли окно при первом отображении.</summary>
        <value>
          Значение <see langword="true" />, если окно активируется при первом отображении; в противном случае — значение <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если окно с его <xref:System.Windows.Window.ShowActivated%2A> свойство `false` — открытия окно не активируется и его <xref:System.Windows.Window.Activated> событие не происходит, пока пользователь вручную активирует окно, выбрав его. После выбора окна, она активирует и деактивируется в обычном режиме.  
  
 Для предотвращения окно активироваться при его открытии <xref:System.Windows.Window.ShowActivated%2A> свойству необходимо присвоить значение `false` перед отображением этого окна (путем вызова <xref:System.Windows.Window.Show%2A>); при установке <xref:System.Windows.Window.ShowActivated%2A> для `false` после окна на экран не делает ничего.  
  
 Установка <xref:System.Windows.Window.ShowActivated%2A> для `false` в окне, которое открывается как модальная, вызвав <xref:System.Windows.Window.ShowDialog%2A>, имеет никаких реальных последствий. Несмотря на то, что не будут активированы модальное окно, модальное окно будет запрещает пользователю активацию любые другие открытые окна приложения.  
  
<a name="dependencyPropertyInfo_WindowShowActivated"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Window.ShowActivatedProperty>|  
|Значение свойства метаданных `true`|Нет|  
  
   
  
## Examples  
 В следующем примере показано, как с помощью разметки можно настроить окно на открытие без активации.  
  
 [!code-xaml[WindowShowActivatedSnippets#ShowUnactivatedMARKUP1](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml#showunactivatedmarkup1)]  
  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/AWindow.xaml.cs#showunactivatedcodebehind)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedCODEBEHIND](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/awindow.xaml.vb#showunactivatedcodebehind)]  
  
 Приведенный ниже показано, как настроить окно на открытие без активации с помощью кода.  
  
 [!code-csharp[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowActivatedSnippets/CSharp/Window1.xaml.cs#showunactivatedwindowcode)]
 [!code-vb[WindowShowActivatedSnippets#ShowUnactivatedWindowCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowActivatedSnippets/visualbasic/window1.xaml.vb#showunactivatedwindowcode)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowActivatedProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowActivatedProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowActivatedProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowActivatedProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowActivatedProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowActivatedProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.ShowActivated" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowDialog">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; ShowDialog ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; ShowDialog() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Window.ShowDialog" />
      <MemberSignature Language="VB.NET" Value="Public Function ShowDialog () As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; ShowDialog();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Открывает окно и возвращается только после его закрытия.</summary>
        <returns>Значение <see cref="T:System.Nullable`1" /> типа <see cref="T:System.Boolean" />, определяющее было действие принято (<see langword="true" />) или отменено (<see langword="false" />). Возвращаемое значение представляет собой значение свойства <see cref="P:System.Windows.Window.DialogResult" /> перед закрытием окна.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Windows.Window> создается экземпляр класса, она не отображается по умолчанию. <xref:System.Windows.Window.ShowDialog%2A> показано окно, отключает все окна в приложении и возвращает только при закрытии окна. Этот тип окна называется *модального* окно.  
  
 Модальные окна в основном используются как диалоговые окна. Диалоговое окно — это специальный тип окна, используемый приложениями для взаимодействия с пользователями при выполнении задач, таких как открытие файлов или печать документов. Диалоговые окна зачастую позволяют пользователям принять или отменить задачу, для которого они были показаны, прежде чем закрыть диалоговое окно. <xref:System.Windows.Window.ShowDialog%2A> Возвращает <xref:System.Nullable%601> <xref:System.Boolean> значение, указывающее, было ли действие принятия или отмены. Возвращаемое значение представляет собой значение свойства <xref:System.Windows.Window.DialogResult%2A> перед закрытием окна. Дополнительные сведения см. в разделе <xref:System.Windows.Window.DialogResult%2A>.  
  
 Окно, которое открывается вызовом <xref:System.Windows.Window.ShowDialog%2A> метод не имеет связи с окном, открывший его автоматически; в частности, открытое окно не знает, какое окно он открыт. Эту связь можно установить с помощью <xref:System.Windows.Window.Owner%2A> свойство и управляемых с помощью <xref:System.Windows.Window.OwnedWindows%2A> свойство. Для поддержки [!INCLUDE[TLA2#tla_ui](~/includes/tla2sharptla-ui-md.md)] автоматизации (см. [Обзор модели автоматизации пользовательского интерфейса](~/docs/framework/ui-automation/ui-automation-overview.md)), <xref:System.Windows.Window.Owner%2A> должно быть задано для окно, открытое посредством вызова <xref:System.Windows.Window.ShowDialog%2A>.  
  
 Когда модальный [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] окна (окно открывается вызовом <xref:System.Windows.Window.ShowDialog%2A>) закрывается, ранее активированное окно активируется. Если модальное окно [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] окно имеет окно-владелец (см. <xref:System.Windows.Window.Owner%2A>), окно-владелец не активируется повторно, когда модальное [!INCLUDE[TLA2#tla_wpf](~/includes/tla2sharptla-wpf-md.md)] окно закрывается, если она была ранее активированное окно.  
  
> [!NOTE]
>  Этот метод не может вызываться, когда окно размещается в браузере.  
  
   
  
## Examples  
 В следующем образце показано, как открыть модальное окно.  
  
 [!code-csharp[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/WindowShowDialogSnippets/CSharp/MainWindow.xaml.cs#windowshowdialogcode)]
 [!code-vb[WindowShowDialogSnippets#WindowShowDialogCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/WindowShowDialogSnippets/visualbasic/mainwindow.xaml.vb#windowshowdialogcode)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          Метод <see cref="M:System.Windows.Window.ShowDialog" /> вызывается для окна, которое закрывается (<see cref="E:System.Windows.Window.Closing" />) или закрыто (<see cref="E:System.Windows.Window.Closed" />).</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для разрешения на активацию окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.AllWindows" /></permission>
        <altmember cref="M:System.Windows.Window.Close" />
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbar">
      <MemberSignature Language="C#" Value="public bool ShowInTaskbar { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShowInTaskbar" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.ShowInTaskbar" />
      <MemberSignature Language="VB.NET" Value="Public Property ShowInTaskbar As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShowInTaskbar { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, имеет ли окно кнопку в панели задач.</summary>
        <value>
          <see langword="true" />, если окно имеет кнопку в панели задач; в противном случае — <see langword="false" />. Не применяется, если окно размещено в браузере.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Windows.Window.ShowInTaskbar%2A> равно `true`, окне также отображаются в списке выбора приложения ALT + TAB.  
  
 Значок, используемый для кнопки панели задач и список выбора приложения ALT + TAB — это значение <xref:System.Windows.Window.Icon%2A> свойства.  
  
> [!NOTE]
>  Не удается задать или получить значение этого свойства, если окно размещено в браузере.  
  
<a name="dependencyPropertyInfo_WindowShowInTaskbar"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Window.ShowInTaskbarProperty>|  
|Значение свойства метаданных `true`|Нет|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShowInTaskbarProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty ShowInTaskbarProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty ShowInTaskbarProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.ShowInTaskbarProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ShowInTaskbarProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ ShowInTaskbarProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.ShowInTaskbar" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SizeToContent">
      <MemberSignature Language="C#" Value="public System.Windows.SizeToContent SizeToContent { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.SizeToContent SizeToContent" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.SizeToContent" />
      <MemberSignature Language="VB.NET" Value="Public Property SizeToContent As SizeToContent" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::SizeToContent SizeToContent { System::Windows::SizeToContent get(); void set(System::Windows::SizeToContent value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.SizeToContent</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, изменится ли автоматически размер окна в соответствии с размером его содержимого.</summary>
        <value>Значение <see cref="T:System.Windows.SizeToContent" />. Значение по умолчанию: <see cref="F:System.Windows.SizeToContent.Manual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При <xref:System.Windows.Window.SizeToContent%2A> равно <xref:System.Windows.SizeToContent.WidthAndHeight>, устанавливая либо <xref:System.Windows.FrameworkElement.Height%2A> или <xref:System.Windows.FrameworkElement.Width%2A> не влияет; оба свойства могут быть заданы, но они устанавливаются с помощью значения не применяются в окно.  
  
 Когда <xref:System.Windows.Window.SizeToContent%2A> равно <xref:System.Windows.SizeToContent.Height>, параметр <xref:System.Windows.FrameworkElement.Height%2A> изменяется высота окна.  
  
 Когда <xref:System.Windows.Window.SizeToContent%2A> равно <xref:System.Windows.SizeToContent.Width>, параметр <xref:System.Windows.FrameworkElement.Width%2A> не изменяет ширину окна.  
  
 Если <xref:System.Windows.Window.SizeToContent%2A> имеет значение, отличное от <xref:System.Windows.SizeToContent.Manual>:  
  
-   <xref:System.Windows.Window.SizeToContent%2A> автоматически устанавливается значение <xref:System.Windows.SizeToContent.Manual> при изменении размера окна, с помощью захвата для изменения размера и перетащите границу.  
  
-   При изменении размера содержимого, в результате которого его окно будет изменяться, <xref:System.Windows.FrameworkElement.SizeChanged> возникает.  
  
 Если окно является прозрачным (см. <xref:System.Windows.Window.AllowsTransparency%2A>), параметр следует рассматривать <xref:System.Windows.Window.SizeToContent%2A> для <xref:System.Windows.SizeToContent.WidthAndHeight> для обеспечения окна не больше его видимого содержимого.  
  
> [!NOTE]
>  Не удается задать или получить значение этого свойства, если окно размещено в браузере.  
  
<a name="dependencyPropertyInfo_WindowSizeToContent"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Window.SizeToContentProperty>|  
|Значение свойства метаданных `true`|Нет|  
  
   
  
## Examples  
 Следующий пример показывает, как задать <xref:System.Windows.Window.SizeToContent%2A> свойства в коде, чтобы указать, изменение размера окна в соответствии с содержимым.  
  
 [!code-csharp[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/csharp/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/CSharp/MainWindow.xaml.cs#setwindowsizetocontentpropertycode)]
 [!code-vb[HOWTOWindowManagementSnippets#SetWindowSizeToContentPropertyCODE](~/samples/snippets/visualbasic/VS_Snippets_Wpf/HOWTOWindowManagementSnippets/visualbasic/mainwindow.xaml.vb#setwindowsizetocontentpropertycode)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Window.MeasureOverride(System.Windows.Size)" />
        <altmember cref="M:System.Windows.Window.ArrangeOverride(System.Windows.Size)" />
        <altmember cref="P:System.Windows.Window.ResizeMode" />
      </Docs>
    </Member>
    <Member MemberName="SizeToContentProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty SizeToContentProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty SizeToContentProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.SizeToContentProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly SizeToContentProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ SizeToContentProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.SizeToContent" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SourceInitialized">
      <MemberSignature Language="C#" Value="public event EventHandler SourceInitialized;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler SourceInitialized" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.SourceInitialized" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event SourceInitialized As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ SourceInitialized;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Данное событие инициируется для поддержки взаимодействия с [!INCLUDE[TLA#tla_win32](~/includes/tlasharptla-win32-md.md)]. См. раздел <see cref="T:System.Windows.Interop.HwndSource" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StateChanged">
      <MemberSignature Language="C#" Value="public event EventHandler StateChanged;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler StateChanged" />
      <MemberSignature Language="DocId" Value="E:System.Windows.Window.StateChanged" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event StateChanged As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler ^ StateChanged;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при изменении свойства окна <see cref="P:System.Windows.Window.WindowState" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Window.WindowState" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfo">
      <MemberSignature Language="C#" Value="public System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Windows.Shell.TaskbarItemInfo TaskbarItemInfo" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.TaskbarItemInfo" />
      <MemberSignature Language="VB.NET" Value="Public Property TaskbarItemInfo As TaskbarItemInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::Shell::TaskbarItemInfo ^ TaskbarItemInfo { System::Windows::Shell::TaskbarItemInfo ^ get(); void set(System::Windows::Shell::TaskbarItemInfo ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Shell.TaskbarItemInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает эскиз панели задач [!INCLUDE[win7](~/includes/win7-md.md)] для <see cref="T:System.Windows.Window" />.</summary>
        <value>Эскиз панели задач [!INCLUDE[win7](~/includes/win7-md.md)] для <see cref="T:System.Windows.Window" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об использовании [!INCLUDE[win7](~/includes/win7-md.md)] эскиза, см. в разделе задач <xref:System.Windows.Shell.TaskbarItemInfo> класса.  
  
 ]]></format>
        </remarks>
        <altmember cref="N:System.Windows.Shell" />
      </Docs>
    </Member>
    <Member MemberName="TaskbarItemInfoProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TaskbarItemInfoProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TaskbarItemInfoProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TaskbarItemInfoProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TaskbarItemInfoProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TaskbarItemInfoProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.TaskbarItemInfo" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Title" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Title" />
      <MemberSignature Language="VB.NET" Value="Public Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.IWindowService.Title</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Windows.Localizability(System.Windows.LocalizationCategory.Title)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка заголовка окна.</summary>
        <value>Строка <see cref="T:System.String" />, содержащая заголовок окна.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Заголовок <xref:System.Windows.Window>, <xref:System.Windows.Navigation.NavigationWindow>, или [!INCLUDE[TLA#tla_iegeneric](~/includes/tlasharptla-iegeneric-md.md)], можно также задать с помощью <xref:System.Windows.Controls.Page.WindowTitle%2A?displayProperty=nameWithType>.  
  
<a name="dependencyPropertyInfo_WindowTitle"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Window.TitleProperty>|  
|Значение свойства метаданных `true`|Нет|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TitleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TitleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TitleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TitleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TitleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TitleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.Title" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Top">
      <MemberSignature Language="C#" Value="public double Top { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Top" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Top" />
      <MemberSignature Language="VB.NET" Value="Public Property Top As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Top { double get(); void set(double value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.TypeConverter("System.Windows.LengthConverter, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35, Custom=null")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает позицию верхнего края окна относительно рабочего стола.</summary>
        <value>Позиция верхнего края окна в логических единицах (1/96 дюйма).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда <xref:System.Windows.Window> свернуто или развернуто, это значение соответствует точка восстановления верхней границей для <xref:System.Windows.Window>.  
  
 Это свойство нельзя задать с помощью стиля.  
  
 Если вы не укажете значение, <xref:System.Windows.Window.Top%2A> присвоено значение по умолчанию. Можно также указать значение по умолчанию, задав <xref:System.Windows.Window.Top%2A> для <xref:System.Double.NaN>. Ни <xref:System.Double.NegativeInfinity> , ни <xref:System.Double.PositiveInfinity> является допустимым значением для <xref:System.Windows.Window.Top%2A>.  
  
> [!NOTE]
>  Не удается задать или получить значение этого свойства, если окно размещено в браузере.  
  
<a name="dependencyPropertyInfo_WindowTop"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Window.TopProperty>|  
|Значение свойства метаданных `true`|Нет|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.Left" />
      </Docs>
    </Member>
    <Member MemberName="Topmost">
      <MemberSignature Language="C#" Value="public bool Topmost { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Topmost" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.Topmost" />
      <MemberSignature Language="VB.NET" Value="Public Property Topmost As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Topmost { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, отображается ли окно поверх всех окон в Z-порядке.</summary>
        <value>
          Значение <see langword="true" />, если окно является самым верхним; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Окно которого <xref:System.Windows.Window.Topmost%2A> свойству `true` появляется над все окна, <xref:System.Windows.Window.Topmost%2A> задано значение `false`.  
  
 В группе windows, имеющих <xref:System.Windows.Window.Topmost%2A> свойству `true`, окно, которое активируется в настоящее время является самое верхнее окно. Аналогичным образом для группы windows, имеющие <xref:System.Windows.Window.Topmost%2A> свойству `false`.  
  
> [!NOTE]
>  Не удается задать или получить значение этого свойства, если окно размещено в браузере.  
  
<a name="dependencyPropertyInfo_WindowTopmost"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Window.TopmostProperty>|  
|Значение свойства метаданных `true`|Нет|  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.Windows.Window.Activated" />
        <altmember cref="E:System.Windows.Window.Deactivated" />
      </Docs>
    </Member>
    <Member MemberName="TopmostProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopmostProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopmostProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopmostProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopmostProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopmostProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.Topmost" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TopProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TopProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TopProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.TopProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TopProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TopProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.Top" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStartupLocation">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStartupLocation WindowStartupLocation { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStartupLocation WindowStartupLocation" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStartupLocation" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStartupLocation As WindowStartupLocation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStartupLocation WindowStartupLocation { System::Windows::WindowStartupLocation get(); void set(System::Windows::WindowStartupLocation value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.DefaultValue(Mono.Cecil.CustomAttributeArgument)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStartupLocation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка положения окна при его первом отображении.</summary>
        <value>Значение <see cref="T:System.Windows.WindowStartupLocation" />, указывающее верхнюю/левую позицию окна при первом отображении. Значение по умолчанию: <see cref="F:System.Windows.WindowStartupLocation.Manual" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Установка <xref:System.Windows.WindowStartupLocation> для <xref:System.Windows.WindowStartupLocation.Manual> окно будет располагаться в соответствии с его <xref:System.Windows.Window.Left%2A> и <xref:System.Windows.Window.Top%2A> значения свойств. Если параметр <xref:System.Windows.Window.Left%2A> или <xref:System.Windows.Window.Top%2A> не были указаны свойства, их значения определяются операционной системой Windows.  
  
 Параметр <xref:System.Windows.WindowStartupLocation.CenterScreen> выводить окно должен располагаться в центре экрана, содержащего курсор мыши.  
  
 Установка <xref:System.Windows.WindowStartupLocation> для <xref:System.Windows.WindowStartupLocation.CenterOwner> выводить окно должен располагаться в центре окна-владельца (см. <xref:System.Windows.Window.Owner%2A>), если он указан. Окно-владелец может быть еще одно окно WPF или окна не WPF.  
  
> [!NOTE]
>  Дополнительные сведения об окнах WPF с windows, отличных от WPF см. в разделе [WPF и взаимодействие Win32](~/docs/framework/wpf/advanced/wpf-and-win32-interoperation.md) и <xref:System.Windows.Interop.WindowInteropHelper>.  
  
 Если окно-владелец не указан, положение окна определяется таким же образом, как если бы <xref:System.Windows.WindowStartupLocation> равно <xref:System.Windows.WindowStartupLocation.Manual>.  
  
> [!NOTE]
>  Не удается задать или получить значение этого свойства при размещении окна в браузере.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowState">
      <MemberSignature Language="C#" Value="public System.Windows.WindowState WindowState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowState WindowState" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowState" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowState As WindowState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowState WindowState { System::Windows::WindowState get(); void set(System::Windows::WindowState value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, восстановлено ли, свернуто или развернуто окно.</summary>
        <value>Состояние <see cref="T:System.Windows.WindowState" />, определяющее, является ли окно восстановленным, свернутым или развернутым. По умолчанию используется значение <see cref="F:System.Windows.WindowState.Normal" /> (восстановлено).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Прежде чем окна сворачивать или разворачивать, его размер и расположение, хранятся в <xref:System.Windows.Window.RestoreBounds%2A>. Восстанавливаются при последующем восстановлении окна его размер и расположение значения значениями из <xref:System.Windows.Window.RestoreBounds%2A>.  
  
 Когда <xref:System.Windows.Window.WindowState%2A> изменения свойств, <xref:System.Windows.Window.StateChanged> возникает.  
  
> [!NOTE]
>  Не удается задать или получить значение этого свойства, если окно размещено в браузере.  
  
<a name="dependencyPropertyInfo_WindowWindowState"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Window.WindowStateProperty>|  
|Значение свойства метаданных `true`|<xref:System.Windows.FrameworkPropertyMetadata.BindsTwoWayByDefault%2A>|  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Window.RestoreBounds" />
      </Docs>
    </Member>
    <Member MemberName="WindowStateProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStateProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStateProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStateProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStateProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStateProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.WindowState" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyle">
      <MemberSignature Language="C#" Value="public System.Windows.WindowStyle WindowStyle { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Windows.WindowStyle WindowStyle" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Window.WindowStyle" />
      <MemberSignature Language="VB.NET" Value="Public Property WindowStyle As WindowStyle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Windows::WindowStyle WindowStyle { System::Windows::WindowStyle get(); void set(System::Windows::WindowStyle value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.WindowStyle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получение или установка стиля границы окна.</summary>
        <value>Объект <see cref="T:System.Windows.WindowStyle" />, задающий стиль границы окна. Значение по умолчанию: <see cref="F:System.Windows.WindowStyle.SingleBorderWindow" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Window.WindowStyle%2A> может принимать одно из <xref:System.Windows.WindowStyle> значений перечисления, включая <xref:System.Windows.WindowStyle.None>, <xref:System.Windows.WindowStyle.ToolWindow>, <xref:System.Windows.WindowStyle.SingleBorderWindow> (по умолчанию), и <xref:System.Windows.WindowStyle.ThreeDBorderWindow>.  
  
 На следующем рисунке показана стили окна на [!INCLUDE[TLA#tla_longhorn](~/includes/tlasharptla-longhorn-md.md)] (Windows Vista Aero тема с прозрачности включен):  
  
 ![Стили окна](~/add/media/windowoverviewfigure6.PNG "стили окна")  
  
> [!NOTE]
>  Не удается задать или получить значение этого свойства, если окно размещено в браузере.  
  
<a name="dependencyPropertyInfo_WindowWindowStyle"></a>   
## <a name="dependency-property-information"></a>Сведения о свойстве зависимостей  
  
|||  
|-|-|  
|Поле идентификатора|<xref:System.Windows.Window.WindowStyleProperty>|  
|Значение свойства метаданных `true`|Нет|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WindowStyleProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty WindowStyleProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty WindowStyleProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Window.WindowStyleProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly WindowStyleProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ WindowStyleProperty;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Идентифицирует свойство зависимостей <see cref="P:System.Windows.Window.WindowStyle" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>