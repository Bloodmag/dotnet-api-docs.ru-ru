<Type Name="XContainer" FullName="System.Xml.Linq.XContainer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="975ff3e595a7e42b32687e50bd64d6eefc73e39b" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30720938" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class XContainer : System.Xml.Linq.XNode" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit XContainer extends System.Xml.Linq.XNode" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XContainer" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class XContainer&#xA;Inherits XNode" />
  <TypeSignature Language="C++ CLI" Value="public ref class XContainer abstract : System::Xml::Linq::XNode" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.Linq.XNode</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Представляет узел, который может содержать другие узлы.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот класс предоставляет функциональные возможности, такие как поиск к следующему или предыдущему сестринскому узлу или перечисление непосредственных дочерних элементов узла.  
  
 Два класса, которые являются производными от <xref:System.Xml.Linq.XContainer> , <xref:System.Xml.Linq.XDocument> и <xref:System.Xml.Linq.XElement>.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет указанное содержимое в качестве дочерних элементов в данный объект <see cref="T:System.Xml.Linq.XContainer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод добавляет новое содержимое после существующего содержимого <xref:System.Xml.Linq.XContainer>.  
  
 Дополнительные сведения о допустимом содержимом, которое может быть передан этой функции см. в разделе [объектов допустимое содержимое XElement и XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
 Этот метод вызывает <xref:System.Xml.Linq.XObject.Changed> и <xref:System.Xml.Linq.XObject.Changing> события.  
  
   
  
## Examples  
 Следующий пример создает два XML-дерева и затем использует этот метод для добавления результаты запроса к одному из них.  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("NewElement", "Content")  
);  
xmlTree.Add(  
    from el in srcTree.Elements()  
    where (int)el >= 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _  
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
Dim xmlTree As XElement = _   
        <Root>  
            <NewElement>Content</NewElement>  
        </Root>  
xmlTree.Add( _  
    From el In srcTree.Elements _  
    Where CInt(el) >= 3 _  
    Select el)  
Console.WriteLine(xmlTree)  
```  
  
 В этом примере выводятся следующие данные:  
  
```xml  
<Root>  
  <NewElement>Content</NewElement>  
  <Element3>3</Element3>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XContainer.AddFirst" />
        <altmember cref="M:System.Xml.Linq.XContainer.RemoveNodes" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.ReplaceNodes" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::Object ^ content);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content">Объект содержимого, включающий простое содержимое или коллекцию объектов содержимого, подлежащих добавлению.</param>
        <summary>Добавляет указанное содержимое в качестве дочерних элементов данного объекта <see cref="T:System.Xml.Linq.XContainer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод добавляет новое содержимое после существующего содержимого <xref:System.Xml.Linq.XContainer>.  
  
 Дополнительные сведения о допустимом содержимом, которое может быть передан этой функции см. в разделе [объектов допустимое содержимое XElement и XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
 Этот метод вызывает <xref:System.Xml.Linq.XObject.Changed> и <xref:System.Xml.Linq.XObject.Changing> события.  
  
   
  
## Examples  
 В следующем примере создаются два XML-дерева и затем использует этот метод для добавления <xref:System.Xml.Linq.XElement> объекта к одному из них. Он также добавляет результаты [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] запросов к XML-дереву.  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
xmlTree.Add(new XElement("NewChild", "new content"));  
xmlTree.Add(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
// Even though Child9 does not exist in srcTree, the following statement will not  
// throw an exception, and nothing will be added to xmlTree.  
xmlTree.Add(srcTree.Element("Child9"));  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
xmlTree.Add(New XElement("NewChild", "new content"))  
xmlTree.Add( _  
    From el In srcTree.Elements() _  
    Where CInt(el) > 3 _  
    Select el _  
)  
' Even though Child9 does not exist in srcTree, the following statement will not  
' throw an exception, and nothing will be added to xmlTree.  
xmlTree.Add(srcTree.<Child9>)  
Console.WriteLine(xmlTree)  
  
```  
  
 В этом примере выводятся следующие данные:  
  
```xml  
<Root>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
  <NewChild>new content</NewChild>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XContainer.AddFirst" />
        <altmember cref="M:System.Xml.Linq.XContainer.RemoveNodes" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.ReplaceNodes" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.Add(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content">Список параметров объектов содержимого.</param>
        <summary>Добавляет указанное содержимое в качестве дочерних элементов данного объекта <see cref="T:System.Xml.Linq.XContainer" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод добавляет новое содержимое после существующего содержимого <xref:System.Xml.Linq.XContainer>.  
  
 Дополнительные сведения о допустимом содержимом, которое может быть передан этой функции см. в разделе [объектов допустимое содержимое XElement и XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
 Этот метод вызывает <xref:System.Xml.Linq.XObject.Changed> и <xref:System.Xml.Linq.XObject.Changing> события.  
  
   
  
## Examples  
 Следующий пример создает два XML-дерева, этот метод используется для добавления <xref:System.Xml.Linq.XElement> объекта к одному из них. Он также добавляет результаты [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] запросов к XML-дереву.  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
xmlTree.Add(new XElement("NewChild", "new content"));  
xmlTree.Add(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
// Even though Child9 does not exist in srcTree, the following statement will not  
// throw an exception, and nothing will be added to xmlTree  
xmlTree.Add(srcTree.Element("Child9"));  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _  
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
xmlTree.Add(New XElement("NewChild", "new content"))  
xmlTree.Add( _  
    From el In srcTree.Elements() _  
    Where CInt(el) > 3 _  
    Select el _  
)  
' Even though Child9 does not exist in srcTree, the following statement will not  
' throw an exception, and nothing will be added to xmlTree  
xmlTree.Add(srcTree.<Child9>)  
Console.WriteLine(xmlTree)  
```  
  
 В этом примере выводятся следующие данные:  
  
```xml  
<Root>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
  <NewChild>new content</NewChild>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XContainer.AddFirst" />
        <altmember cref="M:System.Xml.Linq.XContainer.RemoveNodes" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.ReplaceNodes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="AddFirst">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Добавляет заданное содержимое как первые дочерние элементы данного документа или элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод добавляет новое содержимое перед существующее содержимое элемента <xref:System.Xml.Linq.XContainer>.  
  
 Дополнительные сведения о допустимом содержимом, которое может быть передан этой функции см. в разделе [объектов допустимое содержимое XElement и XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
 Этот метод вызывает <xref:System.Xml.Linq.XObject.Changed> и <xref:System.Xml.Linq.XObject.Changing> события.  
  
   
  
## Examples  
 Следующий пример создает два XML-дерева и затем использует этот метод для добавления результаты запроса к одному из них.  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("NewElement", "Content")  
);  
xmlTree.AddFirst(  
    from el in srcTree.Elements()  
    where (int)el >= 3  
    select el  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
Dim xmlTree As XElement = <Root>  
                              <NewElement>Content</NewElement>  
                          </Root>  
xmlTree.AddFirst( _  
    From el In srcTree.Elements _  
    Where CInt(el) >= 3 _  
    Select el)  
Console.WriteLine(xmlTree)  
  
```  
  
 В этом примере выводятся следующие данные:  
  
```xml  
<Root>  
  <Element3>3</Element3>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <NewElement>Content</NewElement>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XContainer.Add" />
        <altmember cref="M:System.Xml.Linq.XContainer.RemoveNodes" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.ReplaceNodes" />
      </Docs>
    </MemberGroup>
    <Member MemberName="AddFirst">
      <MemberSignature Language="C#" Value="public void AddFirst (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFirst(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.AddFirst(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFirst (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFirst(System::Object ^ content);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content">Объект содержимого, включающий простое содержимое или коллекцию объектов содержимого, подлежащих добавлению.</param>
        <summary>Добавляет заданное содержимое как первые дочерние элементы данного документа или элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод добавляет новое содержимое перед существующее содержимое элемента <xref:System.Xml.Linq.XContainer>.  
  
 Дополнительные сведения о допустимом содержимом, которое может быть передан этой функции см. в разделе [объектов допустимое содержимое XElement и XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
 Этот метод вызывает <xref:System.Xml.Linq.XObject.Changed> и <xref:System.Xml.Linq.XObject.Changing> события.  
  
   
  
## Examples  
 Следующий пример создает два XML-дерева, этот метод используется для добавления <xref:System.Xml.Linq.XElement> объект в качестве первого элемента и до одного из них. Он также добавляет результаты [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] запросов к XML-дереву.  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
xmlTree.AddFirst(new XElement("NewChild", "new content"));  
xmlTree.AddFirst(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
// Even though Child9 does not exist in srcTree, the following statement will not  
// throw an exception, and nothing will be added to xmlTree  
xmlTree.AddFirst(srcTree.Element("Child9"));  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
xmlTree.AddFirst(New XElement("NewChild", "new content"))  
xmlTree.AddFirst( _  
    From el In srcTree.Elements() _  
    Where CInt(el) > 3 _  
    Select el _  
)  
' Even though Child9 does not exist in srcTree, the following statement will not  
' throw an exception, and nothing will be added to xmlTree  
xmlTree.AddFirst(srcTree.<Child9>)  
Console.WriteLine(xmlTree)  
```  
  
 В этом примере выводятся следующие данные:  
  
```xml  
<Root>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <NewChild>new content</NewChild>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XContainer.Add" />
        <altmember cref="M:System.Xml.Linq.XContainer.RemoveNodes" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.ReplaceNodes" />
      </Docs>
    </Member>
    <Member MemberName="AddFirst">
      <MemberSignature Language="C#" Value="public void AddFirst (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddFirst(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.AddFirst(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddFirst (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddFirst(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content">Список параметров объектов содержимого.</param>
        <summary>Добавляет заданное содержимое как первые дочерние элементы данного документа или элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод добавляет новое содержимое перед существующее содержимое элемента <xref:System.Xml.Linq.XContainer>.  
  
 Дополнительные сведения о допустимом содержимом, которое может быть передан этой функции см. в разделе [объектов допустимое содержимое XElement и XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
 Этот метод вызывает <xref:System.Xml.Linq.XObject.Changed> и <xref:System.Xml.Linq.XObject.Changing> события.  
  
   
  
## Examples  
 В следующем примере создаются два XML-дерева и использует этот метод для добавления <xref:System.Xml.Linq.XElement> объект в качестве первого элемента и до одного из них. Он также добавляет результаты [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] запросов к XML-дереву.  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
xmlTree.AddFirst(new XElement("NewChild", "new content"));  
xmlTree.AddFirst(  
    from el in srcTree.Elements()  
    where (int)el > 3  
    select el  
);  
// Even though Child9 does not exist in srcTree, the following statement will not  
// throw an exception, and nothing will be added to xmlTree.  
xmlTree.AddFirst(srcTree.Element("Child9"));  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
xmlTree.AddFirst(New XElement("NewChild", "new content"))  
xmlTree.AddFirst( _  
    From el In srcTree.Elements() _  
    Where CInt(el) > 3 _  
    Select el _  
)  
' Even though Child9 does not exist in srcTree, the following statement will not  
' throw an exception, and nothing will be added to xmlTree.  
xmlTree.AddFirst(srcTree.<Child9>)  
Console.WriteLine(xmlTree)  
```  
  
 В этом примере выводятся следующие данные:  
  
```xml  
<Root>  
  <Element4>4</Element4>  
  <Element5>5</Element5>  
  <NewChild>new content</NewChild>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Родительским объектом является <see langword="null" />.</exception>
        <altmember cref="Overload:System.Xml.Linq.XContainer.Add" />
        <altmember cref="M:System.Xml.Linq.XContainer.RemoveNodes" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.ReplaceNodes" />
      </Docs>
    </Member>
    <Member MemberName="CreateWriter">
      <MemberSignature Language="C#" Value="public System.Xml.XmlWriter CreateWriter ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.XmlWriter CreateWriter() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.CreateWriter" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateWriter () As XmlWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::XmlWriter ^ CreateWriter();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlWriter</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает <see cref="T:System.Xml.XmlWriter" />, который можно использовать для добавления узлов в <see cref="T:System.Xml.Linq.XContainer" />.</summary>
        <returns>
          <see cref="T:System.Xml.XmlWriter" /> который готов принять содержимое для записи.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В ходе сериализации префиксы пространства имен выводятся из атрибутов пространства имен в XML-дерева.  
  
 Дополнительные сведения см. в разделе [работа с пространствами имен XML](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430).  
  
   
  
## Examples  
 Этот метод можно использовать для выполнения преобразования XSLT. Можно создать XML-дерево, создать <xref:System.Xml.XmlReader> из XML-дерево, создать новый документ и <xref:System.Xml.XmlWriter> записи в новый документ. После этого можно вызвать преобразование XSLT, передавая <xref:System.Xml.XmlReader> и <xref:System.Xml.XmlWriter> для преобразования. После успешного завершения преобразования новое XML-дерево заполняется ее результатами.  
  
```csharp  
string xslMarkup = @"<?xml version='1.0'?>  
<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
    <xsl:template match='/Parent'>  
        <Root>  
            <C1><xsl:value-of select='Child1'/></C1>  
            <C2><xsl:value-of select='Child2'/></C2>  
        </Root>  
    </xsl:template>  
</xsl:stylesheet>";  
  
XDocument xmlTree = new XDocument(  
    new XElement("Parent",  
        new XElement("Child1", "Child1 data"),  
        new XElement("Child2", "Child2 data")  
    )  
);  
  
XDocument newTree = new XDocument();  
using (XmlWriter writer = newTree.CreateWriter()) {  
    // Load the style sheet.  
    XslCompiledTransform xslt = new XslCompiledTransform();  
    xslt.Load(XmlReader.Create(new StringReader(xslMarkup)));  
  
    // Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateReader(), writer);  
}  
  
Console.WriteLine(newTree);  
```  
  
```vb  
Dim xslMarkup As XDocument = _   
    <?xml version='1.0'?>  
    <xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='1.0'>  
        <xsl:template match='/Parent'>  
            <Root>  
                <C1><xsl:value-of select='Child1'/></C1>  
                <C2><xsl:value-of select='Child2'/></C2>  
            </Root>  
        </xsl:template>  
    </xsl:stylesheet>  
  
Dim xmlTree As XElement = _   
    <Parent>  
        <Child1>Child1 data</Child1>  
        <Child2>Child2 data</Child2>  
    </Parent>  
  
Dim newTree As XDocument = New XDocument()  
  
Using writer As XmlWriter = newTree.CreateWriter()  
    ' Load the style sheet.  
    Dim xslt As XslCompiledTransform = _  
        New XslCompiledTransform()  
    xslt.Load(xslMarkup.CreateReader())  
  
    ' Execute the transform and output the results to a writer.  
    xslt.Transform(xmlTree.CreateReader(), writer)  
End Using  
  
Console.WriteLine(newTree)  
```  
  
 В этом примере выводятся следующие данные:  
  
```xml  
<Root>  
  <C1>Child1 data</C1>  
  <C2>Child2 data</C2>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DescendantNodes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt; DescendantNodes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XNode&gt; DescendantNodes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.DescendantNodes" />
      <MemberSignature Language="VB.NET" Value="Public Function DescendantNodes () As IEnumerable(Of XNode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XNode ^&gt; ^ DescendantNodes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает коллекцию подчиненных узлов для документа или элемента в порядке следования документов.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />
          <see cref="T:System.Xml.Linq.XNode" /> содержащий подчиненные узлы <see cref="T:System.Xml.Linq.XContainer" /> в порядке следования документов.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что атрибуты не являются узлами в [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)], поэтому они не будут частью коллекции, возвращаемой этим методом.  
  
 Этот метод использует отложенное выполнение.  
  
   
  
## Examples  
 В следующем примере создается XML-дерева и затем выполняется перебор <xref:System.Xml.Linq.XContainer.DescendantNodes%2A> оси.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    // Attributes are not nodes, so will not be returned by DescendantNodes.  
    new XAttribute("Att1", "AttributeContent"),  
    new XElement("Child",  
        new XElement("GrandChild", "element content")  
    )  
);  
IEnumerable<XNode> dnas =  
    from node in xmlTree.DescendantNodes()  
    select node;  
foreach (XNode node in dnas)  
{  
    if (node is XElement)  
        Console.WriteLine((node as XElement).Name);  
    else  
        Console.WriteLine(node);  
}  
```  
  
```vb  
' Attributes are not nodes, so will not be returned by DescendantNodes.  
Dim xmlTree As XElement = _   
    <Root Att1="AttributeContent">  
        <Child>  
            <GrandChild>element content</GrandChild>  
        </Child>  
    </Root>  
  
Dim dnas = From node In xmlTree.DescendantNodes _  
           Select node  
  
For Each node In dnas  
    If TypeOf node Is XElement Then  
        Console.WriteLine(DirectCast(node, XElement).Name)  
    Else  
        Console.WriteLine(node)  
    End If  
Next  
```  
  
 В этом примере выводятся следующие данные:  
  
```  
Child  
GrandChild  
element content  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XContainer.Descendants" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.Elements" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Descendants">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает коллекцию подчиненных узлов для данного документа или элемента в порядке следования документов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует отложенное выполнение.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XContainer.DescendantNodes" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.Elements" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Descendants">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Descendants ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; Descendants() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.Descendants" />
      <MemberSignature Language="VB.NET" Value="Public Function Descendants () As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ Descendants();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает коллекцию подчиненных узлов для данного документа или элемента в порядке следования документов.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />
          <see cref="T:System.Xml.Linq.XElement" /> содержащий подчиненные элементы <see cref="T:System.Xml.Linq.XContainer" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что этот метод не возвращает самого в результате <xref:System.Collections.Generic.IEnumerable%601>. В разделе <xref:System.Xml.Linq.XElement.DescendantsAndSelf%2A> , если нужно включить текущего <xref:System.Xml.Linq.XElement> в результатах.  
  
 Этот метод использует отложенное выполнение.  
  
   
  
## Examples  
 Следующий пример создает XML-дерева и затем использует этот метод оси для получения потомков.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XAttribute("Att1", "AttributeContent"),  
    new XElement("Child",  
        new XText("Some text"),  
        new XElement("GrandChild", "element content")  
    )  
);  
IEnumerable<XElement> de =  
    from el in xmlTree.Descendants()  
    select el;  
foreach (XElement el in de)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
' Attributes are not nodes, so will not be returned by DescendantNodes.  
Dim xmlTree As XElement = _  
    <Root Att1="AttributeContent">  
        <Child>Some text  
            <GrandChild>element content</GrandChild>  
        </Child>  
    </Root>  
Dim de = From el In xmlTree.Descendants _  
         Select el  
  
For Each el In de  
    Console.WriteLine(el.Name)  
Next  
```  
  
 В этом примере выводятся следующие данные:  
  
```  
Child  
GrandChild  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XElement.DescendantsAndSelf" />
        <altmember cref="M:System.Xml.Linq.XContainer.DescendantNodes" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.Elements" />
      </Docs>
    </Member>
    <Member MemberName="Descendants">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Descendants (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; Descendants(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.Descendants(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Descendants (name As XName) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ Descendants(System::Xml::Linq::XName ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name">Выражение <see cref="T:System.Xml.Linq.XName" /> для сопоставления.</param>
        <summary>Возвращает фильтрованную коллекцию подчиненных узлов для данного документа или элемента в порядке следования документов. В коллекцию включаются только элементы, соответствующие <see cref="T:System.Xml.Linq.XName" />.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />
          <see cref="T:System.Xml.Linq.XElement" />, содержащий подчиненные элементы <see cref="T:System.Xml.Linq.XContainer" />, которые соответствуют заданному <see cref="T:System.Xml.Linq.XName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует отложенное выполнение.  
  
   
  
## Examples  
 В следующем примере выводится все потомки элемента.  
  
```csharp  
// Attributes are not nodes, so will not be returned by DescendantNodes.  
XElement xmlTree = new XElement("Root",  
    new XAttribute("Att1", "AttributeContent"),  
    new XElement("Child",  
        new XText("Some text"),  
        new XElement("GrandChild", "element content")  
    )  
);  
IEnumerable<XElement> de =  
    from el in xmlTree.Descendants("Child")  
    select el;  
foreach (XElement el in de)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
' Attributes are not nodes, so will not be returned by the descendants axis.  
Dim xmlTree As XElement = _   
    <Root Att1="AttributeContent">  
         <Child>Some text  
             <GrandChild>element content</GrandChild>  
         </Child>  
     </Root>  
  
Dim de = From el In xmlTree...<Child> _  
         Select el  
  
For Each el In de  
    Console.WriteLine(el.Name)  
Next  
```  
  
 В этом примере выводятся следующие данные:  
  
```  
Child  
```  
  
 Ниже приведен тот же пример, но в этом случае XML находится в пространстве имен. Дополнительные сведения см. в разделе [работа с пространствами имен XML](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430).  
  
```csharp  
// Attributes are not nodes, so will not be returned by DescendantNodes.  
XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree = new XElement(aw + "Root",  
    new XAttribute(aw + "Att1", "AttributeContent"),  
    new XElement(aw + "Child",  
        new XText("Some text"),  
        new XElement(aw + "GrandChild", "element content")  
    )  
);  
IEnumerable<XElement> de =  
    from el in xmlTree.Descendants(aw + "Child")  
    select el;  
foreach (XElement el in de)  
    Console.WriteLine(el.Name);  
```  
  
```vb  
Imports <xmlns:aw = "http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        ' Attributes are not nodes, so will not be returned by the descendants axis.  
        Dim xmlTree As XElement = _   
            <aw:Root aw:Att1="AttributeContent">  
                 <aw:Child>Some text  
                     <aw:GrandChild>element content</aw:GrandChild>  
                 </aw:Child>  
             </aw:Root>  
  
        Dim de = From el In xmlTree...<aw:Child> _  
                 Select el  
  
        For Each el In de  
            Console.WriteLine(el.Name)  
        Next  
    End Sub  
End Module  
```  
  
 В этом примере выводятся следующие данные:  
  
```  
{http://www.adventure-works.com}Child  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XContainer.DescendantNodes" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.Elements" />
      </Docs>
    </Member>
    <Member MemberName="Element">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XElement Element (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Xml.Linq.XElement Element(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.Element(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Element (name As XName) As XElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Xml::Linq::XElement ^ Element(System::Xml::Linq::XName ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name">Выражение <see cref="T:System.Xml.Linq.XName" /> для сопоставления.</param>
        <summary>Получает первый (в порядке следования документа) дочерний элемент с заданным <see cref="T:System.Xml.Linq.XName" />.</summary>
        <returns>
          <see cref="T:System.Xml.Linq.XElement" />, который соответствует заданному <see cref="T:System.Xml.Linq.XName" /> или <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращает `null` , если нет элемента с указанным именем.  
  
 Некоторые методы осей возвращают коллекции элементов или атрибутов. Этот метод возвращает только один элемент.  
  
 Этот метод возвращает `null` , если элемент с указанным именем не найден. Все методы, которые позволяют создавать элементы (конструктор <xref:System.Xml.Linq.XElement>, <xref:System.Xml.Linq.XContainer.Add%2A>и так далее) принимают `null` как допустимый аргумент. Это позволяет использовать подходящий идиом: этот метод можно вызвать в рамках функционального построения, и такой элемент добавляется в XML-дерево, создается только в том случае, если элемент существует в исходном дереве. В следующем примере показано эту идиому.  
  
 В отличие от к <xref:System.Xml.Linq.XContainer.Elements%2A>, этот метод не является метод оси. Он не использует отложенное выполнение; он просто возвращает элемент при вызове.  
  
   
  
## Examples  
 В следующем примере показано два способа использования этого метода. В первом случае метод находит элемент в `srcTree`. Во втором случае метод не находит элемент в исходном дереве элемент не добавляется к `xmlTree`, и исключение не возникает.  
  
 Обратите внимание, что пример Visual Basic использует дочернее свойство XML. Он также является допустимым для использования <xref:System.Xml.Linq.XContainer.Element%2A> непосредственно в Visual Basic.  
  
```csharp  
XElement srcTree = new XElement("Root",  
    new XElement("Element1", 1),  
    new XElement("Element2", 2),  
    new XElement("Element3", 3),  
    new XElement("Element4", 4),  
    new XElement("Element5", 5)  
);  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5),  
    srcTree.Element("Element3"),  
    // Even though Element9 does not exist in srcTree, the following line  
    // will not throw an exception.  
    srcTree.Element("Element9")  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim srcTree As XElement = _   
        <Root>  
            <Element1>1</Element1>  
            <Element2>2</Element2>  
            <Element3>3</Element3>  
            <Element4>4</Element4>  
            <Element5>5</Element5>  
        </Root>  
  
Dim xmlTree As XElement = _  
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
            <%= srcTree.<Element3> %>  
            <%= srcTree.<Element9> %>  
        </Root>  
  
' Even though Element9 does not exist in srcTree, adding it to the tree  
' will not throw an exception.  
  
Console.WriteLine(xmlTree)  
```  
  
 В этом примере выводятся следующие данные:  
  
```xml  
<Root>  
  <Child1>1</Child1>  
  <Child2>2</Child2>  
  <Child3>3</Child3>  
  <Child4>4</Child4>  
  <Child5>5</Child5>  
  <Element3>3</Element3>  
</Root>  
```  
  
 Ниже приведен тот же пример, но в этом случае XML находится в пространстве имен. Дополнительные сведения см. в разделе [работа с пространствами имен XML](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430).  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement srcTree = new XElement(aw + "Root",  
    new XAttribute(XNamespace.Xmlns + "aw", "http://www.adventure-works.com"),  
    new XElement(aw + "Element1", 1),  
    new XElement(aw + "Element2", 2),  
    new XElement(aw + "Element3", 3),  
    new XElement(aw + "Element4", 4),  
    new XElement(aw + "Element5", 5)  
);  
XElement xmlTree = new XElement(aw + "Root",  
    new XAttribute(XNamespace.Xmlns + "aw", "http://www.adventure-works.com"),  
    new XElement(aw + "Child1", 1),  
    new XElement(aw + "Child2", 2),  
    new XElement(aw + "Child3", 3),  
    new XElement(aw + "Child4", 4),  
    new XElement(aw + "Child5", 5),  
    srcTree.Element(aw + "Element3"),  
    // Even though Element9 does not exist in srcTree, the following line  
    // will not throw an exception.  
    srcTree.Element(aw + "Element9")  
);  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim srcTree As XElement = _   
            <aw:Root>  
                <aw:Element1>1</aw:Element1>  
                <aw:Element2>2</aw:Element2>  
                <aw:Element3>3</aw:Element3>  
                <aw:Element4>4</aw:Element4>  
                <aw:Element5>5</aw:Element5>  
            </aw:Root>  
  
        Dim xmlTree As XElement = _  
            <aw:Root>  
                <aw:Child1>1</aw:Child1>  
                <aw:Child2>2</aw:Child2>  
                <aw:Child3>3</aw:Child3>  
                <aw:Child4>4</aw:Child4>  
                <aw:Child5>5</aw:Child5>  
                <%= srcTree.<aw:Element3> %>  
                <%= srcTree.<aw:Element9> %>  
            </aw:Root>  
  
        ' Even though Element9 does not exist in srcTree, adding it to the tree  
        ' will not throw an exception.  
  
        Console.WriteLine(xmlTree)  
    End Sub  
End Module  
```  
  
 В этом примере выводятся следующие данные:  
  
```xml  
<aw:Root xmlns:aw="http://www.adventure-works.com">  
  <aw:Child1>1</aw:Child1>  
  <aw:Child2>2</aw:Child2>  
  <aw:Child3>3</aw:Child3>  
  <aw:Child4>4</aw:Child4>  
  <aw:Child5>5</aw:Child5>  
  <aw:Element3>3</aw:Element3>  
</aw:Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XContainer.Elements" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Elements">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает коллекцию дочерних элементов для данного документа или элемента в порядке следования документа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует отложенное выполнение.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XContainer.Element(System.Xml.Linq.XName)" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.Descendants" />
        <altmember cref="M:System.Xml.Linq.XContainer.DescendantNodes" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Elements">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Elements ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; Elements() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.Elements" />
      <MemberSignature Language="VB.NET" Value="Public Function Elements () As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ Elements();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает коллекцию дочерних элементов для данного документа или элемента в порядке следования документа.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />
          <see cref="T:System.Xml.Linq.XElement" />, содержащий дочерние элементы данного <see cref="T:System.Xml.Linq.XContainer" /> в порядке следования документа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует отложенное выполнение.  
  
   
  
## Examples  
 Следующий пример создает XML-дерева и затем выбирает некоторые элементы, с помощью этого метода оси.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
IEnumerable<XElement> elements =  
    from el in xmlTree.Elements()  
    where (int)el <= 3  
    select el;  
foreach (XElement el in elements)  
    Console.WriteLine(el);  
```  
  
```vb  
Dim xmlTree As XElement = _  
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim elements = From el In xmlTree.Elements _  
               Where el.Value <= 3 _  
               Select el  
  
For Each el In elements  
    Console.WriteLine(el)  
Next  
```  
  
 В этом примере выводятся следующие данные:  
  
```  
<Child1>1</Child1>  
<Child2>2</Child2>  
<Child3>3</Child3>  
```  
  
 Ниже приведен тот же пример, но в этом случае XML находится в пространстве имен. Дополнительные сведения см. в разделе [работа с пространствами имен XML](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430).  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree = new XElement(aw + "Root",  
    new XAttribute(XNamespace.Xmlns + "aw", "http://www.adventure-works.com"),  
    new XElement(aw + "Child1", 1),  
    new XElement(aw + "Child2", 2),  
    new XElement(aw + "Child3", 3),  
    new XElement(aw + "Child4", 4),  
    new XElement(aw + "Child5", 5)  
);  
IEnumerable<XElement> elements =  
    from el in xmlTree.Elements()  
    where (int)el <= 3  
    select el;  
foreach (XElement el in elements)  
    Console.WriteLine(el);  
```  
  
```vb  
Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = _  
            <aw:Root>  
                <aw:Child1>1</aw:Child1>  
                <aw:Child2>2</aw:Child2>  
                <aw:Child3>3</aw:Child3>  
                <aw:Child4>4</aw:Child4>  
                <aw:Child5>5</aw:Child5>  
            </aw:Root>  
  
        Dim elements = From el In xmlTree.Elements _  
                       Where el.Value <= 3 _  
                       Select el  
  
        For Each el In elements  
            Console.WriteLine(el)  
        Next  
    End Sub  
End Module  
```  
  
 В этом примере выводятся следующие данные:  
  
```  
<aw:Child1 xmlns:aw="http://www.adventure-works.com">1</aw:Child1>  
<aw:Child2 xmlns:aw="http://www.adventure-works.com">2</aw:Child2>  
<aw:Child3 xmlns:aw="http://www.adventure-works.com">3</aw:Child3>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XContainer.Element(System.Xml.Linq.XName)" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.Descendants" />
        <altmember cref="M:System.Xml.Linq.XContainer.DescendantNodes" />
      </Docs>
    </Member>
    <Member MemberName="Elements">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt; Elements (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XElement&gt; Elements(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.Elements(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Elements (name As XName) As IEnumerable(Of XElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XElement ^&gt; ^ Elements(System::Xml::Linq::XName ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XElement&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name">Выражение <see cref="T:System.Xml.Linq.XName" /> для сопоставления.</param>
        <summary>Возвращает фильтрованную коллекцию дочерних элементов для данного документа или элемента в порядке следования документа. В коллекцию включаются только элементы, соответствующие <see cref="T:System.Xml.Linq.XName" />.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />
          <see cref="T:System.Xml.Linq.XElement" />, содержащий дочерние элементы данного <see cref="T:System.Xml.Linq.XContainer" />, который имеет совпадающий <see cref="T:System.Xml.Linq.XName" /> в порядке следования документа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует отложенное выполнение.  
  
   
  
## Examples  
 Следующий пример создает XML-дерева, а затем выбирает несколько дочерних элементов с помощью этого метода оси.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Type1", 1),  
    new XElement("Type1", 2),  
    new XElement("Type2", 3),  
    new XElement("Type2", 4),  
    new XElement("Type2", 5)  
);  
IEnumerable<XElement> elements =  
    from el in xmlTree.Elements("Type2")  
    select el;  
foreach (XElement el in elements)  
    Console.WriteLine(el);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Type1>1</Type1>  
            <Type1>2</Type1>  
            <Type2>3</Type2>  
            <Type2>4</Type2>  
            <Type2>5</Type2>  
        </Root>  
  
Dim elements = From el In xmlTree.<Type2> _  
               Select el  
  
For Each el In elements  
    Console.WriteLine(el)  
Next  
```  
  
 В этом примере выводятся следующие данные:  
  
```  
<Type2>3</Type2>  
<Type2>4</Type2>  
<Type2>5</Type2>  
```  
  
 Ниже приведен тот же пример, но в этом случае XML находится в пространстве имен. Дополнительные сведения см. в разделе [работа с пространствами имен XML](http://msdn.microsoft.com/library/e3003209-3234-45be-a832-47feb7927430).  
  
```csharp  
XNamespace aw = "http://www.adventure-works.com";  
XElement xmlTree = new XElement(aw + "Root",  
    new XAttribute(XNamespace.Xmlns + "aw", "http://www.adventure-works.com"),  
    new XElement(aw + "Type1", 1),  
    new XElement(aw + "Type1", 2),  
    new XElement(aw + "Type2", 3),  
    new XElement(aw + "Type2", 4),  
    new XElement(aw + "Type2", 5)  
);  
IEnumerable<XElement> elements =  
    from el in xmlTree.Elements(aw + "Type2")  
    select el;  
foreach (XElement el in elements)  
    Console.WriteLine(el);  
```  
  
```vb  
Imports <xmlns:aw="http://www.adventure-works.com">  
  
Module Module1  
    Sub Main()  
        Dim xmlTree As XElement = _   
            <aw:Root>  
                <aw:Type1>1</aw:Type1>  
                <aw:Type1>2</aw:Type1>  
                <aw:Type2>3</aw:Type2>  
                <aw:Type2>4</aw:Type2>  
                <aw:Type2>5</aw:Type2>  
            </aw:Root>  
  
        Dim elements = From el In xmlTree.<aw:Type2> _  
                       Select el  
  
        For Each el In elements  
            Console.WriteLine(el)  
        Next  
    End Sub  
End Module  
```  
  
 В этом примере выводятся следующие данные:  
  
```  
<aw:Type2 xmlns:aw="http://www.adventure-works.com">3</aw:Type2>  
<aw:Type2 xmlns:aw="http://www.adventure-works.com">4</aw:Type2>  
<aw:Type2 xmlns:aw="http://www.adventure-works.com">5</aw:Type2>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XContainer.Element(System.Xml.Linq.XName)" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.Descendants" />
        <altmember cref="M:System.Xml.Linq.XContainer.DescendantNodes" />
      </Docs>
    </Member>
    <Member MemberName="FirstNode">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNode FirstNode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XNode FirstNode" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XContainer.FirstNode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FirstNode As XNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XNode ^ FirstNode { System::Xml::Linq::XNode ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает первый дочерний узел от данного узла.</summary>
        <value>
          <see cref="T:System.Xml.Linq.XNode" />, содержащий первый дочерний узел <see cref="T:System.Xml.Linq.XContainer" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается элемент, содержащий дочерние элементы. Затем он возвращает первый дочерний узел родительского элемента.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XNode firstNode = xmlTree.FirstNode;  
Console.WriteLine(firstNode);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim firstNode As XNode = xmlTree.FirstNode  
Console.WriteLine(firstNode)  
```  
  
 В этом примере выводятся следующие данные:  
  
```xml  
<Child1>1</Child1>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xml.Linq.XContainer.LastNode" />
        <altmember cref="M:System.Xml.Linq.XContainer.Nodes" />
      </Docs>
    </Member>
    <Member MemberName="LastNode">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XNode LastNode { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XNode LastNode" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XContainer.LastNode" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastNode As XNode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XNode ^ LastNode { System::Xml::Linq::XNode ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XNode</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает последний дочерний узел от данного узла.</summary>
        <value>
          <see cref="T:System.Xml.Linq.XNode" />, содержащий последний дочерний узел <see cref="T:System.Xml.Linq.XContainer" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере создается элемент, содержащий дочерние элементы. Затем он возвращает последний дочерний узел родительского элемента.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XElement("Child5", 5)  
);  
XNode lastNode = xmlTree.LastNode;  
Console.WriteLine(lastNode);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <Child3>3</Child3>  
            <Child4>4</Child4>  
            <Child5>5</Child5>  
        </Root>  
  
Dim lastNode As XNode = xmlTree.LastNode  
Console.WriteLine(lastNode)  
```  
  
 В этом примере выводятся следующие данные:  
  
```xml  
<Child5>5</Child5>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xml.Linq.XContainer.FirstNode" />
        <altmember cref="M:System.Xml.Linq.XContainer.Nodes" />
      </Docs>
    </Member>
    <Member MemberName="Nodes">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt; Nodes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;class System.Xml.Linq.XNode&gt; Nodes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.Nodes" />
      <MemberSignature Language="VB.NET" Value="Public Function Nodes () As IEnumerable(Of XNode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Xml::Linq::XNode ^&gt; ^ Nodes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Xml.Linq.XNode&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает коллекцию дочерних узлов для данного документа или элемента в порядке следования документа.</summary>
        <returns>
          <see cref="T:System.Collections.Generic.IEnumerable`1" />
          <see cref="T:System.Xml.Linq.XNode" />, содержащий содержимое данного <see cref="T:System.Xml.Linq.XContainer" /> в порядке следования документа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Обратите внимание, что содержимое не включает атрибуты. В [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)], атрибуты не учитываются как узлы дерева. Они являются пары имя/значение, связанное с элементом.  
  
 Этот метод использует отложенное выполнение.  
  
   
  
## Examples  
 Следующий пример создает XML-дерево с различными типами узлов. Затем выполняется запрос этот метод оси, чтобы перечислить и распечатать узлы.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XComment("a comment"),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XText("mixed content"),  
    new XElement("Child5", 5)  
);  
IEnumerable<XNode> nodes =  
    from nd in xmlTree.Nodes()  
    select nd;  
foreach (XNode node in nodes)  
    Console.WriteLine(node);  
```  
  
```vb  
Dim xmlTree As XElement = _   
        <Root>  
            <Child1>1</Child1>  
            <Child2>2</Child2>  
            <!--a comment-->  
            <Child3>3</Child3>  
            <Child4>4</Child4>mixed content<Child5>5</Child5>  
            </Root>  
  
Dim nodes = From nd In xmlTree.Nodes() _  
            Select nd  
  
For Each node In nodes  
    Console.WriteLine(node)  
Next  
```  
  
 В этом примере выводятся следующие данные:  
  
```  
<Child1>1</Child1>  
<Child2>2</Child2>  
<!--a comment-->  
<Child3>3</Child3>  
<Child4>4</Child4>  
mixed content  
<Child5>5</Child5>  
```  
  
 Следующий пример создает XML-дерева, содержащий различные типы узлов. Затем выполняется перечисление в частях дерева с распечаткой типов узлов.  
  
```csharp  
XDocument xmlTree = new XDocument(  
    new XComment("a comment"),  
    new XProcessingInstruction("xml-stylesheet", "type=\"text/xsl\" href=\"hello.xsl\""),  
    new XElement("Root",  
        new XAttribute("Att", "attContent"),  
        new XElement("Child1",  
            new XCData("CDATA content")  
        ),  
        new XElement("Child2",  
            new XText("Text content")  
        )  
    )  
);  
  
foreach (XNode node in xmlTree.Nodes())  
{  
    Console.WriteLine(node.NodeType);  
    if (node.NodeType == XmlNodeType.Element)  
    {  
        foreach (XAttribute att in ((XElement)node).Attributes())  
            Console.WriteLine(att.NodeType);  
        foreach (XNode node2 in ((XElement)node).Nodes())  
        {  
            Console.WriteLine(node2.NodeType);  
            if (node2.NodeType == XmlNodeType.Element)  
                foreach (XNode node3 in ((XElement)node2).Nodes())  
                    Console.WriteLine(node3.NodeType);  
        }  
    }  
}  
```  
  
```vb  
Dim xmlTree As XDocument = _   
    <?xml version="1.0" encoding="utf-8"?>  
    <!--a comment-->  
    <?xml-stylesheet type='text/xsl' href='hello.xsl'?>  
    <Root Att="attContent">  
        <Child1><![CDATA[CDATA content]]]><![CDATA[]></Child1>  
        <Child2>Text content</Child2>  
    </Root>  
  
' Note that XNode uses XmlNodeType, which is in the System.Xml namespace  
For Each node In xmlTree.Nodes  
    Console.WriteLine(node.NodeType.ToString())  
    If node.NodeType = XmlNodeType.Element Then  
        For Each att In DirectCast(node, XElement).Attributes  
            Console.WriteLine(att.NodeType.ToString())  
        Next  
        For Each node2 In DirectCast (node, XElement).Nodes()  
            Console.WriteLine(node2.NodeType.ToString())  
            If node2.NodeType = XmlNodeType.Element Then  
                For Each node3 In DirectCast (node2, XElement).Nodes  
                    Console.WriteLine(node3.NodeType.ToString())  
                Next  
            End If  
        Next  
    End If  
Next  
```  
  
 В этом примере выводятся следующие данные:  
  
```  
Comment  
ProcessingInstruction  
Element  
Attribute  
Element  
CDATA  
Element  
Text  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Xml.Linq.XElement.Attributes" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.Descendants" />
        <altmember cref="M:System.Xml.Linq.XContainer.DescendantNodes" />
      </Docs>
    </Member>
    <Member MemberName="RemoveNodes">
      <MemberSignature Language="C#" Value="public void RemoveNodes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveNodes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.RemoveNodes" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveNodes ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveNodes();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет дочерние элементы из данного документа или элемента.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если этот метод вызывается для элемента, который содержит атрибуты, этот метод не удалит атрибуты. Чтобы удалить атрибуты элемента, используйте <xref:System.Xml.Linq.XElement.RemoveAttributes%2A>.  
  
 <xref:System.Xml.Linq.Extensions.Remove%2A> Метод имеет связанные функциональные возможности. Он удаляет дочерние узлы каждого узла в коллекции.  
  
 Этот метод вызывает <xref:System.Xml.Linq.XObject.Changed> и <xref:System.Xml.Linq.XObject.Changing> события.  
  
   
  
## Examples  
 Следующий пример создает XML-дерева, содержащий некоторые дочерние узлы. Затем он вызывает этот метод для удаления дочерних узлов.  
  
```csharp  
XElement xmlTree = new XElement("Root",  
    new XElement("Child1", 1),  
    new XElement("Child2", 2),  
    new XComment("a comment"),  
    new XElement("Child3", 3),  
    new XElement("Child4", 4),  
    new XText("mixed content"),  
    new XElement("Child5", 5)  
);  
xmlTree.RemoveNodes();  
Console.WriteLine(xmlTree);  
```  
  
```vb  
Dim xmltree As XElement = _   
    <Root>  
        <Child1>1</Child1>  
        <Child2>2</Child2>  
        <!--a comment-->  
        <Child3>3</Child3>  
        <Child4>4</Child4>mixed content<Child5>5</Child5>  
    </Root>  
  
xmltree.RemoveNodes()  
Console.WriteLine(xmltree)  
```  
  
 В этом примере выводятся следующие данные:  
  
```xml  
<Root />  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XContainer.Add" />
        <altmember cref="Overload:System.Xml.Linq.XContainer.ReplaceNodes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReplaceNodes">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Заменяет дочерние узлы данного документа или элемента заданным содержимым.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о допустимом содержимом, которое может быть передан этой функции см. в разделе [объектов допустимое содержимое XElement и XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
 Этот метод вызывает <xref:System.Xml.Linq.XObject.Changed> и <xref:System.Xml.Linq.XObject.Changing> события.  
  
 Данный метод обладает семантикой снимка. Сначала он создает копию нового содержимого. Он затем удаляет все дочерние узлы данного узла. Наконец он добавляет новое содержимое как дочерние узлы. Это означает, что можно заменить посредством запроса по дочерним узлам, сами дочерние узлы.  
  
   
  
## Examples  
 Следующий пример создает два XML-дерева и затем использует этот метод для замены содержимого одного из них с результатами запроса.  
  
```csharp  
XElement root = new XElement("Root",  
    new XElement("Child", 1),  
    new XElement("Child", 2),  
    new XElement("Child", 3),  
    new XElement("Child", 4),  
    new XElement("Child", 5)  
);  
root.ReplaceNodes(  
    from el in root.Elements()  
    where (int)el >= 3  
    select el  
);  
Console.WriteLine(root);  
```  
  
```vb  
Dim root As XElement = _   
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
root.ReplaceNodes( _  
    From el In root.Elements _  
    Where el.Value >= 3 _  
    Select el)  
Console.WriteLine(root)  
```  
  
 В этом примере выводятся следующие данные:  
  
```xml  
<Root>  
  <Child>3</Child>  
  <Child>4</Child>  
  <Child>5</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XContainer.Add" />
        <altmember cref="M:System.Xml.Linq.XContainer.RemoveNodes" />
      </Docs>
    </MemberGroup>
    <Member MemberName="ReplaceNodes">
      <MemberSignature Language="C#" Value="public void ReplaceNodes (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReplaceNodes(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.ReplaceNodes(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReplaceNodes (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReplaceNodes(System::Object ^ content);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content">Объект содержимого, включающий простое содержимое или коллекцию объектов содержимого, которые заменяют дочерние узлы.</param>
        <summary>Заменяет дочерние узлы данного документа или элемента заданным содержимым.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о допустимом содержимом, которое может быть передан этой функции см. в разделе [объектов допустимое содержимое XElement и XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
 Этот метод вызывает <xref:System.Xml.Linq.XObject.Changed> и <xref:System.Xml.Linq.XObject.Changing> события.  
  
 Данный метод обладает семантикой снимка. Сначала он создает копию нового содержимого. Он затем удаляет все дочерние узлы данного узла. Наконец он добавляет новое содержимое как дочерние узлы. Это означает, что можно заменить посредством запроса по дочерним узлам, сами дочерние узлы.  
  
   
  
## Examples  
 В следующем примере создается XML-дерево, содержащее дочерние узлы. Затем все дочерние узлы заменяет с единственным элементом.  
  
 Чтобы увидеть пример замены дочерние узлы с результатами [!INCLUDE[vbteclinq](~/includes/vbteclinq-md.md)] запросов см. в разделе <xref:System.Xml.Linq.XContainer.ReplaceNodes%2A>.  
  
```csharp  
XElement root = new XElement("Root",  
    new XElement("Child", 1),  
    new XElement("Child", 2),  
    new XElement("Child", 3),  
    new XElement("Child", 4),  
    new XElement("Child", 5)  
);  
root.ReplaceNodes(  
    from el in root.Elements()  
    where (int)el >= 3  
    select el  
);  
Console.WriteLine(root);  
```  
  
```vb  
Dim root As XElement = _   
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
root.ReplaceNodes( _  
    From el In root.Elements _  
    Where el.Value >= 3 _  
    Select el)  
Console.WriteLine(root)  
```  
  
 В этом примере выводятся следующие данные:  
  
```xml  
<Root>  
  <Child>3</Child>  
  <Child>4</Child>  
  <Child>5</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XContainer.Add" />
        <altmember cref="M:System.Xml.Linq.XContainer.RemoveNodes" />
      </Docs>
    </Member>
    <Member MemberName="ReplaceNodes">
      <MemberSignature Language="C#" Value="public void ReplaceNodes (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReplaceNodes(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XContainer.ReplaceNodes(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReplaceNodes (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReplaceNodes(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content">Список параметров объектов содержимого.</param>
        <summary>Заменяет дочерние узлы данного документа или элемента заданным содержимым.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о допустимом содержимом, которое может быть передан этой функции см. в разделе [объектов допустимое содержимое XElement и XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).  
  
 Этот метод вызывает <xref:System.Xml.Linq.XObject.Changed> и <xref:System.Xml.Linq.XObject.Changing> события.  
  
 Данный метод обладает семантикой снимка. Сначала он создает копию нового содержимого. Он затем удаляет все дочерние узлы данного узла. Наконец он добавляет новое содержимое как дочерние узлы. Это означает, что можно заменить посредством запроса по дочерним узлам, сами дочерние узлы.  
  
   
  
## Examples  
 В следующем примере создается словарь и XML-дерева. Затем запрос словарь, в результаты запроса проецируются <xref:System.Collections.Generic.IEnumerable%601> из <xref:System.Xml.Linq.XElement>и заменяет содержимое XML-дерева с результатами запроса.  
  
```csharp  
XElement root = new XElement("Root",  
    new XElement("Child", 1),  
    new XElement("Child", 2),  
    new XElement("Child", 3),  
    new XElement("Child", 4),  
    new XElement("Child", 5)  
);  
root.ReplaceNodes(  
    from el in root.Elements()  
    where (int)el >= 3  
    select el  
);  
Console.WriteLine(root);  
```  
  
```vb  
Dim root As XElement = _   
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
root.ReplaceNodes( _  
    From el In root.Elements _  
    Where el.Value >= 3 _  
    Select el)  
Console.WriteLine(root)  
```  
  
 В этом примере выводятся следующие данные:  
  
```xml  
<Root>  
  <Child>3</Child>  
  <Child>4</Child>  
  <Child>5</Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Xml.Linq.XContainer.Add" />
        <altmember cref="M:System.Xml.Linq.XContainer.RemoveNodes" />
      </Docs>
    </Member>
  </Members>
</Type>