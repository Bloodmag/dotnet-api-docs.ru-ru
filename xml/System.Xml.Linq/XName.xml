<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="XName.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-efd8310" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">ae25fbb5-14a8-44f2-90c2-3c6d6fcaae7fe3ff53886d4e9e6cdd7246f72367203e391a117f.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">e3ff53886d4e9e6cdd7246f72367203e391a117f</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1b899505ed6d42225f2b3c9150bfdc080d0d1f9b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/28/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XName">
          <source>Represents a name of an XML element or attribute.</source>
          <target state="translated">Представляет имя XML-элемента или атрибута.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>XML names include a namespace and a local name.</source>
          <target state="translated">Имена XML включает пространство имен и локального имени.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>A <bpt id="p1">*</bpt>fully qualified name<ept id="p1">*</ept> is the combination of the namespace and local name.</source>
          <target state="translated">Объект <bpt id="p1">*</bpt>полное имя<ept id="p1">*</ept> представляет собой комбинацию локального имени и пространства имен.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>Creating an XName Object</source>
          <target state="translated">Для создания объекта XName</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source><ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> does not contain any public constructors.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> Нет открытых конструкторов.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>Instead, this class provides an implicit conversion from <ph id="ph1">&lt;xref:System.String&gt;</ph> that allows you to create an <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">Вместо этого данный класс предоставляет неявное преобразование из <ph id="ph1">&lt;xref:System.String&gt;</ph> , позволяет создавать <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>The most common place you use this conversion is when constructing an element or attribute: The first argument to the <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> constructor is an <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">Наиболее распространенным использовать это преобразование является при создании элемента или атрибута: первый аргумент <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> конструктор является <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>By passing a string, you take advantage of the implicit conversion.</source>
          <target state="translated">Путем передачи строки, можно воспользоваться преимуществами неявного преобразования.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>The following code creates an element with a name that is in no namespace:</source>
          <target state="translated">Следующий код создает элемент с именем, которое находится вне пространства имен:</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>In Visual Basic, it is more appropriate to use XML literals:</source>
          <target state="translated">В Visual Basic более целесообразно использовать литералы XML:</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>This example produces the following output:</source>
          <target state="translated">В этом примере выводятся следующие данные:</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>Assigning a string to an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> uses the implicit conversion from <ph id="ph2">&lt;xref:System.String&gt;</ph>.</source>
          <target state="translated">Назначить строку для <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> используется неявное преобразование из <ph id="ph2">&lt;xref:System.String&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>The Visual Basic example creates the <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> using XML literals.</source>
          <target state="translated">В примере Visual Basic создает <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> с помощью XML-литералов.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>Even though XML literals are used, an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> object is created for the <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>.</source>
          <target state="translated">Несмотря на то, что используются XML-литералы, <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> объекта создается для <ph id="ph2">&lt;xref:System.Xml.Linq.XElement&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>In addition, you can call the <ph id="ph1">&lt;xref:System.Xml.Linq.XName.Get%2A&gt;</ph> method for an <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph> object.</source>
          <target state="translated">Кроме того, можно вызвать <ph id="ph1">&lt;xref:System.Xml.Linq.XName.Get%2A&gt;</ph> метод <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>However, the recommended way is to use the implicit conversion from string.</source>
          <target state="translated">Тем не менее рекомендуется использовать неявное преобразование из строки.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>Creating an XName in a Namespace</source>
          <target state="translated">Создание XName в пространстве имен</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>As with XML, an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> can be in a namespace, or it can be in no namespace.</source>
          <target state="translated">Как и в XML, <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> может находиться в пространстве имен или может быть вне пространства имен.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>For C#, the recommended approach for creating an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> in a namespace is to declare the <ph id="ph2">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> object, then use the override of the addition operator.</source>
          <target state="translated">Для C#, рекомендуемый подход для создания <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> в пространстве имен — объявить <ph id="ph2">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> объекта, а затем использовать переопределение оператора сложения.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>For Visual Basic, the recommended approach is to use XML literals and global namespace declarations to create XML that is in a namespace.</source>
          <target state="translated">В Visual Basic рекомендуется использовать литералы XML и деклараций глобальных пространств имен для создания XML-ФАЙЛ, в пространстве имен.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>This example produces the following output:</source>
          <target state="translated">В этом примере выводятся следующие данные:</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>Creating an XName in no Namespace</source>
          <target state="translated">Создание XName вне пространства имен</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XName.Namespace%2A&gt;</ph> property of an <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph> object is guaranteed to not be null.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XName.Namespace%2A&gt;</ph> Свойство <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph> объект гарантированно не иметь значение null.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>If the <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> is in no namespace, then the <ph id="ph2">&lt;xref:System.Xml.Linq.XName.Namespace%2A&gt;</ph> property will be set to <ph id="ph3">&lt;xref:System.Xml.Linq.XNamespace.None%2A&gt;</ph>.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> находится вне пространства имен, то <ph id="ph2">&lt;xref:System.Xml.Linq.XName.Namespace%2A&gt;</ph> свойству будет присвоено <ph id="ph3">&lt;xref:System.Xml.Linq.XNamespace.None%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>The following code demonstrates this:</source>
          <target state="translated">Это демонстрируется в следующем коде:</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>This example produces the following output:</source>
          <target state="translated">В этом примере выводятся следующие данные:</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>Using Expanded Names</source>
          <target state="translated">Использование развернутых имен</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>You can also create an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> from a expanded XML name in the form <ph id="ph2">`{namespace}localname`</ph>:</source>
          <target state="translated">Можно также создать <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> из развернутое имя XML в виде <ph id="ph2">`{namespace}localname`</ph>:</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>This example produces the following output:</source>
          <target state="translated">В этом примере выводятся следующие данные:</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>Be aware that creating an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> through an expanded name is less efficient than creating an <ph id="ph2">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> object and using the override of the addition operator.</source>
          <target state="translated">Имейте в виду, что создание <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> через развернутое имя является менее эффективным, чем создание <ph id="ph2">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> объекта и используя переопределение оператора сложения.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>It is also less efficient than importing a global namespace and using XML literals in Visual Basic.</source>
          <target state="translated">Это менее эффективно, чем импорт глобального пространства имен и использование литералов XML в Visual Basic.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>If you create an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> using an expanded name, LINQ to XML must find the atomized instance of a namespace.</source>
          <target state="translated">Если вы создаете <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> с помощью развернутое имя, LINQ to XML необходимо найти атомизированных экземпляр пространства имен.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>This work must be repeated for every use of an expanded name.</source>
          <target state="translated">Эту работу, необходимо повторить для каждого использования развернутого имени.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>This additional time is likely to be negligible when writing LINQ queries; however, it might be significant when creating a large XML tree.</source>
          <target state="translated">Это дополнительное время, вероятнее всего можно пренебречь, при написании запросов LINQ; Тем не менее можно значительно при создании большого XML-дерева.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>XName Objects are Atomized</source>
          <target state="translated">Выполняется атомизация объектов XName</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source><ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> objects are guaranteed to be atomized; that is, if two <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph> objects have exactly the same namespace and exactly the same local name, they will share the same instance.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> объекты гарантированно атомизированы; то есть если два <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph> объектов есть ровно то же пространство имен и одно и то же имя локального, они будут совместно использовать тот же экземпляр.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>The equality and comparison operators are also provided explicitly for this purpose.</source>
          <target state="translated">Операторы равенства и сравнения также предоставлены именно для этой цели.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>Among other benefits, this feature allows for faster execution of queries.</source>
          <target state="translated">Помимо прочих преимуществ эта функция позволяет быстрее выполнять запросы.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>When filtering on the name of elements or attributes, the comparisons expressed in predicates use identity comparison, not value comparison.</source>
          <target state="translated">При фильтрации по имени, элементов или атрибутов, выраженное в предикатах сравнения используйте сравнения идентичности, а не для сравнения значений.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>It is much faster to determine that two references actually refer to the same object than to compare two strings.</source>
          <target state="translated">Этот способ гораздо быстрее, чтобы определить, что две ссылки фактически ссылаются на один и тот же объект, чем сравнивать две строки.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.Equals(System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> to compare to the current <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> для сравнения с текущим объектом <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.Equals(System.Object)">
          <source>Determines whether the specified <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> is equal to this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</source>
          <target state="translated">Определяет, является ли указанное <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> равным данному <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.Equals(System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the specified <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> is equal to the current <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>; otherwise <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если указанный <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> равен текущему <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>; в ином случае — <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Equals(System.Object)">
          <source>For two <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> objects to be equal, they must have the same expanded name.</source>
          <target state="translated">Для двух <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> объекты равны, они должны иметь одинаковое развернутое имя.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" uid="T:System.Xml.Linq.XName">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> object.</source>
          <target state="translated">Вызывает объект <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>This method provides overloads that allow you to create an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> from a expanded XML name.</source>
          <target state="translated">Этот метод предоставляет перегруженные методы, которые позволяют создавать <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> из развернутое имя XML.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>You can create an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> from a string in the form <ph id="ph2">`{namespace}localname`</ph>, or from a namespace and a local name, specified separately.</source>
          <target state="translated">Можно создать <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> из строки в виде <ph id="ph2">`{namespace}localname`</ph>, или из пространства имен и локального имени, указанного отдельно.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>A much more common and easier way to create an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> is to use the implicit conversion from string.</source>
          <target state="translated">Гораздо более часто применяемый и легкий способ создания <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> заключается в использовании неявное преобразование из строки.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>To create a name that is in a namespace, the common approach is to use the addition operator overload that allows you to combine an <ph id="ph1">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> object and a string.</source>
          <target state="translated">Создать имя, которое находится в пространстве имен, распространенным подходом является использование перегрузки оператора сложения, которая позволяет объединять <ph id="ph1">&lt;xref:System.Xml.Linq.XNamespace&gt;</ph> object и string.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>For more information and examples, see <bpt id="p1">[</bpt>How to: Create a Document with Namespaces (C#) (LINQ to XML)<ept id="p1">](http://msdn.microsoft.com/library/af4a595e-ffb2-4187-a61b-d5ed71642c4c)</ept>.</source>
          <target state="translated">Дополнительные сведения и примеры см. в разделе <bpt id="p1">[</bpt>как: Создание документа с пространствами имен (C#) (LINQ to XML)<ept id="p1">](http://msdn.microsoft.com/library/af4a595e-ffb2-4187-a61b-d5ed71642c4c)</ept>.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>For more information on using namespaces in Visual Basic, see <bpt id="p1">[</bpt>Namespaces in Visual Basic (LINQ to XML)<ept id="p1">](http://msdn.microsoft.com/library/10b7ba7b-518c-4f14-899f-892575d14dcc)</ept>.</source>
          <target state="translated">Дополнительные сведения об использовании пространства имен в Visual Basic см. в разделе <bpt id="p1">[</bpt>пространства имен в Visual Basic (LINQ to XML)<ept id="p1">](http://msdn.microsoft.com/library/10b7ba7b-518c-4f14-899f-892575d14dcc)</ept>.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>Because <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> objects are atomized, if there is an existing <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph> with exactly the same name, the assigned variable will refer to the existing <ph id="ph3">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">Поскольку <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> объекты разделены, если имеется существующий <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph> в одно и то же имя, назначенного переменной будет ссылаться на существующие <ph id="ph3">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Xml.Linq.XName">
          <source>If there is no existing <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>, a new one will be created and initialized.</source>
          <target state="translated">При отсутствии существующих <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>, новый один будет создана и инициализирована.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.Get(System.String)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that contains an expanded XML name in the format <bpt id="p1">&lt;c&gt;</bpt>{namespace}localname<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Строка <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, которая содержит развернутое имя XML в формате <bpt id="p1">&lt;c&gt;</bpt>{пространство_имен}локальное_имя<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.Get(System.String)">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> object from an expanded name.</source>
          <target state="translated">Вызывает объект <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> из развернутого имени.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.Get(System.String)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> object constructed from the expanded name.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> сконструирован из развернутого имени.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String)">
          <source>This method contains overloads that allow you to create an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">Этот метод содержит перегрузки, которые позволяют создавать <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String)">
          <source>You can create it from a expanded XML name in the form <ph id="ph1">`{namespace}localname`</ph>, or from a namespace and a local name, specified separately.</source>
          <target state="translated">Вы можете создать на развернутое имя XML в виде <ph id="ph1">`{namespace}localname`</ph>, или из пространства имен и локального имени, указанного отдельно.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String)">
          <source>A much more common and easier way to create an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> is to use the implicit conversion from string.</source>
          <target state="translated">Гораздо более часто применяемый и легкий способ создания <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> заключается в использовании неявное преобразование из строки.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String)">
          <source>Because <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> are atomized, if there is an existing <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph> with exactly the same name, the assigned variable will refer to the existing <ph id="ph3">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">Поскольку <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> разделены, если имеется существующий <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph> в одно и то же имя, назначенного переменной будет ссылаться на существующие <ph id="ph3">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String)">
          <source>If there is no existing <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>, a new one will be created and initialized.</source>
          <target state="translated">При отсутствии существующих <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>, новый один будет создана и инициализирована.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String)">
          <source>The following example shows the use of this method.</source>
          <target state="translated">В следующем примере показано использование этого метода.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String)">
          <source>This example produces the following output:</source>
          <target state="translated">В этом примере выводятся следующие данные:</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.Get(System.String,System.String)">
          <source>A local (unqualified) name.</source>
          <target state="translated">Локальное (неопределенное) имя.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.Get(System.String,System.String)">
          <source>An XML namespace.</source>
          <target state="translated">Пространство имен XML.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.Get(System.String,System.String)">
          <source>Gets an <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> object from a local name and a namespace.</source>
          <target state="translated">Вызывает объект <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> из локального имени и пространства имен.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.Get(System.String,System.String)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> object created from the specified local name and namespace.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>, созданный из указанного локального имени и пространства имен.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String,System.String)">
          <source>This method contains overloads that allow you to create an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">Этот метод содержит перегрузки, которые позволяют создавать <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String,System.String)">
          <source>You can create it from an expanded XML name in the form <ph id="ph1">`{namespace}localname`</ph>, or from a namespace and a local name, specified separately.</source>
          <target state="translated">Вы можете создать на развернутое имя XML в виде <ph id="ph1">`{namespace}localname`</ph>, или из пространства имен и локального имени, указанного отдельно.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String,System.String)">
          <source>A much more common and easier way to create an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> is to use the implicit conversion from string.</source>
          <target state="translated">Гораздо более часто применяемый и легкий способ создания <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> заключается в использовании неявное преобразование из строки.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String,System.String)">
          <source>Because <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> are atomized, if there is an existing <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph> with exactly the same name, the assigned variable will refer to the existing <ph id="ph3">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">Поскольку <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> разделены, если имеется существующий <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph> в одно и то же имя, назначенного переменной будет ссылаться на существующие <ph id="ph3">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String,System.String)">
          <source>If there is no existing <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>, a new one will be created and initialized.</source>
          <target state="translated">При отсутствии существующих <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>, новый один будет создана и инициализирована.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String,System.String)">
          <source>The following example shows the use of this method.</source>
          <target state="translated">В следующем примере показано использование этого метода.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.Get(System.String,System.String)">
          <source>This example produces the following output:</source>
          <target state="translated">В этом примере выводятся следующие данные:</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.GetHashCode">
          <source>Gets a hash code for this <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</source>
          <target state="translated">Возвращает хэш-код для данного объекта <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.GetHashCode">
          <source>An <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> that contains the hash code for the <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> содержит хэш-код для <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.GetHashCode">
          <source>This method serves as a hash function for <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">Этот метод служит хэш-функцией для <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.GetHashCode">
          <source>You can use <ph id="ph1">&lt;xref:System.Xml.Linq.XName.GetHashCode%2A&gt;</ph> in hashing algorithms, or in data structures such as a hash table.</source>
          <target state="translated">Можно использовать <ph id="ph1">&lt;xref:System.Xml.Linq.XName.GetHashCode%2A&gt;</ph> в алгоритмах хэширования или в структурах данных, например в хэш-таблице.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XName.LocalName">
          <source>Gets the local (unqualified) part of the name.</source>
          <target state="translated">Вызывает локальную (неопределенную) часть имени.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XName.LocalName">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that contains the local (unqualified) part of the name.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, содержащий локальную (неопределенную) часть имени.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XName.LocalName">
          <source>This property is guaranteed to not be <ph id="ph1">`null`</ph>.</source>
          <target state="translated">Это свойство гарантированно не будет <ph id="ph1">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XName.LocalName">
          <source>The following example shows the use of this property.</source>
          <target state="translated">В следующем примере показано использование этого свойства.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XName.LocalName">
          <source>This example produces the following output:</source>
          <target state="translated">В этом примере выводятся следующие данные:</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XName.Namespace">
          <source>Gets the namespace part of the fully qualified name.</source>
          <target state="translated">Вызывает часть пространства имен полностью определенного имени.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XName.Namespace">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNamespace" /&gt;</ph> that contains the namespace part of the name.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNamespace" /&gt;</ph>, содержит часть имени пространства имен.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XName.Namespace">
          <source>The <ph id="ph1">&lt;xref:System.Xml.Linq.XName.Namespace%2A&gt;</ph> property is guaranteed to not be <ph id="ph2">`null`</ph>.</source>
          <target state="translated">Гарантируется, что свойство <ph id="ph1">&lt;xref:System.Xml.Linq.XName.Namespace%2A&gt;</ph> не имеет значения <ph id="ph2">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XName.Namespace">
          <source>If an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> is in no namespace, this property returns <ph id="ph2">&lt;xref:System.Xml.Linq.XNamespace.None%2A&gt;</ph>.</source>
          <target state="translated">Если <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> находится вне пространства имен, это свойство возвращает <ph id="ph2">&lt;xref:System.Xml.Linq.XNamespace.None%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XName.Namespace">
          <source>The following example shows the use of this property.</source>
          <target state="translated">В следующем примере показано использование этого свойства.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XName.Namespace">
          <source>This example produces the following output:</source>
          <target state="translated">В этом примере выводятся следующие данные:</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" uid="P:System.Xml.Linq.XName.NamespaceName">
          <source>Returns the URI of the <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNamespace" /&gt;</ph> for this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</source>
          <target state="translated">Возвращает URI <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNamespace" /&gt;</ph> для этого <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XName.NamespaceName">
          <source>The URI of the <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNamespace" /&gt;</ph> for this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</source>
          <target state="translated">Возвращает URI <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XNamespace" /&gt;</ph> для этого <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XName.NamespaceName">
          <source>This is a convenience property to get the namespace name from an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">Это свойство предусмотрено для удобства для получения имени пространства имен из <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XName.NamespaceName">
          <source>This example creates an element in a namespace, and then prints the element's namespace.</source>
          <target state="translated">В этом примере создается элемент в пространстве имен, а затем выводит пространство имен.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Xml.Linq.XName.NamespaceName">
          <source>This example produces the following output:</source>
          <target state="translated">В этом примере выводятся следующие данные:</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.op_Equality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>The first <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> to compare.</source>
          <target state="translated">Первый экземпляр <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> для сравнения.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.op_Equality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>The second <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> to compare.</source>
          <target state="translated">Второй экземпляр <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> для сравнения.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.op_Equality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>Returns a value indicating whether two instances of <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are equal.</source>
          <target state="translated">Возвращает значение, указывающее, равны ли два экземпляра <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.op_Equality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> and <ph id="ph3">&lt;paramref name="right" /&gt;</ph> are equal; otherwise <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если <ph id="ph2">&lt;paramref name="left" /&gt;</ph> и <ph id="ph3">&lt;paramref name="right" /&gt;</ph> равны; в ином случае — <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.op_Equality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>The operator overloads <ph id="ph1">`==`</ph> and <ph id="ph2">`!=`</ph> are included to enable comparisons between <ph id="ph3">&lt;xref:System.Xml.Linq.XName&gt;</ph> and a <ph id="ph4">`string`</ph>, such as<ph id="ph5">`element.Name == "SomeElementName"`</ph>.</source>
          <target state="translated">Перегрузки операторов <ph id="ph1">`==`</ph> и <ph id="ph2">`!=`</ph> включены для включения сравнений <ph id="ph3">&lt;xref:System.Xml.Linq.XName&gt;</ph> и <ph id="ph4">`string`</ph>, такие как<ph id="ph5">`element.Name == "SomeElementName"`</ph>.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.op_Equality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>The predefined reference equality operators in C# require one operand to be convertible to the type of the other through reference conversions only.</source>
          <target state="translated">Предопределенная ссылка операторов равенства в C# требует, чтобы один операнд допускать преобразование к типу другого только через преобразования ссылки.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.op_Equality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>These operators do not consider the implicit conversion from string to <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">Эти операторы не учитывают неявное преобразование из строки в <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.op_Equality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>The following example shows some comparisons between <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> objects and strings.</source>
          <target state="translated">Следующий пример показывает некоторые сравнения между <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> объекты и строки.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.op_Equality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>This example produces the following output:</source>
          <target state="translated">В этом примере выводятся следующие данные:</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.op_Implicit(System.String)~System.Xml.Linq.XName">
          <source>A string that contains an expanded XML name in the format <bpt id="p1">&lt;c&gt;</bpt>{namespace}localname<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Строка, которая содержит развернутое имя XML в формате <bpt id="p1">&lt;c&gt;</bpt>{пространство_имен}локальное_имя<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.op_Implicit(System.String)~System.Xml.Linq.XName">
          <source>Converts a string formatted as an expanded XML name (that is,<bpt id="p1">&lt;c&gt;</bpt>{namespace}localname<ept id="p1">&lt;/c&gt;</ept>) to an <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> object.</source>
          <target state="translated">Преобразует строку, отформатированную как развернутое имя XML (то есть <bpt id="p1">&lt;c&gt;</bpt>{пространство_имен}локальное_имя<ept id="p1">&lt;/c&gt;</ept>), в объект <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.op_Implicit(System.String)~System.Xml.Linq.XName">
          <source>An <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> object constructed from the expanded name.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> сконструирован из развернутого имени.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.op_Implicit(System.String)~System.Xml.Linq.XName">
          <source>You are using this implicit operator when you create an <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> or <ph id="ph2">&lt;xref:System.Xml.Linq.XAttribute&gt;</ph> by passing a string to the appropriate constructor.</source>
          <target state="translated">Вы используете этот неявный оператор при создании <ph id="ph1">&lt;xref:System.Xml.Linq.XElement&gt;</ph> или <ph id="ph2">&lt;xref:System.Xml.Linq.XAttribute&gt;</ph> путем передачи строки в соответствующий конструктор.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.op_Implicit(System.String)~System.Xml.Linq.XName">
          <source>The following example creates an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> by assigning a string to it, which invokes this implicit conversion operator.</source>
          <target state="translated">В следующем примере создается <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> необходимо назначить строку к нему, который вызывает этот неявный оператор преобразования.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.op_Implicit(System.String)~System.Xml.Linq.XName">
          <source>This example produces the following output:</source>
          <target state="translated">В этом примере выводятся следующие данные:</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.op_Inequality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>The first <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> to compare.</source>
          <target state="translated">Первый экземпляр <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> для сравнения.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.op_Inequality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>The second <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> to compare.</source>
          <target state="translated">Второй экземпляр <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> для сравнения.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.op_Inequality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>Returns a value indicating whether two instances of <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> are not equal.</source>
          <target state="translated">Возвращает значение, указывающее, являются ли два экземпляра <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> неравными.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.op_Inequality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;paramref name="left" /&gt;</ph> and <ph id="ph3">&lt;paramref name="right" /&gt;</ph> are not equal; otherwise <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если <ph id="ph2">&lt;paramref name="left" /&gt;</ph> и <ph id="ph3">&lt;paramref name="right" /&gt;</ph> не равны; в ином случае — <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.op_Inequality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>The operator overloads <ph id="ph1">`==`</ph> and <ph id="ph2">`!=`</ph> are included to enable comparisons between <ph id="ph3">&lt;xref:System.Xml.Linq.XName&gt;</ph> and a string, such as<ph id="ph4">`element.Name == "SomeElementName"`</ph>.</source>
          <target state="translated">Перегрузки операторов <ph id="ph1">`==`</ph> и <ph id="ph2">`!=`</ph> включены для включения сравнений <ph id="ph3">&lt;xref:System.Xml.Linq.XName&gt;</ph> и строку, например<ph id="ph4">`element.Name == "SomeElementName"`</ph>.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.op_Inequality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>The predefined reference equality operators in C# require one operand to be convertible to the type of the other through reference conversions only.</source>
          <target state="translated">Предопределенная ссылка операторов равенства в C# требует, чтобы один операнд допускать преобразование к типу другого только через преобразования ссылки.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.op_Inequality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>These operators do not consider the implicit conversion from string to <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">Эти операторы не учитывают неявное преобразование из строки в <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.op_Inequality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>The following C# example compares an <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> object to a string, which invokes this operator.</source>
          <target state="translated">В следующем примере C# сравнивают <ph id="ph1">&lt;xref:System.Xml.Linq.XName&gt;</ph> объекта в строку, которая вызывает этот оператор.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.op_Inequality(System.Xml.Linq.XName,System.Xml.Linq.XName)">
          <source>This example produces the following output:</source>
          <target state="translated">В этом примере выводятся следующие данные:</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.System#IEquatable&amp;lt;System#Xml#Linq#XName&amp;gt;#Equals(System.Xml.Linq.XName)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> to compare with this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> для сравнения с данным объектом <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.System#IEquatable&amp;lt;System#Xml#Linq#XName&amp;gt;#Equals(System.Xml.Linq.XName)">
          <source>Indicates whether the current <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> is equal to the specified <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</source>
          <target state="translated">Показывает, является ли текущий <ph id="ph1">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> равным указанному <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.System#IEquatable&amp;lt;System#Xml#Linq#XName&amp;gt;#Equals(System.Xml.Linq.XName)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> is equal to the specified <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>, otherwise <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, если этот <ph id="ph2">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph> равен указанному <ph id="ph3">&lt;see cref="T:System.Xml.Linq.XName" /&gt;</ph>, в ином случае — <ph id="ph4">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> to populate with data.</source>
          <target state="translated">Объект <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> для заполнения данными.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>The destination (see <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph>) for this serialization.</source>
          <target state="translated">Конечный объект (см. <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.StreamingContext" /&gt;</ph>) для этой сериализации.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>Populates a <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> with the data required to serialize the target object.</source>
          <target state="translated">Заполняет объект <ph id="ph1">&lt;see cref="T:System.Runtime.Serialization.SerializationInfo" /&gt;</ph> данными, необходимыми для сериализации целевого объекта.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
          <source>This method is used internally to serialize object graphs that contain LINQ to XML objects.</source>
          <target state="translated">Этот метод используется внутренне для сериализации графов объектов, содержащих LINQ для объектов XML.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.ToString">
          <source>Returns the expanded XML name in the format <bpt id="p1">&lt;c&gt;</bpt>{namespace}localname<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Возвращает развернутое имя XML в формате <bpt id="p1">&lt;c&gt;</bpt>{пространство_имен}локальное_имя<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" uid="M:System.Xml.Linq.XName.ToString">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that contains the expanded XML name in the format <bpt id="p1">&lt;c&gt;</bpt>{namespace}localname<ept id="p1">&lt;/c&gt;</ept>.</source>
          <target state="translated">Строка <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, которая содержит развернутое имя XML в формате <bpt id="p1">&lt;c&gt;</bpt>{пространство_имен}локальное_имя<ept id="p1">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.ToString">
          <source>The following example calls <ph id="ph1">&lt;xref:System.Console.WriteLine%2A&gt;</ph>, passing an <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</source>
          <target state="translated">В следующем примере вызывается <ph id="ph1">&lt;xref:System.Console.WriteLine%2A&gt;</ph>, передав <ph id="ph2">&lt;xref:System.Xml.Linq.XName&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.ToString">
          <source>This causes the <ph id="ph1">&lt;xref:System.Xml.Linq.XName.ToString%2A&gt;</ph> method to be called.</source>
          <target state="translated">В результате <ph id="ph1">&lt;xref:System.Xml.Linq.XName.ToString%2A&gt;</ph> вызываемого метода.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Xml.Linq.XName.ToString">
          <source>This example produces the following output:</source>
          <target state="translated">В этом примере выводятся следующие данные:</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>