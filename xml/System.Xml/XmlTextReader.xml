<Type Name="XmlTextReader" FullName="System.Xml.XmlTextReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="fc7d765170296a270026ece865d6eb31cd64ddfa" />
    <Meta Name="ms.sourcegitcommit" Value="b15b8cf0f6dbc1504057c88969d9ef4b790891fe" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="05/11/2018" />
    <Meta Name="ms.locfileid" Value="34061678" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XmlTextReader : System.Xml.XmlReader, System.Xml.IXmlLineInfo, System.Xml.IXmlNamespaceResolver" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlTextReader extends System.Xml.XmlReader implements class System.Xml.IXmlLineInfo, class System.Xml.IXmlNamespaceResolver" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlTextReader" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlTextReader&#xA;Inherits XmlReader&#xA;Implements IXmlLineInfo, IXmlNamespaceResolver" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlTextReader : System::Xml::XmlReader, System::Xml::IXmlLineInfo, System::Xml::IXmlNamespaceResolver" />
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.XmlReader</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Xml.IXmlLineInfo</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.IXmlNamespaceResolver</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет средство чтения, обеспечивающее быстрый прямой доступ (без кэширования) к данным XML.  
  
 Начиная с .NET Framework версии 2.0 рекомендуется использовать класс <see cref="T:System.Xml.XmlReader" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 <xref:System.Xml.XmlTextReader> предоставляет доступ только вперед, только для чтения в поток XML-данных. Текущим является узел, на котором расположен модуль чтения. Средство чтения может с помощью любого из методов чтения и свойства, соответствующие значению текущего узла.  
  
 Этот класс реализует <xref:System.Xml.XmlReader> и соответствует W3C языка (XML) 1.0 и пространств имен в рекомендации XML. `XmlTextReader` предоставляет следующие функциональные возможности:  
  
-   Применяет правила корректный XML.  
  
-   `XmlTextReader` не поддерживает проверку данных.  
  
-   Проверяет, что `DocumentType` узлы имеют правильный формат. `XmlTextReader` проверяет правильность DTD, но не выполняет проверку с помощью DTD.  
  
-   Для узлов, где <xref:System.Xml.XmlTextReader.NodeType%2A> — `XmlNodeType.EntityReference`, пустых `EntityReference` возвращается узел (т. е <xref:System.Xml.XmlTextReader.Value%2A> свойство `String.Empty`).  
  
> [!NOTE]
>  Реальные объявления сущностей в DTD называются `Entity` узлов. При ссылке на эти узлы в данных, они называются `EntityReference` узлов.  
  
-   Не расширяет атрибуты по умолчанию.  
  
 Поскольку `XmlTextReader` не выполняет дополнительных проверок, требуемых для проверки данных, он предоставляет быстрое средство синтаксического анализа.  
  
 При выполнении проверки данных, используйте проверяющего <xref:System.Xml.XmlReader>.  
  
 Для считывания XML-данных из <xref:System.Xml.XmlDocument>, используйте <xref:System.Xml.XmlNodeReader>.  
  
 `XmlTextReader` Создает <xref:System.Xml.XmlException> XML-ошибки синтаксического анализа. После исключения состояние средства чтения не является прогнозируемым. Например указанный тип узла может отличаться от фактического типа текущего узла. Используйте <xref:System.Xml.XmlTextReader.ReadState%2A> свойство, чтобы проверить, является ли модуль чтения находится в состоянии ошибки.  
  
## <a name="security-considerations"></a>Вопросы безопасности  
 Ниже перечислены аспекты, которые необходимо учитывать при использовании <xref:System.Xml.XmlTextReader> класса.  
  
-   Исключения, создаваемые <xref:System.Xml.XmlTextReader> , могут содержать сведения о пути, которые не следует в приведенном выше приложения. Приложения должны перехватывать исключения и обрабатывать их соответствующим образом.  
  
-   Обработка определения DTD по умолчанию включена. Отключите обработку DTD, если вас интересуют отказ в обслуживании, или при работе с ненадежными источниками. Задать <xref:System.Xml.XmlTextReader.DtdProcessing%2A> свойства <xref:System.Xml.DtdProcessing.Prohibit> для отключения обработки DTD.  
  
     Если обработка DTD включена, то с помощью класса <xref:System.Xml.XmlSecureResolver> можно ограничить ресурсы, доступные для объекта <xref:System.Xml.XmlTextReader>. Кроме того, можно создать собственное приложение, ограничивающее объем памяти и время, выделяемое на обработку XML. Например, можно ограничить время ожидания в приложении ASP.NET.  
  
-   XML-данные могут содержать ссылки на внешние ресурсы, такие как DTD-файл. По умолчанию внешние ресурсы разрешаются с помощью объекта <xref:System.Xml.XmlUrlResolver> без пользовательских учетных данных. Это можно сделать еще более безопасным, выполнив одно из следующих действий.  
  
    -   Ограничить ресурсы, к которым имеет доступ <xref:System.Xml.XmlTextReader>, установив в качестве значения свойства <xref:System.Xml.XmlTextReader.XmlResolver%2A> объект <xref:System.Xml.XmlSecureResolver>.  
  
    -   Не разрешать <xref:System.Xml.XmlReader> открывать какие-либо внешние ресурсы, установив для свойства <xref:System.Xml.XmlTextReader.XmlResolver%2A> значение `null`.  
  
-   XML-данные могут содержать большое количество атрибутов, деклараций пространств имен, вложенных элементов и так далее, на обработку которых требуется значительное время. Чтобы ограничить размер входных данных, который отправляется <xref:System.Xml.XmlTextReader>, создать пользовательскую реализацию IStream и передайте в него <xref:System.Xml.XmlTextReader>.  
  
-   <xref:System.Xml.XmlReader.ReadValueChunk%2A> Метод может использоваться для обработки больших массивов данных. Этот метод за раз считывает небольшое число символов, а не выделяет одну строку для всего значения.  
  
-   По умолчанию общие сущности не раскрываются. Общие сущности раскрываются при вызове метода <xref:System.Xml.XmlTextReader.ResolveEntity%2A>.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Этот класс имеет требования наследования. Требуется полное доверие для наследования от <see langword="XmlTextReader" />.</para>
    </block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xml.XmlTextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlTextReader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XmlTextReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see langword="XmlTextReader" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (System.IO.Stream input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (input As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::IO::Stream ^ input);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="input">Поток, содержащий считываемые XML-данные.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xml.XmlTextReader" /> с указанным потоком.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 <xref:System.Xml.XmlTextReader> Декодирует поток с помощью <xref:System.Text.Encoding?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (System.IO.TextReader input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextReader input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (input As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::IO::TextReader ^ input);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="input">
          <see langword="TextReader" />, содержащий считываемые XML-данные.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xml.XmlTextReader" /> указанным значением <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Предполагается, что для `TextReader` задана верная кодировка. Используется клиентами, которые уже прочитали некоторые вещи из потока в сценарии составного MIME.  
  
   
  
## Examples  
 В следующем примере загружается в XML-строку `XmlTextReader` с помощью <xref:System.IO.StringReader> класса.  
  
 [!code-cpp[XmlTextReader.cctor1#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.cctor1/CPP/rdrcctor1.cpp#1)]
 [!code-csharp[XmlTextReader.cctor1#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.cctor1/CS/rdrcctor1.cs#1)]
 [!code-vb[XmlTextReader.cctor1#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.cctor1/VB/rdrcctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">URL-адрес файла с XML-данными. Для свойства <see cref="P:System.Xml.XmlTextReader.BaseURI" /> задано это значение.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xml.XmlTextReader" /> с указанным файлом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Если файл находится на ресурсе, требующем учетных данных, используйте <xref:System.Xml.XmlTextReader.XmlResolver%2A> свойство, чтобы указать необходимые учетные данные.  
  
> [!NOTE]
>  В версии 1.1 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], частично доверенный код не может установить `XmlResolver` свойство. Необходимо создать <xref:System.Xml.XmlUrlResolver> с необходимыми учетными данными, передать URI в <xref:System.Xml.XmlUrlResolver.GetEntity%2A?displayProperty=nameWithType> метода, а затем создать `XmlTextReader` с помощью полученного <xref:System.IO.Stream> объекта. Эта процедура описана в следующем коде C#.  
  
```csharp  
// Create a resolver with the necessary credentials.  
XmlUrlResolver resolver = new XmlUrlResolver();  
NetworkCredential nc = new NetworkCredential(SecurelyStoredUserName, SecurelyStoredPassword, SecurelyStoredDomain);  
resolver.Credentials = nc;   
// Get a Stream object containing the XML file.  
Uri myUri = new Uri ("http://myServer/data/books.xml");  
Stream s=(Stream)resolver.GetEntity(myUri, null, typeof(Stream));  
// Construct a reader using the Stream object.  
XmlTextReader reader = new XmlTextReader(s);  
```  
  
   
  
## Examples  
 В следующем примере считывает XML-файла и отображение каждого из узлов.  
  
 [!code-cpp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/VB/source.vb#1)]  
  
 В примере используется файл `items.xml`, в качестве входных данных.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти указанный файл.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Не удается найти часть имени файла или каталога.</exception>
        <exception cref="T:System.InvalidOperationException">
          Параметр <paramref name="url" /> равен пустой строке.</exception>
        <exception cref="T:System.Net.WebException">Не удается разрешить удаленное имя файла.  
  
 - или -  
  
 При обработке этого запроса возникла ошибка.</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="url" /> не является допустимым URI.</exception>
        <altmember cref="P:System.Xml.XmlTextReader.XmlResolver" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlTextReader (System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XmlTextReader(System::Xml::XmlNameTable ^ nt);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="nt">Используемый <see langword="XmlNameTable" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xml.XmlTextReader" /> указанным значением <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (System.IO.Stream input, System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream input, class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.IO.Stream,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (input As Stream, nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::IO::Stream ^ input, System::Xml::XmlNameTable ^ nt);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="input">Поток, содержащий считываемые XML-данные.</param>
        <param name="nt">Используемый <see langword="XmlNameTable" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xml.XmlTextReader" /> с указанными потоком и <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 <xref:System.Xml.XmlTextReader> Декодирует поток с помощью <xref:System.Text.Encoding?displayProperty=nameWithType>.  
  
 Если указать имя таблицы, этот конструктор использует имена, уже определенные в этой таблице.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Параметру <paramref name="input" /> или <paramref name="nt" /> задано значение <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (System.IO.TextReader input, System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextReader input, class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.IO.TextReader,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (input As TextReader, nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::IO::TextReader ^ input, System::Xml::XmlNameTable ^ nt);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="input">
          <see langword="TextReader" />, содержащий считываемые XML-данные.</param>
        <param name="nt">Используемый <see langword="XmlNameTable" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xml.XmlTextReader" /> с заданными свойствами <see cref="T:System.IO.TextReader" /> и <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Предполагается, что для `TextReader` задана верная кодировка. Используется клиентами, которые уже прочитали некоторые вещи из потока в сценарии составного MIME.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Значение <paramref name="nt" /> равно <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url, System.IO.Stream input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url, class System.IO.Stream input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String, input As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url, System::IO::Stream ^ input);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="input" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="url">URL-адрес, используемый для разрешения внешних ресурсов. Для свойства <see cref="P:System.Xml.XmlTextReader.BaseURI" /> задано это значение.</param>
        <param name="input">Поток, содержащий считываемые XML-данные.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xml.XmlTextReader" /> с указанным URL-адресом и потоком.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="input" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url, System.IO.TextReader input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url, class System.IO.TextReader input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String, input As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url, System::IO::TextReader ^ input);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="input" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="url">URL-адрес, используемый для разрешения внешних ресурсов. Для свойства <see cref="P:System.Xml.XmlTextReader.BaseURI" /> задано это значение.</param>
        <param name="input">
          <see langword="TextReader" />, содержащий считываемые XML-данные.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xml.XmlTextReader" /> с указанным URL-адресом и <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Предполагается, что для `TextReader` задана верная кодировка. Используется клиентами, которые уже прочитали некоторые вещи из потока в сценарии составного MIME.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url, System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url, class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String, nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url, System::Xml::XmlNameTable ^ nt);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="url">URL-адрес файла, содержащего считываемые данные XML.</param>
        <param name="nt">Используемый <see langword="XmlNameTable" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xml.XmlTextReader" /> с указанным файлом и <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Значение <paramref name="nt" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Не удается найти указанный файл.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Не удается найти часть имени файла или каталога.</exception>
        <exception cref="T:System.InvalidOperationException">
          Параметр <paramref name="url" /> равен пустой строке.</exception>
        <exception cref="T:System.Net.WebException">Не удается разрешить удаленное имя файла.  
  
 - или -  
  
 При обработке этого запроса возникла ошибка.</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="url" /> не является допустимым URI.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (System.IO.Stream xmlFragment, System.Xml.XmlNodeType fragType, System.Xml.XmlParserContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream xmlFragment, valuetype System.Xml.XmlNodeType fragType, class System.Xml.XmlParserContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.IO.Stream,System.Xml.XmlNodeType,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xmlFragment As Stream, fragType As XmlNodeType, context As XmlParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::IO::Stream ^ xmlFragment, System::Xml::XmlNodeType fragType, System::Xml::XmlParserContext ^ context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xmlFragment" Type="System.IO.Stream" />
        <Parameter Name="fragType" Type="System.Xml.XmlNodeType" />
        <Parameter Name="context" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="xmlFragment">Поток, содержащий анализируемый фрагмент XML.</param>
        <param name="fragType">Тип <see cref="T:System.Xml.XmlNodeType" /> фрагмента XML. Также определяет содержимое фрагмента. (См. таблицу, приведенную ниже.)</param>
        <param name="context">Класс <see cref="T:System.Xml.XmlParserContext" />, в котором анализируется <c>xmlFragment</c>. Это включает в себя используемый класс <see cref="T:System.Xml.XmlNameTable" />, кодировку, область пространства имен, текущая область <c>xml:lang</c> и <c>xml:space</c>.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xml.XmlTextReader" /> с указанными потоком, <see cref="T:System.Xml.XmlNodeType" /> и <see cref="T:System.Xml.XmlParserContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Этот конструктор анализирует заданную строку как фрагмент XML. Если фрагмент XML — элемент или атрибут, можно обойти правила верхнего уровня для XML-документы правильного формата.  
  
 В следующей таблице перечислены допустимые значения для `fragType`.  
  
|Тип узла XML|Фрагмент может содержать|  
|-----------------|--------------------------|  
|`Element`|Любое допустимое содержимое элемента (например, любое сочетание элементов, комментарии, инструкции по обработке, разделы CDATA, текст и ссылки на сущности).<br /><br /> Также можно передавать XML-декларацию. Это позволяет указать кодировку XML-фрагмент, вместо того установить его на <xref:System.Xml.XmlParserContext> объекта.|  
|`Attribute`|Значение атрибута (часть в кавычках).|  
|`Document`|Содержимое всего XML-документа. Это обеспечивает правила на уровне документа.|  
  
 Средство чтения использует следующие, чтобы определить кодировку потока.  
  
1.  Проверяет <xref:System.Xml.XmlParserContext.Encoding%2A?displayProperty=nameWithType> свойство, чтобы определить кодировку.  
  
2.  Если `Encoding` свойство `null`, средство чтения проверяет метку порядка байтов в начале потока.  
  
3.  Если `Encoding` свойство `null`и найти метка порядка байтов отсутствуют, средство чтения используется кодировка UTF-8.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="fragType" /> не является элементом, атрибутом и документом <see langword="XmlNodeType" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="xmlFragment" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url, System.IO.Stream input, System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url, class System.IO.Stream input, class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.IO.Stream,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String, input As Stream, nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url, System::IO::Stream ^ input, System::Xml::XmlNameTable ^ nt);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="url">URL-адрес, используемый для разрешения внешних ресурсов. Для свойства <see cref="P:System.Xml.XmlTextReader.BaseURI" /> задано это значение. Если значение <c>url</c> равно <see langword="null" />, то <see langword="BaseURI" /> задается значение <see langword="String.Empty" />.</param>
        <param name="input">Поток, содержащий считываемые XML-данные.</param>
        <param name="nt">Используемый <see langword="XmlNameTable" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xml.XmlTextReader" /> с указанными URL-адресом, потоком и <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Параметру <paramref name="input" /> или <paramref name="nt" /> задано значение <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url, System.IO.TextReader input, System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url, class System.IO.TextReader input, class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.IO.TextReader,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String, input As TextReader, nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url, System::IO::TextReader ^ input, System::Xml::XmlNameTable ^ nt);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="url">URL-адрес, используемый для разрешения внешних ресурсов. Для свойства <see cref="P:System.Xml.XmlTextReader.BaseURI" /> задано это значение. Если значение <c>url</c> равно <see langword="null" />, то <see langword="BaseURI" /> задается значение <see langword="String.Empty" />.</param>
        <param name="input">
          <see langword="TextReader" />, содержащий считываемые XML-данные.</param>
        <param name="nt">Используемый <see langword="XmlNameTable" />.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xml.XmlTextReader" /> с указанным URL-адресом, <see cref="T:System.IO.TextReader" /> и <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Предполагается, что для `TextReader` задана верная кодировка. Используется клиентами, которые уже прочитали некоторые вещи из потока в сценарии составного MIME.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение <paramref name="nt" /> равно <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string xmlFragment, System.Xml.XmlNodeType fragType, System.Xml.XmlParserContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string xmlFragment, valuetype System.Xml.XmlNodeType fragType, class System.Xml.XmlParserContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.Xml.XmlNodeType,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xmlFragment As String, fragType As XmlNodeType, context As XmlParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ xmlFragment, System::Xml::XmlNodeType fragType, System::Xml::XmlParserContext ^ context);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xmlFragment" Type="System.String" />
        <Parameter Name="fragType" Type="System.Xml.XmlNodeType" />
        <Parameter Name="context" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="xmlFragment">Строка, содержащая анализируемый фрагмент XML.</param>
        <param name="fragType">Тип <see cref="T:System.Xml.XmlNodeType" /> фрагмента XML. Также определяет содержимое строки фрагмента. (См. таблицу, приведенную ниже.)</param>
        <param name="context">Класс <see cref="T:System.Xml.XmlParserContext" />, в котором анализируется <c>xmlFragment</c>. Это включает в себя используемый класс <see cref="T:System.Xml.XmlNameTable" />, кодировку, область пространства имен, текущая область <c>xml:lang</c> и <c>xml:space</c>.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Xml.XmlTextReader" /> с указанной строкой, <see cref="T:System.Xml.XmlNodeType" /> и <see cref="T:System.Xml.XmlParserContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Этот конструктор анализирует заданную строку как фрагмент XML. Если фрагмент XML — элемент или атрибут, можно обойти правила верхнего уровня для XML-документы правильного формата. Этот конструктор может обрабатывать строки, возвращаемые из <xref:System.Xml.XmlReader.ReadInnerXml%2A>.  
  
 В следующей таблице перечислены допустимые значения для `fragType` и как средство чтения анализирует различных типов узлов.  
  
|Тип узла XML|Фрагмент может содержать|  
|-----------------|--------------------------|  
|Элемент|Любое допустимое содержимое элемента (например, любое сочетание элементов, комментарии, инструкции по обработке, разделы CDATA, текст и ссылки на сущности).<br /><br /> Также можно передавать XML-декларацию. Это позволяет указать кодировку XML-фрагмент, вместо того установить его на <xref:System.Xml.XmlParserContext> объекта.|  
|Атрибут|Значение атрибута (часть в кавычках).|  
|Document|Содержимое всего XML-документа. Это обеспечивает правила на уровне документа.|  
  
   
  
## Examples  
 В следующем примере анализируется фрагмент XML. Она использует `XmlParserContext` и его <xref:System.Xml.XmlNamespaceManager> для обработки разрешения пространства имен.  
  
 [!code-cpp[XmlTextReader.Cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.Cctor/CPP/readfrag.cpp#1)]
 [!code-csharp[XmlTextReader.Cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.Cctor/CS/readfrag.cs#1)]
 [!code-vb[XmlTextReader.Cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.Cctor/VB/readfrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="fragType" /> не является <see langword="Element" />, <see langword="Attribute" /> или <see langword="Document" /><see langword="XmlNodeType" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="xmlFragment" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlParserContext" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="AttributeCount">
      <MemberSignature Language="C#" Value="public override int AttributeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AttributeCount" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.AttributeCount" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AttributeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int AttributeCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает количество атрибутов текущего узла.</summary>
        <value>Количество атрибутов текущего узла.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это свойство применимо к `Element`, `DocumentType` и `XmlDeclaration` только узлы. (Другие типы узлов не имеют атрибутов).  
  
   
  
## Examples  
 Следующий пример отображает все атрибуты на текущем узле.  
  
 [!code-cpp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public override string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.BaseURI" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BaseURI { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает базовый URI текущего узла.</summary>
        <value>Базовый URI текущего узла.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Сетевой XML-документ состоит из фрагментов данных, объединяемых с помощью различных механизмов включения стандарта W3C и поэтому содержит узлы, полученные из различных мест. Примером этого являются объекты, но это не ограничивается только DTD. Базовый URI указывает происхождения этих узлов. Если имеется базовый URI для возвращаемых узлов отсутствует (например, они были извлечены из строки в памяти), `String.Empty` возвращается.  
  
   
  
## Examples  
 В следующем примере отображается базовый URI для каждого узла.  
  
 [!code-cpp[Classic WebData XmlTextReader.BaseURI Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.BaseURI Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.BaseURI Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.BaseURI Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.BaseURI Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.BaseURI Example/VB/source.vb#1)]  
  
 В примере используется файл `baseuri.xml`, в качестве входных данных.  
  
 [!code-xml[Classic WebData XmlTextReader.BaseURI Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.BaseURI Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="CanReadBinaryContent">
      <MemberSignature Language="C#" Value="public override bool CanReadBinaryContent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadBinaryContent" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.CanReadBinaryContent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanReadBinaryContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadBinaryContent { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, реализует ли объект <see cref="T:System.Xml.XmlTextReader" /> методы чтения двоичного содержимого.</summary>
        <value>
          Значение <see langword="true" />, если реализуются методы чтения двоичного содержимого; в противном случае — <see langword="false" />. Класс <see cref="T:System.Xml.XmlTextReader" /> всегда возвращает значение <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Используются следующие методы чтения двоичного содержимого <xref:System.Xml.XmlTextReader.ReadContentAsBase64%2A>, <xref:System.Xml.XmlTextReader.ReadContentAsBinHex%2A>, <xref:System.Xml.XmlTextReader.ReadElementContentAsBase64%2A>, и <xref:System.Xml.XmlTextReader.ReadElementContentAsBinHex%2A> методы.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="CanReadValueChunk">
      <MemberSignature Language="C#" Value="public override bool CanReadValueChunk { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadValueChunk" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.CanReadValueChunk" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanReadValueChunk As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadValueChunk { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, реализует ли объект <see cref="T:System.Xml.XmlTextReader" /> метод <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />.</summary>
        <value>
          Значение <see langword="true" />, если объект <see cref="T:System.Xml.XmlTextReader" /> реализует метод <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />; в противном случае — <see langword="false" />. Класс <see cref="T:System.Xml.XmlTextReader" /> всегда возвращает значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 <xref:System.Xml.XmlTextReader> Вызывает <xref:System.NotSupportedException> Если <xref:System.Xml.XmlReader.ReadValueChunk%2A> вызывается метод.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="CanResolveEntity">
      <MemberSignature Language="C#" Value="public override bool CanResolveEntity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanResolveEntity" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.CanResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanResolveEntity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanResolveEntity { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, определяющее, способно ли данное средство чтения выполнять синтаксический анализ и разрешение сущностей.</summary>
        <value>
          Значение <see langword="true" />, если средство чтения позволяет анализировать и разрешать сущности; в противном случае — <see langword="false" />. Класс <see langword="XmlTextReader" /> всегда возвращает значение <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это изменение в [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] выпуска. В предыдущих версиях `XmlTextReader` класса не может разрешить сущности и `CanResolveEntity` всегда возвращается `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Изменяет значение свойства <see cref="P:System.Xml.XmlReader.ReadState" /> на <see langword="Closed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Этот метод также освобождает все ресурсы, используемые при чтении. Если средство чтения создано с помощью потока, этот метод также вызывает `Close` базового потока.  
  
 Если `Close` уже был вызван, никакие действия не выполняются.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Depth">
      <MemberSignature Language="C#" Value="public override int Depth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Depth" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Depth" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Depth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Depth { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает глубину текущего узла в XML-документе.</summary>
        <value>Глубина текущего узла в XML-документе.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
   
  
## Examples  
 В следующем примере отображается каждый узел, включая его глубину, номер строки и позиции строки.  
  
 [!code-cpp[XmlTextReader.LineNum#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.LineNum/CPP/readlinenum.cpp#1)]
 [!code-csharp[XmlTextReader.LineNum#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.LineNum/CS/readlinenum.cs#1)]
 [!code-vb[XmlTextReader.LineNum#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.LineNum/VB/readlinenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="DtdProcessing">
      <MemberSignature Language="C#" Value="public System.Xml.DtdProcessing DtdProcessing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.DtdProcessing DtdProcessing" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.DtdProcessing" />
      <MemberSignature Language="VB.NET" Value="Public Property DtdProcessing As DtdProcessing" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::DtdProcessing DtdProcessing { System::Xml::DtdProcessing get(); void set(System::Xml::DtdProcessing value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.DtdProcessing</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает перечисление <see cref="T:System.Xml.DtdProcessing" />.</summary>
        <value>Перечисление <see cref="T:System.Xml.DtdProcessing" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.DtdProcessing> Перечисление содержит <xref:System.Xml.DtdProcessing.Prohibit>, <xref:System.Xml.DtdProcessing.Ignore>, и <xref:System.Xml.DtdProcessing.Parse> перечислителей. <xref:System.Xml.DtdProcessing.Parse> значение по умолчанию. <xref:System.Xml.XmlTextReader.DtdProcessing%2A> Свойство заменяет `ProhibitDTD` свойство и добавляет возможность пропуска элемент DOCTYPE.  
  
> [!IMPORTANT]
>  Если <xref:System.Xml.XmlTextReader.DtdProcessing%2A> свойству <xref:System.Xml.DtdProcessing.Ignore?displayProperty=nameWithType>, <xref:System.Xml.XmlTextReader> не сообщают, что определения DTD. Это означает, что DTD и DOCTYPE будут потеряны при выводе.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Encoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding Encoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding Encoding" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Encoding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Encoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ Encoding { System::Text::Encoding ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает кодировку документа.</summary>
        <value>Значение кодировки. Если атрибут кодировки и метка порядка байтов отсутствуют, по умолчанию используется кодировка UTF-8.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Поскольку <xref:System.Xml.XmlTextReader> использует <xref:System.Text.Encoding?displayProperty=nameWithType> класса `XmlTextReader` также поддерживают все кодировки, поддерживаемые этим классом. Исключением из этого является любая кодировка, например UTF-7 и EBCDIC, которая сопоставляет `<?xml` последовательности для различных байтовых значений, чем UTF-8.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EntityHandling">
      <MemberSignature Language="C#" Value="public System.Xml.EntityHandling EntityHandling { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.EntityHandling EntityHandling" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.EntityHandling" />
      <MemberSignature Language="VB.NET" Value="Public Property EntityHandling As EntityHandling" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::EntityHandling EntityHandling { System::Xml::EntityHandling get(); void set(System::Xml::EntityHandling value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.EntityHandling</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее способ обработки сущностей средством чтения.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Xml.EntityHandling" />. Если <see langword="EntityHandling" /> не задан, по умолчанию для него используется значение <see langword="EntityHandling.ExpandCharEntities" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это свойство можно изменить на лету и вступит в силу после следующего <xref:System.Xml.XmlTextReader.Read%2A> вызова.  
  
 Когда `EntityHandling` равно `ExpandCharEntities`, значения атрибутов нормализуются лишь частично. Средство чтения нормализует каждый отдельный текстовый узел независимо от содержимого соседних узлов.  
  
 Для демонстрации разницы между сущностью режимами обработки, рассмотрим следующий XML-код:  
  
```  
<!DOCTYPE doc [<!ENTITY num "123">]>  
    <doc> &#65; &num; </doc>  
```  
  
 Когда `EntityHandling` равно `ExpandEntities` узел элемента «doc» содержит один текстовый узел с расширенным текстом сущности:  
  
|Глубина|Тип узла|name|Значение|  
|-----------|---------------|----------|-----------|  
|1|`Text`||A 123|  
  
 Когда `EntityHandling` равно `ExpandCharEntites`, и <xref:System.Xml.XmlTextReader.WhitespaceHandling%2A> задано значение `Significant` или `All`, элемент «doc» расширяет сущность знака и возвращает основную сущность в виде узла:  
  
|Глубина|Тип узла|name|Значение|  
|-----------|---------------|----------|-----------|  
|1|`Text`||А|  
|1|`EntityReference`|num||  
|1|`SignificantWhitespace`|||  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public override bool EOF { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EOF" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.EOF" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property EOF As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EOF { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, определяющее, позиционировано ли средство чтения в конец потока.</summary>
        <value>
          Значение <see langword="true" />, если средство чтения установлено в конец потока; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает значение атрибута.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public override string GetAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.GetAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetAttribute (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetAttribute(int i);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Индекс атрибута. Индексация начинается с нуля. (Индекс первого атрибута равен нулю.)</param>
        <summary>Возвращает значение атрибута по заданному индексу.</summary>
        <returns>Значение указанного атрибута.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Этот метод не изменяет позицию средства чтения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="i" /> меньше 0 или больше или равен <see cref="P:System.Xml.XmlTextReader.AttributeCount" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public override string GetAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.GetAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetAttribute (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetAttribute(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Полное имя атрибута.</param>
        <summary>Возвращает значение атрибута с указанным именем.</summary>
        <returns>Значение указанного атрибута. Если атрибут не найден, возвращается значение <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Этот метод не изменяет позицию средства чтения.  
  
 Если средство чтения расположено на `DocumentType` узел, этот метод можно использовать для получения констант PUBLIC и системы, например, `reader.GetAttribute("PUBLIC")`  
  
   
  
## Examples  
 Следующий пример возвращает значение атрибута ISBN.  
  
 [!code-cpp[Classic WebData XmlTextReader.GetAttribute1 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.GetAttribute1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.GetAttribute1 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.GetAttribute1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.GetAttribute1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.GetAttribute1 Example/VB/source.vb#1)]  
  
 В примере используется файл `attrs.xml`, в качестве входных данных.  
  
 [!code-xml[Classic WebData XmlTextReader.GetAttribute1 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.GetAttribute1 Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public override string GetAttribute (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetAttribute(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.GetAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetAttribute (localName As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetAttribute(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Локальное имя атрибута.</param>
        <param name="namespaceURI">Универсальный код ресурса (URI) пространства имен атрибута.</param>
        <summary>Возвращает значение атрибута с указанным локальным именем и универсальным кодом ресурса (URI) пространства имен.</summary>
        <returns>Значение указанного атрибута. Если атрибут не найден, возвращается значение <see langword="null" />. Этот метод не изменяет позицию средства чтения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Следующий код XML содержит атрибут в определенном пространстве имен:  
  
```xml  
<test xmlns:dt="urn:datatypes" dt:type="int"/>  
```  
  
 Для поиска `dt:type` атрибут, используя один (префикс и локальное имя) или два аргумента (локальное имя и URI пространства имен):  
  
```csharp  
String dt = reader.GetAttribute("dt:type");  
String dt2 = reader.GetAttribute("type","urn:datatypes");  
```  
  
 Для уточняющего запроса `xmlns:dt` атрибут, используйте один из следующих аргументов:  
  
```csharp  
String dt3 = reader.GetAttribute("xmlns:dt");  
String dt4 = reader.GetAttribute("dt",http://www.w3.org/2000/xmlns/);  
```  
  
 Можно также получить эти сведения с помощью <xref:System.Xml.XmlTextReader.Prefix%2A> свойство.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="GetNamespacesInScope">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,string&gt; GetNamespacesInScope (System.Xml.XmlNamespaceScope scope);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IDictionary`2&lt;string, string&gt; GetNamespacesInScope(valuetype System.Xml.XmlNamespaceScope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.GetNamespacesInScope(System.Xml.XmlNamespaceScope)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNamespacesInScope (scope As XmlNamespaceScope) As IDictionary(Of String, String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ GetNamespacesInScope(System::Xml::XmlNamespaceScope scope);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(System.Xml.XmlNamespaceScope)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Xml.XmlNamespaceScope" />
      </Parameters>
      <Docs>
        <param name="scope">С помощью значения <see cref="T:System.Xml.XmlNamespaceScope" /> указывается тип узлов пространства имен, которые следует возвратить.</param>
        <summary>Возвращает коллекцию, содержащую все пространства имен, которые в настоящий момент находятся в области видимости.</summary>
        <returns>Объект <see cref="T:System.Collections.IDictionary" />, содержащий все текущие пространства имен в области. Если средство чтения не позиционировано на какой-либо элемент, возвращается пустой словарь (без пространств имен).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Словарь состоит из коллекции имен пространств имен, отсортированных по префиксу. Он может использоваться для перечисления пространств имен в области видимости. Словарь является отключенной копией списка пространств имен средства чтения. Он остается неизменным при изменения текущего списка пространств имен в области видимости позиция средства чтения.  
  
 В следующей таблице описаны как <xref:System.Xml.XmlNamespaceScope> влияет на значение перечисления, будет ли или не по умолчанию и встроенные пространства имен возвращаются с <xref:System.Xml.XmlTextReader.GetNamespacesInScope%2A>.  
  
|Значение XmlNamespaceScope|xmlns: XML|xmlns:xmlns|xmlns =»»|  
|-----------------------------|---------------|-----------------|---------------|  
|`All`|да|Нет|Нет|  
|`ExcludeXml`|Нет|Нет|Нет|  
|`Local`|Нет|Нет|да|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="GetRemainder">
      <MemberSignature Language="C#" Value="public System.IO.TextReader GetRemainder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.TextReader GetRemainder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.GetRemainder" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRemainder () As TextReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::TextReader ^ GetRemainder();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает оставшуюся часть XML-кода, находящегося в буфере.</summary>
        <returns>Объект <see cref="T:System.IO.TextReader" />, содержащий оставшуюся часть XML-кода, находящегося в буфере.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Поскольку <xref:System.Xml.XmlTextReader> буферизованной `Read`, должен уметь получения остатка от неиспользуемую буфера, чтобы данные не теряются. Это позволяет протоколов (например, составное MIME) паковать XML в одном потоке с другими данными.  
  
 После вызова этого метода <xref:System.Xml.XmlTextReader.EOF%2A> равно `true`.  
  
   
  
## Examples  
 В следующем примере считывается первая часть XML-документ и затем использует `GetRemainder` для завершения чтения документа с помощью второго средства чтения.  
  
 [!code-cpp[Classic WebData XmlTextReader.GetRemainder Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.GetRemainder Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.GetRemainder Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.GetRemainder Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.GetRemainder Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.GetRemainder Example/VB/source.vb#1)]  
  
 В примере входного файла `tworeads.xml`.  
  
 [!code-xml[Classic WebData XmlTextReader.GetRemainder Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.GetRemainder Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="HasLineInfo">
      <MemberSignature Language="C#" Value="public bool HasLineInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HasLineInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.HasLineInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function HasLineInfo () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool HasLineInfo();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlLineInfo.HasLineInfo</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, определяющее возможность возвращения классом сведений о строке.</summary>
        <returns>
          Значение <see langword="true" />, если класс может возвратить сведения о строке, в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="HasValue">
      <MemberSignature Language="C#" Value="public override bool HasValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValue" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.HasValue" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property HasValue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasValue { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, определяющие наличие у текущего узла свойства <see cref="P:System.Xml.XmlTextReader.Value" />, значение которого отличается от <see langword="String.Empty" />.</summary>
        <value>
          Значение <see langword="true" />, если узел, на котором расположено средство чтения, может иметь значение <see langword="Value" />; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 В следующей таблице представлен список возвращаемых типов узлов со значениями.  
  
|Тип узла|Значение|  
|---------------|-----------|  
|`Attribute`|Значение атрибута.|  
|`CDATA`|Содержимое раздела CDATA.|  
|`Comment`|Содержимое комментария.|  
|`DocumentType`|Внутреннее подмножество.|  
|`ProcessingInstruction`|Все содержимое, за исключением цели.|  
|`SignificantWhitespace`|Пустое пространство в разметке модели со смешанным содержимым.|  
|`Text`|Содержимое текстового узла.|  
|`Whitespace`|Пробелы между разметкой.|  
|`XmlDeclaration`|Содержимое декларации.|  
  
   
  
## Examples  
 Следующий пример отображает значение для каждого узла, который может иметь значение.  
  
 [!code-cpp[Classic WebData XmlTextReader.HasValue Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.HasValue Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.HasValue Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.HasValue Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.HasValue Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.HasValue Example/VB/source.vb#1)]  
  
 В примере используется файл `book1.xml`, в качестве входных данных.  
  
 [!code-xml[Classic WebData XmlTextReader.HasValue Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.HasValue Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="IsDefault">
      <MemberSignature Language="C#" Value="public override bool IsDefault { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefault" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.IsDefault" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDefault { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, показывающее, является ли текущий узел атрибутом, который был создан из значения по умолчанию, определенного в определении DTD или в схеме.</summary>
        <value>Данное свойство всегда возвращает значение <see langword="false" />. (<see cref="T:System.Xml.XmlTextReader" /> не расширяет атрибуты по умолчанию).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это свойство применимо только к узлам атрибутов.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="IsEmptyElement">
      <MemberSignature Language="C#" Value="public override bool IsEmptyElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmptyElement" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.IsEmptyElement" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEmptyElement As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEmptyElement { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, определяющее, является ли текущий узел пустым элементом (например, <c>&lt;MyElement/&gt;</c>).</summary>
        <value>
          <see langword="true" /> Если текущий узел является элементом (<see cref="P:System.Xml.XmlTextReader.NodeType" /> равняется <see langword="XmlNodeType.Element" />), заканчивается <c> / &gt; </c>; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это свойство позволяет определить разницу между:  
  
 `<item num="123"/>` (`IsEmptyElement` — `true`).  
  
 `<item num="123">` (`IsEmptyElement` — `false`, несмотря на то, что содержимое элемента является пустым).  
  
 Соответствующий `EndElement` узел для пустых элементов не создается.  
  
 `IsEmptyElement` просто сообщает, является ли элемент в исходном документе конечный тег элемента.  
  
   
  
## Examples  
 Следующий пример отображает текстовое содержимое каждого элемента.  
  
 [!code-cpp[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/VB/source.vb#1)]  
  
 В примере используется файл `elems.xml`, в качестве входных данных.  
  
 [!code-xml[Classic WebData XmlReader.IsStartElement Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="LineNumber">
      <MemberSignature Language="C#" Value="public int LineNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LineNumber" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.LineNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LineNumber As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LineNumber { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Xml.IXmlLineInfo.LineNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает номер текущей строки.</summary>
        <value>Текущий номер строки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это свойство чаще всего используется для отчетов об ошибках, но можно вызвать в любое время. Начальное значение для этого свойства равно `1`.  
  
 В сочетании с <xref:System.Xml.XmlTextReader.LinePosition%2A>, значение `1,1` указывает на начало документа.  
  
   
  
## Examples  
 В следующем примере отображается каждый узел, включая его глубину, номер строки и позиции строки.  
  
 [!code-cpp[XmlTextReader.LineNum#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.LineNum/CPP/readlinenum.cpp#1)]
 [!code-csharp[XmlTextReader.LineNum#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.LineNum/CS/readlinenum.cs#1)]
 [!code-vb[XmlTextReader.LineNum#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.LineNum/VB/readlinenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="LinePosition">
      <MemberSignature Language="C#" Value="public int LinePosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LinePosition" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.LinePosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LinePosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LinePosition { int get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Xml.IXmlLineInfo.LinePosition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает позицию в текущей строке.</summary>
        <value>Позиция в текущей строке.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это свойство чаще всего используется для отчетов об ошибках, но можно вызвать в любое время. Начальным значением свойства является `1`.  
  
 Указанное положение — первый символ текста в разметке.  
  
```  
<root>  
abc<tag/>  
</root>  
```  
  
 В первой строке текста XML `LinePosition` из `2` соответствует символу `r`; во второй строке `LinePosition` из `5` соответствует символу `t`; а в третьей строке `LinePosition` из `3` соответствует символу `r`.  
  
 В сочетании с <xref:System.Xml.XmlTextReader.LineNumber%2A>, значение `1,1` указывает на начало документа.  
  
   
  
## Examples  
 В следующем примере отображается каждый узел, включая его глубину, номер строки и позиции строки.  
  
 [!code-cpp[XmlTextReader.LineNum#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.LineNum/CPP/readlinenum.cpp#1)]
 [!code-csharp[XmlTextReader.LineNum#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.LineNum/CS/readlinenum.cs#1)]
 [!code-vb[XmlTextReader.LineNum#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.LineNum/VB/readlinenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public override string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает локальное имя текущего узла.</summary>
        <value>Имя текущего узла с удаленным префиксом. Например <see langword="LocalName" /> — <see langword="book" /> для элемента <c> &lt;bk: book&gt;</c>.  
  
 Для безымянных типов узлов (например, <see langword="Text" />, <see langword="Comment" /> и т. д.) данное свойство возвращает <see langword="String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
   
  
## Examples  
 В следующем примере отображается локальное имя каждого узла и, если они существуют, префикс и URI пространства имен.  
  
 [!code-cpp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/VB/source.vb#1)]  
  
 В примере используется файл `book2.xml`, в качестве входных данных.  
  
 [!code-xml[Classic WebData XmlTextReader.LocalName Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="LookupNamespace">
      <MemberSignature Language="C#" Value="public override string LookupNamespace (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string LookupNamespace(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.LookupNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function LookupNamespace (prefix As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ LookupNamespace(System::String ^ prefix);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.LookupNamespace(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Префикс, для которого требуется разрешить URI пространства имен. Чтобы сопоставить пространство имен по умолчанию, необходимо передать пустую строку. Эту строку не следует атомизировать.</param>
        <summary>Разрешает префикс пространства имен в области видимости текущего элемента.</summary>
        <returns>URI пространства имен, которое отображает префикс, или значение <see langword="null" />, если соответствующий префикс не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 В следующем XML, если средство чтения расположено на `href` атрибут префикс `a` разрешается путем вызова `reader.LookupNamespace("a")`. Возвращаемая строка является `urn:456`.  
  
```xml  
<root xmlns:a="urn:456">  
 <item>  
 <ref href="a:b"/>  
 </item>  
</root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойству <see cref="P:System.Xml.XmlTextReader.Namespaces" /> задано значение <see langword="true" />, а свойству <paramref name="prefix" /> — <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveToAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Переходит к указанному атрибуту.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public override void MoveToAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void MoveToAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub MoveToAttribute (i As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void MoveToAttribute(int i);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">Индекс атрибута.</param>
        <summary>Переходит к атрибуту с указанным индексом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
   
  
## Examples  
 Следующий пример отображает все атрибуты на текущем узле.  
  
 [!code-cpp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="i" /> меньше 0 или больше или равен <see cref="P:System.Xml.XmlReader.AttributeCount" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public override bool MoveToAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToAttribute (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToAttribute(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Полное имя атрибута.</param>
        <summary>Переходит к атрибуту с указанным именем.</summary>
        <returns>
          Значение <see langword="true" />, если атрибут найден; в противном случае — <see langword="false" />. Если значение <see langword="false" />, позиция средства чтения не изменяется.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 После вызова метода `MoveToAttribute`, <xref:System.Xml.XmlTextReader.Name%2A>, <xref:System.Xml.XmlTextReader.NamespaceURI%2A>, и <xref:System.Xml.XmlTextReader.Prefix%2A> свойства отражает свойства этого атрибута.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public override bool MoveToAttribute (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToAttribute(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToAttribute (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToAttribute(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">Локальное имя атрибута.</param>
        <param name="namespaceURI">Универсальный код ресурса (URI) пространства имен атрибута.</param>
        <summary>Переходит к атрибуту с указанным локальным именем и URI пространства имен.</summary>
        <returns>
          Значение <see langword="true" />, если атрибут найден; в противном случае — <see langword="false" />. Если значение <see langword="false" />, позиция средства чтения не изменяется.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 После вызова метода `MoveToAttribute`, <xref:System.Xml.XmlTextReader.Name%2A>, <xref:System.Xml.XmlTextReader.NamespaceURI%2A>, и <xref:System.Xml.XmlTextReader.Prefix%2A> свойства отражает свойства этого атрибута.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="MoveToElement">
      <MemberSignature Language="C#" Value="public override bool MoveToElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToElement" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToElement();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Переходит к элементу, содержащему текущий узел атрибута.</summary>
        <returns>
          Значение <see langword="true" />, если средство чтения находится на атрибуте (средство чтения перемещается к элементу с этим атрибутом); в противном случае — <see langword="false" /> (позиция средства чтения не изменяется).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Используйте этот метод для возврата элемента после просмотра его атрибутов. Этот метод перемещает средство чтения к одному из следующих типов узлов: `Element`, `DocumentType`, или `XmlDeclaration`.  
  
   
  
## Examples  
 Следующий пример отображает все атрибуты на текущем узле.  
  
 [!code-cpp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="MoveToFirstAttribute">
      <MemberSignature Language="C#" Value="public override bool MoveToFirstAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToFirstAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToFirstAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToFirstAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToFirstAttribute();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Переходит к первому атрибуту.</summary>
        <returns>
          Значение <see langword="true" />, если атрибут существует (средство чтения перемещается к первому атрибуту); в противном случае — <see langword="false" /> (позиция средства чтения не изменяется).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
   
  
## Examples  
 Следующий пример возвращает значение первого атрибута корневого узла.  
  
 [!code-cpp[Classic WebData XmlTextReader.MoveToFirstAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToFirstAttribute Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.MoveToFirstAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToFirstAttribute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.MoveToFirstAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToFirstAttribute Example/VB/source.vb#1)]  
  
 В примере используется файл `attrs.xml`, в качестве входных данных.  
  
 [!code-xml[Classic WebData XmlTextReader.MoveToFirstAttribute Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToFirstAttribute Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="MoveToNextAttribute">
      <MemberSignature Language="C#" Value="public override bool MoveToNextAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToNextAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToNextAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToNextAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToNextAttribute();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Переходит к следующему атрибуту.</summary>
        <returns>
          Значение <see langword="true" />, если присутствует следующий атрибут; значение <see langword="false" />, если другие атрибуты отсутствуют.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Если текущий узел является узлом элемента, этот метод эквивалентен <xref:System.Xml.XmlTextReader.MoveToFirstAttribute%2A>. Если `MoveToNextAttribute` возвращает `true`, средство чтения перемещается к следующему атрибуту; в противном случае позиция средства чтения не изменяется.  
  
   
  
## Examples  
 Следующий пример отображает все атрибуты на текущем узле.  
  
 [!code-cpp[Classic WebData XmlReader.HasAttributes Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.HasAttributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.HasAttributes Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.HasAttributes Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.HasAttributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.HasAttributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает полное имя текущего узла.</summary>
        <value>Полное имя текущего узла. Например <see langword="Name" /> — <see langword="bk:book" /> для элемента <c> &lt;bk: book&gt;</c>.  
  
 Возвращаемое имя зависит от значения свойства <see cref="P:System.Xml.XmlTextReader.NodeType" /> узла. Значения возвращаются для представленных ниже типов узлов. Для других типов узлов возвращается пустая строка.  
  
 <list type="table"><listheader><term> Тип узла  
  
 </term><description> Имя  
  
 </description></listheader><item><term><see langword="Attribute" /></term><description> Имя атрибута.  
  
 </description></item><item><term><see langword="DocumentType" /></term><description> Имя типа документа.  
  
 </description></item><item><term><see langword="Element" /></term><description> Имя тега.  
  
 </description></item><item><term><see langword="EntityReference" /></term><description> Имя ссылки на сущность.  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description> Цель инструкции по обработке.  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description> Строковый литерал <see langword="xml" />.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
   
  
## Examples  
 В следующем примере считывает XML-файла и отображение каждого из узлов.  
  
 [!code-cpp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/VB/source.vb#1)]  
  
 В образце используется файл `items.xml`.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Namespaces">
      <MemberSignature Language="C#" Value="public bool Namespaces { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Namespaces" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Namespaces" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespaces As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Namespaces { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, поддерживаются ли пространства имен.</summary>
        <value>
          Значение <see langword="true" /> — поддержка осуществляется; в противном случае — <see langword="false" />. Значение по умолчанию: <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это свойство определяет, поддерживает ли средство чтения пространства имен W3C в рекомендации XML, расположенной по www.w3.org/TR/REC-xml-names.  
  
 `Namespaces` Свойство нельзя изменить после операции чтения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Установка значения этого свойства после того, как выполнена операция чтения (значение <see cref="P:System.Xml.XmlTextReader.ReadState" /> не равно <see langword="ReadState.Initial" />).</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="NamespaceURI">
      <MemberSignature Language="C#" Value="public override string NamespaceURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NamespaceURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.NamespaceURI" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NamespaceURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ NamespaceURI { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает URI пространства имен (определенное в спецификации W3C Namespace) узла, на который позиционировано средство чтения.</summary>
        <value>URI пространства имен текущего узла; в противном случае — пустая строка.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это свойство применимо к `Element` и `Attribute` только узлы.  
  
   
  
## Examples  
 В следующем примере отображается локальное имя каждого узла и, если они существуют, префикс и URI пространства имен.  
  
 [!code-cpp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/VB/source.vb#1)]  
  
 В примере используется файл `book2.xml`, в качестве входных данных.  
  
 [!code-xml[Classic WebData XmlTextReader.LocalName Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.NameTable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NameTable As XmlNameTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNameTable ^ NameTable { System::Xml::XmlNameTable ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает класс <see cref="T:System.Xml.XmlNameTable" />, связанный с данной реализацией.</summary>
        <value>
          <see langword="XmlNameTable" />, позволяющий получать в узле разделенную версию строки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Возвращаются все имена узлов и атрибутов из <xref:System.Xml.XmlTextReader> , разделены с помощью `NameTable`. Если то же имя возвращается несколько раз (например, `Customer`), затем же `String` объект возвращается для этого имени. Это позволяет писать эффективный код, выполняющий сравнения строк, вместо сравнения строк дорогих объектов.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNameTable" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает тип текущего узла.</summary>
        <value>Одно из значений <see cref="T:System.Xml.XmlNodeType" />, предоставляющее тип текущего узла.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это свойство не возвращает следующие `XmlNodeType` типов: `Document`, `DocumentFragment`, `Entity`, `EndEntity`, или `Notation`.  
  
   
  
## Examples  
 В следующем примере считывает XML-файла и отображение каждого из узлов.  
  
 [!code-cpp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/VB/source.vb#1)]  
  
 В образце используется файл `items.xml`.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Normalization">
      <MemberSignature Language="C#" Value="public bool Normalization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Normalization" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Normalization" />
      <MemberSignature Language="VB.NET" Value="Public Property Normalization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Normalization { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее необходимость нормализации символов-разделителей и значений атрибутов.</summary>
        <value>
          Значение <see langword="true" /> для нормализации; в противном случае — <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это свойство можно изменить в любое время и вступает в силу следующая операция чтения.  
  
> [!NOTE]
>  Если <xref:System.Xml.XmlTextReader> используется для создания <xref:System.Xml.XmlValidatingReader>, для нормализации значений атрибутов, `Normalization` должно быть присвоено `true`.  
  
 Если `Normalization` имеет значение `false`, это также отключает проверку диапазона символов для числовых сущностей. В результате сущности-символы, такие как `&#0;`, разрешены.  
  
 Ниже описаны нормализация значений атрибутов.  
  
-   Для символьной ссылки символ, на который указывает ссылка, добавляется к значению атрибута.  
  
-   Для ссылки на сущность рекурсивно обрабатывается заменяемый текст этой сущности.  
  
-   Для символы пробелов (#x 20, #xD, #xA, #x 9) добавьте #x 20 к нормализованному значению. (Только один #x 20 добавляется последовательности «#xD #xA», которая является частью анализируемой внешней сущности или значение литерала entity внутренней разбора).  
  
-   Остальные символы обрабатываются путем добавления их к нормализованному значению.  
  
-   Если объявленный значение не CDATA, отменить все начальные и конечные знаки пространства (#x20) и замените последовательности пробелов (#x20) (#x20) с одним пробельным символом.  
  
 `XmlTextReader` Выполняет только атрибут или нормализации CDATA. Не выполняет нормализации конкретного DTD Если це `XmlValidatingReader`.  
  
 См. Дополнительные сведения о нормализации рекомендации W3C XML 1.0.  
  
   
  
## Examples  
 В следующем примере показано поведение средства чтения с нормализацией включен и отключении.  
  
 [!code-cpp[XmlTextReader.Normalization#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.Normalization/CPP/readnormal.cpp#1)]
 [!code-csharp[XmlTextReader.Normalization#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.Normalization/CS/readnormal.cs#1)]
 [!code-vb[XmlTextReader.Normalization#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.Normalization/VB/readnormal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Установка значения этого свойства после закрытия средства чтения (<see cref="P:System.Xml.XmlTextReader.ReadState" /> равно <see langword="ReadState.Closed" />).</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public override string Prefix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Prefix { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает префикс пространства имен, связанный с текущим узлом.</summary>
        <value>Префикс пространства имен, связанный с текущим узлом.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
   
  
## Examples  
 В следующем примере отображается локальное имя каждого узла и, если они существуют, префикс и URI пространства имен.  
  
 [!code-cpp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/VB/source.vb#1)]  
  
 В примере используется файл `book2.xml`, в качестве входных данных.  
  
 [!code-xml[Classic WebData XmlTextReader.LocalName Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ProhibitDtd">
      <MemberSignature Language="C#" Value="public bool ProhibitDtd { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ProhibitDtd" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.ProhibitDtd" />
      <MemberSignature Language="VB.NET" Value="Public Property ProhibitDtd As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ProhibitDtd { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use DtdProcessing property instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее, следует ли разрешить обработку DTD. Это свойство устарело. Взамен рекомендуется использовать <see cref="P:System.Xml.XmlTextReader.DtdProcessing" />.</summary>
        <value>
          Значение <see langword="true" /> для отключения обработки DTD; в противном случае — <see langword="false" />. Значение по умолчанию: <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Обработка DTD включена по умолчанию для обеспечения обратной совместимости. Однако если приложение не требует обработки DTD, следует отключить этот параметр. Отключение обработки DTD может быть полезным для предотвращения некоторых разновидностей атак типа «отказ в обслуживании». Если значение `true`, модуль чтения создает <xref:System.Xml.XmlException> при обнаружении содержимого DTD.  
  
 Если обработка DTD включена, необходимо знать последствия включения DTD из ненадежных источников и возможную атаку отказа в обслуживании. Используйте <xref:System.Xml.XmlSecureResolver> для ограничения ресурсов, <xref:System.Xml.XmlTextReader> доступен. Кроме того, можно создать собственное приложение, ограничивающее объем памяти и время, выделяемое на обработку XML. Например можно ограничить время ожидания в приложении ASP.NET  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="QuoteChar">
      <MemberSignature Language="C#" Value="public override char QuoteChar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char QuoteChar" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.QuoteChar" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property QuoteChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property char QuoteChar { char get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает знак кавычек, используемый для выделения значения узла атрибута.</summary>
        <value>Знак кавычек (" или ') для выделения значения узла атрибута.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это свойство применимо только к узлам атрибутов.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Read();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает следующий узел из потока.</summary>
        <returns>
          Значение <see langword="true" />, если чтение прошло успешно; значение <see langword="false" />, если отсутствуют узлы для чтения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Если средство чтения сначала создается и инициализируется, нет сведения недоступны. Необходимо вызвать метод `Read` для чтения первого узла.  
  
 Этот метод требует по крайней мере четыре байта из потока данных, чтобы начать анализ. Если возвращено менее четырех байтов и в потоке нет дополнительных данных, метод завершится с ошибкой. Если в потоке данных, метод остановит анализ до получения четвертого байта.  
  
   
  
## Examples  
 В следующем примере считывает XML-файла и отображение каждого узла.  
  
 [!code-cpp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/VB/source.vb#1)]  
  
 В образце используется файл `items.xml`.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Произошла ошибка при синтаксическом анализе XML.</exception>
        <altmember cref="T:System.Xml.EntityHandling" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ReadAttributeValue">
      <MemberSignature Language="C#" Value="public override bool ReadAttributeValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool ReadAttributeValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadAttributeValue" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadAttributeValue () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool ReadAttributeValue();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Разбирает значение атрибута в один или несколько узлов <see langword="Text" />, <see langword="EntityReference" /> или <see langword="EndEntity" />.</summary>
        <returns>
          Значение <see langword="true" />, если присутствуют возвращаемые узлы.  
  
 Значение <see langword="false" />, если средство чтения не расположено на узле атрибута при первом вызове или все значения атрибута считаны.  
  
 Пустой атрибут (например, <c>misc=""</c>) возвращает значение <see langword="true" /> с отдельным узлом, имеющим значение <see langword="String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Используйте этот метод после вызова `MoveToAttribute` прочитать текст или сущности ссылки узлы, которые составляют значение атрибута. <xref:System.Xml.XmlReader.Depth%2A> Узлов значение атрибута равно единице плюс глубина узла атрибута; оно увеличивается или уменьшается на единицу при переходах по ссылкам на основную сущность.  
  
   
  
## Examples  
 В следующем примере считывается атрибут с текстом и узлов сущностей.  
  
 [!code-cpp[XmlTextReader.ReadAttributeValue#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.ReadAttributeValue/CPP/readattrval.cpp#1)]
 [!code-csharp[XmlTextReader.ReadAttributeValue#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.ReadAttributeValue/CS/readattrval.cs#1)]
 [!code-vb[XmlTextReader.ReadAttributeValue#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.ReadAttributeValue/VB/readattrval.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ReadBase64">
      <MemberSignature Language="C#" Value="public int ReadBase64 (byte[] array, int offset, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadBase64(unsigned int8[] array, int32 offset, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadBase64 (array As Byte(), offset As Integer, len As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadBase64(cli::array &lt;System::Byte&gt; ^ array, int offset, int len);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Массив символов, выполняющий функции буфера, в который записывается текстовое содержимое.</param>
        <param name="offset">Начинающийся с нуля индекс в массиве, указывающий место, с которого метод начнет запись в буфер.</param>
        <param name="len">Число байтов для записи в буфер.</param>
        <summary>Декодирует данные из кодировки Base64 и возвращает результат в виде декодированных двоичных байтов.</summary>
        <returns>Количество байтов, записанных в буфер.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Как <xref:System.Xml.XmlTextReader.ReadChars%2A>, этот метод можно вызывать повторно для чтения больших потоков внедренного текста. Данный метод декодирует содержимое Base64 и возвращает раскодированные двоичные байты (например, встроенный Base64 закодированный в формате GIF) в буфер. См. в RFC 1521. (Вы можете получить RFC с [запроса веб-сайте](https://www.rfc-editor.org).)  
  
   
  
## Examples  
 В следующем примере считывается файл, содержащий данные Base64 и BinHex.  
  
 [!code-cpp[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/VB/source.vb#1)]  
  
 В образце используется файл `binary.xml`  
  
 [!code-xml[Classic WebData XmlTextReader.ReadBase64 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Недопустимая последовательность Base64.</exception>
        <exception cref="T:System.ArgumentNullException">Значение <paramref name="array" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="offset" /> &lt; равно 0 или <paramref name="len" /> &lt; равно 0, или <paramref name="len" /> &gt; <paramref name="array" />.Length- <paramref name="offset" />.</exception>
        <altmember cref="M:System.Xml.XmlTextWriter.WriteBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ReadBinHex">
      <MemberSignature Language="C#" Value="public int ReadBinHex (byte[] array, int offset, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadBinHex(unsigned int8[] array, int32 offset, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadBinHex (array As Byte(), offset As Integer, len As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadBinHex(cli::array &lt;System::Byte&gt; ^ array, int offset, int len);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">Массив байтов, выполняющий функции буфера, в который записываются декодированные двоичные байты.</param>
        <param name="offset">Начинающийся с нуля индекс в массиве, указывающий место, с которого метод начнет запись в буфер.</param>
        <param name="len">Число байтов для записи в буфер.</param>
        <summary>Декодирует <see langword="BinHex" /> и возвращает результат в виде декодированных двоичных байтов.</summary>
        <returns>Количество байтов, записываемых в буфер.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Как <xref:System.Xml.XmlTextReader.ReadChars%2A>, этот метод можно вызывать повторно для чтения больших потоков внедренного текста. Декодирует его `BinHex` содержимое и возвращает раскодированные двоичные байты (например, встроенный `BinHex` рисунок в формате GIF) в буфер.  
  
   
  
## Examples  
 В следующем примере считывается файл, содержащий `Base64` и `BinHex` данных.  
  
 [!code-cpp[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/VB/source.vb#1)]  
  
 В образце используется файл `binary.xml`  
  
 [!code-xml[Classic WebData XmlTextReader.ReadBase64 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Недопустимая последовательность <see langword="BinHex" />.</exception>
        <exception cref="T:System.ArgumentNullException">Значение <paramref name="array" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="offset" /> &lt; равно 0 или <paramref name="len" /> &lt; равно 0, или <paramref name="len" /> &gt; <paramref name="array" />.Length- <paramref name="offset" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ReadChars">
      <MemberSignature Language="C#" Value="public int ReadChars (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadChars(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadChars(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadChars (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadChars(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив символов, выполняющий функции буфера, в который записывается текстовое содержимое.</param>
        <param name="index">Положение в <c>buffer</c>, с которого метод начинает запись текстового содержимого.</param>
        <param name="count">Число символов, записываемых в <c>buffer</c>.</param>
        <summary>Считывает текстовое содержимое элемента в буфер символов. Этот метод предназначен для чтения больших потоков внедренного текста путем его последовательного вызова.</summary>
        <returns>Число прочитанных знаков. Если средство чтения находится не на элементе или отсутствует возвращаемый текст, это значение может быть равно <see langword="0" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это наиболее эффективный способ обработки очень больших потоков внедренного текста в XML-документа. Вместо распределения больших строковых объектов `ReadChars` возвращает содержимое текстового буфера за один раз. Этот метод предназначен для работы только с узлами элементов. Прочие типы узлов Причина `ReadChars` для возврата `0`.  
  
 В следующем XML, если модуль чтения располагается в открывающем теге `ReadChars` возвращает `test` и перемещает средство чтения после закрывающего тега.  
  
```xml  
<Item>test</Item>  
```  
  
 `ReadChars` имеет следующие функциональные возможности:  
  
-   Этот метод предназначен для работы только с узлами элементов. Прочие типы узлов Причина `ReadChars` возвращает значение 0.  
  
-   Этот метод возвращает фактическое содержимое символа. Нет не выполняется разрешение сущностей, CDATA или другой разметки. `ReadChars` Возвращает содержимое между открывающим и закрывающий тег, включая разметку.  
  
-   `ReadChars` пропускает XML-разметку, которая не является правильным. Например, при чтении следующую строку XML `<A>1<A>2</A>`, `ReadChars` возвращает `1<A>2</A>`. (Он возвращает разметку из соответствующей пары элементов и игнорирует другие.)  
  
-   Этот метод не выполняет нормализацию.  
  
-   Когда `ReadChars` достиг конца потока символов, то возвращается значение 0 и средство чтения расположено после закрывающего тега.  
  
-   Атрибут чтения методы недоступны при использовании `ReadChars`.  
  
 Например используя следующий XML-код:  
  
```xml  
<thing>  
 some text  
</thing>  
<item>  
</item>  
```  
  
 Средство чтения расположено на `<item>` элемент в конце цикла.  
  
```csharp  
if (XmlNodeType.Element == reader.NodeType && "thing" == reader.Name)  
{  
 while(0 != reader.ReadChars(buffer, 0, 1)  
 {  
 // Do something.  
 // Attribute values are not available at this point.  
 }  
}  
```  
  
   
  
## Examples  
 В следующем примере считывается в XML с помощью `ReadChars`.  
  
 [!code-cpp[Classic WebData XmlTextReader.ReadChars Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadChars Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.ReadChars Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadChars Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.ReadChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.ReadChars Example/VB/source.vb#1)]  
  
 В примере в качестве входных данных используется файл `items.xml`.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="count" /> больше, чем размер, указанный в <paramref name="buffer" /> (размер буфера — <paramref name="index" />).</exception>
        <exception cref="T:System.ArgumentNullException">Значение <paramref name="buffer" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />
          <see langword="&lt; 0" /> или <paramref name="count" /><see langword="&lt; 0" />.</exception>
        <altmember cref="M:System.Xml.XmlTextReader.ReadBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Xml.XmlTextReader.ReadBinHex(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64">
      <MemberSignature Language="C#" Value="public override int ReadContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Буфер, в который копируется полученный текст. Это значение не может быть равно <see langword="null" />.</param>
        <param name="index">Смещение в буфере, с которого следует начать копировать результат.</param>
        <param name="count">Максимальное количество копируемых в буфер байтов. Этот метод возвращает фактическое количество скопированных байтов.</param>
        <summary>Считывает содержимое и возвращает раскодированные двоичные байты <see langword="Base64" />.</summary>
        <returns>Количество байтов, записанных в буфер.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Этот метод создает поток содержимого, декодирует `Base64` содержимое и возвращает раскодированные двоичные байты (например, встроенный `Base64`-рисунок в формате GIF) в буфер. Этот метод можно вызывать повторно для чтения больших потоков внедренного текста. Дополнительные сведения см. в разделе RFC 1521 «часть MIME (Multipurpose Internet Mail Extensions) одной: механизмы для определения и описания формата тел сообщений Интернета». Вы можете получить RFC с [запроса веб-сайте](https://www.rfc-editor.org).  
  
> [!NOTE]
>  Вы не должны работать с любого из свойств чтения между вызовами <xref:System.Xml.XmlTextReader.ReadContentAsBase64%2A> метода, метод возвращает значение 0.  
  
 Этот метод имеет следующие особенности:  
  
-   <xref:System.Xml.XmlTextReader.ReadContentAsBase64%2A> Возвращает значение 0 по достижении конца потока байтов, которым проводится на. Средство чтения находится на первом узле без содержимого.  
  
-   Если указать меньшее или точное число байтов, остающихся в потоке средство чтения остается в текущей позиции.  
  
-   <xref:System.Xml.XmlTextReader.ReadContentAsBase64%2A> не поддерживается для следующих типов узлов XML: `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation`, `Entity`, `DocumentFragment`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение <paramref name="buffer" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          Метод <see cref="M:System.Xml.XmlTextReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" /> не поддерживается в текущем узле.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение индекса в буфере или сумма значений индекса и счетчика больше, чем выделенный размер буфера.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlTextReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHex">
      <MemberSignature Language="C#" Value="public override int ReadContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Буфер, в который копируется полученный текст. Это значение не может быть равно <see langword="null" />.</param>
        <param name="index">Смещение в буфере, с которого следует начать копировать результат.</param>
        <param name="count">Максимальное количество копируемых в буфер байтов. Этот метод возвращает фактическое количество скопированных байтов.</param>
        <summary>Считывает содержимое и возвращает раскодированные двоичные байты <see langword="BinHex" />.</summary>
        <returns>Количество байтов, записанных в буфер.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Этот метод создает поток содержимого, декодирует `BinHex` содержимое и возвращает раскодированные двоичные байты (например, встроенный `BinHex` рисунок в формате GIF) в буфер. Этот метод можно вызывать повторно для чтения больших потоков внедренного текста.  
  
> [!NOTE]
>  Вы не должны работать с любого из свойств чтения между вызовами <xref:System.Xml.XmlTextReader.ReadContentAsBinHex%2A> метода, метод возвращает значение 0.  
  
 Этот метод имеет следующие особенности:  
  
-   <xref:System.Xml.XmlTextReader.ReadContentAsBinHex%2A> Возвращает значение 0 по достижении конца потока байтов, которым проводится на. Средство чтения находится на первом узле без содержимого.  
  
-   Если указать меньшее или точное число байтов, остающихся в потоке средство чтения остается в текущей позиции.  
  
-   <xref:System.Xml.XmlTextReader.ReadContentAsBinHex%2A> не поддерживается для следующих типов узлов XML: `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation`, `Entity`, `DocumentFragment`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение <paramref name="buffer" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          Метод <see cref="M:System.Xml.XmlTextReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" /> не поддерживается на текущем узле.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение индекса в буфере или сумма значений индекса и счетчика больше, чем выделенный размер буфера.</exception>
        <exception cref="T:System.NotSupportedException">Реализация <see cref="T:System.Xml.XmlTextReader" /> не поддерживает данный метод.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlTextReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64">
      <MemberSignature Language="C#" Value="public override int ReadElementContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadElementContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadElementContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadElementContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Буфер, в который копируется полученный текст. Это значение не может быть равно <see langword="null" />.</param>
        <param name="index">Смещение в буфере, с которого следует начать копировать результат.</param>
        <param name="count">Максимальное количество копируемых в буфер байтов. Этот метод возвращает фактическое количество скопированных байтов.</param>
        <summary>Считывает элемент и декодирует его из кодировки Base64.</summary>
        <returns>Количество байтов, записанных в буфер.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Этот метод считывает содержимое элемента, декодирует его с помощью кодировки Base64 и возвращает раскодированные двоичные байты (например, встроенный Base64 закодированный в формате GIF) в буфер. Дополнительные сведения см. в разделе RFC 1521 «часть MIME (Multipurpose Internet Mail Extensions) одной: механизмы для определения и описания формата тел сообщений Интернета». Вы можете получить RFC с [запроса веб-сайте](https://www.rfc-editor.org).  
  
 Этот метод может считывать только элементы с простым содержимым. Элемент может содержать текст, пробелы, значимые пробелы, разделы CDATA, комментарии и инструкции по обработке. Он также может содержать ссылки на сущности, которые разворачиваются автоматически. Элемент не может иметь дочерние элементы.  
  
 Этот метод выполняется аналогично <xref:System.Xml.XmlTextReader.ReadContentAsBase64%2A> за исключением того, что он может вызываться только для типов узлов элемента.  
  
 Если `count` значение больше, чем число байтов в документе, или равно количеству байтов в документе, <xref:System.Xml.XmlTextReader> считывает все оставшиеся байты в документе и возвращает число считанных байтов. Следующий <xref:System.Xml.XmlTextReader> вызов метода возвращает нулевое значение и перемещает средство чтения на следующий узел <xref:System.Xml.XmlNodeType.EndElement>.  
  
 При вызове метода <xref:System.Xml.XmlTextReader.Read%2A> перед все содержимое элемента выделено, средство чтения может повести себя, как если бы была использована первого содержимого и затем <xref:System.Xml.XmlTextReader.Read%2A> был вызван метод. Это означает, что средство чтения считывает весь текст, пока не будет обнаружен конечного элемента. Затем он считывает узел закрывающего тега, считывает следующий узел и перемещает себя на последующем узле.  
  
   
  
## Examples  
 В разделе <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A?displayProperty=nameWithType> пример, с помощью этого метода.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение <paramref name="buffer" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Текущий узел не является узлом элемента.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение индекса в буфере или сумма значений индекса и счетчика больше, чем выделенный размер буфера.</exception>
        <exception cref="T:System.NotSupportedException">Реализация <see cref="T:System.Xml.XmlTextReader" /> не поддерживает данный метод.</exception>
        <exception cref="T:System.Xml.XmlException">Элемент содержит смешанное содержимое.</exception>
        <exception cref="T:System.FormatException">Не удается преобразовать содержимое в требуемый тип.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlTextReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHex">
      <MemberSignature Language="C#" Value="public override int ReadElementContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadElementContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadElementContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadElementContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Буфер, в который копируется полученный текст. Это значение не может быть равно <see langword="null" />.</param>
        <param name="index">Смещение в буфере, с которого следует начать копировать результат.</param>
        <param name="count">Максимальное количество копируемых в буфер байтов. Этот метод возвращает фактическое количество скопированных байтов.</param>
        <summary>Считывает элемент и декодирует содержимое <see langword="BinHex" />.</summary>
        <returns>Количество байтов, записанных в буфер.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Этот метод считывает содержимое элемента, декодирует его с помощью `BinHex` кодирования и возвращает раскодированные двоичные байты (например, встроенный `BinHex` рисунок в формате GIF) в буфер.  
  
 Этот метод может считывать только элементы с простым содержимым. Элемент может содержать текст, пробелы, значимые пробелы, разделы CDATA, комментарии и инструкции по обработке. Он также может содержать ссылки на сущности, которые разворачиваются автоматически. Элемент не может иметь дочерние элементы.  
  
 Этот метод выполняется аналогично <xref:System.Xml.XmlTextReader.ReadContentAsBinHex%2A> за исключением того, что он может вызываться только для типов узлов элемента.  
  
 Если `count` значение больше, чем число байтов в документе, или равно количеству байтов в документе, <xref:System.Xml.XmlTextReader> считывает все оставшиеся байты в документе и возвращает число считанных байтов. Следующий <xref:System.Xml.XmlTextReader> вызов метода возвращает нулевое значение и перемещает средство чтения на следующий узел <xref:System.Xml.XmlNodeType.EndElement>.  
  
 При вызове метода <xref:System.Xml.XmlTextReader.Read%2A> перед все содержимое элемента выделено, средство чтения может повести себя, как если бы была использована первого содержимого и затем <xref:System.Xml.XmlTextReader.Read%2A> был вызван метод. Это означает, что средство чтения считывает весь текст, пока не будет обнаружен конечного элемента. Затем он считывает узел закрывающего тега, считывает следующий узел и перемещает себя на последующем узле.  
  
   
  
## Examples  
 В разделе <xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A?displayProperty=nameWithType> пример, с помощью этого метода.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение <paramref name="buffer" /> равно <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Текущий узел не является узлом элемента.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение индекса в буфере или сумма значений индекса и счетчика больше, чем выделенный размер буфера.</exception>
        <exception cref="T:System.NotSupportedException">Реализация <see cref="T:System.Xml.XmlReader" /> не поддерживает данный метод.</exception>
        <exception cref="T:System.Xml.XmlException">Элемент содержит смешанное содержимое.</exception>
        <exception cref="T:System.FormatException">Не удается преобразовать содержимое в требуемый тип.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlTextReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadState">
      <MemberSignature Language="C#" Value="public override System.Xml.ReadState ReadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.ReadState ReadState" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.ReadState" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReadState As ReadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::ReadState ReadState { System::Xml::ReadState get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.ReadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает состояние средства чтения.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Xml.ReadState" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadString">
      <MemberSignature Language="C#" Value="public override string ReadString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает содержимое элемента или текстового узла в виде строки.</summary>
        <returns>Содержимое элемента или текстового узла. Если средство чтения позиционировано не на элемент или текстовый узел, а также если отсутствует возвращаемый текст, это может быть пустая строка.  
  
 <see langword="Note:" /> Текстовым узлом может быть элемент или текстовой узел атрибута.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Если средство чтения находится на элементе, `ReadString` объединяет текст, значимые пробелы, символы-разделители, и `CData` типы узел раздела, а затем возвращает объединенные данные в качестве содержимого элемента. Он останавливается при нахождении разметки, включая комментарии и инструкции по обработке. Это может случиться в модели смешанного содержимого или во время считывания закрывающего тега элемента.  
  
 Если средство чтения находится на текстовом узле `ReadString` выполняет же объединение от текстового узла до закрывающего тега элемента. Если модуль чтения расположен в текстовом узле атрибута, метод `ReadString` работает так же, как в случае, когда модуль чтения располагается в открывающем теге элемента, и возвращает все объединенные текстовые узлы элемента.  
  
   
  
## Examples  
 Следующий пример отображает текстовое содержимое каждого элемента.  
  
 [!code-cpp[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/VB/source.vb#1)]  
  
 В примере используется файл `elems.xml`, в качестве входных данных.  
  
 [!code-xml[Classic WebData XmlReader.IsStartElement Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">Произошла ошибка при синтаксическом анализе XML.</exception>
        <exception cref="T:System.InvalidOperationException">Предпринята попытка выполнить недопустимую операцию.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ResetState">
      <MemberSignature Language="C#" Value="public void ResetState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ResetState" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetState ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetState();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Сбрасывает состояние средства чтения на ReadState.Initial.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Этот метод позволяет анализировать несколько XML-документов в отдельном потоке. Когда будет достигнут конец XML-документа, можно вызвать `ResetState` сбрасывает состояние средства чтения следующего XML-документа.  
  
> [!IMPORTANT]
>  Документы в потоке должны совместно использовать ту же кодировку. Если это условие не выполняется, когда `ResetState` вызывается <xref:System.Xml.XmlException> возникает исключение. (Это изменение в поведении относительно платформы .NET Framework версии 1.1 и более ранних версий).  
  
 Следующие свойства не подвержены `ResetState`.  
  
-   <xref:System.Xml.XmlTextReader.Normalization%2A>  
  
-   <xref:System.Xml.XmlTextReader.Namespaces%2A>  
  
-   <xref:System.Xml.XmlTextReader.XmlResolver%2A>  
  
-   <xref:System.Xml.XmlTextReader.WhitespaceHandling%2A>  
  
   
  
## Examples  
 В следующем примере анализируется двух XML-документов в отдельном потоке.  
  
 [!code-cpp[XmlTextReader.ResetState#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.ResetState/CPP/resetstate.cpp#1)]
 [!code-csharp[XmlTextReader.ResetState#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.ResetState/CS/resetstate.cs#1)]
 [!code-vb[XmlTextReader.ResetState#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.ResetState/VB/resetstate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Вызывает <see langword="ResetState" />, если средство чтения было создано с помощью <see cref="T:System.Xml.XmlParserContext" />.</exception>
        <exception cref="T:System.Xml.XmlException">У документов в одном потоке разная кодировка.</exception>
        <altmember cref="T:System.Xml.ReadState" />
      </Docs>
    </Member>
    <Member MemberName="ResolveEntity">
      <MemberSignature Language="C#" Value="public override void ResolveEntity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ResolveEntity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ResolveEntity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ResolveEntity();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Разрешает ссылки на сущности для узлов <see langword="EntityReference" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Если средство чтения расположено на `EntityReference` узел (`XmlNodeType.EntityReference`), если <xref:System.Xml.XmlTextReader.Read%2A> вызывается после вызова этого метода замещающего текста сущности анализируется. По завершении замещения текста сущности `EndEntity` для закрытия области действия ссылок на сущности возвращается узел.  
  
> [!NOTE]
>  После вызова этого метода, если сущность является частью значения атрибута, необходимо вызвать <xref:System.Xml.XmlTextReader.ReadAttributeValue%2A> для доступа к объекту.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public override void Skip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Skip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.Skip" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Skip ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Skip();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Пропускает дочерний узел текущего узла.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 В следующем XML-КОДЕ входных данных, если средство чтения расположено на `<a>` узла или любого из его атрибутов, вызов `Skip` помещает модуль чтения для `<b>` узла.  
  
 Если средство чтения расположено на конечном узле уже (такие как `<x>` узел или текстовый узел `abc`), что вызов `Skip` является таким же, как вызов <xref:System.Xml.XmlTextReader.Read%2A>.  
  
```xml  
<a name="bob" age="123">  
  <x/>abc<y/>  
</a>  
<b>  
 ...  
</b>  
```  
  
 Этот метод проверяет корректный XML.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="System.Xml.IXmlNamespaceResolver.GetNamespacesInScope">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IDictionary&lt;string,string&gt; IXmlNamespaceResolver.GetNamespacesInScope (System.Xml.XmlNamespaceScope scope);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, string&gt; System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(valuetype System.Xml.XmlNamespaceScope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.System#Xml#IXmlNamespaceResolver#GetNamespacesInScope(System.Xml.XmlNamespaceScope)" />
      <MemberSignature Language="VB.NET" Value="Function GetNamespacesInScope (scope As XmlNamespaceScope) As IDictionary(Of String, String) Implements IXmlNamespaceResolver.GetNamespacesInScope" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(System::Xml::XmlNamespaceScope scope) = System::Xml::IXmlNamespaceResolver::GetNamespacesInScope;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(System.Xml.XmlNamespaceScope)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Xml.XmlNamespaceScope" />
      </Parameters>
      <Docs>
        <param name="scope">С помощью значения <see cref="T:System.Xml.XmlNamespaceScope" /> указывается тип узлов пространства имен, которые следует возвратить.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(System.Xml.XmlNamespaceScope)" />.</summary>
        <returns>Объект <see cref="T:System.Collections.IDictionary" />, содержащий текущие пространства имен в области.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Xml.XmlTextReader> приведен к типу интерфейса <xref:System.Xml.IXmlNamespaceResolver>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="System.Xml.IXmlNamespaceResolver.LookupNamespace">
      <MemberSignature Language="C#" Value="string IXmlNamespaceResolver.LookupNamespace (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.Xml.IXmlNamespaceResolver.LookupNamespace(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.System#Xml#IXmlNamespaceResolver#LookupNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function LookupNamespace (prefix As String) As String Implements IXmlNamespaceResolver.LookupNamespace" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.Xml.IXmlNamespaceResolver.LookupNamespace(System::String ^ prefix) = System::Xml::IXmlNamespaceResolver::LookupNamespace;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.LookupNamespace(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">Префикс, URI пространства имен которого нужно найти.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.Xml.IXmlNamespaceResolver.LookupNamespace(System.String)" />.</summary>
        <returns>URI пространства имен, сопоставленное с префиксом; <see langword="null" />, если префикс не сопоставлен с URI пространства имен.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Xml.XmlTextReader> приведен к типу интерфейса <xref:System.Xml.IXmlNamespaceResolver>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="System.Xml.IXmlNamespaceResolver.LookupPrefix">
      <MemberSignature Language="C#" Value="string IXmlNamespaceResolver.LookupPrefix (string namespaceName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.Xml.IXmlNamespaceResolver.LookupPrefix(string namespaceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.System#Xml#IXmlNamespaceResolver#LookupPrefix(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function LookupPrefix (namespaceName As String) As String Implements IXmlNamespaceResolver.LookupPrefix" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.Xml.IXmlNamespaceResolver.LookupPrefix(System::String ^ namespaceName) = System::Xml::IXmlNamespaceResolver::LookupPrefix;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.LookupPrefix(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="namespaceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="namespaceName">URI пространства имен, префикс которого нужно найти.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.Xml.IXmlNamespaceResolver.LookupPrefix(System.String)" />.</summary>
        <returns>Префикс, сопоставленный с URI пространства имен; <see langword="null" /> если URI пространства имен не сопоставлен с префиксом.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public override string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Value" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Value { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает текстовое значение текущего узла.</summary>
        <value>Возвращаемое значение зависит от значения свойства <see cref="P:System.Xml.XmlTextReader.NodeType" /> узла. В следующей таблице представлен список возвращаемых типов узлов со значениями. Все прочие типы узлов возвращают значение <see langword="String.Empty" />.  
  
 <list type="table"><listheader><term> Тип узла  
  
 </term><description> Значение  
  
 </description></listheader><item><term><see langword="Attribute" /></term><description> Значение атрибута.  
  
 </description></item><item><term><see langword="CDATA" /></term><description> Содержимое раздела CDATA.  
  
 </description></item><item><term><see langword="Comment" /></term><description> Содержимое комментария.  
  
 </description></item><item><term><see langword="DocumentType" /></term><description> Внутреннее подмножество.  
  
 </description></item><item><term><see langword="ProcessingInstruction" /></term><description> Все содержимое, за исключением цели.  
  
 </description></item><item><term><see langword="SignificantWhitespace" /></term><description> Пробел в <see langword="xml:space" />= 'preserve' области.  
  
 </description></item><item><term><see langword="Text" /></term><description> Содержимое текстового узла.  
  
 </description></item><item><term><see langword="Whitespace" /></term><description> Пробел между элементами разметки.  
  
 </description></item><item><term><see langword="XmlDeclaration" /></term><description> Содержимое декларации.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
   
  
## Examples  
 В следующем примере считывает XML-файла и отображение каждого узла.  
  
 [!code-cpp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/VB/source.vb#1)]  
  
 В образце используется файл `items.xml`.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="WhitespaceHandling">
      <MemberSignature Language="C#" Value="public System.Xml.WhitespaceHandling WhitespaceHandling { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.WhitespaceHandling WhitespaceHandling" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.WhitespaceHandling" />
      <MemberSignature Language="VB.NET" Value="Public Property WhitespaceHandling As WhitespaceHandling" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::WhitespaceHandling WhitespaceHandling { System::Xml::WhitespaceHandling get(); void set(System::Xml::WhitespaceHandling value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.WhitespaceHandling</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, определяющее способ обработки символов-разделителей.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Xml.WhitespaceHandling" />. По умолчанию используется значение <see langword="WhitespaceHandling.All" /> (возвращает узлы <see langword="Whitespace" /> и <see langword="SignificantWhitespace" />).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это свойство можно изменить в любое время и вступает в силу следующая операция чтения.  
  
 Поскольку `XmlTextReader` нет доступных сведений DTD `SignificantWhitepsace` возвращаются только узлы внутри `xml:space='preserve'` области.  
  
   
  
## Examples  
 В следующем примере считывается XML-фрагмента.  
  
 [!code-cpp[Classic WebData XmlTextReader.WhitespaceHandling Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.WhitespaceHandling Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.WhitespaceHandling Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.WhitespaceHandling Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.WhitespaceHandling Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.WhitespaceHandling Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Указано недопустимое значение.</exception>
        <exception cref="T:System.InvalidOperationException">Установка значения этого свойства после закрытия средства чтения (<see cref="P:System.Xml.XmlTextReader.ReadState" /> равно <see langword="ReadState.Closed" />).</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="XmlLang">
      <MemberSignature Language="C#" Value="public override string XmlLang { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string XmlLang" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.XmlLang" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property XmlLang As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ XmlLang { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает текущую область действия <see langword="xml:lang" />.</summary>
        <value>Текущая область действия <see langword="xml:lang" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это свойство представляет `xml:lang` область, в которой находится текущий узел. Например, ниже приведен фрагмент XML `xml:lang` задать для английского языка в корневой элемент:  
  
 \<корневой XML: lang = "en-us» >  
  
 \<имя > Fred \< /name >  
  
 \</ root >  
  
 Если средство чтения расположено на `name` элемент, это свойство можно использовать для поиска, что он находится в области английский (США) `xml:lang` атрибута.  
  
   
  
## Examples  
 В следующем примере отображается `xml:lang` значение для каждого узла.  
  
 [!code-cpp[XmlTextReader.XmlLang#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.XmlLang/CPP/readlang.cpp#1)]
 [!code-csharp[XmlTextReader.XmlLang#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.XmlLang/CS/readlang.cs#1)]
 [!code-vb[XmlTextReader.XmlLang#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.XmlLang/VB/readlang.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="XmlResolver">
      <MemberSignature Language="C#" Value="public System.Xml.XmlResolver XmlResolver { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlResolver XmlResolver" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.XmlResolver" />
      <MemberSignature Language="VB.NET" Value="Public Property XmlResolver As XmlResolver" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlResolver ^ XmlResolver {  void set(System::Xml::XmlResolver ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlResolver</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Задает <see cref="T:System.Xml.XmlResolver" /> для разрешения ссылок на DTD.</summary>
        <value>Используемый <see langword="XmlResolver" />. Если он имеет значение <see langword="null" />, внешние ресурсы не разрешаются.  
  
 В [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] версии 1.1 вызывающий объект должен иметь полное доверие, чтобы иметь возможность указывать <see langword="XmlResolver" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Средство чтения использует `XmlResolver` для разрешения расположения файла, загружаемого в средство чтения, так и для разрешения ссылок на DTD. Например, если в XML-КОДЕ содержится объявление DOCTYPE `<!DOCTYPE book SYSTEM book.dtd>` средство чтения разрешает это внешний файл и гарантирует, что DTD имеет правильный формат. Средство чтения не использует DTD для проверки.  
  
 Это свойство можно изменить в любое время и вступает в силу следующая операция чтения. Если это свойство имеет значение `null`, не разрешаются любые ссылки на DTD, обнаруженные средством чтения.  
  
 В версии 1.1 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], если это свойство не задано, уровень доверия приложения определяет поведение по умолчанию.  
  
 `Fully trusted code:` Средство чтения использует значение по умолчанию <xref:System.Xml.XmlUrlResolver> без учетных данных пользователя. Если для доступа к сетевому ресурсу требуется проверка подлинности, используйте `XmlResolver` свойство, чтобы указать `XmlResolver` необходимые учетные данные.  
  
 `Semi-trusted code:` `XmlResolver` Свойству `null`. Внешние ресурсы не разрешаются.  
  
   
  
## Examples  
 В следующем примере используется `XmlResolver` свойство, чтобы указать учетные данные, необходимые для доступа к сетевому файлу.  
  
 [!code-cpp[XmlTextReader.XmlResolver#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.XmlResolver/CPP/rdr_resolver.cpp#1)]
 [!code-csharp[XmlTextReader.XmlResolver#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.XmlResolver/CS/rdr_resolver.cs#1)]
 [!code-vb[XmlTextReader.XmlResolver#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.XmlResolver/VB/rdr_resolver.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xml.XmlUrlResolver.Credentials" />
        <altmember cref="T:System.Net.CredentialCache" />
        <altmember cref="T:System.Net.NetworkCredential" />
        <altmember cref="T:System.Xml.XmlSecureResolver" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="XmlSpace">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlSpace XmlSpace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlSpace XmlSpace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.XmlSpace" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property XmlSpace As XmlSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlSpace XmlSpace { System::Xml::XmlSpace get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает текущую область действия <see langword="xml:space" />.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Xml.XmlSpace" />. Если область действия <see langword="xml:space" /> отсутствует, данное свойство принимает значение <see langword="XmlSpace.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
   
  
## Examples  
 В следующем примере анализируется файл и возвращает значащих пробелов, если `xml:space='preserve'` найти область.  
  
 [!code-cpp[XmlTextReader.XmlSpace#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.XmlSpace/CPP/readspace.cpp#1)]
 [!code-csharp[XmlTextReader.XmlSpace#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.XmlSpace/CS/readspace.cs#1)]
 [!code-vb[XmlTextReader.XmlSpace#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.XmlSpace/VB/readspace.vb#1)]  
  
 В примере используется файл `authors.xml`, в качестве входных данных.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
  </Members>
</Type>