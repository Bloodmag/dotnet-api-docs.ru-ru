<Type Name="XmlTextReader" FullName="System.Xml.XmlTextReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="adbf39d3716bacce895ac5eee8d993ee7079e17f" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36434437" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class XmlTextReader : System.Xml.XmlReader, System.Xml.IXmlLineInfo, System.Xml.IXmlNamespaceResolver" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XmlTextReader extends System.Xml.XmlReader implements class System.Xml.IXmlLineInfo, class System.Xml.IXmlNamespaceResolver" />
  <TypeSignature Language="DocId" Value="T:System.Xml.XmlTextReader" />
  <TypeSignature Language="VB.NET" Value="Public Class XmlTextReader&#xA;Inherits XmlReader&#xA;Implements IXmlLineInfo, IXmlNamespaceResolver" />
  <TypeSignature Language="C++ CLI" Value="public ref class XmlTextReader : System::Xml::XmlReader, System::Xml::IXmlLineInfo, System::Xml::IXmlNamespaceResolver" />
  <TypeSignature Language="F#" Value="type XmlTextReader = class&#xA;    inherit XmlReader&#xA;    interface IXmlLineInfo&#xA;    interface IXmlNamespaceResolver" />
  <AssemblyInfo>
    <AssemblyName>System.Xml</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.XmlReader</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Xml.IXmlLineInfo</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Xml.IXmlNamespaceResolver</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a reader that provides fast, non-cached, forward-only access to XML data.  Starting with the .NET Framework 2.0, we recommend that you use the <see cref="T:System.Xml.XmlReader" /> class instead.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 <xref:System.Xml.XmlTextReader> предоставляет доступ только вперед, только для чтения в поток XML-данных. Текущим является узел, на котором расположен модуль чтения. Средство чтения может с помощью любого из методов чтения и свойства, соответствующие значению текущего узла.  
  
 Этот класс реализует <xref:System.Xml.XmlReader> и соответствует W3C языка (XML) 1.0 и пространств имен в рекомендации XML. `XmlTextReader` предоставляет следующие функциональные возможности:  
  
-   Применяет правила корректный XML.  
  
-   `XmlTextReader` не поддерживает проверку данных.  
  
-   Проверяет, что `DocumentType` узлы имеют правильный формат. `XmlTextReader` проверяет правильность DTD, но не выполняет проверку с помощью DTD.  
  
-   Для узлов, где <xref:System.Xml.XmlTextReader.NodeType%2A> — `XmlNodeType.EntityReference`, пустых `EntityReference` возвращается узел (т. е <xref:System.Xml.XmlTextReader.Value%2A> свойство `String.Empty`).  
  
> [!NOTE]
>  Реальные объявления сущностей в DTD называются `Entity` узлов. При ссылке на эти узлы в данных, они называются `EntityReference` узлов.  
  
-   Не расширяет атрибуты по умолчанию.  
  
 Поскольку `XmlTextReader` не выполняет дополнительных проверок, требуемых для проверки данных, он предоставляет быстрое средство синтаксического анализа.  
  
 При выполнении проверки данных, используйте проверяющего <xref:System.Xml.XmlReader>.  
  
 Для считывания XML-данных из <xref:System.Xml.XmlDocument>, используйте <xref:System.Xml.XmlNodeReader>.  
  
 `XmlTextReader` Создает <xref:System.Xml.XmlException> XML-ошибки синтаксического анализа. После исключения состояние средства чтения не является прогнозируемым. Например указанный тип узла может отличаться от фактического типа текущего узла. Используйте <xref:System.Xml.XmlTextReader.ReadState%2A> свойство, чтобы проверить, является ли модуль чтения находится в состоянии ошибки.  
  
## <a name="security-considerations"></a>Вопросы безопасности  
 Ниже перечислены аспекты, которые необходимо учитывать при использовании <xref:System.Xml.XmlTextReader> класса.  
  
-   Исключения, создаваемые <xref:System.Xml.XmlTextReader> , могут содержать сведения о пути, которые не следует в приведенном выше приложения. Приложения должны перехватывать исключения и обрабатывать их соответствующим образом.  
  
-   Обработка определения DTD по умолчанию включена. Отключите обработку DTD, если вас интересуют отказ в обслуживании, или при работе с ненадежными источниками. Задать <xref:System.Xml.XmlTextReader.DtdProcessing%2A> свойства <xref:System.Xml.DtdProcessing.Prohibit> для отключения обработки DTD.  
  
     Если обработка DTD включена, то с помощью класса <xref:System.Xml.XmlSecureResolver> можно ограничить ресурсы, доступные для объекта <xref:System.Xml.XmlTextReader>. Кроме того, можно создать собственное приложение, ограничивающее объем памяти и время, выделяемое на обработку XML. Например, можно ограничить время ожидания в приложении ASP.NET.  
  
-   XML-данные могут содержать ссылки на внешние ресурсы, такие как DTD-файл. По умолчанию внешние ресурсы разрешаются с помощью объекта <xref:System.Xml.XmlUrlResolver> без пользовательских учетных данных. Это можно сделать еще более безопасным, выполнив одно из следующих действий.  
  
    -   Ограничить ресурсы, к которым имеет доступ <xref:System.Xml.XmlTextReader>, установив в качестве значения свойства <xref:System.Xml.XmlTextReader.XmlResolver%2A> объект <xref:System.Xml.XmlSecureResolver>.  
  
    -   Не разрешать <xref:System.Xml.XmlReader> открывать какие-либо внешние ресурсы, установив для свойства <xref:System.Xml.XmlTextReader.XmlResolver%2A> значение `null`.  
  
-   XML-данные могут содержать большое количество атрибутов, деклараций пространств имен, вложенных элементов и так далее, на обработку которых требуется значительное время. Чтобы ограничить размер входных данных, который отправляется <xref:System.Xml.XmlTextReader>, создать пользовательскую реализацию IStream и передайте в него <xref:System.Xml.XmlTextReader>.  
  
-   <xref:System.Xml.XmlReader.ReadValueChunk%2A> Метод может использоваться для обработки больших массивов данных. Этот метод за раз считывает небольшое число символов, а не выделяет одну строку для всего значения.  
  
-   По умолчанию общие сущности не раскрываются. Общие сущности раскрываются при вызове метода <xref:System.Xml.XmlTextReader.ResolveEntity%2A>.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Этот класс имеет требования наследования. Требуется полное доверие для наследования от <see langword="XmlTextReader" />.</para>
    </block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Xml.XmlTextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlTextReader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XmlTextReader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initializes a new instance of the <see langword="XmlTextReader" />.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (System.IO.Stream input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (input As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::IO::Stream ^ input);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : System.IO.Stream -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader input" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="input">The stream containing the XML data to read.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Xml.XmlTextReader" /> class with the specified stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 <xref:System.Xml.XmlTextReader> Декодирует поток с помощью <xref:System.Text.Encoding?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (System.IO.TextReader input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextReader input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (input As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::IO::TextReader ^ input);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : System.IO.TextReader -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader input" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="input">The <see langword="TextReader" /> containing the XML data to read.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Xml.XmlTextReader" /> class with the specified <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Предполагается, что `TextReader` уже установлен в правильной кодировке. Используется клиентами, которые уже прочитали некоторые вещи из потока в сценарии составного MIME.  
  
   
  
## Examples  
 В следующем примере загружается в XML-строку `XmlTextReader` с помощью <xref:System.IO.StringReader> класса.  
  
 [!code-cpp[XmlTextReader.cctor1#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.cctor1/CPP/rdrcctor1.cpp#1)]
 [!code-csharp[XmlTextReader.cctor1#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.cctor1/CS/rdrcctor1.cs#1)]
 [!code-vb[XmlTextReader.cctor1#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.cctor1/VB/rdrcctor1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : string -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader url" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="url">The URL for the file containing the XML data. The <see cref="P:System.Xml.XmlTextReader.BaseURI" /> is set to this value.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Xml.XmlTextReader" /> class with the specified file.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Если файл находится на ресурсе, требующем учетных данных, используйте <xref:System.Xml.XmlTextReader.XmlResolver%2A> свойство, чтобы указать необходимые учетные данные.  
  
> [!NOTE]
>  В версии 1.1 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], частично доверенный код не может установить `XmlResolver` свойство. Необходимо создать <xref:System.Xml.XmlUrlResolver> с необходимыми учетными данными, передать URI в <xref:System.Xml.XmlUrlResolver.GetEntity%2A?displayProperty=nameWithType> метода, а затем создать `XmlTextReader` с помощью полученного <xref:System.IO.Stream> объекта. Эта процедура описана в следующем коде C#.  
  
```csharp  
// Create a resolver with the necessary credentials.  
XmlUrlResolver resolver = new XmlUrlResolver();  
NetworkCredential nc = new NetworkCredential(SecurelyStoredUserName, SecurelyStoredPassword, SecurelyStoredDomain);  
resolver.Credentials = nc;   
// Get a Stream object containing the XML file.  
Uri myUri = new Uri ("http://myServer/data/books.xml");  
Stream s=(Stream)resolver.GetEntity(myUri, null, typeof(Stream));  
// Construct a reader using the Stream object.  
XmlTextReader reader = new XmlTextReader(s);  
```  
  
   
  
## Examples  
 В следующем примере считывает XML-файла и отображение каждого из узлов.  
  
 [!code-cpp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/VB/source.vb#1)]  
  
 В примере используется файл `items.xml`, в качестве входных данных.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">The specified file cannot be found.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Part of the filename or directory cannot be found.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="url" /> is an empty string.</exception>
        <exception cref="T:System.Net.WebException">The remote filename cannot be resolved.  -or-  An error occurred while processing the request.</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="url" /> is not a valid URI.</exception>
        <altmember cref="P:System.Xml.XmlTextReader.XmlResolver" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected XmlTextReader (System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; XmlTextReader(System::Xml::XmlNameTable ^ nt);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : System.Xml.XmlNameTable -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader nt" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="nt">The <see langword="XmlNameTable" /> to use.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Xml.XmlTextReader" /> class with the specified <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (System.IO.Stream input, System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream input, class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.IO.Stream,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (input As Stream, nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::IO::Stream ^ input, System::Xml::XmlNameTable ^ nt);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : System.IO.Stream * System.Xml.XmlNameTable -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader (input, nt)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="input">The stream containing the XML data to read.</param>
        <param name="nt">The <see langword="XmlNameTable" /> to use.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Xml.XmlTextReader" /> class with the specified stream and <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 <xref:System.Xml.XmlTextReader> Декодирует поток с помощью <xref:System.Text.Encoding?displayProperty=nameWithType>.  
  
 Если указать имя таблицы, этот конструктор использует имена, уже определенные в этой таблице.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">The <paramref name="input" /> or <paramref name="nt" /> value is <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (System.IO.TextReader input, System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.TextReader input, class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.IO.TextReader,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (input As TextReader, nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::IO::TextReader ^ input, System::Xml::XmlNameTable ^ nt);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : System.IO.TextReader * System.Xml.XmlNameTable -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader (input, nt)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="input">The <see langword="TextReader" /> containing the XML data to read.</param>
        <param name="nt">The <see langword="XmlNameTable" /> to use.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Xml.XmlTextReader" /> class with the specified <see cref="T:System.IO.TextReader" /> and <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Предполагается, что `TextReader` уже установлен в правильной кодировке. Используется клиентами, которые уже прочитали некоторые вещи из потока в сценарии составного MIME.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">The <paramref name="nt" /> value is <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url, System.IO.Stream input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url, class System.IO.Stream input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.IO.Stream)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String, input As Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url, System::IO::Stream ^ input);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : string * System.IO.Stream -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader (url, input)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="input" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="url">The URL to use for resolving external resources. The <see cref="P:System.Xml.XmlTextReader.BaseURI" /> is set to this value.</param>
        <param name="input">The stream containing the XML data to read.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Xml.XmlTextReader" /> class with the specified URL and stream.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="input" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url, System.IO.TextReader input);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url, class System.IO.TextReader input) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String, input As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url, System::IO::TextReader ^ input);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : string * System.IO.TextReader -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader (url, input)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="input" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="url">The URL to use for resolving external resources. The <see cref="P:System.Xml.XmlTextReader.BaseURI" /> is set to this value.</param>
        <param name="input">The <see langword="TextReader" /> containing the XML data to read.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Xml.XmlTextReader" /> class with the specified URL and <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Предполагается, что `TextReader` уже установлен в правильной кодировке. Используется клиентами, которые уже прочитали некоторые вещи из потока в сценарии составного MIME.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url, System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url, class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String, nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url, System::Xml::XmlNameTable ^ nt);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : string * System.Xml.XmlNameTable -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader (url, nt)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="url">The URL for the file containing the XML data to read.</param>
        <param name="nt">The <see langword="XmlNameTable" /> to use.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Xml.XmlTextReader" /> class with the specified file and <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">The <paramref name="nt" /> value is <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">The specified file cannot be found.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Part of the filename or directory cannot be found.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="url" /> is an empty string.</exception>
        <exception cref="T:System.Net.WebException">The remote filename cannot be resolved.  -or-  An error occurred while processing the request.</exception>
        <exception cref="T:System.UriFormatException">
          <paramref name="url" /> is not a valid URI.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (System.IO.Stream xmlFragment, System.Xml.XmlNodeType fragType, System.Xml.XmlParserContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.IO.Stream xmlFragment, valuetype System.Xml.XmlNodeType fragType, class System.Xml.XmlParserContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.IO.Stream,System.Xml.XmlNodeType,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xmlFragment As Stream, fragType As XmlNodeType, context As XmlParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::IO::Stream ^ xmlFragment, System::Xml::XmlNodeType fragType, System::Xml::XmlParserContext ^ context);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : System.IO.Stream * System.Xml.XmlNodeType * System.Xml.XmlParserContext -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader (xmlFragment, fragType, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xmlFragment" Type="System.IO.Stream" />
        <Parameter Name="fragType" Type="System.Xml.XmlNodeType" />
        <Parameter Name="context" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="xmlFragment">The stream containing the XML fragment to parse.</param>
        <param name="fragType">The <see cref="T:System.Xml.XmlNodeType" /> of the XML fragment. This also determines what the fragment can contain. (See table below.)</param>
        <param name="context">The <see cref="T:System.Xml.XmlParserContext" /> in which the <c>xmlFragment</c> is to be parsed. This includes the <see cref="T:System.Xml.XmlNameTable" /> to use, encoding, namespace scope, the current <c>xml:lang</c>, and the <c>xml:space</c> scope.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Xml.XmlTextReader" /> class with the specified stream, <see cref="T:System.Xml.XmlNodeType" />, and <see cref="T:System.Xml.XmlParserContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Этот конструктор анализирует заданную строку как фрагмент XML. Если фрагмент XML — элемент или атрибут, можно обойти правила верхнего уровня для XML-документы правильного формата.  
  
 В следующей таблице перечислены допустимые значения для `fragType`.  
  
|Тип узла XML|Фрагмент может содержать|  
|-----------------|--------------------------|  
|`Element`|Любое допустимое содержимое элемента (например, любое сочетание элементов, комментарии, инструкции по обработке, разделы CDATA, текст и ссылки на сущности).<br /><br /> Также можно передавать XML-декларацию. Это позволяет указать кодировку XML-фрагмент, вместо того установить его на <xref:System.Xml.XmlParserContext> объекта.|  
|`Attribute`|Значение атрибута (часть в кавычках).|  
|`Document`|Содержимое всего XML-документа. Это обеспечивает правила на уровне документа.|  
  
 Средство чтения использует следующие, чтобы определить кодировку потока.  
  
1.  Проверяет <xref:System.Xml.XmlParserContext.Encoding%2A?displayProperty=nameWithType> свойство, чтобы определить кодировку.  
  
2.  Если `Encoding` свойство `null`, средство чтения проверяет метку порядка байтов в начале потока.  
  
3.  Если `Encoding` свойство `null`и найти метка порядка байтов отсутствуют, средство чтения используется кодировка UTF-8.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="fragType" /> is not an Element, Attribute, or Document <see langword="XmlNodeType" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="xmlFragment" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url, System.IO.Stream input, System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url, class System.IO.Stream input, class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.IO.Stream,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String, input As Stream, nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url, System::IO::Stream ^ input, System::Xml::XmlNameTable ^ nt);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : string * System.IO.Stream * System.Xml.XmlNameTable -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader (url, input, nt)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="input" Type="System.IO.Stream" />
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="url">The URL to use for resolving external resources. The <see cref="P:System.Xml.XmlTextReader.BaseURI" /> is set to this value. If <c>url</c> is <see langword="null" />, <see langword="BaseURI" /> is set to <see langword="String.Empty" />.</param>
        <param name="input">The stream containing the XML data to read.</param>
        <param name="nt">The <see langword="XmlNameTable" /> to use.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Xml.XmlTextReader" /> class with the specified URL, stream and <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">The <paramref name="input" /> or <paramref name="nt" /> value is <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string url, System.IO.TextReader input, System.Xml.XmlNameTable nt);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string url, class System.IO.TextReader input, class System.Xml.XmlNameTable nt) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.IO.TextReader,System.Xml.XmlNameTable)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (url As String, input As TextReader, nt As XmlNameTable)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ url, System::IO::TextReader ^ input, System::Xml::XmlNameTable ^ nt);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : string * System.IO.TextReader * System.Xml.XmlNameTable -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader (url, input, nt)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="url" Type="System.String" />
        <Parameter Name="input" Type="System.IO.TextReader" />
        <Parameter Name="nt" Type="System.Xml.XmlNameTable" />
      </Parameters>
      <Docs>
        <param name="url">The URL to use for resolving external resources. The <see cref="P:System.Xml.XmlTextReader.BaseURI" /> is set to this value. If <c>url</c> is <see langword="null" />, <see langword="BaseURI" /> is set to <see langword="String.Empty" />.</param>
        <param name="input">The <see langword="TextReader" /> containing the XML data to read.</param>
        <param name="nt">The <see langword="XmlNameTable" /> to use.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Xml.XmlTextReader" /> class with the specified URL, <see cref="T:System.IO.TextReader" /> and <see cref="T:System.Xml.XmlNameTable" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Предполагается, что `TextReader` уже установлен в правильной кодировке. Используется клиентами, которые уже прочитали некоторые вещи из потока в сценарии составного MIME.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="nt" /> value is <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XmlTextReader (string xmlFragment, System.Xml.XmlNodeType fragType, System.Xml.XmlParserContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string xmlFragment, valuetype System.Xml.XmlNodeType fragType, class System.Xml.XmlParserContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.#ctor(System.String,System.Xml.XmlNodeType,System.Xml.XmlParserContext)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (xmlFragment As String, fragType As XmlNodeType, context As XmlParserContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XmlTextReader(System::String ^ xmlFragment, System::Xml::XmlNodeType fragType, System::Xml::XmlParserContext ^ context);" />
      <MemberSignature Language="F#" Value="new System.Xml.XmlTextReader : string * System.Xml.XmlNodeType * System.Xml.XmlParserContext -&gt; System.Xml.XmlTextReader" Usage="new System.Xml.XmlTextReader (xmlFragment, fragType, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="xmlFragment" Type="System.String" />
        <Parameter Name="fragType" Type="System.Xml.XmlNodeType" />
        <Parameter Name="context" Type="System.Xml.XmlParserContext" />
      </Parameters>
      <Docs>
        <param name="xmlFragment">The string containing the XML fragment to parse.</param>
        <param name="fragType">The <see cref="T:System.Xml.XmlNodeType" /> of the XML fragment. This also determines what the fragment string can contain. (See table below.)</param>
        <param name="context">The <see cref="T:System.Xml.XmlParserContext" /> in which the <c>xmlFragment</c> is to be parsed. This includes the <see cref="T:System.Xml.XmlNameTable" /> to use, encoding, namespace scope, the current <c>xml:lang</c>, and the <c>xml:space</c> scope.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Xml.XmlTextReader" /> class with the specified string, <see cref="T:System.Xml.XmlNodeType" />, and <see cref="T:System.Xml.XmlParserContext" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Этот конструктор анализирует заданную строку как фрагмент XML. Если фрагмент XML — элемент или атрибут, можно обойти правила верхнего уровня для XML-документы правильного формата. Этот конструктор может обрабатывать строки, возвращаемые из <xref:System.Xml.XmlReader.ReadInnerXml%2A>.  
  
 В следующей таблице перечислены допустимые значения для `fragType` и как средство чтения анализирует различных типов узлов.  
  
|Тип узла XML|Фрагмент может содержать|  
|-----------------|--------------------------|  
|Элемент|Любое допустимое содержимое элемента (например, любое сочетание элементов, комментарии, инструкции по обработке, разделы CDATA, текст и ссылки на сущности).<br /><br /> Также можно передавать XML-декларацию. Это позволяет указать кодировку XML-фрагмент, вместо того установить его на <xref:System.Xml.XmlParserContext> объекта.|  
|Атрибут|Значение атрибута (часть в кавычках).|  
|Document|Содержимое всего XML-документа. Это обеспечивает правила на уровне документа.|  
  
   
  
## Examples  
 В следующем примере анализируется фрагмент XML. Она использует `XmlParserContext` и его <xref:System.Xml.XmlNamespaceManager> для обработки разрешения пространства имен.  
  
 [!code-cpp[XmlTextReader.Cctor#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.Cctor/CPP/readfrag.cpp#1)]
 [!code-csharp[XmlTextReader.Cctor#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.Cctor/CS/readfrag.cs#1)]
 [!code-vb[XmlTextReader.Cctor#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.Cctor/VB/readfrag.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">
          <paramref name="fragType" /> is not an <see langword="Element" />, <see langword="Attribute" />, or <see langword="Document" /><see langword="XmlNodeType" />.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="xmlFragment" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlParserContext" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="AttributeCount">
      <MemberSignature Language="C#" Value="public override int AttributeCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 AttributeCount" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.AttributeCount" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AttributeCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int AttributeCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.AttributeCount : int" Usage="System.Xml.XmlTextReader.AttributeCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of attributes on the current node.</summary>
        <value>Количество атрибутов текущего узла.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это свойство применимо к `Element`, `DocumentType` и `XmlDeclaration` только узлы. (Другие типы узлов не имеют атрибутов).  
  
   
  
## Examples  
 Следующий пример отображает все атрибуты на текущем узле.  
  
 [!code-cpp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="BaseURI">
      <MemberSignature Language="C#" Value="public override string BaseURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.BaseURI" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BaseURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ BaseURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseURI : string" Usage="System.Xml.XmlTextReader.BaseURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the base URI of the current node.</summary>
        <value>Базовый URI текущего узла.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Сетевой XML-документ состоит из фрагментов данных, объединяемых с помощью различных механизмов включения стандарта W3C и поэтому содержит узлы, полученные из различных мест. Примером этого являются объекты, но это не ограничивается только DTD. Базовый URI указывает происхождения этих узлов. Если имеется базовый URI для возвращаемых узлов отсутствует (например, они были извлечены из строки в памяти), `String.Empty` возвращается.  
  
   
  
## Examples  
 В следующем примере отображается базовый URI для каждого узла.  
  
 [!code-cpp[Classic WebData XmlTextReader.BaseURI Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.BaseURI Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.BaseURI Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.BaseURI Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.BaseURI Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.BaseURI Example/VB/source.vb#1)]  
  
 В примере используется файл `baseuri.xml`, в качестве входных данных.  
  
 [!code-xml[Classic WebData XmlTextReader.BaseURI Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.BaseURI Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="CanReadBinaryContent">
      <MemberSignature Language="C#" Value="public override bool CanReadBinaryContent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadBinaryContent" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.CanReadBinaryContent" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanReadBinaryContent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadBinaryContent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReadBinaryContent : bool" Usage="System.Xml.XmlTextReader.CanReadBinaryContent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Xml.XmlTextReader" /> implements the binary content read methods.</summary>
        <value>Значение <see langword="true" />, если реализуются методы чтения двоичного содержимого; в противном случае — <see langword="false" />. Класс <see cref="T:System.Xml.XmlTextReader" /> всегда возвращает значение <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Используются следующие методы чтения двоичного содержимого <xref:System.Xml.XmlTextReader.ReadContentAsBase64%2A>, <xref:System.Xml.XmlTextReader.ReadContentAsBinHex%2A>, <xref:System.Xml.XmlTextReader.ReadElementContentAsBase64%2A>, и <xref:System.Xml.XmlTextReader.ReadElementContentAsBinHex%2A> методы.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="CanReadValueChunk">
      <MemberSignature Language="C#" Value="public override bool CanReadValueChunk { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanReadValueChunk" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.CanReadValueChunk" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanReadValueChunk As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanReadValueChunk { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanReadValueChunk : bool" Usage="System.Xml.XmlTextReader.CanReadValueChunk" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the <see cref="T:System.Xml.XmlTextReader" /> implements the <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" /> method.</summary>
        <value>Значение <see langword="true" />, если объект <see cref="T:System.Xml.XmlTextReader" /> реализует метод <see cref="M:System.Xml.XmlReader.ReadValueChunk(System.Char[],System.Int32,System.Int32)" />; в противном случае — <see langword="false" />. Класс <see cref="T:System.Xml.XmlTextReader" /> всегда возвращает значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 <xref:System.Xml.XmlTextReader> Вызывает <xref:System.NotSupportedException> Если <xref:System.Xml.XmlReader.ReadValueChunk%2A> вызывается метод.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="CanResolveEntity">
      <MemberSignature Language="C#" Value="public override bool CanResolveEntity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool CanResolveEntity" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.CanResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property CanResolveEntity As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool CanResolveEntity { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.CanResolveEntity : bool" Usage="System.Xml.XmlTextReader.CanResolveEntity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether this reader can parse and resolve entities.</summary>
        <value>Значение <see langword="true" />, если средство чтения позволяет анализировать и разрешать сущности; в противном случае — <see langword="false" />. Класс <see langword="XmlTextReader" /> всегда возвращает значение <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это изменение в [!INCLUDE[dnprdnext](~/includes/dnprdnext-md.md)] выпуска. В предыдущих версиях `XmlTextReader` класса не может разрешить сущности и `CanResolveEntity` всегда возвращается `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public override void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.Close" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Close();" />
      <MemberSignature Language="F#" Value="override this.Close : unit -&gt; unit" Usage="xmlTextReader.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Changes the <see cref="P:System.Xml.XmlReader.ReadState" /> to <see langword="Closed" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Этот метод также освобождает все ресурсы, используемые при чтении. Если средство чтения создано с помощью потока, этот метод также вызывает `Close` базового потока.  
  
 Если `Close` уже был вызван, никакие действия не выполняются.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Depth">
      <MemberSignature Language="C#" Value="public override int Depth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Depth" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Depth" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Depth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int Depth { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Depth : int" Usage="System.Xml.XmlTextReader.Depth" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the depth of the current node in the XML document.</summary>
        <value>Глубина текущего узла в XML-документе.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
   
  
## Examples  
 В следующем примере отображается каждый узел, включая его глубину, номер строки и позиции строки.  
  
 [!code-cpp[XmlTextReader.LineNum#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.LineNum/CPP/readlinenum.cpp#1)]
 [!code-csharp[XmlTextReader.LineNum#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.LineNum/CS/readlinenum.cs#1)]
 [!code-vb[XmlTextReader.LineNum#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.LineNum/VB/readlinenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="DtdProcessing">
      <MemberSignature Language="C#" Value="public System.Xml.DtdProcessing DtdProcessing { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.DtdProcessing DtdProcessing" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.DtdProcessing" />
      <MemberSignature Language="VB.NET" Value="Public Property DtdProcessing As DtdProcessing" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::DtdProcessing DtdProcessing { System::Xml::DtdProcessing get(); void set(System::Xml::DtdProcessing value); };" />
      <MemberSignature Language="F#" Value="member this.DtdProcessing : System.Xml.DtdProcessing with get, set" Usage="System.Xml.XmlTextReader.DtdProcessing" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.DtdProcessing</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the <see cref="T:System.Xml.DtdProcessing" /> enumeration.</summary>
        <value>Перечисление <see cref="T:System.Xml.DtdProcessing" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Xml.DtdProcessing> Перечисление содержит <xref:System.Xml.DtdProcessing.Prohibit>, <xref:System.Xml.DtdProcessing.Ignore>, и <xref:System.Xml.DtdProcessing.Parse> перечислителей. <xref:System.Xml.DtdProcessing.Parse> значение по умолчанию. <xref:System.Xml.XmlTextReader.DtdProcessing%2A> Свойство заменяет `ProhibitDTD` свойство и добавляет возможность пропуска элемент DOCTYPE.  
  
> [!IMPORTANT]
>  Если <xref:System.Xml.XmlTextReader.DtdProcessing%2A> свойству <xref:System.Xml.DtdProcessing.Ignore?displayProperty=nameWithType>, <xref:System.Xml.XmlTextReader> не сообщают, что определения DTD. Это означает, что DTD и DOCTYPE будут потеряны при выводе.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Encoding">
      <MemberSignature Language="C#" Value="public System.Text.Encoding Encoding { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Text.Encoding Encoding" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Encoding" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Encoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Text::Encoding ^ Encoding { System::Text::Encoding ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Encoding : System.Text.Encoding" Usage="System.Xml.XmlTextReader.Encoding" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the encoding of the document.</summary>
        <value>Значение кодировки. Если атрибут кодировки и метка порядка байтов отсутствуют, по умолчанию используется кодировка UTF-8.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Поскольку <xref:System.Xml.XmlTextReader> использует <xref:System.Text.Encoding?displayProperty=nameWithType> класса `XmlTextReader` также поддерживают все кодировки, поддерживаемые этим классом. Исключением из этого является любая кодировка, например UTF-7 и EBCDIC, которая сопоставляет `<?xml` последовательности для различных байтовых значений, чем UTF-8.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EntityHandling">
      <MemberSignature Language="C#" Value="public System.Xml.EntityHandling EntityHandling { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.EntityHandling EntityHandling" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.EntityHandling" />
      <MemberSignature Language="VB.NET" Value="Public Property EntityHandling As EntityHandling" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::EntityHandling EntityHandling { System::Xml::EntityHandling get(); void set(System::Xml::EntityHandling value); };" />
      <MemberSignature Language="F#" Value="member this.EntityHandling : System.Xml.EntityHandling with get, set" Usage="System.Xml.XmlTextReader.EntityHandling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.EntityHandling</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that specifies how the reader handles entities.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Xml.EntityHandling" />. Если <see langword="EntityHandling" /> не задан, по умолчанию для него используется значение <see langword="EntityHandling.ExpandCharEntities" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это свойство можно изменить на лету и вступит в силу после следующего <xref:System.Xml.XmlTextReader.Read%2A> вызова.  
  
 Когда `EntityHandling` равно `ExpandCharEntities`, значения атрибутов нормализуются лишь частично. Средство чтения нормализует каждый отдельный текстовый узел независимо от содержимого соседних узлов.  
  
 Для демонстрации разницы между сущностью режимами обработки, рассмотрим следующий XML-код:  
  
```  
<!DOCTYPE doc [<!ENTITY num "123"]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public override bool EOF { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EOF" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.EOF" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property EOF As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool EOF { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.EOF : bool" Usage="System.Xml.XmlTextReader.EOF" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the reader is positioned at the end of the stream.</summary>
        <value>Значение <see langword="true" />, если средство чтения установлено в конец потока; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets the value of an attribute.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public override string GetAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.GetAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetAttribute (i As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetAttribute(int i);" />
      <MemberSignature Language="F#" Value="override this.GetAttribute : int -&gt; string" Usage="xmlTextReader.GetAttribute i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">The index of the attribute. The index is zero-based. (The first attribute has index 0.)</param>
        <summary>Gets the value of the attribute with the specified index.</summary>
        <returns>The value of the specified attribute.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Этот метод не изменяет позицию средства чтения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="i" /> parameter is less than 0 or greater than or equal to <see cref="P:System.Xml.XmlTextReader.AttributeCount" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public override string GetAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.GetAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetAttribute (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetAttribute : string -&gt; string" Usage="xmlTextReader.GetAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The qualified name of the attribute.</param>
        <summary>Gets the value of the attribute with the specified name.</summary>
        <returns>The value of the specified attribute. If the attribute is not found, <see langword="null" /> is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Этот метод не изменяет позицию средства чтения.  
  
 Если средство чтения расположено на `DocumentType` узел, этот метод можно использовать для получения констант PUBLIC и системы, например, `reader.GetAttribute("PUBLIC")`  
  
   
  
## Examples  
 Следующий пример возвращает значение атрибута ISBN.  
  
 [!code-cpp[Classic WebData XmlTextReader.GetAttribute1 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.GetAttribute1 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.GetAttribute1 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.GetAttribute1 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.GetAttribute1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.GetAttribute1 Example/VB/source.vb#1)]  
  
 В примере используется файл `attrs.xml`, в качестве входных данных.  
  
 [!code-xml[Classic WebData XmlTextReader.GetAttribute1 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.GetAttribute1 Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="GetAttribute">
      <MemberSignature Language="C#" Value="public override string GetAttribute (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string GetAttribute(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.GetAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetAttribute (localName As String, namespaceURI As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ GetAttribute(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="override this.GetAttribute : string * string -&gt; string" Usage="xmlTextReader.GetAttribute (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">The local name of the attribute.</param>
        <param name="namespaceURI">The namespace URI of the attribute.</param>
        <summary>Gets the value of the attribute with the specified local name and namespace URI.</summary>
        <returns>The value of the specified attribute. If the attribute is not found, <see langword="null" /> is returned. This method does not move the reader.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Следующий код XML содержит атрибут в определенном пространстве имен:  
  
```xml  
<test xmlns:dt="urn:datatypes" dt:type="int"/>  
```  
  
 Для поиска `dt:type` атрибут, используя один (префикс и локальное имя) или два аргумента (локальное имя и URI пространства имен):  
  
```csharp  
String dt = reader.GetAttribute("dt:type");  
String dt2 = reader.GetAttribute("type","urn:datatypes");  
```  
  
 Для уточняющего запроса `xmlns:dt` атрибут, используйте один из следующих аргументов:  
  
```csharp  
String dt3 = reader.GetAttribute("xmlns:dt");  
String dt4 = reader.GetAttribute("dt",http://www.w3.org/2000/xmlns/);  
```  
  
 Можно также получить эти сведения с помощью <xref:System.Xml.XmlTextReader.Prefix%2A> свойство.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="GetNamespacesInScope">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IDictionary&lt;string,string&gt; GetNamespacesInScope (System.Xml.XmlNamespaceScope scope);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IDictionary`2&lt;string, string&gt; GetNamespacesInScope(valuetype System.Xml.XmlNamespaceScope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.GetNamespacesInScope(System.Xml.XmlNamespaceScope)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNamespacesInScope (scope As XmlNamespaceScope) As IDictionary(Of String, String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ GetNamespacesInScope(System::Xml::XmlNamespaceScope scope);" />
      <MemberSignature Language="F#" Value="member this.GetNamespacesInScope : System.Xml.XmlNamespaceScope -&gt; System.Collections.Generic.IDictionary&lt;string, string&gt;" Usage="xmlTextReader.GetNamespacesInScope scope" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(System.Xml.XmlNamespaceScope)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Xml.XmlNamespaceScope" />
      </Parameters>
      <Docs>
        <param name="scope">An <see cref="T:System.Xml.XmlNamespaceScope" /> value that specifies the type of namespace nodes to return.</param>
        <summary>Gets a collection that contains all namespaces currently in-scope.</summary>
        <returns>An <see cref="T:System.Collections.IDictionary" /> object that contains all the current in-scope namespaces. If the reader is not positioned on an element, an empty dictionary (no namespaces) is returned.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Словарь состоит из коллекции имен пространств имен, отсортированных по префиксу. Он может использоваться для перечисления пространств имен в области видимости. Словарь является отключенной копией списка пространств имен средства чтения. Он остается неизменным при изменения текущего списка пространств имен в области видимости позиция средства чтения.  
  
 В следующей таблице описаны как <xref:System.Xml.XmlNamespaceScope> влияет на значение перечисления, будет ли или не по умолчанию и встроенные пространства имен возвращаются с <xref:System.Xml.XmlTextReader.GetNamespacesInScope%2A>.  
  
|Значение XmlNamespaceScope|xmlns: XML|xmlns:xmlns|xmlns =»»|  
|-----------------------------|---------------|-----------------|---------------|  
|`All`|да|Нет|Нет|  
|`ExcludeXml`|Нет|Нет|Нет|  
|`Local`|Нет|Нет|да|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="GetRemainder">
      <MemberSignature Language="C#" Value="public System.IO.TextReader GetRemainder ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IO.TextReader GetRemainder() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.GetRemainder" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRemainder () As TextReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IO::TextReader ^ GetRemainder();" />
      <MemberSignature Language="F#" Value="member this.GetRemainder : unit -&gt; System.IO.TextReader" Usage="xmlTextReader.GetRemainder " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextReader</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the remainder of the buffered XML.</summary>
        <returns>A <see cref="T:System.IO.TextReader" /> containing the remainder of the buffered XML.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Поскольку <xref:System.Xml.XmlTextReader> буферизованной `Read`, должен уметь получения остатка от неиспользуемую буфера, чтобы данные не теряются. Это позволяет протоколов (например, составное MIME) паковать XML в одном потоке с другими данными.  
  
 После вызова этого метода <xref:System.Xml.XmlTextReader.EOF%2A> равно `true`.  
  
   
  
## Examples  
 В следующем примере считывается первая часть XML-документ и затем использует `GetRemainder` для завершения чтения документа с помощью второго средства чтения.  
  
 [!code-cpp[Classic WebData XmlTextReader.GetRemainder Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.GetRemainder Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.GetRemainder Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.GetRemainder Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.GetRemainder Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.GetRemainder Example/VB/source.vb#1)]  
  
 В примере входного файла `tworeads.xml`.  
  
 [!code-xml[Classic WebData XmlTextReader.GetRemainder Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.GetRemainder Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="HasLineInfo">
      <MemberSignature Language="C#" Value="public bool HasLineInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool HasLineInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.HasLineInfo" />
      <MemberSignature Language="VB.NET" Value="Public Function HasLineInfo () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool HasLineInfo();" />
      <MemberSignature Language="F#" Value="abstract member HasLineInfo : unit -&gt; bool&#xA;override this.HasLineInfo : unit -&gt; bool" Usage="xmlTextReader.HasLineInfo " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlLineInfo.HasLineInfo</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets a value indicating whether the class can return line information.</summary>
        <returns>
          <see langword="true" /> if the class can return line information; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="HasValue">
      <MemberSignature Language="C#" Value="public override bool HasValue { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasValue" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.HasValue" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property HasValue As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool HasValue { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasValue : bool" Usage="System.Xml.XmlTextReader.HasValue" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the current node can have a <see cref="P:System.Xml.XmlTextReader.Value" /> other than <see langword="String.Empty" />.</summary>
        <value>Значение <see langword="true" />, если узел, на котором расположено средство чтения, может иметь значение <see langword="Value" />; в противном случае — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 В следующей таблице представлен список возвращаемых типов узлов со значениями.  
  
|Тип узла|Значение|  
|---------------|-----------|  
|`Attribute`|Значение атрибута.|  
|`CDATA`|Содержимое раздела CDATA.|  
|`Comment`|Содержимое комментария.|  
|`DocumentType`|Внутреннее подмножество.|  
|`ProcessingInstruction`|Все содержимое, за исключением цели.|  
|`SignificantWhitespace`|Пробел между элементами разметки в модели смешанного содержимого.|  
|`Text`|Содержимое текстового узла.|  
|`Whitespace`|Пробелы между разметкой.|  
|`XmlDeclaration`|Содержимое декларации.|  
  
   
  
## Examples  
 Следующий пример отображает значение для каждого узла, который может иметь значение.  
  
 [!code-cpp[Classic WebData XmlTextReader.HasValue Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.HasValue Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.HasValue Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.HasValue Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.HasValue Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.HasValue Example/VB/source.vb#1)]  
  
 В примере используется файл `book1.xml`, в качестве входных данных.  
  
 [!code-xml[Classic WebData XmlTextReader.HasValue Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.HasValue Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="IsDefault">
      <MemberSignature Language="C#" Value="public override bool IsDefault { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDefault" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.IsDefault" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsDefault As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDefault { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDefault : bool" Usage="System.Xml.XmlTextReader.IsDefault" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the current node is an attribute that was generated from the default value defined in the DTD or schema.</summary>
        <value>Данное свойство всегда возвращает значение <see langword="false" />. (<see cref="T:System.Xml.XmlTextReader" /> не расширяет атрибуты по умолчанию).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это свойство применимо только к узлам атрибутов.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="IsEmptyElement">
      <MemberSignature Language="C#" Value="public override bool IsEmptyElement { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmptyElement" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.IsEmptyElement" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsEmptyElement As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEmptyElement { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmptyElement : bool" Usage="System.Xml.XmlTextReader.IsEmptyElement" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the current node is an empty element (for example, <c>&lt;MyElement/&gt;</c>).</summary>
        <value>
          <see langword="true" /> Если текущий узел является элементом (<see cref="P:System.Xml.XmlTextReader.NodeType" /> равняется <see langword="XmlNodeType.Element" />), заканчивается <c> / &gt; </c>; в противном случае <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это свойство позволяет определить разницу между:  
  
 `<item num="123"/>` (`IsEmptyElement` — `true`).  
  
 `<item num="123">` (`IsEmptyElement` — `false`, несмотря на то, что содержимое элемента является пустым).  
  
 Соответствующий `EndElement` узел для пустых элементов не создается.  
  
 `IsEmptyElement` просто сообщает, является ли элемент в исходном документе конечный тег элемента.  
  
   
  
## Examples  
 Следующий пример отображает текстовое содержимое каждого элемента.  
  
 [!code-cpp[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/VB/source.vb#1)]  
  
 В примере используется файл `elems.xml`, в качестве входных данных.  
  
 [!code-xml[Classic WebData XmlReader.IsStartElement Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="LineNumber">
      <MemberSignature Language="C#" Value="public int LineNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LineNumber" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.LineNumber" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LineNumber As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LineNumber { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LineNumber : int" Usage="System.Xml.XmlTextReader.LineNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Xml.IXmlLineInfo.LineNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the current line number.</summary>
        <value>Текущий номер строки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это свойство чаще всего используется для отчетов об ошибках, но можно вызвать в любое время. Начальное значение для этого свойства равно `1`.  
  
 В сочетании с <xref:System.Xml.XmlTextReader.LinePosition%2A>, значение `1,1` указывает на начало документа.  
  
   
  
## Examples  
 В следующем примере отображается каждый узел, включая его глубину, номер строки и позиции строки.  
  
 [!code-cpp[XmlTextReader.LineNum#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.LineNum/CPP/readlinenum.cpp#1)]
 [!code-csharp[XmlTextReader.LineNum#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.LineNum/CS/readlinenum.cs#1)]
 [!code-vb[XmlTextReader.LineNum#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.LineNum/VB/readlinenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="LinePosition">
      <MemberSignature Language="C#" Value="public int LinePosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 LinePosition" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.LinePosition" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LinePosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int LinePosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.LinePosition : int" Usage="System.Xml.XmlTextReader.LinePosition" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Xml.IXmlLineInfo.LinePosition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the current line position.</summary>
        <value>Позиция в текущей строке.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это свойство чаще всего используется для отчетов об ошибках, но можно вызвать в любое время. Начальным значением свойства является `1`.  
  
 Указанное положение — первый символ текста в разметке.  
  
```  
<root>  
abc<tag/>  
</root>  
```  
  
 В первой строке текста XML `LinePosition` из `2` соответствует символу `r`; во второй строке `LinePosition` из `5` соответствует символу `t`; а в третьей строке `LinePosition` из `3` соответствует символу `r`.  
  
 В сочетании с <xref:System.Xml.XmlTextReader.LineNumber%2A>, значение `1,1` указывает на начало документа.  
  
   
  
## Examples  
 В следующем примере отображается каждый узел, включая его глубину, номер строки и позиции строки.  
  
 [!code-cpp[XmlTextReader.LineNum#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.LineNum/CPP/readlinenum.cpp#1)]
 [!code-csharp[XmlTextReader.LineNum#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.LineNum/CS/readlinenum.cs#1)]
 [!code-vb[XmlTextReader.LineNum#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.LineNum/VB/readlinenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="LocalName">
      <MemberSignature Language="C#" Value="public override string LocalName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string LocalName" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.LocalName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property LocalName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ LocalName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalName : string" Usage="System.Xml.XmlTextReader.LocalName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the local name of the current node.</summary>
        <value>Имя текущего узла с удаленным префиксом. Например <see langword="LocalName" /> — <see langword="book" /> для элемента <c> &lt;bk: book&gt;</c>.  Для безымянных типов узлов (например, <see langword="Text" />, <see langword="Comment" /> и т. д.) данное свойство возвращает <see langword="String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
   
  
## Examples  
 В следующем примере отображается локальное имя каждого узла и, если они существуют, префикс и URI пространства имен.  
  
 [!code-cpp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/VB/source.vb#1)]  
  
 В примере используется файл `book2.xml`, в качестве входных данных.  
  
 [!code-xml[Classic WebData XmlTextReader.LocalName Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="LookupNamespace">
      <MemberSignature Language="C#" Value="public override string LookupNamespace (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string LookupNamespace(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.LookupNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function LookupNamespace (prefix As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ LookupNamespace(System::String ^ prefix);" />
      <MemberSignature Language="F#" Value="override this.LookupNamespace : string -&gt; string" Usage="xmlTextReader.LookupNamespace prefix" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.LookupNamespace(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">The prefix whose namespace URI you want to resolve. To match the default namespace, pass an empty string. This string does not have to be atomized.</param>
        <summary>Resolves a namespace prefix in the current element's scope.</summary>
        <returns>The namespace URI to which the prefix maps or <see langword="null" /> if no matching prefix is found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 В следующем XML, если средство чтения расположено на `href` атрибут префикс `a` разрешается путем вызова `reader.LookupNamespace("a")`. Возвращаемая строка является `urn:456`.  
  
```xml  
<root xmlns:a="urn:456">  
 <item>  
 <ref href="a:b"/>  
 </item>  
</root>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <see cref="P:System.Xml.XmlTextReader.Namespaces" /> property is set to <see langword="true" /> and the <paramref name="prefix" /> value is <see langword="null" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveToAttribute">
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Moves to the specified attribute.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public override void MoveToAttribute (int i);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void MoveToAttribute(int32 i) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToAttribute(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub MoveToAttribute (i As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void MoveToAttribute(int i);" />
      <MemberSignature Language="F#" Value="override this.MoveToAttribute : int -&gt; unit" Usage="xmlTextReader.MoveToAttribute i" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="i" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="i">The index of the attribute.</param>
        <summary>Moves to the attribute with the specified index.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
   
  
## Examples  
 Следующий пример отображает все атрибуты на текущем узле.  
  
 [!code-cpp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="i" /> parameter is less than 0 or greater than or equal to <see cref="P:System.Xml.XmlReader.AttributeCount" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public override bool MoveToAttribute (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToAttribute(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToAttribute(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToAttribute (name As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToAttribute(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.MoveToAttribute : string -&gt; bool" Usage="xmlTextReader.MoveToAttribute name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">The qualified name of the attribute.</param>
        <summary>Moves to the attribute with the specified name.</summary>
        <returns>
          <see langword="true" /> if the attribute is found; otherwise, <see langword="false" />. If <see langword="false" />, the reader's position does not change.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 После вызова метода `MoveToAttribute`, <xref:System.Xml.XmlTextReader.Name%2A>, <xref:System.Xml.XmlTextReader.NamespaceURI%2A>, и <xref:System.Xml.XmlTextReader.Prefix%2A> свойства отражает свойства этого атрибута.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="MoveToAttribute">
      <MemberSignature Language="C#" Value="public override bool MoveToAttribute (string localName, string namespaceURI);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToAttribute(string localName, string namespaceURI) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToAttribute(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToAttribute (localName As String, namespaceURI As String) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToAttribute(System::String ^ localName, System::String ^ namespaceURI);" />
      <MemberSignature Language="F#" Value="override this.MoveToAttribute : string * string -&gt; bool" Usage="xmlTextReader.MoveToAttribute (localName, namespaceURI)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localName" Type="System.String" />
        <Parameter Name="namespaceURI" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="localName">The local name of the attribute.</param>
        <param name="namespaceURI">The namespace URI of the attribute.</param>
        <summary>Moves to the attribute with the specified local name and namespace URI.</summary>
        <returns>
          <see langword="true" /> if the attribute is found; otherwise, <see langword="false" />. If <see langword="false" />, the reader's position does not change.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 После вызова метода `MoveToAttribute`, <xref:System.Xml.XmlTextReader.Name%2A>, <xref:System.Xml.XmlTextReader.NamespaceURI%2A>, и <xref:System.Xml.XmlTextReader.Prefix%2A> свойства отражает свойства этого атрибута.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="MoveToElement">
      <MemberSignature Language="C#" Value="public override bool MoveToElement ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToElement() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToElement" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToElement () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToElement();" />
      <MemberSignature Language="F#" Value="override this.MoveToElement : unit -&gt; bool" Usage="xmlTextReader.MoveToElement " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Moves to the element that contains the current attribute node.</summary>
        <returns>
          <see langword="true" /> if the reader is positioned on an attribute (the reader moves to the element that owns the attribute); <see langword="false" /> if the reader is not positioned on an attribute (the position of the reader does not change).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Используйте этот метод для возврата элемента после просмотра его атрибутов. Этот метод перемещает средство чтения к одному из следующих типов узлов: `Element`, `DocumentType`, или `XmlDeclaration`.  
  
   
  
## Examples  
 Следующий пример отображает все атрибуты на текущем узле.  
  
 [!code-cpp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.MoveToElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToElement Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="MoveToFirstAttribute">
      <MemberSignature Language="C#" Value="public override bool MoveToFirstAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToFirstAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToFirstAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToFirstAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToFirstAttribute();" />
      <MemberSignature Language="F#" Value="override this.MoveToFirstAttribute : unit -&gt; bool" Usage="xmlTextReader.MoveToFirstAttribute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Moves to the first attribute.</summary>
        <returns>
          <see langword="true" /> if an attribute exists (the reader moves to the first attribute); otherwise, <see langword="false" /> (the position of the reader does not change).</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
   
  
## Examples  
 Следующий пример возвращает значение первого атрибута корневого узла.  
  
 [!code-cpp[Classic WebData XmlTextReader.MoveToFirstAttribute Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToFirstAttribute Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.MoveToFirstAttribute Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToFirstAttribute Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.MoveToFirstAttribute Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToFirstAttribute Example/VB/source.vb#1)]  
  
 В примере используется файл `attrs.xml`, в качестве входных данных.  
  
 [!code-xml[Classic WebData XmlTextReader.MoveToFirstAttribute Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.MoveToFirstAttribute Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="MoveToNextAttribute">
      <MemberSignature Language="C#" Value="public override bool MoveToNextAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool MoveToNextAttribute() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.MoveToNextAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function MoveToNextAttribute () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool MoveToNextAttribute();" />
      <MemberSignature Language="F#" Value="override this.MoveToNextAttribute : unit -&gt; bool" Usage="xmlTextReader.MoveToNextAttribute " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Moves to the next attribute.</summary>
        <returns>
          <see langword="true" /> if there is a next attribute; <see langword="false" /> if there are no more attributes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Если текущий узел является узлом элемента, этот метод эквивалентен <xref:System.Xml.XmlTextReader.MoveToFirstAttribute%2A>. Если `MoveToNextAttribute` возвращает `true`, средство чтения перемещается к следующему атрибуту; в противном случае позиция средства чтения не изменяется.  
  
   
  
## Examples  
 Следующий пример отображает все атрибуты на текущем узле.  
  
 [!code-cpp[Classic WebData XmlReader.HasAttributes Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.HasAttributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.HasAttributes Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.HasAttributes Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.HasAttributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.HasAttributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Xml.XmlTextReader.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the qualified name of the current node.</summary>
        <value>Полное имя текущего узла. Например <see langword="Name" /> — <see langword="bk:book" /> для элемента <c> &lt;bk: book&gt;</c>.  Возвращаемое имя зависит от значения свойства <see cref="P:System.Xml.XmlTextReader.NodeType" /> узла. Значения возвращаются для представленных ниже типов узлов. Для других типов узлов возвращается пустая строка.  
  
 <list type="table"><listheader><term> Тип узла </term><description> имя </description></listheader><item><term><see langword="Attribute" /></term><description> имя атрибута.  </description></item><item><term><see langword="DocumentType" /></term><description> Имя типа документа.  </description></item><item><term><see langword="Element" /></term><description> Имя тега.  </description></item><item><term><see langword="EntityReference" /></term><description> Имя ссылки на сущность.  </description></item><item><term><see langword="ProcessingInstruction" /></term><description> Цель инструкции по обработке.  </description></item><item><term><see langword="XmlDeclaration" /></term><description> Строковый литерал <see langword="xml" />.  </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
   
  
## Examples  
 В следующем примере считывает XML-файла и отображение каждого из узлов.  
  
 [!code-cpp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/VB/source.vb#1)]  
  
 В образце используется файл `items.xml`.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Namespaces">
      <MemberSignature Language="C#" Value="public bool Namespaces { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Namespaces" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Namespaces" />
      <MemberSignature Language="VB.NET" Value="Public Property Namespaces As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Namespaces { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Namespaces : bool with get, set" Usage="System.Xml.XmlTextReader.Namespaces" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether to do namespace support.</summary>
        <value>Значение <see langword="true" /> — поддержка осуществляется; в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это свойство определяет, поддерживает ли средство чтения пространства имен W3C в рекомендации XML, расположенной по www.w3.org/TR/REC-xml-names.  
  
 `Namespaces` Свойство нельзя изменить после операции чтения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Setting this property after a read operation has occurred (<see cref="P:System.Xml.XmlTextReader.ReadState" /> is not <see langword="ReadState.Initial" />).</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="NamespaceURI">
      <MemberSignature Language="C#" Value="public override string NamespaceURI { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string NamespaceURI" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.NamespaceURI" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NamespaceURI As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ NamespaceURI { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NamespaceURI : string" Usage="System.Xml.XmlTextReader.NamespaceURI" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the namespace URI (as defined in the W3C Namespace specification) of the node on which the reader is positioned.</summary>
        <value>URI пространства имен текущего узла; в противном случае — пустая строка.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это свойство применимо к `Element` и `Attribute` только узлы.  
  
   
  
## Examples  
 В следующем примере отображается локальное имя каждого узла и, если они существуют, префикс и URI пространства имен.  
  
 [!code-cpp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/VB/source.vb#1)]  
  
 В примере используется файл `book2.xml`, в качестве входных данных.  
  
 [!code-xml[Classic WebData XmlTextReader.LocalName Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="NameTable">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNameTable NameTable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlNameTable NameTable" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.NameTable" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NameTable As XmlNameTable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNameTable ^ NameTable { System::Xml::XmlNameTable ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NameTable : System.Xml.XmlNameTable" Usage="System.Xml.XmlTextReader.NameTable" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNameTable</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the <see cref="T:System.Xml.XmlNameTable" /> associated with this implementation.</summary>
        <value>
          <see langword="XmlNameTable" />, позволяющий получать в узле разделенную версию строки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Возвращаются все имена узлов и атрибутов из <xref:System.Xml.XmlTextReader> , разделены с помощью `NameTable`. Если то же имя возвращается несколько раз (например, `Customer`), затем же `String` объект возвращается для этого имени. Это позволяет писать эффективный код, выполняющий сравнения строк, вместо сравнения строк дорогих объектов.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlNameTable" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Xml.XmlNodeType" Usage="System.Xml.XmlTextReader.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the type of the current node.</summary>
        <value>Одно из значений <see cref="T:System.Xml.XmlNodeType" />, предоставляющее тип текущего узла.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это свойство не возвращает следующие `XmlNodeType` типов: `Document`, `DocumentFragment`, `Entity`, `EndEntity`, или `Notation`.  
  
   
  
## Examples  
 В следующем примере считывает XML-файла и отображение каждого из узлов.  
  
 [!code-cpp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/VB/source.vb#1)]  
  
 В образце используется файл `items.xml`.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Normalization">
      <MemberSignature Language="C#" Value="public bool Normalization { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Normalization" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Normalization" />
      <MemberSignature Language="VB.NET" Value="Public Property Normalization As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Normalization { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Normalization : bool with get, set" Usage="System.Xml.XmlTextReader.Normalization" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether to normalize white space and attribute values.</summary>
        <value>Значение <see langword="true" /> для нормализации; в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это свойство можно изменить в любое время и вступает в силу следующая операция чтения.  
  
> [!NOTE]
>  Если <xref:System.Xml.XmlTextReader> используется для создания <xref:System.Xml.XmlValidatingReader>, для нормализации значений атрибутов, `Normalization` должно быть присвоено `true`.  
  
 Если `Normalization` имеет значение `false`, это также отключает проверку диапазона символов для числовых сущностей. В результате сущности-символы, такие как `&#0;`, разрешены.  
  
 Ниже описаны нормализация значений атрибутов.  
  
-   Для символьной ссылки символ, на который указывает ссылка, добавляется к значению атрибута.  
  
-   Для ссылки на сущность рекурсивно обрабатывается заменяемый текст этой сущности.  
  
-   Для символы пробелов (#x 20, #xD, #xA, #x 9) добавьте #x 20 к нормализованному значению. (Только один #x 20 добавляется последовательности «#xD #xA», которая является частью анализируемой внешней сущности или значение литерала entity внутренней разбора).  
  
-   Остальные символы обрабатываются путем добавления их к нормализованному значению.  
  
-   Если объявленный значение не CDATA, отменить все начальные и конечные знаки пространства (#x20) и замените последовательности пробелов (#x20) (#x20) с одним пробельным символом.  
  
 `XmlTextReader` Выполняет только атрибут или нормализации CDATA. Не выполняет нормализации конкретного DTD Если це `XmlValidatingReader`.  
  
 См. Дополнительные сведения о нормализации рекомендации W3C XML 1.0.  
  
   
  
## Examples  
 В следующем примере показано поведение средства чтения с нормализацией включен и отключении.  
  
 [!code-cpp[XmlTextReader.Normalization#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.Normalization/CPP/readnormal.cpp#1)]
 [!code-csharp[XmlTextReader.Normalization#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.Normalization/CS/readnormal.cs#1)]
 [!code-vb[XmlTextReader.Normalization#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.Normalization/VB/readnormal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Setting this property when the reader is closed (<see cref="P:System.Xml.XmlTextReader.ReadState" /> is <see langword="ReadState.Closed" />).</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Prefix">
      <MemberSignature Language="C#" Value="public override string Prefix { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Prefix" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Prefix" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Prefix As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Prefix { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Prefix : string" Usage="System.Xml.XmlTextReader.Prefix" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the namespace prefix associated with the current node.</summary>
        <value>Префикс пространства имен, связанный с текущим узлом.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
   
  
## Examples  
 В следующем примере отображается локальное имя каждого узла и, если они существуют, префикс и URI пространства имен.  
  
 [!code-cpp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.LocalName Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/VB/source.vb#1)]  
  
 В примере используется файл `book2.xml`, в качестве входных данных.  
  
 [!code-xml[Classic WebData XmlTextReader.LocalName Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.LocalName Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ProhibitDtd">
      <MemberSignature Language="C#" Value="public bool ProhibitDtd { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ProhibitDtd" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.ProhibitDtd" />
      <MemberSignature Language="VB.NET" Value="Public Property ProhibitDtd As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ProhibitDtd { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ProhibitDtd : bool with get, set" Usage="System.Xml.XmlTextReader.ProhibitDtd" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use DtdProcessing property instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value indicating whether to allow DTD processing. This property is obsolete. Use <see cref="P:System.Xml.XmlTextReader.DtdProcessing" /> instead.</summary>
        <value>Значение <see langword="true" /> для отключения обработки DTD; в противном случае — <see langword="false" />. Значение по умолчанию — <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Обработка DTD включена по умолчанию для обеспечения обратной совместимости. Однако если приложение не требует обработки DTD, следует отключить этот параметр. Отключение обработки DTD может быть полезным для предотвращения некоторых разновидностей атак типа «отказ в обслуживании». Если значение `true`, модуль чтения создает <xref:System.Xml.XmlException> при обнаружении содержимого DTD.  
  
 Если обработка DTD включена, необходимо знать последствия включения DTD из ненадежных источников и возможную атаку отказа в обслуживании. Используйте <xref:System.Xml.XmlSecureResolver> для ограничения ресурсов, <xref:System.Xml.XmlTextReader> доступен. Кроме того, можно создать собственное приложение, ограничивающее объем памяти и время, выделяемое на обработку XML. Например можно ограничить время ожидания в приложении ASP.NET  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="QuoteChar">
      <MemberSignature Language="C#" Value="public override char QuoteChar { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance char QuoteChar" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.QuoteChar" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property QuoteChar As Char" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property char QuoteChar { char get(); };" />
      <MemberSignature Language="F#" Value="member this.QuoteChar : char" Usage="System.Xml.XmlTextReader.QuoteChar" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the quotation mark character used to enclose the value of an attribute node.</summary>
        <value>Знак кавычек (" или ') для выделения значения узла атрибута.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это свойство применимо только к узлам атрибутов.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public override bool Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.Read" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Read () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Read();" />
      <MemberSignature Language="F#" Value="override this.Read : unit -&gt; bool" Usage="xmlTextReader.Read " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reads the next node from the stream.</summary>
        <returns>
          <see langword="true" /> if the next node was read successfully; <see langword="false" /> if there are no more nodes to read.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Если средство чтения сначала создается и инициализируется, нет сведения недоступны. Необходимо вызвать метод `Read` для чтения первого узла.  
  
 Этот метод требует по крайней мере четыре байта из потока данных, чтобы начать анализ. Если возвращено менее четырех байтов и в потоке нет дополнительных данных, метод завершится с ошибкой. Если в потоке данных, метод остановит анализ до получения четвертого байта.  
  
   
  
## Examples  
 В следующем примере считывает XML-файла и отображение каждого узла.  
  
 [!code-cpp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/VB/source.vb#1)]  
  
 В образце используется файл `items.xml`.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">An error occurred while parsing the XML.</exception>
        <altmember cref="T:System.Xml.EntityHandling" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ReadAttributeValue">
      <MemberSignature Language="C#" Value="public override bool ReadAttributeValue ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool ReadAttributeValue() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadAttributeValue" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadAttributeValue () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool ReadAttributeValue();" />
      <MemberSignature Language="F#" Value="override this.ReadAttributeValue : unit -&gt; bool" Usage="xmlTextReader.ReadAttributeValue " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Parses the attribute value into one or more <see langword="Text" />, <see langword="EntityReference" />, or <see langword="EndEntity" /> nodes.</summary>
        <returns>
          <see langword="true" /> if there are nodes to return.  
  
 <see langword="false" /> if the reader is not positioned on an attribute node when the initial call is made or if all the attribute values have been read.  An empty attribute, such as, <c>misc=""</c>, returns <see langword="true" /> with a single node with a value of <see langword="String.Empty" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Используйте этот метод после вызова `MoveToAttribute` прочитать текст или сущности ссылки узлы, которые составляют значение атрибута. <xref:System.Xml.XmlReader.Depth%2A> Узлов значение атрибута равно единице плюс глубина узла атрибута; оно увеличивается или уменьшается на единицу при переходах по ссылкам на основную сущность.  
  
   
  
## Examples  
 В следующем примере считывается атрибут с текстом и узлов сущностей.  
  
 [!code-cpp[XmlTextReader.ReadAttributeValue#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.ReadAttributeValue/CPP/readattrval.cpp#1)]
 [!code-csharp[XmlTextReader.ReadAttributeValue#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.ReadAttributeValue/CS/readattrval.cs#1)]
 [!code-vb[XmlTextReader.ReadAttributeValue#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.ReadAttributeValue/VB/readattrval.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ReadBase64">
      <MemberSignature Language="C#" Value="public int ReadBase64 (byte[] array, int offset, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadBase64(unsigned int8[] array, int32 offset, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadBase64 (array As Byte(), offset As Integer, len As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadBase64(cli::array &lt;System::Byte&gt; ^ array, int offset, int len);" />
      <MemberSignature Language="F#" Value="member this.ReadBase64 : byte[] * int * int -&gt; int" Usage="xmlTextReader.ReadBase64 (array, offset, len)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">The array of characters that serves as the buffer to which the text contents are written.</param>
        <param name="offset">The zero-based index into the array specifying where the method can begin to write to the buffer.</param>
        <param name="len">The number of bytes to write into the buffer.</param>
        <summary>Decodes Base64 and returns the decoded binary bytes.</summary>
        <returns>The number of bytes written to the buffer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Как <xref:System.Xml.XmlTextReader.ReadChars%2A>, этот метод можно вызывать повторно для чтения больших потоков внедренного текста. Данный метод декодирует содержимое Base64 и возвращает раскодированные двоичные байты (например, встроенный Base64 закодированный в формате GIF) в буфер. См. в RFC 1521. (Вы можете получить RFC с [запроса веб-сайте](https://www.rfc-editor.org).)  
  
   
  
## Examples  
 В следующем примере считывается файл, содержащий данные Base64 и BinHex.  
  
 [!code-cpp[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/VB/source.vb#1)]  
  
 В образце используется файл `binary.xml`  
  
 [!code-xml[Classic WebData XmlTextReader.ReadBase64 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">The Base64 sequence is not valid.</exception>
        <exception cref="T:System.ArgumentNullException">The value of <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> &lt; 0, or <paramref name="len" /> &lt; 0, or <paramref name="len" /> &gt; <paramref name="array" />.Length- <paramref name="offset" />.</exception>
        <altmember cref="M:System.Xml.XmlTextWriter.WriteBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ReadBinHex">
      <MemberSignature Language="C#" Value="public int ReadBinHex (byte[] array, int offset, int len);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadBinHex(unsigned int8[] array, int32 offset, int32 len) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadBinHex (array As Byte(), offset As Integer, len As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadBinHex(cli::array &lt;System::Byte&gt; ^ array, int offset, int len);" />
      <MemberSignature Language="F#" Value="member this.ReadBinHex : byte[] * int * int -&gt; int" Usage="xmlTextReader.ReadBinHex (array, offset, len)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="len" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">The byte array that serves as the buffer to which the decoded binary bytes are written.</param>
        <param name="offset">The zero-based index into the array specifying where the method can begin to write to the buffer.</param>
        <param name="len">The number of bytes to write into the buffer.</param>
        <summary>Decodes <see langword="BinHex" /> and returns the decoded binary bytes.</summary>
        <returns>The number of bytes written to your buffer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Как <xref:System.Xml.XmlTextReader.ReadChars%2A>, этот метод можно вызывать повторно для чтения больших потоков внедренного текста. Декодирует его `BinHex` содержимое и возвращает раскодированные двоичные байты (например, встроенный `BinHex` рисунок в формате GIF) в буфер.  
  
   
  
## Examples  
 В следующем примере считывается файл, содержащий `Base64` и `BinHex` данных.  
  
 [!code-cpp[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.ReadBase64 Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/VB/source.vb#1)]  
  
 В образце используется файл `binary.xml`  
  
 [!code-xml[Classic WebData XmlTextReader.ReadBase64 Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.ReadBase64 Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">The <see langword="BinHex" /> sequence is not valid.</exception>
        <exception cref="T:System.ArgumentNullException">The value of <paramref name="array" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="offset" /> &lt; 0, or <paramref name="len" /> &lt; 0, or <paramref name="len" /> &gt; <paramref name="array" />.Length- <paramref name="offset" />.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ReadChars">
      <MemberSignature Language="C#" Value="public int ReadChars (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReadChars(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadChars(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadChars (buffer As Char(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReadChars(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="member this.ReadChars : char[] * int * int -&gt; int" Usage="xmlTextReader.ReadChars (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">The array of characters that serves as the buffer to which the text contents are written.</param>
        <param name="index">The position within <c>buffer</c> where the method can begin writing text contents.</param>
        <param name="count">The number of characters to write into <c>buffer</c>.</param>
        <summary>Reads the text contents of an element into a character buffer. This method is designed to read large streams of embedded text by calling it successively.</summary>
        <returns>The number of characters read. This can be <see langword="0" /> if the reader is not positioned on an element or if there is no more text content to return in the current context.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это наиболее эффективный способ обработки очень больших потоков внедренного текста в XML-документа. Вместо распределения больших строковых объектов `ReadChars` возвращает содержимое текстового буфера за один раз. Этот метод предназначен для работы только с узлами элементов. Прочие типы узлов Причина `ReadChars` для возврата `0`.  
  
 В следующем XML, если модуль чтения располагается в открывающем теге `ReadChars` возвращает `test` и перемещает средство чтения после закрывающего тега.  
  
```xml  
<Item>test</Item>  
```  
  
 `ReadChars` имеет следующие функциональные возможности:  
  
-   Этот метод предназначен для работы только с узлами элементов. Прочие типы узлов Причина `ReadChars` возвращает значение 0.  
  
-   Этот метод возвращает фактическое содержимое символа. Нет не выполняется разрешение сущностей, CDATA или другой разметки. `ReadChars` Возвращает содержимое между открывающим и закрывающий тег, включая разметку.  
  
-   `ReadChars` пропускает XML-разметку, которая не является правильным. Например, при чтении следующую строку XML `<A>1<A>2</A>`, `ReadChars` возвращает `1<A>2</A>`. (Он возвращает разметку из соответствующей пары элементов и игнорирует другие.)  
  
-   Этот метод не выполняет нормализацию.  
  
-   Когда `ReadChars` достиг конца потока символов, то возвращается значение 0 и средство чтения расположено после закрывающего тега.  
  
-   Атрибут чтения методы недоступны при использовании `ReadChars`.  
  
 Например используя следующий XML-код:  
  
```xml  
<thing>  
 some text  
</thing>  
<item>  
</item>  
```  
  
 Средство чтения расположено на `<item>` элемент в конце цикла.  
  
```csharp  
if (XmlNodeType.Element == reader.NodeType && "thing" == reader.Name)  
{  
 while(0 != reader.ReadChars(buffer, 0, 1)  
 {  
 // Do something.  
 // Attribute values are not available at this point.  
 }  
}  
```  
  
   
  
## Examples  
 В следующем примере считывается в XML с помощью `ReadChars`.  
  
 [!code-cpp[Classic WebData XmlTextReader.ReadChars Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadChars Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.ReadChars Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.ReadChars Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.ReadChars Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.ReadChars Example/VB/source.vb#1)]  
  
 В примере в качестве входных данных используется файл `items.xml`.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="count" /> is greater than the space specified in the <paramref name="buffer" /> (buffer size - <paramref name="index" />).</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> value is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="index" />
          <see langword="&lt; 0" /> or <paramref name="count" /><see langword="&lt; 0" />.</exception>
        <altmember cref="M:System.Xml.XmlTextReader.ReadBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="M:System.Xml.XmlTextReader.ReadBinHex(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBase64">
      <MemberSignature Language="C#" Value="public override int ReadContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadContentAsBase64 : byte[] * int * int -&gt; int" Usage="xmlTextReader.ReadContentAsBase64 (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />.</param>
        <param name="index">The offset into the buffer where to start copying the result.</param>
        <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
        <summary>Reads the content and returns the <see langword="Base64" /> decoded binary bytes.</summary>
        <returns>The number of bytes written to the buffer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Этот метод создает поток содержимого, декодирует `Base64` содержимое и возвращает раскодированные двоичные байты (например, встроенный `Base64`-рисунок в формате GIF) в буфер. Этот метод можно вызывать повторно для чтения больших потоков внедренного текста. Дополнительные сведения см. в разделе RFC 1521 «часть MIME (Multipurpose Internet Mail Extensions) одной: механизмы для определения и описания формата тел сообщений Интернета». Вы можете получить RFC с [запроса веб-сайте](https://www.rfc-editor.org).  
  
> [!NOTE]
>  Вы не должны работать с любого из свойств чтения между вызовами <xref:System.Xml.XmlTextReader.ReadContentAsBase64%2A> метода, метод возвращает значение 0.  
  
 Этот метод имеет следующие особенности:  
  
-   <xref:System.Xml.XmlTextReader.ReadContentAsBase64%2A> Возвращает значение 0 по достижении конца потока байтов, которым проводится на. Средство чтения находится на первом узле без содержимого.  
  
-   Если указать меньшее или точное число байтов, остающихся в потоке средство чтения остается в текущей позиции.  
  
-   <xref:System.Xml.XmlTextReader.ReadContentAsBase64%2A> не поддерживается для следующих типов узлов XML: `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation`, `Entity`, `DocumentFragment`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> value is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Xml.XmlTextReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" /> is not supported in the current node.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The index into the buffer or index + count is larger than the allocated buffer size.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlTextReader.ReadContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadContentAsBinHex">
      <MemberSignature Language="C#" Value="public override int ReadContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadContentAsBinHex : byte[] * int * int -&gt; int" Usage="xmlTextReader.ReadContentAsBinHex (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />.</param>
        <param name="index">The offset into the buffer where to start copying the result.</param>
        <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
        <summary>Reads the content and returns the <see langword="BinHex" /> decoded binary bytes.</summary>
        <returns>The number of bytes written to the buffer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Этот метод создает поток содержимого, декодирует `BinHex` содержимое и возвращает раскодированные двоичные байты (например, встроенный `BinHex` рисунок в формате GIF) в буфер. Этот метод можно вызывать повторно для чтения больших потоков внедренного текста.  
  
> [!NOTE]
>  Вы не должны работать с любого из свойств чтения между вызовами <xref:System.Xml.XmlTextReader.ReadContentAsBinHex%2A> метода, метод возвращает значение 0.  
  
 Этот метод имеет следующие особенности:  
  
-   <xref:System.Xml.XmlTextReader.ReadContentAsBinHex%2A> Возвращает значение 0 по достижении конца потока байтов, которым проводится на. Средство чтения находится на первом узле без содержимого.  
  
-   Если указать меньшее или точное число байтов, остающихся в потоке средство чтения остается в текущей позиции.  
  
-   <xref:System.Xml.XmlTextReader.ReadContentAsBinHex%2A> не поддерживается для следующих типов узлов XML: `Element`, `XmlDeclaration`, `None`, `Document`, `DocumentType`, `Notation`, `Entity`, `DocumentFragment`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> value is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <see cref="M:System.Xml.XmlTextReader.ReadContentAsBinHex(System.Byte[],System.Int32,System.Int32)" /> is not supported on the current node.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The index into the buffer or index + count is larger than the allocated buffer size.</exception>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XmlTextReader" /> implementation does not support this method.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlTextReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
        <altmember cref="T:System.Xml.XmlNodeType" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBase64">
      <MemberSignature Language="C#" Value="public override int ReadElementContentAsBase64 (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadElementContentAsBase64(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadElementContentAsBase64 (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadElementContentAsBase64(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadElementContentAsBase64 : byte[] * int * int -&gt; int" Usage="xmlTextReader.ReadElementContentAsBase64 (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />.</param>
        <param name="index">The offset into the buffer where to start copying the result.</param>
        <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
        <summary>Reads the element and decodes the Base64 content.</summary>
        <returns>The number of bytes written to the buffer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Этот метод считывает содержимое элемента, декодирует его с помощью кодировки Base64 и возвращает раскодированные двоичные байты (например, встроенный Base64 закодированный в формате GIF) в буфер. Дополнительные сведения см. в разделе RFC 1521 «часть MIME (Multipurpose Internet Mail Extensions) одной: механизмы для определения и описания формата тел сообщений Интернета». Вы можете получить RFC с [запроса веб-сайте](https://www.rfc-editor.org).  
  
 Этот метод может считывать только элементы с простым содержимым. Элемент может содержать текст, пробелы, значимые пробелы, разделы CDATA, комментарии и инструкции по обработке. Он также может содержать ссылки на сущности, которые разворачиваются автоматически. Элемент не может иметь дочерние элементы.  
  
 Этот метод выполняется аналогично <xref:System.Xml.XmlTextReader.ReadContentAsBase64%2A> за исключением того, что он может вызываться только для типов узлов элемента.  
  
 Если `count` значение больше, чем число байтов в документе, или равно количеству байтов в документе, <xref:System.Xml.XmlTextReader> считывает все оставшиеся байты в документе и возвращает число считанных байтов. Следующий <xref:System.Xml.XmlTextReader> вызов метода возвращает нулевое значение и перемещает средство чтения на следующий узел <xref:System.Xml.XmlNodeType.EndElement>.  
  
 При вызове метода <xref:System.Xml.XmlTextReader.Read%2A> перед все содержимое элемента выделено, средство чтения может повести себя, как если бы была использована первого содержимого и затем <xref:System.Xml.XmlTextReader.Read%2A> был вызван метод. Это означает, что средство чтения считывает весь текст, пока не будет обнаружен конечного элемента. Затем он считывает узел закрывающего тега, считывает следующий узел и перемещает себя на последующем узле.  
  
   
  
## Examples  
 В разделе <xref:System.Xml.XmlReader.ReadElementContentAsBase64%2A?displayProperty=nameWithType> пример, с помощью этого метода.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> value is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The current node is not an element node.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The index into the buffer or index + count is larger than the allocated buffer size.</exception>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XmlTextReader" /> implementation does not support this method.</exception>
        <exception cref="T:System.Xml.XmlException">The element contains mixed-content.</exception>
        <exception cref="T:System.FormatException">The content cannot be converted to the requested type.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlTextReader.ReadElementContentAsBase64(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadElementContentAsBinHex">
      <MemberSignature Language="C#" Value="public override int ReadElementContentAsBinHex (byte[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 ReadElementContentAsBinHex(unsigned int8[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadElementContentAsBinHex (buffer As Byte(), index As Integer, count As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int ReadElementContentAsBinHex(cli::array &lt;System::Byte&gt; ^ buffer, int index, int count);" />
      <MemberSignature Language="F#" Value="override this.ReadElementContentAsBinHex : byte[] * int * int -&gt; int" Usage="xmlTextReader.ReadElementContentAsBinHex (buffer, index, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">The buffer into which to copy the resulting text. This value cannot be <see langword="null" />.</param>
        <param name="index">The offset into the buffer where to start copying the result.</param>
        <param name="count">The maximum number of bytes to copy into the buffer. The actual number of bytes copied is returned from this method.</param>
        <summary>Reads the element and decodes the <see langword="BinHex" /> content.</summary>
        <returns>The number of bytes written to the buffer.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Этот метод считывает содержимое элемента, декодирует его с помощью `BinHex` кодирования и возвращает раскодированные двоичные байты (например, встроенный `BinHex` рисунок в формате GIF) в буфер.  
  
 Этот метод может считывать только элементы с простым содержимым. Элемент может содержать текст, пробелы, значимые пробелы, разделы CDATA, комментарии и инструкции по обработке. Он также может содержать ссылки на сущности, которые разворачиваются автоматически. Элемент не может иметь дочерние элементы.  
  
 Этот метод выполняется аналогично <xref:System.Xml.XmlTextReader.ReadContentAsBinHex%2A> за исключением того, что он может вызываться только для типов узлов элемента.  
  
 Если `count` значение больше, чем число байтов в документе, или равно количеству байтов в документе, <xref:System.Xml.XmlTextReader> считывает все оставшиеся байты в документе и возвращает число считанных байтов. Следующий <xref:System.Xml.XmlTextReader> вызов метода возвращает нулевое значение и перемещает средство чтения на следующий узел <xref:System.Xml.XmlNodeType.EndElement>.  
  
 При вызове метода <xref:System.Xml.XmlTextReader.Read%2A> перед все содержимое элемента выделено, средство чтения может повести себя, как если бы была использована первого содержимого и затем <xref:System.Xml.XmlTextReader.Read%2A> был вызван метод. Это означает, что средство чтения считывает весь текст, пока не будет обнаружен конечного элемента. Затем он считывает узел закрывающего тега, считывает следующий узел и перемещает себя на последующем узле.  
  
   
  
## Examples  
 В разделе <xref:System.Xml.XmlReader.ReadElementContentAsBinHex%2A?displayProperty=nameWithType> пример, с помощью этого метода.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">The <paramref name="buffer" /> value is <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">The current node is not an element node.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The index into the buffer or index + count is larger than the allocated buffer size.</exception>
        <exception cref="T:System.NotSupportedException">The <see cref="T:System.Xml.XmlReader" /> implementation does not support this method.</exception>
        <exception cref="T:System.Xml.XmlException">The element contains mixed-content.</exception>
        <exception cref="T:System.FormatException">The content cannot be converted to the requested type.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
        <altmember cref="M:System.Xml.XmlTextReader.ReadElementContentAsBinHex(System.Byte[],System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="ReadState">
      <MemberSignature Language="C#" Value="public override System.Xml.ReadState ReadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.ReadState ReadState" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.ReadState" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReadState As ReadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::ReadState ReadState { System::Xml::ReadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ReadState : System.Xml.ReadState" Usage="System.Xml.XmlTextReader.ReadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.ReadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the state of the reader.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Xml.ReadState" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadString">
      <MemberSignature Language="C#" Value="public override string ReadString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ReadString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ReadString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ReadString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ReadString();" />
      <MemberSignature Language="F#" Value="override this.ReadString : unit -&gt; string" Usage="xmlTextReader.ReadString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Reads the contents of an element or a text node as a string.</summary>
        <returns>The contents of the element or text node. This can be an empty string if the reader is positioned on something other than an element or text node, or if there is no more text content to return in the current context.  
  
 <see langword="Note:" /> The text node can be either an element or an attribute text node.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Если средство чтения находится на элементе, `ReadString` объединяет текст, значимые пробелы, символы-разделители, и `CData` типы узел раздела, а затем возвращает объединенные данные в качестве содержимого элемента. Он останавливается при нахождении разметки, включая комментарии и инструкции по обработке. Это может случиться в модели смешанного содержимого или во время считывания закрывающего тега элемента.  
  
 Если средство чтения находится на текстовом узле `ReadString` выполняет же объединение от текстового узла до закрывающего тега элемента. Если модуль чтения расположен в текстовом узле атрибута, метод `ReadString` работает так же, как в случае, когда модуль чтения располагается в открывающем теге элемента, и возвращает все объединенные текстовые узлы элемента.  
  
   
  
## Examples  
 Следующий пример отображает текстовое содержимое каждого элемента.  
  
 [!code-cpp[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlReader.IsStartElement Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/VB/source.vb#1)]  
  
 В примере используется файл `elems.xml`, в качестве входных данных.  
  
 [!code-xml[Classic WebData XmlReader.IsStartElement Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlReader.IsStartElement Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Xml.XmlException">An error occurred while parsing the XML.</exception>
        <exception cref="T:System.InvalidOperationException">An invalid operation was attempted.</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="ResetState">
      <MemberSignature Language="C#" Value="public void ResetState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ResetState" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetState ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetState();" />
      <MemberSignature Language="F#" Value="member this.ResetState : unit -&gt; unit" Usage="xmlTextReader.ResetState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resets the state of the reader to ReadState.Initial.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Этот метод позволяет анализировать несколько XML-документов в отдельном потоке. Когда будет достигнут конец XML-документа, можно вызвать `ResetState` сбрасывает состояние средства чтения следующего XML-документа.  
  
> [!IMPORTANT]
>  Документы в потоке должны совместно использовать ту же кодировку. Если это условие не выполняется, когда `ResetState` вызывается <xref:System.Xml.XmlException> возникает исключение. (Это изменение в поведении относительно платформы .NET Framework версии 1.1 и более ранних версий).  
  
 Следующие свойства не подвержены `ResetState`.  
  
-   <xref:System.Xml.XmlTextReader.Normalization%2A>  
  
-   <xref:System.Xml.XmlTextReader.Namespaces%2A>  
  
-   <xref:System.Xml.XmlTextReader.XmlResolver%2A>  
  
-   <xref:System.Xml.XmlTextReader.WhitespaceHandling%2A>  
  
   
  
## Examples  
 В следующем примере анализируется двух XML-документов в отдельном потоке.  
  
 [!code-cpp[XmlTextReader.ResetState#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.ResetState/CPP/resetstate.cpp#1)]
 [!code-csharp[XmlTextReader.ResetState#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.ResetState/CS/resetstate.cs#1)]
 [!code-vb[XmlTextReader.ResetState#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.ResetState/VB/resetstate.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Calling <see langword="ResetState" /> if the reader was constructed using an <see cref="T:System.Xml.XmlParserContext" />.</exception>
        <exception cref="T:System.Xml.XmlException">Documents in a single stream do not share the same encoding.</exception>
        <altmember cref="T:System.Xml.ReadState" />
      </Docs>
    </Member>
    <Member MemberName="ResolveEntity">
      <MemberSignature Language="C#" Value="public override void ResolveEntity ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void ResolveEntity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.ResolveEntity" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub ResolveEntity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void ResolveEntity();" />
      <MemberSignature Language="F#" Value="override this.ResolveEntity : unit -&gt; unit" Usage="xmlTextReader.ResolveEntity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Resolves the entity reference for <see langword="EntityReference" /> nodes.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Если средство чтения расположено на `EntityReference` узел (`XmlNodeType.EntityReference`), если <xref:System.Xml.XmlTextReader.Read%2A> вызывается после вызова этого метода замещающего текста сущности анализируется. По завершении замещения текста сущности `EndEntity` для закрытия области действия ссылок на сущности возвращается узел.  
  
> [!NOTE]
>  После вызова этого метода, если сущность является частью значения атрибута, необходимо вызвать <xref:System.Xml.XmlTextReader.ReadAttributeValue%2A> для доступа к объекту.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Skip">
      <MemberSignature Language="C#" Value="public override void Skip ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Skip() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.Skip" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Skip ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Skip();" />
      <MemberSignature Language="F#" Value="override this.Skip : unit -&gt; unit" Usage="xmlTextReader.Skip " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Skips the children of the current node.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 В следующем XML-КОДЕ входных данных, если средство чтения расположено на `<a>` узла или любого из его атрибутов, вызов `Skip` помещает модуль чтения для `<b>` узла.  
  
 Если средство чтения расположено на конечном узле уже (такие как `<x>` узел или текстовый узел `abc`), что вызов `Skip` является таким же, как вызов <xref:System.Xml.XmlTextReader.Read%2A>.  
  
```xml  
<a name="bob" age="123">  
  <x/>abc<y/>  
</a>  
<b>  
 ...  
</b>  
```  
  
 Этот метод проверяет корректный XML.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="System.Xml.IXmlNamespaceResolver.GetNamespacesInScope">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IDictionary&lt;string,string&gt; IXmlNamespaceResolver.GetNamespacesInScope (System.Xml.XmlNamespaceScope scope);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, string&gt; System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(valuetype System.Xml.XmlNamespaceScope scope) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.System#Xml#IXmlNamespaceResolver#GetNamespacesInScope(System.Xml.XmlNamespaceScope)" />
      <MemberSignature Language="VB.NET" Value="Function GetNamespacesInScope (scope As XmlNamespaceScope) As IDictionary(Of String, String) Implements IXmlNamespaceResolver.GetNamespacesInScope" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IDictionary&lt;System::String ^, System::String ^&gt; ^ System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(System::Xml::XmlNamespaceScope scope) = System::Xml::IXmlNamespaceResolver::GetNamespacesInScope;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(System.Xml.XmlNamespaceScope)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.String&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="scope" Type="System.Xml.XmlNamespaceScope" />
      </Parameters>
      <Docs>
        <param name="scope">An <see cref="T:System.Xml.XmlNamespaceScope" /> value that specifies the type of namespace nodes to return.</param>
        <summary>For a description of this member, see <see cref="M:System.Xml.IXmlNamespaceResolver.GetNamespacesInScope(System.Xml.XmlNamespaceScope)" />.</summary>
        <returns>An <see cref="T:System.Collections.IDictionary" /> that contains the current in-scope namespaces.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Xml.XmlTextReader> приведен к типу интерфейса <xref:System.Xml.IXmlNamespaceResolver>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="System.Xml.IXmlNamespaceResolver.LookupNamespace">
      <MemberSignature Language="C#" Value="string IXmlNamespaceResolver.LookupNamespace (string prefix);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.Xml.IXmlNamespaceResolver.LookupNamespace(string prefix) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.System#Xml#IXmlNamespaceResolver#LookupNamespace(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function LookupNamespace (prefix As String) As String Implements IXmlNamespaceResolver.LookupNamespace" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.Xml.IXmlNamespaceResolver.LookupNamespace(System::String ^ prefix) = System::Xml::IXmlNamespaceResolver::LookupNamespace;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.LookupNamespace(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="prefix" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="prefix">The prefix whose namespace URI you wish to find.</param>
        <summary>For a description of this member, see <see cref="M:System.Xml.IXmlNamespaceResolver.LookupNamespace(System.String)" />.</summary>
        <returns>The namespace URI that is mapped to the prefix; <see langword="null" /> if the prefix is not mapped to a namespace URI.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Xml.XmlTextReader> приведен к типу интерфейса <xref:System.Xml.IXmlNamespaceResolver>.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="System.Xml.IXmlNamespaceResolver.LookupPrefix">
      <MemberSignature Language="C#" Value="string IXmlNamespaceResolver.LookupPrefix (string namespaceName);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.Xml.IXmlNamespaceResolver.LookupPrefix(string namespaceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.XmlTextReader.System#Xml#IXmlNamespaceResolver#LookupPrefix(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function LookupPrefix (namespaceName As String) As String Implements IXmlNamespaceResolver.LookupPrefix" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.Xml.IXmlNamespaceResolver.LookupPrefix(System::String ^ namespaceName) = System::Xml::IXmlNamespaceResolver::LookupPrefix;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlNamespaceResolver.LookupPrefix(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="namespaceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="namespaceName">The namespace URI whose prefix you wish to find.</param>
        <summary>For a description of this member, see <see cref="M:System.Xml.IXmlNamespaceResolver.LookupPrefix(System.String)" />.</summary>
        <returns>The prefix that is mapped to the namespace URI; <see langword="null" /> if the namespace URI is not mapped to a prefix.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public override string Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Value" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.Value" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Value As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Value { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : string" Usage="System.Xml.XmlTextReader.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the text value of the current node.</summary>
        <value>Возвращаемое значение зависит от значения свойства <see cref="P:System.Xml.XmlTextReader.NodeType" /> узла. В следующей таблице представлен список возвращаемых типов узлов со значениями. Все прочие типы узлов возвращают значение <see langword="String.Empty" />.  
  
 <list type="table"><listheader><term> Тип узла </term><description> значение </description></listheader><item><term><see langword="Attribute" /></term><description> значение атрибута.  </description></item><item><term><see langword="CDATA" /></term><description> Содержимое раздела CDATA.  </description></item><item><term><see langword="Comment" /></term><description> Содержимое комментария.  </description></item><item><term><see langword="DocumentType" /></term><description> Внутреннее подмножество.  </description></item><item><term><see langword="ProcessingInstruction" /></term><description> Все содержимое, за исключением цели.  </description></item><item><term><see langword="SignificantWhitespace" /></term><description> Пробел в <see langword="xml:space" />= 'preserve' области.  </description></item><item><term><see langword="Text" /></term><description> Содержимое текстового узла.  </description></item><item><term><see langword="Whitespace" /></term><description> Пробел между элементами разметки.  </description></item><item><term><see langword="XmlDeclaration" /></term><description> Содержимое декларации.  </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
   
  
## Examples  
 В следующем примере считывает XML-файла и отображение каждого узла.  
  
 [!code-cpp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.Name Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/VB/source.vb#1)]  
  
 В образце используется файл `items.xml`.  
  
 [!code-xml[Classic WebData XmlTextReader.Name Example#2](~/samples/snippets/xml/VS_Snippets_Data/Classic WebData XmlTextReader.Name Example/XML/source.xml#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="WhitespaceHandling">
      <MemberSignature Language="C#" Value="public System.Xml.WhitespaceHandling WhitespaceHandling { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.WhitespaceHandling WhitespaceHandling" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.WhitespaceHandling" />
      <MemberSignature Language="VB.NET" Value="Public Property WhitespaceHandling As WhitespaceHandling" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::WhitespaceHandling WhitespaceHandling { System::Xml::WhitespaceHandling get(); void set(System::Xml::WhitespaceHandling value); };" />
      <MemberSignature Language="F#" Value="member this.WhitespaceHandling : System.Xml.WhitespaceHandling with get, set" Usage="System.Xml.XmlTextReader.WhitespaceHandling" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.WhitespaceHandling</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a value that specifies how white space is handled.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Xml.WhitespaceHandling" />. По умолчанию используется значение <see langword="WhitespaceHandling.All" /> (возвращает узлы <see langword="Whitespace" /> и <see langword="SignificantWhitespace" />).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это свойство можно изменить в любое время и вступает в силу следующая операция чтения.  
  
 Поскольку `XmlTextReader` нет доступных сведений DTD `SignificantWhitepsace` возвращаются только узлы внутри `xml:space='preserve'` области.  
  
   
  
## Examples  
 В следующем примере считывается XML-фрагмента.  
  
 [!code-cpp[Classic WebData XmlTextReader.WhitespaceHandling Example#1](~/samples/snippets/cpp/VS_Snippets_Data/Classic WebData XmlTextReader.WhitespaceHandling Example/CPP/source.cpp#1)]
 [!code-csharp[Classic WebData XmlTextReader.WhitespaceHandling Example#1](~/samples/snippets/csharp/VS_Snippets_Data/Classic WebData XmlTextReader.WhitespaceHandling Example/CS/source.cs#1)]
 [!code-vb[Classic WebData XmlTextReader.WhitespaceHandling Example#1](~/samples/snippets/visualbasic/VS_Snippets_Data/Classic WebData XmlTextReader.WhitespaceHandling Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Invalid value specified.</exception>
        <exception cref="T:System.InvalidOperationException">Setting this property when the reader is closed (<see cref="P:System.Xml.XmlTextReader.ReadState" /> is <see langword="ReadState.Closed" />).</exception>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="XmlLang">
      <MemberSignature Language="C#" Value="public override string XmlLang { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string XmlLang" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.XmlLang" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property XmlLang As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ XmlLang { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.XmlLang : string" Usage="System.Xml.XmlTextReader.XmlLang" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the current <see langword="xml:lang" /> scope.</summary>
        <value>Текущая область действия <see langword="xml:lang" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Это свойство представляет `xml:lang` область, в которой находится текущий узел. Например, ниже приведен фрагмент XML `xml:lang` задать для английского языка в корневой элемент:  
  
 \<корневой XML: lang = "en-us» >  
  
 \<имя > Fred \< /name >  
  
 \</ root >  
  
 Если средство чтения расположено на `name` элемент, это свойство можно использовать для поиска, что он находится в области английский (США) `xml:lang` атрибута.  
  
   
  
## Examples  
 В следующем примере отображается `xml:lang` значение для каждого узла.  
  
 [!code-cpp[XmlTextReader.XmlLang#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.XmlLang/CPP/readlang.cpp#1)]
 [!code-csharp[XmlTextReader.XmlLang#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.XmlLang/CS/readlang.cs#1)]
 [!code-vb[XmlTextReader.XmlLang#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.XmlLang/VB/readlang.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="XmlResolver">
      <MemberSignature Language="C#" Value="public System.Xml.XmlResolver XmlResolver { set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.XmlResolver XmlResolver" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.XmlResolver" />
      <MemberSignature Language="VB.NET" Value="Public Property XmlResolver As XmlResolver" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::XmlResolver ^ XmlResolver {  void set(System::Xml::XmlResolver ^ value); };" />
      <MemberSignature Language="F#" Value="member this.XmlResolver : System.Xml.XmlResolver" Usage="System.Xml.XmlTextReader.XmlResolver" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlResolver</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Sets the <see cref="T:System.Xml.XmlResolver" /> used for resolving DTD references.</summary>
        <value>Используемый <see langword="XmlResolver" />. Если он имеет значение <see langword="null" />, внешние ресурсы не разрешаются.  В версии 1.1 [! INCLUDE[dnprdnshort](~/includes/dnprdnshort-MD.MD)], вызывающая сторона должна быть полностью доверенной для указания <see langword="XmlResolver" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
 Средство чтения использует `XmlResolver` для разрешения расположения файла, загружаемого в средство чтения, так и для разрешения ссылок на DTD. Например, если в XML-КОДЕ содержится объявление DOCTYPE `<!DOCTYPE book SYSTEM book.dtd>` средство чтения разрешает это внешний файл и гарантирует, что DTD имеет правильный формат. Средство чтения не использует DTD для проверки.  
  
 Это свойство можно изменить в любое время и вступает в силу следующая операция чтения. Если это свойство имеет значение `null`, не разрешаются любые ссылки на DTD, обнаруженные средством чтения.  
  
 В версии 1.1 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], если это свойство не задано, уровень доверия приложения определяет поведение по умолчанию.  
  
 `Fully trusted code:` Средство чтения использует значение по умолчанию <xref:System.Xml.XmlUrlResolver> без учетных данных пользователя. Если для доступа к сетевому ресурсу требуется проверка подлинности, используйте `XmlResolver` свойство, чтобы указать `XmlResolver` необходимые учетные данные.  
  
 `Semi-trusted code:` `XmlResolver` Свойству `null`. Внешние ресурсы не разрешаются.  
  
   
  
## Examples  
 В следующем примере используется `XmlResolver` свойство, чтобы указать учетные данные, необходимые для доступа к сетевому файлу.  
  
 [!code-cpp[XmlTextReader.XmlResolver#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.XmlResolver/CPP/rdr_resolver.cpp#1)]
 [!code-csharp[XmlTextReader.XmlResolver#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.XmlResolver/CS/rdr_resolver.cs#1)]
 [!code-vb[XmlTextReader.XmlResolver#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.XmlResolver/VB/rdr_resolver.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Xml.XmlUrlResolver.Credentials" />
        <altmember cref="T:System.Net.CredentialCache" />
        <altmember cref="T:System.Net.NetworkCredential" />
        <altmember cref="T:System.Xml.XmlSecureResolver" />
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
    <Member MemberName="XmlSpace">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlSpace XmlSpace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlSpace XmlSpace" />
      <MemberSignature Language="DocId" Value="P:System.Xml.XmlTextReader.XmlSpace" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property XmlSpace As XmlSpace" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlSpace XmlSpace { System::Xml::XmlSpace get(); };" />
      <MemberSignature Language="F#" Value="member this.XmlSpace : System.Xml.XmlSpace" Usage="System.Xml.XmlTextReader.XmlSpace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.ReaderWriter</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlSpace</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the current <see langword="xml:space" /> scope.</summary>
        <value>Одно из значений перечисления <see cref="T:System.Xml.XmlSpace" />. Если область действия <see langword="xml:space" /> отсутствует, данное свойство принимает значение <see langword="XmlSpace.None" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Начиная с .NET Framework 2.0, рекомендуется создать <xref:System.Xml.XmlReader> экземпляров с помощью <xref:System.Xml.XmlReader.Create%2A?displayProperty=nameWithType> метод, чтобы воспользоваться преимуществами новых функций.  
  
   
  
## Examples  
 В следующем примере анализируется файл и возвращает значащих пробелов, если `xml:space='preserve'` найти область.  
  
 [!code-cpp[XmlTextReader.XmlSpace#1](~/samples/snippets/cpp/VS_Snippets_Data/XmlTextReader.XmlSpace/CPP/readspace.cpp#1)]
 [!code-csharp[XmlTextReader.XmlSpace#1](~/samples/snippets/csharp/VS_Snippets_Data/XmlTextReader.XmlSpace/CS/readspace.cs#1)]
 [!code-vb[XmlTextReader.XmlSpace#1](~/samples/snippets/visualbasic/VS_Snippets_Data/XmlTextReader.XmlSpace/VB/readspace.vb#1)]  
  
 В примере используется файл `authors.xml`, в качестве входных данных.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Xml.XmlReader" />
      </Docs>
    </Member>
  </Members>
</Type>