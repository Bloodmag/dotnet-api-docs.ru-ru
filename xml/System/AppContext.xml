<Type Name="AppContext" FullName="System.AppContext">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="893966e3a9901acea67237c6fa8d21aea736380a" />
    <Meta Name="ms.sourcegitcommit" Value="81d387351cc43c342755705908f4a5eb8af153d3" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/04/2018" />
    <Meta Name="ms.locfileid" Value="34568289" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class AppContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit AppContext extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.AppContext" />
  <TypeSignature Language="VB.NET" Value="Public Class AppContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppContext abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.AppContext</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Предоставляет члены для задания и получения данных о контексте приложения.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppContext> Класс позволяет авторам библиотек предоставлять согласованный механизм явного отказа для новых функциональных возможностей. Он устанавливает слабо связанный контракт между компонентами для передачи запроса на явный отказ. Эта возможность обычно важна при внесении изменений в существующие функции. В свою очередь, режим неявного согласия для новых функциональных возможностей уже существует.  
  
## <a name="appcontext-for-library-developers"></a>Параметров AppContext разработчикам библиотек  
 Использование библиотек <xref:System.AppContext> переключается класса для определения и предоставления совместимости, во время библиотеки пользователи могут задавать эти параметры для влияния на поведение библиотек. По умолчанию библиотеки предоставляют новые функции и изменяют их (то есть предоставляют прежние функции) только в том случае, если установлен параметр.  Это позволяет библиотекам для предоставления новое поведение для существующих API, продолжая поддерживать вызывающим объектам, которые зависят от предыдущего поведения.  
  
### <a name="defining-the-switch-name"></a>Определение имени параметра  
 Наиболее распространенный способ позволяют потребителям библиотеки отказаться от изменений поведения является определение именованного переключателя.  Его `value` элемент представляет собой пару имя значение, состоящее из имени параметра и его <xref:System.Boolean> значение.  По умолчанию параметр всегда имеет неявное `false`, который определяет новое поведение (и определяет новое поведение участия в программе по умолчанию). Установите значение параметра `true` позволяет ему, который содержит устаревшее поведение. После явного задания коммутатор `false` также определяет новое поведение.  
  
 Рекомендуется использовать согласованный формат для имен коммутатора, так как они представляют собой формальный контракт, предоставляемый библиотекой. Ниже приведены два очевидных формата:  
  
-   *параметр*.*пространство_имен* * имя_параметра*  
  
-   *параметр*.*библиотека*.*имя_параметра*  
  
 После определения и документов коммутатора, вызывающая сторона может использовать его с помощью реестра, добавив [ \<AppContextSwitchOverrides >](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md) элемент их файл конфигурации приложения или путем вызова <xref:System.AppContext.SetSwitch%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> метод программными средствами. В разделе [параметров AppContext для пользователей библиотеки](#ForConsumers) Дополнительные сведения о способах вызывающим объектам использовать и задать значение <xref:System.AppContext> параметров конфигурации.  
  
 При запуске приложения общеязыковая среда выполнения автоматически считывает параметры совместимости реестра и загружает файл конфигурации приложения для заполнения приложения <xref:System.AppContext> экземпляра. Поскольку <xref:System.AppContext> экземпляр заполняется программно вызывающим или средой выполнения, не нужно предпринимать никаких действий, например при вызове <xref:System.AppContext.SetSwitch%2A> метод для настройки <xref:System.AppContext> экземпляра.  
  
### <a name="checking-the-setting"></a>Проверка параметра  
 Затем можно проверить, если потребитель объявило значение коммутатора и соответствующим образом путем вызова act <xref:System.AppContext.TryGetSwitch%2A?displayProperty=nameWithType> метод. Метод возвращает `true` Если `switchName` аргумента найдено, и когда этот метод возвращает его `isEnabled` аргумент указывает значение переключателя.  В противном случае метод возвращает значение `false`.  
  
### <a name="an-example"></a>Пример  
 Следующий пример иллюстрирует использование <xref:System.AppContext> класс, позволяющий выбрать метод библиотеки исходного поведения клиент.   Ниже приведен версии 1.0 библиотеки с именем `StringLibrary`. Он определяет `SubstringStartsAt` метод, который выполняет порядковое сравнение, чтобы определить начальный индекс подстроки в длинной строке.  
  
 [!code-csharp[System.AppContext.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.AppContext.Class/cs/Example4.cs#4)]
 [!code-vb[System.AppContext.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.AppContext.Class/vb/Example4.vb#4)]  
  
 В следующем примере затем используется библиотеки для поиска начальный индекс подстроки «archæ» в «archaeologist». Так как этот метод выполняет порядковое сравнение, не удается найти подстроку.  
  
 [!code-csharp[System.AppContext.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.AppContext.Class/cs/Example4.cs#5)]
 [!code-vb[System.AppContext.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.AppContext.Class/vb/Example4.vb#5)]  
  
 Версия 2 библиотеки, однако изменения `SubstringStartsAt` метод, используемый для сравнения с учетом языка и региональных параметров.  
  
 [!code-csharp[System.AppContext.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.AppContext.Class/cs/Example6.cs#6)]
 [!code-vb[System.AppContext.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.AppContext.Class/vb/Example6.vb#6)]  
  
 При повторной компиляции приложения для запуска в новую версию библиотеки, теперь сообщает обнаружения подстроку «archæ» с индексом 4 в «archaeologist».  
  
 [!code-csharp[System.AppContext.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.AppContext.Class/cs/Example6.cs#7)]
 [!code-vb[System.AppContext.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.AppContext.Class/vb/Example6.vb#7)]  
  
 Это изменение может быть запрещено работу приложений, зависящих от исходное поведение, определив [ \<AppContextSwitchOverrides >](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md) переключения. В этом случае параметр с именем `StringLibrary.DoNotUseCultureSensitiveComparison`. Значением по умолчанию `false`, указывает, что библиотеки должен выполнить его сравнение с учетом языка и региональных параметров версии 2.0. `true` Указывает, что библиотеке должен выполнить порядковое сравнение его версии 1.0.  Незначительное изменение приведенного выше кода позволяет задать переключатель, чтобы определить тип сравнения, который выполняет метод потребителю библиотеки.  
  
 [!code-csharp[System.AppContext.Class#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.AppContext.Class/cs/Example8.cs#8)]
 [!code-vb[System.AppContext.Class#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.AppContext.Class/vb/Example8.vb#8)]  
  
 Если приложение затем может использовать следующий файл конфигурации для восстановления поведения версии 1.0.  
  
```xml  
  
<configuration>  
   <runtime>  
      <AppContextSwitchOverrides value="StringLibrary.DoNotUseCultureSensitiveComparison=true" />   
   </runtime>  
</configuration>  
  
```  
  
 При запуске приложения в файле конфигурации отсутствует, она дает следующий результат:  
  
```  
'archæ' not found in 'The archaeologist'  
```  
  
<a name="ForConsumers"></a>   
## <a name="appcontext-for-library-consumers"></a>Параметров AppContext для пользователей библиотеки  
 Если потребитель библиотеки <xref:System.AppContext> позволяет воспользоваться преимуществами библиотеки или метод библиотеки механизм явного отказа для новых функциональных возможностей.   Отдельные методы библиотеки классов, который вы вызываете определить конкретного коммутаторов, включающие или отключающие новое поведение. Значение параметра является логическим. Если это `false`, которой обычно является значение по умолчанию, новое поведение включено; Если это `true`, новое поведение отключена, и элемент ведет себя по-другому.  
  
 Значение параметра можно задать одним из трех способов:  
  
-   Путем вызова <xref:System.AppContext.SetSwitch%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> метод в коде.  `switchName` Аргумент определяет имя коммутатора и `isEnabled` свойство определяет значение переключателя. Поскольку <xref:System.AppContext> является статическим классом, он доступен на основе на уровне домена приложения.  
  
     Вызов <xref:System.AppContext.SetSwitch%28System.String%2CSystem.Boolean%29?displayProperty=nameWithType> имеет область приложения; то есть, он влияет только приложение.  
  
-   Добавив `<AppContextSwitchOverrides>` элемент [ \<среды выполнения >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) раздел файла app.config. Параметр имеет один атрибут, `value`, значение которого является строка, которая представляет пару ключ значение, содержащее имя параметра и его значение.  
  
     Для определения нескольких коммутаторов, разделения пары ключ значение каждого коммутатора в [ \<AppContextSwitchOverrides >](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md) элемента `value` атрибут точкой с запятой. В этом случае `<AppContextSwitchOverrides>` элемент имеет следующий формат:  
  
    ```xml  
    <AppContextSwitchOverrides value="switchName1=value1;switchName2=value2" />  
    ```  
  
     С помощью `<AppContextSwitchOverrides>` у элемента для определения параметра конфигурации области приложения, то есть оно влияет на только приложение.  

    > [!NOTE]    
    > Сведения на коммутаторах, определенные в .NET Framework см. в разделе [ \<AppContextSwitchOverrides > элемент](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md).

-   Добавив строковое значение, имя которой представляет имя коммутатора для `HKLM\SOFTWARE\Microsoft\.NETFramework\AppContext` ключа в реестре. Его значение должно быть строковым представлением <xref:System.Boolean> , может быть проанализирован <xref:System.Boolean.Parse%2A?displayProperty=nameWithType> метода, то есть он должен быть «True», «true», «False» или «false». Если среда выполнения обнаруживает любое другое значение, он игнорирует ключ.  
  
     Использование реестра для определения <xref:System.AppContext> коммутатор имеет область машины; то есть, он влияет на каждое приложение выполняется на компьютере.  
  
 Если же коммутатору задано более чем одним способом, является порядок очередности для определения параметра, который переопределяет другие:  
  
1.  Программный параметр.  
  
2.  Параметр в файле конфигурации приложения.  
  
3.  Параметр реестра.  
  
 Вот простое приложение, которое передает файл URI для <xref:System.IO.Path.GetDirectoryName%2A?displayProperty=nameWithType> метод.  Когда работает в среде .NET Framework 4.6, она вызывает <xref:System.ArgumentException> из-за `file://` больше не является допустимой частью пути к файлу.  
  
 [!code-csharp[System.AppContext.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.AppContext.Class/cs/ForConsumers1.cs#10)]
 [!code-vb[System.AppContext.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.AppContext.Class/vb/ForConsumers1.vb#10)]  
  
 Чтобы восстановить прежнее поведение данного метода и избежать возникновения исключения, можно добавить `Switch.System.IO.UseLegacyPathHandling` переключитесь в файле конфигурации приложения, например:  
  
```xml  
<configuration>  
    <runtime>  
        <AppContextSwitchOverrides value="Switch.System.IO.UseLegacyPathHandling=true" />    
    </runtime>  
</configuration>  
```  
## <a name="see-also"></a>См. также
[Коммутатор параметров AppContext](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md)

 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public static string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppContext.BaseDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property BaseDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ BaseDirectory { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AppContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает путь к базовому каталогу, в котором сопоставитель сборок производит поиск.</summary>
        <value>Путь к базовому каталогу, в котором сопоставитель сборок производит поиск.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это каждого свойства домена приложения. Его значение соответствует <xref:System.AppDomain.BaseDirectory%2A?displayProperty=nameWithType> свойства текущего домена приложения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppContext.GetData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AppContext</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя элемента данных.</param>
        <summary>Возвращает значение именованного элемента данных, назначенное текущему домену приложения.</summary>
        <returns>Значение <paramref name="name" />, если <paramref name="name" /> определяет именованное значение; в противном случае — <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSwitch">
      <MemberSignature Language="C#" Value="public static void SetSwitch (string switchName, bool isEnabled);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetSwitch(string switchName, bool isEnabled) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppContext.SetSwitch(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetSwitch (switchName As String, isEnabled As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetSwitch(System::String ^ switchName, bool isEnabled);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AppContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchName" Type="System.String" />
        <Parameter Name="isEnabled" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="switchName">Имя переключателя.</param>
        <param name="isEnabled">Значение переключателя.</param>
        <summary>Задает значение переключателя.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppContext> Класс позволяет авторам библиотек предоставлять согласованный механизм явного отказа для новых функциональных возможностей. Он устанавливает слабо связанный контракт между компонентами для передачи запроса на явный отказ. Эта возможность обычно важна при внесении изменений в существующие функции. В свою очередь, режим неявного согласия для новых функциональных возможностей уже существует.  
  
 <xref:System.AppContext.SetSwitch%2A> Метод вызывается методом приложения (или библиотека), чтобы объявить значение параметра (который всегда имеет <xref:System.Boolean> значение), определяемое зависимой библиотекой. Параметр всегда имеет неявное `false`, который определяет новое поведение. Установите значение параметра `true` позволяет ему, который содержит устаревшее поведение. После явного задания коммутатор `false` также определяет новое поведение. Зависимые библиотеки затем можно проверить значение переключателя, вызвав <xref:System.AppContext.TryGetSwitch%2A> метод.  
  
> [!NOTE]
>  Рекомендуется использовать согласованный формат для имен коммутатора, так как они представляют собой формальный контракт, предоставляемый библиотекой. Ниже приведены два очевидных формата:  
>   
>  -   *параметр*.*пространство_имен* * имя_параметра*  
> -   *параметр*.*библиотека*.*имя_параметра*  
  
 Для приложений, работающих на платформе .NET Framework, установив значение переключателя программными средствами его можно также задать:  
  
-   Путем добавления имени параметра и значение для [ \<AppContextSwitchOverrides >](~/docs/framework/configure-apps/file-schema/runtime/appcontextswitchoverrides-element.md) элемент в [ \<среды выполнения >](~/docs/framework/configure-apps/file-schema/runtime/runtime-element.md) раздел файла конфигурации приложения. Например, следующий код определяет параметр с именем `Libraries.FPLibrary.UseExactFloatingPointComparison` , значение которого является `False`.  
  
    ```xml  
  
    <configuration>  
       <runtime>  
          <AppContextSwitchOverrides value="Libraries.FPLibrary.UseExactFloatingPointComparison=false" />   
       </runtime>  
    </configuration>  
  
    ```  
  
-   Добавив строковое значение, имя которой представляет имя коммутатора для `HKLM\SOFTWARE\Microsoft\.NETFramework\AppContext` ключа в реестре. Его значение должно быть строковым представлением <xref:System.Boolean> , может быть проанализирован <xref:System.Boolean.Parse%2A?displayProperty=nameWithType> метода, то есть он должен быть «True», «true», «False» или «false».  
  
 Если `switchName` уже существует, его значение перезаписывается `isEnabled` аргумент.  То есть, последний вызов <xref:System.AppContext.SetSwitch%2A> метод переопределяет значение, определенное в реестре, в файле конфигурации приложения или с предыдущих вызовов <xref:System.AppContext.SetSwitch%2A> метод.  
 
 ### <a name="appcontextsetswitch-and-net-core"></a>AppContext.SetSwitch и .NET Core

.NET core поддерживает программный вызовы с <xref:System.AppContext.SetSwitch%2A> только метод. Поддерживаются следующие параметры:

|Параметр|Значения|Описание:|
|--|--|--|
|`System.Net.Http.useSocketsHttpHandler` |`true`|`false`|Определяет, является ли высокого уровня сетевых API-интерфейсов, таких как <xref:System.Net.Http.HttpClient> использовать <xref:System.Net.Http.SocketsHttpHandler?displayProperty=nameWithType> (`true`) или <xref:System.Net.Http.HttpClientHandler?displayProperty=nameWithType> (`false`).|   
  
## Examples  
 Следующий код задает параметр с именем `Switch.AmazingLib.ThrowOnException` для `true`, который позволяет устаревшее поведение. Библиотеку можно затем проверить, установлен ли потребитель библиотека значение переключателя путем вызова <xref:System.AppContext.TryGetSwitch%2A> метод.  
  
 [!code-csharp[System.AppContext.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.AppContext.Class/cs/TestValue1.cs#1)]
 [!code-vb[System.AppContext.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.AppContext.Class/vb/TestValue1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="switchName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойство <paramref name="switchName" /> имеет значение <see cref="F:System.String.Empty" />.</exception>
        <altmember cref="M:System.AppContext.TryGetSwitch(System.String,System.Boolean@)" />
      </Docs>
    </Member>
    <Member MemberName="TargetFrameworkName">
      <MemberSignature Language="C#" Value="public static string TargetFrameworkName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string TargetFrameworkName" />
      <MemberSignature Language="DocId" Value="P:System.AppContext.TargetFrameworkName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TargetFrameworkName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ TargetFrameworkName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AppContext</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает имя целевой версии платформы текущего приложения.</summary>
        <value>Имя целевой версии платформы текущего приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Имя требуемой версии .NET framework, соответствует значению <xref:System.Runtime.Versioning.TargetFrameworkAttribute.FrameworkName%2A?displayProperty=nameWithType> свойство. Список имен платформы .NET framework для платформы .NET Framework см. в разделе [ &lt;supportedRuntime&gt; элемент](~/docs/framework/configure-apps/file-schema/startup/supportedruntime-element.md) элемента.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.Versioning.TargetFrameworkAttribute" />
        <altmember cref="P:System.Runtime.Versioning.TargetFrameworkAttribute.FrameworkName" />
      </Docs>
    </Member>
    <Member MemberName="TryGetSwitch">
      <MemberSignature Language="C#" Value="public static bool TryGetSwitch (string switchName, out bool isEnabled);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryGetSwitch(string switchName, [out] bool&amp; isEnabled) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppContext.TryGetSwitch(System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryGetSwitch (switchName As String, ByRef isEnabled As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryGetSwitch(System::String ^ switchName, [Runtime::InteropServices::Out] bool % isEnabled);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.AppContext</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="switchName" Type="System.String" />
        <Parameter Name="isEnabled" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="switchName">Имя переключателя.</param>
        <param name="isEnabled">При возвращении этого метода содержит значение для <c>switchName</c>, если <c>switchName</c> найден, или <see langword="false" />, если <c>switchName</c> не найден. Этот параметр передается неинициализированным.</param>
        <summary>Предпринимает попытку получения значения переключателя.</summary>
        <returns>
          <see langword="true" />, если для <paramref name="switchName" /> задано значение и аргумент <paramref name="isEnabled" /> содержит значение переключателя; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppContext> Класс позволяет авторам библиотек предоставлять согласованный механизм явного отказа для новых функциональных возможностей. Он устанавливает слабо связанный контракт между компонентами для передачи запроса на явный отказ. Эта возможность обычно важна при внесении изменений в существующие функции. В свою очередь, режим неявного согласия для новых функциональных возможностей уже существует.  
  
 Общеязыковая среда выполнения автоматически заполняет коммутаторов, назначенный <xref:System.AppContext> экземпляра путем чтения реестра и файл конфигурации приложения. Затем можно переопределить значения этих параметров, и добавлены новые параметры, путем вызова <xref:System.AppContext.SetSwitch%2A> метод.  
  
 Вызывает библиотеку <xref:System.AppContext.TryGetSwitch%2A> метод для проверки ли ее пользователей было объявлено значение переключателя, а затем соответствующим образом реагировать на него.  По умолчанию параметр не определен, новые функциональные возможности включения... Если определен параметр и его значение равно `false`, новые функциональные возможности включена. Если его значение равно `true`, устаревшее поведение включен.  
  
   
  
## Examples  
 В следующем примере определяется, задан ли потребитель библиотеки коммутатор с именем `Switch.AmazingLib.ThrowOnException`.  
  
 [!code-csharp[System.AppContext.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.AppContext.Class/cs/TestValue1.cs#2)]
 [!code-vb[System.AppContext.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.AppContext.Class/vb/TestValue1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="switchName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойство <paramref name="switchName" /> имеет значение <see cref="F:System.String.Empty" />.</exception>
        <altmember cref="M:System.AppContext.SetSwitch(System.String,System.Boolean)" />
      </Docs>
    </Member>
  </Members>
</Type>