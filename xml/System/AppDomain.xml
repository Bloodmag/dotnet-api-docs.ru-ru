<Type Name="AppDomain" FullName="System.AppDomain">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c3ab234edad8a65f7b4b6688da32990c9642f79d" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30731668" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.AppDomain" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomain&#xA;Inherits MarshalByRefObject&#xA;Implements _AppDomain, IEvidenceFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomain sealed : MarshalByRefObject, _AppDomain, System::Security::IEvidenceFactory" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System._AppDomain</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет домен приложения, являющийся изолированной средой, в которой выполняются приложения. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Домены приложений, которые представлены <xref:System.AppDomain> объектов, помогающие границы изоляции, выгрузки и безопасности для выполнения управляемого кода.  
  
-   Использование доменов приложений для изоляции задач, которые могут привести к остановке процесса. Если состояние <xref:System.AppDomain> , выполняется задача работает нестабильно, <xref:System.AppDomain> без влияния на процесс может быть выгружен. Это важно, если процесс должен выполняться длительное без перезагрузки. Можно также использовать домены приложений для изоляции задач, которые не следует совместно использовать данные.  
  
-   Если сборка загружается в домен приложения по умолчанию, он не может быть выгружен из памяти во время выполнения процесса. Тем не менее если открыть второй домен приложения для загрузки и выполнения сборки, сборка выгружается, когда домен приложения выгружен. Этот прием можно используйте для минимизации рабочего набора долго выполняющихся процессов, которые периодически использовать большие библиотеки DLL.  
  
 Можно запустить несколько доменов приложений в одном процессе; Однако нет однозначного соответствия между потоками и доменами приложений. Несколько потоков могут принадлежать одному домену приложения, и во время данного потока не связана ни с одним доменом приложения, в любой момент времени, поток выполняется в одном домене приложения.  
  
 Домены приложений создаются с помощью <xref:System.AppDomain.CreateDomain%2A> метод. <xref:System.AppDomain> экземпляры используются для загрузки и выполнения сборок (<xref:System.Reflection.Assembly>). Когда <xref:System.AppDomain> — больше не используется, он может быть выгружен.  
  
 <xref:System.AppDomain> Класс реализует набор событий, которые позволяют приложениям реагировать при загрузке сборки, при выгрузке домена приложения или при возникновении необработанного исключения.  
  
 Дополнительные сведения об использовании доменов приложений см. в разделе [домены приложений](~/docs/framework/app-domains/application-domains.md).  
  
 Этот класс реализует <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, и <xref:System.Security.IEvidenceFactory> интерфейсов.  
  
 Никогда не следует создавать оболочку для удаленного взаимодействия <xref:System.AppDomain> объекта. Таким образом удается опубликовать ссылку на этот удаленный <xref:System.AppDomain>, таких как предоставление доступа к методам <xref:System.AppDomain.CreateInstance%2A> удаленного доступа и эффективно уничтожение управления доступом для кода для этого <xref:System.AppDomain>. Вредоносных клиентов, подключающихся к удаленным <xref:System.AppDomain> удалось получить доступ к любому ресурсу <xref:System.AppDomain> сам имеет доступ. Не создавайте удаленных оболочек для любого типа, расширяющего <xref:System.MarshalByRefObject> и типов, реализующих методы, которые могут использоваться злоумышленниками для обхода системы безопасности.  
  
> [!CAUTION]
>  Значение по умолчанию для <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType> свойство `false`. Этот параметр является безопасной для служб. Для предотвращения загрузки служб из частично доверенного кода, присвойте этому свойству значение `true`.  
  
   
  
## Examples  
 В этом примере показано, как создать новую <xref:System.AppDomain>, создать экземпляр типа, в том, что новые <xref:System.AppDomain>и взаимодействовать с ними объектов этого типа. Кроме того, в этом примере показано, как выгрузить <xref:System.AppDomain> вызывает объект для сбора мусора.  
  
 [!code-cpp[AppDomainX#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainX/cpp/AppDomainX.cpp#1)]
 [!code-csharp[AppDomainX#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainX/cs/AppDomainX.cs#1)]
 [!code-vb[AppDomainX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainX/VB/AppDomainX.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="ActivationContext">
      <MemberSignature Language="C#" Value="public ActivationContext ActivationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ActivationContext ActivationContext" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ActivationContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationContext As ActivationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ActivationContext ^ ActivationContext { ActivationContext ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ActivationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает контекст активации по умолчанию для текущего домена приложения.</summary>
        <value>Объект, представляющий контекст активации для текущего домена приложения, или значение <see langword="null" />, если этот домен не имеет контекста активации.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="AppendPrivatePath">
      <MemberSignature Language="C#" Value="public void AppendPrivatePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AppendPrivatePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.AppendPrivatePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendPrivatePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AppendPrivatePath(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.AppendPrivatePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Имя каталога, который следует добавить в закрытый путь.</param>
        <summary>Добавляет указанное имя каталога к закрытому списку путей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Использование этого свойства не рекомендуется, поскольку это может изменить путь поиска сборок для сборок после их загрузки. Вместо этого следует использовать свойство <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.  
  
 Закрытый путь или относительного пути поиска, — это путь, соответствующий базовому каталогу, где распознаватель сборок будет производить поиск закрытых сборок.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIdentity">
      <MemberSignature Language="C#" Value="public ApplicationIdentity ApplicationIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ApplicationIdentity ApplicationIdentity" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationIdentity As ApplicationIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ApplicationIdentity ^ ApplicationIdentity { ApplicationIdentity ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ApplicationIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает удостоверение приложения в данном домене приложения.</summary>
        <value>Объект, идентифицирующий приложение в данном домене приложения.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает информацию, описывающую разрешения, предоставленные приложению, и то, имеет ли приложение уровень доверия, позволяющий ему выполняться.</summary>
        <value>Объект, инкапсулирующий сведения о разрешениях и доверии для приложения в домене приложения.</value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="ApplyPolicy">
      <MemberSignature Language="C#" Value="public string ApplyPolicy (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyPolicy(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ApplyPolicy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyPolicy (assemblyName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyPolicy(System::String ^ assemblyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Отображаемое имя сборки в форме, заданной свойством <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Возвращает отображаемое имя сборки после применения политики.</summary>
        <returns>Строка, содержащая отображаемое имя сборки после применения политики.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ApplyPolicy%2A> Принимает сборку отображаемое имя и возвращает имя пользователя после применения политики. Это полезно, если необходимо загрузить сборку с использованием политики, так как в контексте только для отражения не применяет политики.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="C#" Value="public event AssemblyLoadEventHandler AssemblyLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.AssemblyLoadEventHandler AssemblyLoad" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyLoad As AssemblyLoadEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event AssemblyLoadEventHandler ^ AssemblyLoad;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyLoad</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AssemblyLoadEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>происходит, когда загружена сборка.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AssemblyLoadEventHandler> Делегат для этого события определяет, какая именно сборка была загружена.  
  
 Чтобы зарегистрировать обработчик событий для этого события, необходимо иметь необходимые разрешения, или <xref:System.Security.SecurityException> возникает исключение.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем образце показано <xref:System.AppDomain.AssemblyLoad> событий.  
  
 Для этого примера кода необходимо указать полное имя сборки. Сведения о том, как получить полное имя сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_AssemblyLoad#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CPP/assemblyload.cpp#1)]
 [!code-csharp[AppDomain_AssemblyLoad#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CS/assemblyload.cs#1)]
 [!code-vb[AppDomain_AssemblyLoad#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_AssemblyLoad/VB/assemblyload.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="AssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler AssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler AssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ AssemblyResolve;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда разрешение сборки завершается неудачей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Он отвечает <xref:System.ResolveEventHandler> для этого события возврат сборки, который задается параметром <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> свойства, или возвращает значение null, если сборка не распознан. Сборка должна быть загружена в контекст выполнения; Если он загружается в контекст только для отражения, загрузка, вызвавшая данное событие, создаваемое завершается ошибкой.  
  
 Рекомендации по использованию этого события см. в разделе [разрешение загрузки сборок](~/docs/framework/app-domains/resolve-assembly-loads.md).  
  
 Начиная с версии [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> свойство возвращает сборку, запросившего загрузку сборки, которую не удалось разрешить. Например загрузчик может быть не удалось загрузить зависимость запрашивающей сборки, так как запрашивающей сборки и ее зависимости не находятся в путь поиска сборок. Знание идентификатора запрашивающей сборки может оказаться полезным при поиске зависимости или определить правильную версию, если доступно более одной версии зависимости. Дополнительные сведения см. в разделе <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
> [!IMPORTANT]
>  Начиная с версии [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], <xref:System.ResolveEventHandler> событие вызывается для всех сборок, включая сборки ресурсов. В более ранних версиях событие не возникло сборок ресурсов. Если локализованные операционной системы, обработчик может вызываться несколько раз: один раз для каждого языка и региональных параметров в цепи перехода.  
  
 Для этого события <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> свойство возвращает имя сборки, перед применением политики.  
  
> [!IMPORTANT]
>  Если зарегистрировано несколько обработчиков событий для данного события, handlersarecalled события в порядке, пока обработчик события возвращает значение, не `null`. Последующие обработчики учитываются.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем образце показано <xref:System.AppDomain.AssemblyResolve> событий.  
  
 Для этого примера кода необходимо указать полное имя сборки. Сведения о том, как получить полное имя сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AssemblyResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyResolve/CPP/assemblyresolve.cpp#1)]
 [!code-csharp[AssemblyResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyResolve/CS/assemblyresolve.cs#1)]
 [!code-vb[AssemblyResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyResolve/VB/assemblyresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.BaseDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BaseDirectory { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.BaseDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает базовый каталог, в котором распознаватель сборок производит поиск.</summary>
        <value>Базовый каталог, в котором распознаватель сборок производит поиск.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство соответствует <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> свойство. Его также можно получить с помощью <xref:System.AppDomain.GetData%2A> метод со строкой «APPBASE».  
  
   
  
## Examples  
 В следующем примере кода создается новый домен приложения, указав базовый каталог, используемый при поиске сборок для загрузки в домен. Затем в примере используется <xref:System.AppDomain.BaseDirectory%2A> , чтобы получить путь к базовому каталогу, для отображения в консоли.  
  
 [!code-cpp[ADSetup#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetup/CPP/adsetup.cpp#1)]
 [!code-csharp[ADSetup#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetup/CS/adsetup.cs#1)]
 [!code-vb[ADSetup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetup/VB/adsetup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям в самом пути, если он имеет форму «file://» или \\\UNC\dir или «c:\\». Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="P:System.AppDomainSetup.ApplicationBase" />
      </Docs>
    </Member>
    <Member MemberName="ClearPrivatePath">
      <MemberSignature Language="C#" Value="public void ClearPrivatePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearPrivatePath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearPrivatePath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearPrivatePath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearPrivatePath();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearPrivatePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Сбрасывает путь, указывающий на размещение закрытых сборок, присваивая ему пустую строку ("").</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Закрытый путь — это путь, соответствующий базовому каталогу, в которое общеязыковая среда выполнения ищет закрытые сборки.  
  
 Дополнительные сведения см. в разделе <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере кода демонстрируется использование <xref:System.AppDomain.ClearPrivatePath%2A> метод, чтобы удалить все записи из списка закрытых путей для поиска при загрузке сборок.  
  
 Этот метод устарел и не должен использоваться для разработки новых приложений.  
  
 [!code-cpp[ADClearPrivatePath#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADClearPrivatePath/CPP/adclearprivatepath.cpp#1)]
 [!code-csharp[ADClearPrivatePath#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADClearPrivatePath/CS/adclearprivatepath.cs#1)]
 [!code-vb[ADClearPrivatePath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADClearPrivatePath/VB/adclearprivatepath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <Member MemberName="ClearShadowCopyPath">
      <MemberSignature Language="C#" Value="public void ClearShadowCopyPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearShadowCopyPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearShadowCopyPath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearShadowCopyPath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearShadowCopyPath();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearShadowCopyPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Сбрасывает список каталогов, содержащих теневые копии сборок, присваивая ему пустую строку ("").</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Путь к теневым копиям — список каталогов, где теневые копии сборок, сохраняются.  
  
 Дополнительные сведения см. в разделе <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> и [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новый экземпляр заданного типа COM.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Имя файла, который содержит сборку, определяющую запрошенный тип.</param>
        <param name="typeName">Имя запрошенного типа.</param>
        <summary>Создает новый экземпляр заданного типа COM. Параметры задают имя файла сборки, содержащей этот тип, и имя типа.</summary>
        <returns>Объект, являющийся оболочкой для нового экземпляра, заданного параметром <paramref name="typeName" />. Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, чтобы создавать объекты удаленно, не загружая тип локально.  
  
 Возвращаемое значение необходимо развернуть, чтобы получить доступ к реальному объекту.  
  
 Объект <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> атрибут со значением `true` явно или по умолчанию должен быть применен тип модели COM для этого метода для создания экземпляра этого типа; в противном случае <xref:System.TypeLoadException> возникает исключение.  
  
   
  
## Examples  
 В следующем образце показано  
  
 [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CPP/createcominstancefrom.cpp#1)]
 [!code-csharp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CS/createcominstancefrom.cs#1)]
 [!code-vb[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/VB/createcominstancefrom.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="assemblyName" /> или <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Не удалось загрузить тип.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.MissingMethodException">Открытый конструктор без параметров не найден.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyName" /> не найден.</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" /> является абстрактным классом.  
  
 - или -  
  
 Этот элемент был вызван при помощи механизма позднего связывания.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          Параметр <paramref name="assemblyName" /> является пустой строкой ("").</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> не является допустимой сборкой.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.NullReferenceException">Указанный объект COM равен <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">для возможности доступа к каталогу сборки, если сборка не является локальным.</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyFile As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя файла, который содержит сборку, определяющую запрошенный тип.</param>
        <param name="typeName">Имя запрошенного типа.</param>
        <param name="hashValue">Представляет значение вычисляемого хэш-кода.</param>
        <param name="hashAlgorithm">Представляет хэш-алгоритм, используемый манифестом сборки.</param>
        <summary>Создает новый экземпляр заданного типа COM. Параметры задают имя файла сборки, содержащей этот тип, и имя типа.</summary>
        <returns>Объект, являющийся оболочкой для нового экземпляра, заданного параметром <paramref name="typeName" />. Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, чтобы создавать объекты удаленно, не загружая тип локально.  
  
 Возвращаемое значение необходимо развернуть, чтобы получить доступ к реальному объекту.  
  
 Объект <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> атрибут со значением `true` явно или по умолчанию должен быть применен тип модели COM для этого метода для создания экземпляра этого типа; в противном случае <xref:System.TypeLoadException> возникает исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="assemblyName" /> или <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.TypeLoadException">Не удалось загрузить тип.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.MissingMethodException">Открытый конструктор без параметров не найден.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> не найден.</exception>
        <exception cref="T:System.MemberAccessException">
          <paramref name="typeName" /> является абстрактным классом.  
  
 - или -  
  
 Этот элемент был вызван при помощи механизма позднего связывания.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="assemblyFile" /> является пустой строкой ("").</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> не является допустимой сборкой.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.NullReferenceException">Указанный объект COM равен <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">для возможности доступа к каталогу сборки, если сборка не является локальным.</permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDomain">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новый домен приложения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Понятное имя домена.</param>
        <summary>Создает новый домен приложения с заданным именем.</summary>
        <returns>Вновь созданный домен приложения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `friendlyName` Предназначен для определения домена таким способом, понятным пользователю. Эта строка должна быть пригодна для отображения в пользовательском интерфейсе.  
  
 Данная перегрузка метода использует <xref:System.AppDomainSetup> сведения из домена приложения по умолчанию.  
  
   
  
## Examples  
 В следующем образце показано, как правило, как создать домен, с помощью одного из <xref:System.AppDomain.CreateDomain%2A> перегрузки.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="friendlyName" /> имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Чтобы получить свидетельство. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="P:System.AppDomain.FriendlyName" />
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Понятное имя домена. Это понятное имя может отображаться в пользовательском интерфейсе для определения домена. Дополнительные сведения см. в разделе <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Свидетельство, идентифицирующее код, который выполняется в домене приложения. Передайте значение <see langword="null" /> для использования свидетельства текущего домена приложения.</param>
        <summary>Создает новый домен приложения с заданным именем с помощью предоставленного свидетельства.</summary>
        <returns>Вновь созданный домен приложения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Данная перегрузка метода использует <xref:System.AppDomainSetup> сведения из домена приложения по умолчанию.  
  
 Если `securityInfo` — не указано, используется свидетельство из текущего домена приложения.  
  
> [!IMPORTANT]
>  Не используйте перегрузку этого метода для создания изолированных доменов приложений. Начиная с версии [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], свидетельство, предоставляемое для `securityInfo` больше не влияет на набор разрешений домена приложения. Используйте <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> перегрузка метода для создания изолированных доменов приложений.  
  
   
  
## Examples  
 В следующем образце показано, как правило, как создать домен, с помощью одного из <xref:System.AppDomain.CreateDomain%2A> перегрузки.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="friendlyName" /> имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Чтобы получить свидетельство. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Понятное имя домена. Это понятное имя может отображаться в пользовательском интерфейсе для определения домена. Дополнительные сведения см. в разделе <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Свидетельство, идентифицирующее код, который выполняется в домене приложения. Передайте значение <see langword="null" /> для использования свидетельства текущего домена приложения.</param>
        <param name="info">Объект, в котором содержатся сведения об инициализации домена приложения.</param>
        <summary>Создает новый домен приложения с использованием заданного имени, свидетельства и сведений об установке домена приложения.</summary>
        <returns>Вновь созданный домен приложения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `info` — не указано, используется перегрузка метода <xref:System.AppDomainSetup> сведения из домена приложения по умолчанию.  
  
 Если `securityInfo` — не указано, используется свидетельство из текущего домена приложения.  
  
> [!IMPORTANT]
>  Не используйте перегрузку этого метода для создания изолированных доменов приложений. Начиная с версии [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], свидетельство, предоставляемое для `securityInfo` больше не влияет на набор разрешений домена приложения. Используйте <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> перегрузка метода для создания изолированных доменов приложений.  
  
   
  
## Examples  
 В следующем образце показано, как правило, как создать домен, с помощью одного из <xref:System.AppDomain.CreateDomain%2A> перегрузки.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="friendlyName" /> имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Чтобы получить свидетельство. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, params System.Security.Policy.StrongName[] fullTrustAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info, class System.Security.PermissionSet grantSet, class System.Security.Policy.StrongName[] fullTrustAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup, grantSet As PermissionSet, ParamArray fullTrustAssemblies As StrongName()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info, System::Security::PermissionSet ^ grantSet, ... cli::array &lt;System::Security::Policy::StrongName ^&gt; ^ fullTrustAssemblies);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
        <Parameter Name="grantSet" Type="System.Security.PermissionSet" />
        <Parameter Name="fullTrustAssemblies" Type="System.Security.Policy.StrongName[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="friendlyName">Понятное имя домена. Это понятное имя может отображаться в пользовательском интерфейсе для определения домена. Дополнительные сведения см. в описании <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Свидетельство, идентифицирующее код, который выполняется в домене приложения. Передайте значение <see langword="null" /> для использования свидетельства текущего домена приложения.</param>
        <param name="info">Объект, в котором содержатся сведения об инициализации домена приложения.</param>
        <param name="grantSet">Набор разрешений по умолчанию, который предоставляется всем сборкам, загружаемым в новый домен приложения, который не имеет специальные разрешения.</param>
        <param name="fullTrustAssemblies">Массив строгих имен, представляющих сборки, которые будут считаться обладающими полным доверием в новом домене приложения.</param>
        <summary>Создает новый домен приложения с использованием заданного имени, свидетельства, сведений об установке домена приложения, используемого по умолчанию набора разрешений и массива сборок с полным доверием.</summary>
        <returns>Вновь созданный домен приложения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Необходимо задать <xref:System.AppDomainSetup.ApplicationBase%2A> свойство <xref:System.AppDomainSetup> , указываемое в качестве объекта `info`. В противном случае создается исключение.  
  
 Если `securityInfo` — не указано, используется свидетельство из текущего домена приложения.  
  
 Информация о `grantSet` и `fullTrustAssemblies` используется для создания <xref:System.Security.Policy.ApplicationTrust> объекта для нового домена приложения.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="friendlyName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Домен приложения равен <see langword="null" />.  
  
 - или -  
  
 Свойство <see cref="P:System.AppDomainSetup.ApplicationBase" /> не задано в объекте <see cref="T:System.AppDomainSetup" />, который предоставляется для <paramref name="info" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности создания и управления доменом приложения. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Понятное имя домена. Это понятное имя может отображаться в пользовательском интерфейсе для определения домена. Дополнительные сведения см. в разделе <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Свидетельство, идентифицирующее код, который выполняется в домене приложения. Передайте значение <see langword="null" /> для использования свидетельства текущего домена приложения.</param>
        <param name="appBasePath">Базовый каталог, в котором распознаватель сборок производит поиск. Дополнительные сведения см. в разделе <see cref="P:System.AppDomain.BaseDirectory" />.</param>
        <param name="appRelativeSearchPath">Путь, соответствующий базовому каталогу, в котором распознаватель сборок будет производить поиск закрытых сборок. Дополнительные сведения см. в разделе <see cref="P:System.AppDomain.RelativeSearchPath" />.</param>
        <param name="shadowCopyFiles">Если значение <see langword="true" />, теневая копия сборки загружается в этот домен приложения.</param>
        <summary>Создает новый домен приложения с заданным именем с использованием свидетельства, пути к базовой папке приложения, относительного пути поиска и параметра, указывающего, должна ли загружаться теневая копия сборки в домен приложения.</summary>
        <returns>Вновь созданный домен приложения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `securityInfo` — не указано, используется свидетельство из текущего домена приложения.  
  
 Дополнительные сведения о теневом копировании см. в разделе <xref:System.AppDomain.ShadowCopyFiles%2A> и [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
> [!IMPORTANT]
>  Не используйте перегрузку этого метода для создания изолированных доменов приложений. Начиная с версии [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], свидетельство, предоставляемое для `securityInfo` больше не влияет на набор разрешений домена приложения. Используйте <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> перегрузка метода для создания изолированных доменов приложений.  
  
   
  
## Examples  
 В следующем образце показано, как правило, как создать домен, с помощью одного из <xref:System.AppDomain.CreateDomain%2A> перегрузки.  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="friendlyName" /> имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Чтобы получить свидетельство. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, class System.AppDomainInitializer adInit, string[] adInitArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean, adInit As AppDomainInitializer, adInitArgs As String()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer ^ adInit, cli::array &lt;System::String ^&gt; ^ adInitArgs);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
        <Parameter Name="adInit" Type="System.AppDomainInitializer" />
        <Parameter Name="adInitArgs" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="friendlyName">Понятное имя домена. Это понятное имя может отображаться в пользовательском интерфейсе для определения домена. Дополнительные сведения см. в разделе <see cref="P:System.AppDomain.FriendlyName" />.</param>
        <param name="securityInfo">Свидетельство, идентифицирующее код, который выполняется в домене приложения. Передайте значение <see langword="null" /> для использования свидетельства текущего домена приложения.</param>
        <param name="appBasePath">Базовый каталог, в котором распознаватель сборок производит поиск. Дополнительные сведения см. в разделе <see cref="P:System.AppDomain.BaseDirectory" />.</param>
        <param name="appRelativeSearchPath">Путь, соответствующий базовому каталогу, в котором распознаватель сборок будет производить поиск закрытых сборок. Дополнительные сведения см. в разделе <see cref="P:System.AppDomain.RelativeSearchPath" />.</param>
        <param name="shadowCopyFiles">
          Значение <see langword="true" /> для загрузки теневой копии сборки в этот домен приложения.</param>
        <param name="adInit">Делегат <see cref="T:System.AppDomainInitializer" />, представляющий метод обратного вызова, вызываемый при инициализации нового объекта <see cref="T:System.AppDomain" />.</param>
        <param name="adInitArgs">Массив строковых аргументов для передачи в обратный вызов, представленный объектом <c>adInit</c>, когда инициализируется новый объект <see cref="T:System.AppDomain" />.</param>
        <summary>Создает новый домен приложения с заданным именем с использованием свидетельства, пути к базовой папке приложения, относительного пути поиска и параметра, указывающего, должна ли загружаться теневая копия сборки в домен приложения. Задает метод обратного вызова, вызываемый, когда инициализируется домен приложения, и массив строковых аргументов для передачи методу обратного вызова.</summary>
        <returns>Вновь созданный домен приложения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод, представленный `adInit` выполняется в контексте вновь созданный домен приложения.  
  
 Если `securityInfo` — не указано, используется свидетельство из текущего домена приложения.  
  
 Дополнительные сведения о теневом копировании см. в разделе <xref:System.AppDomain.ShadowCopyFiles%2A> и [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
> [!IMPORTANT]
>  Не используйте перегрузку этого метода для создания изолированных доменов приложений. Начиная с версии [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], свидетельство, предоставляемое для `securityInfo` больше не влияет на набор разрешений домена приложения. Используйте <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> перегрузка метода для создания изолированных доменов приложений.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="friendlyName" /> имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Чтобы получить свидетельство. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новый экземпляр заданного типа, определенного в указанной сборке.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Отображаемое имя сборки. См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</param>
        <summary>Создает новый экземпляр заданного типа, определенного в указанной сборке.</summary>
        <returns>Объект, являющийся оболочкой для нового экземпляра, заданного параметром <paramref name="typeName" />. Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывает конструктор по умолчанию для `typeName`.  
  
 В разделе <xref:System.Reflection.AssemblyName> форматирования `assemblyName`.  
  
 Попытка вызвать <xref:System.AppDomain.CreateInstance%2A> на целевой домен приложения, который не является текущий домен приложения приведет к успешной загрузки сборки в целевом домене приложения. Поскольку <xref:System.Reflection.Assembly> не <xref:System.MarshalByRefObject>, когда этот метод пытается вернуть <xref:System.Reflection.Assembly> загруженной сборки в текущий домен приложения, общеязыковая среда выполнения предпринимает попытку загрузить сборку в текущем домене приложения и Загрузка может оказаться неудачной. Сборка, загруженная в текущий домен приложения может отличаться от сборки, загруженной во-первых, если параметры пути для двух доменов приложений отличаются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="assemblyName" /> или <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> не является допустимой сборкой.  
  
 - или -  
  
 В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Не удалось найти <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.TypeLoadException">
          Не удалось найти <paramref name="typename" /> в <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">Этот экземпляр имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа на чтение из файла или каталога, а также для доступа к сведениям в сам путь. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">для возможности доступа к каталогу сборки, если сборка не является локальным.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода, при создании экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Отображаемое имя сборки. См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</param>
        <param name="activationAttributes">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации. Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.    
  
 Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation. </param>
        <summary>Создает новый экземпляр заданного типа, определенного в указанной сборке. Параметр определяет массив атрибутов активации.</summary>
        <returns>Объект, являющийся оболочкой для нового экземпляра, заданного параметром <paramref name="typeName" />. Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывает конструктор по умолчанию для `typeName`.  
  
 В разделе <xref:System.Reflection.AssemblyName> форматирования `assemblyName`.  
  
 Попытка вызвать <xref:System.AppDomain.CreateInstance%2A> на целевой домен приложения, который не является текущий домен приложения приведет к успешной загрузки сборки в целевом домене приложения. Поскольку <xref:System.Reflection.Assembly> не <xref:System.MarshalByRefObject>, когда этот метод пытается вернуть <xref:System.Reflection.Assembly> загруженной сборки в текущий домен приложения, общеязыковая среда выполнения предпринимает попытку загрузить сборку в текущем домене приложения и Загрузка может оказаться неудачной. Сборка, загруженная в текущий домен приложения может отличаться от сборки, загруженной во-первых, если параметры пути для двух доменов приложений отличаются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="assemblyName" /> или <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> не является допустимой сборкой.  
  
 - или -  
  
 В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Не удалось найти <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.TypeLoadException">
          Не удалось найти <paramref name="typename" /> в <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">Этот экземпляр имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">для возможности доступа к каталогу сборки, если сборка не является локальным.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода, при создании экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для возможности вызова операций для всех членов типа. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Отображаемое имя сборки. См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</param>
        <param name="ignoreCase">Логическое значение, указывающее, следует ли учитывать регистр при поиске.</param>
        <param name="bindingAttr">Сочетание битовых флагов (от нуля и более), влияющих на поиск конструктора <c>typeName</c>. Если значение параметра <c>bindingAttr</c> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</param>
        <param name="binder">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <see cref="T:System.Reflection.MemberInfo" /> с помощью отражения. Если параметр <c>binder</c> имеет значение NULL, то используется модуль привязки по умолчанию.</param>
        <param name="args">Аргументы для передачи конструктору. Массив аргументов должен соответствовать по числу, порядку и типу параметров вызываемому конструктору. Если предпочтителен конструктор по умолчанию, то объект <c>args</c> должен быть пустым массивом или иметь значение NULL.</param>
        <param name="culture">Сведения о языке и региональных параметрах, которые влияют на приведение <c>args</c> к формальным типам, объявленным для конструктора <c>typeName</c>. Если параметр <c>culture</c> имеет значение <see langword="null" />, используется <see cref="T:System.Globalization.CultureInfo" /> для текущего потока.</param>
        <param name="activationAttributes">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации. Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.    
  
 Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation. </param>
        <summary>Создает новый экземпляр заданного типа, определенного в указанной сборке. Параметры определяют средство связывания, флаги привязки, аргументы конструктора, сведения, связанные с языком и региональными параметрами, используемые для интерпретации аргументов, и необязательные атрибуты активации.</summary>
        <returns>Объект, являющийся оболочкой для нового экземпляра, заданного параметром <paramref name="typeName" />. Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В разделе <xref:System.Reflection.AssemblyName> форматирования `assemblyName`.  
  
 Попытка вызвать <xref:System.AppDomain.CreateInstance%2A> на целевой домен приложения, который не является текущий домен приложения приведет к успешной загрузки сборки в целевом домене приложения. Поскольку <xref:System.Reflection.Assembly> не <xref:System.MarshalByRefObject>, когда этот метод пытается вернуть <xref:System.Reflection.Assembly> загруженной сборки в текущий домен приложения, общеязыковая среда выполнения предпринимает попытку загрузить сборку в текущем домене приложения и Загрузка может оказаться неудачной. Сборка, загруженная в текущий домен приложения может отличаться от сборки, загруженной во-первых, если параметры пути для двух доменов приложений отличаются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="assemblyName" /> или <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> не является допустимой сборкой.  
  
 - или -  
  
 Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Не удалось найти <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий конструктор не найден.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.TypeLoadException">
          Не удалось найти <paramref name="typename" /> в <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">Этот экземпляр имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">для возможности доступа к каталогу сборки, если сборка не является локальным.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода, при создании экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для возможности вызова операций для всех членов типа. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Отображаемое имя сборки. См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</param>
        <param name="ignoreCase">Логическое значение, указывающее, следует ли учитывать регистр при поиске.</param>
        <param name="bindingAttr">Сочетание битовых флагов (от нуля и более), влияющих на поиск конструктора <c>typeName</c>. Если значение параметра <c>bindingAttr</c> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</param>
        <param name="binder">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <see cref="T:System.Reflection.MemberInfo" /> с помощью отражения. Если параметр <c>binder</c> имеет значение NULL, то используется модуль привязки по умолчанию.</param>
        <param name="args">Аргументы для передачи конструктору. Массив аргументов должен соответствовать по числу, порядку и типу параметров вызываемому конструктору. Если предпочтителен конструктор по умолчанию, то объект <c>args</c> должен быть пустым массивом или иметь значение NULL.</param>
        <param name="culture">Сведения о языке и региональных параметрах, которые влияют на приведение <c>args</c> к формальным типам, объявленным для конструктора <c>typeName</c>. Если параметр <c>culture</c> имеет значение <see langword="null" />, используется <see cref="T:System.Globalization.CultureInfo" /> для текущего потока.</param>
        <param name="activationAttributes">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации. Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.    
  
 Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation. </param>
        <param name="securityAttributes">Сведения, используемые для авторизации создания <c>typeName</c>.</param>
        <summary>Создает новый экземпляр заданного типа, определенного в указанной сборке. Параметры определяют средство связывания, флаги привязки, аргументы конструктора, сведения, связанные с языком и региональными параметрами, используемые для интерпретации аргументов, атрибуты активации и авторизацию для создания типа.</summary>
        <returns>Объект, являющийся оболочкой для нового экземпляра, заданного параметром <paramref name="typeName" />. Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В разделе <xref:System.Reflection.AssemblyName> форматирования `assemblyName`.  
  
 Попытка вызвать <xref:System.AppDomain.CreateInstance%2A> на целевой домен приложения, который не является текущий домен приложения приведет к успешной загрузки сборки в целевом домене приложения. Поскольку <xref:System.Reflection.Assembly> не <xref:System.MarshalByRefObject>, когда этот метод пытается вернуть <xref:System.Reflection.Assembly> загруженной сборки в текущий домен приложения, общеязыковая среда выполнения предпринимает попытку загрузить сборку в текущем домене приложения и Загрузка может оказаться неудачной. Сборка, загруженная в текущий домен приложения может отличаться от сборки, загруженной во-первых, если параметры пути для двух доменов приложений отличаются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="assemblyName" /> или <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> не является допустимой сборкой.  
  
 - или -  
  
 В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Не удалось найти <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий конструктор не найден.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.  
  
 - или -  
  
 <paramref name="securityAttributes" /> не является <see langword="null" />. Когда устаревшие политики разграничения доступа кода не включены, <paramref name="securityAttributes" /> должен равняться <see langword="null." />.</exception>
        <exception cref="T:System.TypeLoadException">
          Не удалось найти <paramref name="typename" /> в <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.NullReferenceException">Этот экземпляр имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">для возможности доступа к каталогу сборки, если сборка не является локальным.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Чтобы получить свидетельство. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для возможности вызова операций для всех членов типа. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новый экземпляр заданного типа.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Отображаемое имя сборки. См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</param>
        <summary>Создает новый экземпляр заданного типа. Параметры задают сборку, где определен тип, и имя типа.</summary>
        <returns>Экземпляр объекта, заданного параметром <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это удобный метод, который объединяет <xref:System.AppDomain.CreateInstance%2A> и <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Этот метод вызывает конструктор по умолчанию для `typeName`.  
  
 В разделе <xref:System.Reflection.AssemblyName> форматирования `assemblyName`. В разделе <xref:System.Type.FullName%2A?displayProperty=nameWithType> свойства форматирования `typeName`.  
  
> [!NOTE]
>  Если вызов с ранним связыванием метод `M` объекта типа `T1` , возвращенный <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, и что метод осуществляет вызов с ранним связыванием метод объекта типа `T2` в сборке `C` отличный от Текущая сборка или сборка, содержащая `T1`, сборка `C` загружается в текущий домен приложения. Данная загрузка происходит даже если вызов с ранним связыванием `T1.M()` было внесено в тексте <xref:System.Reflection.Emit.DynamicMethod>, или в других динамически создаваемый код. Если текущий домен является доменом по умолчанию, сборка `C` не может быть выгружен до завершения процесса. Если текущий домен позже пытается загрузить сборку `C`, загрузка может завершиться ошибкой.  
  
   
  
## Examples  
 В следующем примере кода показан простой способ выполнения кода в другом домене приложения. В примере определяется класс с именем `Worker` , наследуемый от <xref:System.MarshalByRefObject>. `Worker` Класса определяет метод, который отображает имя домена приложения, в котором он выполняется. В примере создается экземпляров `Worker` в домене приложения по умолчанию и в новый домен приложения.  
  
> [!NOTE]
>  Сборка, содержащая `Worker` должна быть загружена в оба домена приложения, но его можно загрузить сборки, которые существуют только в новом домене приложения.  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="assemblyName" /> или <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.TypeLoadException">
          Не удалось найти <paramref name="typename" /> в <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Не удалось найти <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> не является допустимой сборкой.  
  
 - или -  
  
 В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки или если вы создаете тип из модуля, отличного от файла манифеста. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">для возможности доступа к каталогу сборки, если сборка не является локальным.</permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Отображаемое имя сборки. См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</param>
        <param name="activationAttributes">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации. Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.    
  
 Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation. </param>
        <summary>Создает новый экземпляр заданного типа. Параметры задают сборку, где определен тип, имя типа и массив атрибутов активации.</summary>
        <returns>Экземпляр объекта, заданного параметром <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это удобный метод, который объединяет <xref:System.AppDomain.CreateInstance%2A> и <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Этот метод вызывает конструктор по умолчанию для `typeName`.  
  
 В разделе <xref:System.Reflection.AssemblyName> форматирования `assemblyName`. В разделе <xref:System.Type.FullName%2A?displayProperty=nameWithType> свойства форматирования `typeName`.  
  
> [!NOTE]
>  Если вызов с ранним связыванием метод `M` объекта типа `T1` , возвращенный <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, и что метод осуществляет вызов с ранним связыванием метод объекта типа `T2` в сборке `C` отличный от Текущая сборка или сборка, содержащая `T1`, сборка `C` загружается в текущий домен приложения. Данная загрузка происходит даже если вызов с ранним связыванием `T1.M()` было внесено в тексте <xref:System.Reflection.Emit.DynamicMethod>, или в других динамически создаваемый код. Если текущий домен является доменом по умолчанию, сборка `C` не может быть выгружен до завершения процесса. Если текущий домен позже пытается загрузить сборку `C`, загрузка может завершиться ошибкой.  
  
   
  
## Examples  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="assemblyName" /> или <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.TypeLoadException">
          Не удалось найти <paramref name="typename" /> в <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Не удалось найти <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> не является допустимой сборкой.  
  
 - или -  
  
 В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">для возможности доступа к каталогу сборки, если сборка не является локальным.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода, при создании экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для возможности вызова операций для всех членов типа. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Отображаемое имя сборки. См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</param>
        <param name="ignoreCase">Логическое значение, указывающее, следует ли учитывать регистр при поиске.</param>
        <param name="bindingAttr">Сочетание битовых флагов (от нуля и более), влияющих на поиск конструктора <c>typeName</c>. Если значение параметра <c>bindingAttr</c> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</param>
        <param name="binder">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <see cref="T:System.Reflection.MemberInfo" /> с помощью отражения. Если параметр <c>binder</c> имеет значение NULL, то используется модуль привязки по умолчанию.</param>
        <param name="args">Аргументы для передачи конструктору. Массив аргументов должен соответствовать по числу, порядку и типу параметров вызываемому конструктору. Если предпочтителен конструктор по умолчанию, то объект <c>args</c> должен быть пустым массивом или иметь значение NULL.</param>
        <param name="culture">Объект, зависящий от языка и региональных параметров, который используется для управления приведением типов. Если параметр <c>culture</c> имеет значение <see langword="null" />, используется <see langword="CultureInfo" /> для текущего потока.</param>
        <param name="activationAttributes">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации. Как правило, массив, который содержит единственный объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />. который определяет URL-адрес, необходимый для активации удаленного объекта.  
  
 Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation. </param>
        <summary>Создает новый экземпляр заданного типа, определенного в заданной сборке, указывая, игнорируется ли регистр имени типа; атрибуты привязки и средство привязки, используемые для выбора создаваемого типа; аргументы конструктора; язык и региональные параметры; и атрибуты активации.</summary>
        <returns>Экземпляр объекта, заданного параметром <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это удобный метод, который объединяет <xref:System.AppDomain.CreateInstance%2A> и <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 В разделе <xref:System.Reflection.AssemblyName> форматирования `assemblyName`. В разделе <xref:System.Type.FullName%2A?displayProperty=nameWithType> свойства форматирования `typeName`.  
  
> [!NOTE]
>  Если вызов с ранним связыванием метод `M` объекта типа `T1` , возвращенный <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, и что метод осуществляет вызов с ранним связыванием метод объекта типа `T2` в сборке `C` отличный от Текущая сборка или сборка, содержащая `T1`, сборка `C` загружается в текущий домен приложения. Данная загрузка происходит даже если вызов с ранним связыванием `T1.M()` было внесено в тексте <xref:System.Reflection.Emit.DynamicMethod>, или в других динамически создаваемый код. Если текущий домен является доменом по умолчанию, сборка `C` не может быть выгружен до завершения процесса. Если текущий домен позже пытается загрузить сборку `C`, загрузка может завершиться ошибкой.  
  
   
  
## Examples  
 В следующем образце показано использование `ignoreCase` параметра.  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="assemblyName" /> или <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий конструктор не найден.</exception>
        <exception cref="T:System.TypeLoadException">
          Не удалось найти <paramref name="typename" /> в <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Не удалось найти <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> не является допустимой сборкой.  
  
 - или -  
  
 Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">для возможности доступа к каталогу сборки, если сборка не является локальным.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода, при создании экземпляра делегата. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для возможности вызова операций для всех членов типа. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Отображаемое имя сборки. См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</param>
        <param name="ignoreCase">Логическое значение, указывающее, следует ли учитывать регистр при поиске.</param>
        <param name="bindingAttr">Сочетание битовых флагов (от нуля и более), влияющих на поиск конструктора <c>typeName</c>. Если значение параметра <c>bindingAttr</c> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</param>
        <param name="binder">Объект, позволяющий осуществлять привязку, приведение типов аргументов, вызов элементов, а также поиск объектов <see cref="T:System.Reflection.MemberInfo" /> с помощью отражения. Если параметр <c>binder</c> имеет значение NULL, то используется модуль привязки по умолчанию.</param>
        <param name="args">Аргументы для передачи конструктору. Массив аргументов должен соответствовать по числу, порядку и типу параметров вызываемому конструктору. Если предпочтителен конструктор по умолчанию, то объект <c>args</c> должен быть пустым массивом или иметь значение NULL.</param>
        <param name="culture">Объект, зависящий от языка и региональных параметров, который используется для управления приведением типов. Если параметр <c>culture</c> имеет значение <see langword="null" />, используется <see langword="CultureInfo" /> для текущего потока.</param>
        <param name="activationAttributes">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации. Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.    
  
 Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation. </param>
        <param name="securityAttributes">Сведения, используемые для авторизации создания <c>typeName</c>.</param>
        <summary>Создает новый экземпляр заданного типа. Параметры определяют имя типа, а также способ его поиска и создания.</summary>
        <returns>Экземпляр объекта, заданного параметром <paramref name="typeName" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это удобный метод, который объединяет <xref:System.AppDomain.CreateInstance%2A> и <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 В разделе <xref:System.Reflection.AssemblyName> форматирования `assemblyName`. В разделе <xref:System.Type.FullName%2A?displayProperty=nameWithType> свойства форматирования `typeName`.  
  
> [!NOTE]
>  Если вызов с ранним связыванием метод `M` объекта типа `T1` , возвращенный <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, и что метод осуществляет вызов с ранним связыванием метод объекта типа `T2` в сборке `C` отличный от Текущая сборка или сборка, содержащая `T1`, сборка `C` загружается в текущий домен приложения. Данная загрузка происходит даже если вызов с ранним связыванием `T1.M()` было внесено в тексте <xref:System.Reflection.Emit.DynamicMethod>, или в других динамически создаваемый код. Если текущий домен является доменом по умолчанию, сборка `C` не может быть выгружен до завершения процесса. Если текущий домен позже пытается загрузить сборку `C`, загрузка может завершиться ошибкой.  
  
   
  
## Examples  
 В следующем образце показано использование `ignoreCase` параметра.  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="assemblyName" /> или <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий конструктор не найден.</exception>
        <exception cref="T:System.TypeLoadException">
          Не удалось найти <paramref name="typename" /> в <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Не удалось найти <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет разрешения на вызов этого конструктора.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> не является допустимой сборкой.  
  
 - или -  
  
 В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">для возможности доступа к каталогу сборки, если сборка не является локальным.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки со свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">для возможности вызова операций для всех членов типа. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новый экземпляр заданного типа, определенного в указанном файле сборки.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя (включая путь) файла, который содержит сборку, определяющую запрошенный тип. Эта сборка загружается с помощью метода <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</param>
        <summary>Создает новый экземпляр заданного типа, определенного в указанном файле сборки.</summary>
        <returns>Объект, являющийся оболочкой для нового экземпляра, или значение <see langword="null" />, если объект <paramref name="typeName" /> не найден. Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Конструктор по умолчанию для `typeName` вызывается.  
  
 Дополнительные сведения см. в описании метода <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 Когда <xref:System.AppDomain.CreateInstanceFrom%2A> метод используется для создания экземпляра в целевой домен приложения, отличные от домена приложения, из которого был сделан вызов, сборка загружается в целевом домене приложения. Тем не менее если экземпляр является оболочку в домен вызывающего приложения, использование распакованного экземпляра определенными способами может вызвать сборка была загружена в домен вызывающего приложения. Например после оболочку экземпляра может быть запрошена сведения об этом типе, чтобы вызывать его методы позднего связывания. Если сборка загружается в домен вызывающего приложения, могут возникать исключения.  
  
-   Если ранее была загружена другая версия той же сборки в домен вызывающего приложения или путь загрузки домена приложения, вызывающего отличается от целевого домена приложения исключения например <xref:System.MissingMethodException> может произойти.  
  
-   Если вызывающий домен приложения выполняет вызовы с ранним связыванием тип экземпляра <xref:System.InvalidCastException> могут возникать при попытке приведения типа экземпляра.  
  
   
  
## Examples  
 В следующем примере показано, как использовать <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> перегрузка метода для создания экземпляра объекта в целевой домен приложения и вызывать его методы.  
  
 В примере определяется `MarshallableExample` класс, который может быть маршалирован через границы домена приложения. В примере формирует путь к текущей выполняемой сборке, создает конечный домен приложения и используется <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> перегрузка метода, чтобы загрузить пример сборку в целевом домене приложения и создайте экземпляр класса `MarshallableExample`.  
  
> [!NOTE]
>  Путь является абсолютным, в этом примере, но относительный путь также будет работать, поскольку <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> метод используется для загрузки сборки.  
  
 После развертывания дескриптор объекта, в примере показано три способа использования объекта в целевой домен приложения.  
  
-   Вызов метода с поздним связыванием, с помощью отражения. Для этого информацию о типе, вследствие чего сборка была загружена в домен приложения вызывающего объекта. (В этом примере он уже загружен.)  
  
-   Приведение объекта к интерфейсу, известный вызывающий и вызываемый объект. Если событие определено в вызывающей сборке или в третьем сборки, упоминаемой в вызывающий и вызываемый объект, вызываемой сборки не загружена в домен приложения вызывающего объекта.  
  
-   С помощью объекта напрямую, если его тип известен вызывающему объекту. Сборка должна быть загружена в домен приложения вызывающего объекта.  
  
 Другой способ избежать вызванного сборка загружается в домен приложения вызывающего объекта — вызывающий объект мог быть производным от <xref:System.MarshalByRefObject> класса и определение метода, который может быть запущен в целевом домене приложения. Этот метод может использовать отражение для проверки целевой сборки, так как целевая сборка уже загружена в целевом домене приложения. Далее приведен пример <xref:System.AppDomain.DynamicDirectory%2A> свойство.  
  
 [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cpp/example.cpp#1)]
 [!code-csharp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cs/example.cs#1)]
 [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Не удалось найти <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.TypeLoadException">
          Не удалось найти <paramref name="typeName" /> в <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.MissingMethodException">Открытый конструктор без параметров не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет достаточно разрешений для вызова этого конструктора.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> не является допустимой сборкой.  
  
 - или -  
  
 В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.NullReferenceException">Этот экземпляр имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">для возможности доступа к каталогу сборки, если сборка не является локальным.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя (включая путь) файла, который содержит сборку, определяющую запрошенный тип. Эта сборка загружается с помощью метода <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</param>
        <param name="activationAttributes">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации. Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.    
  
 Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation. </param>
        <summary>Создает новый экземпляр заданного типа, определенного в указанном файле сборки.</summary>
        <returns>Объект, являющийся оболочкой для нового экземпляра, или значение <see langword="null" />, если объект <paramref name="typeName" /> не найден. Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Конструктор по умолчанию для `typeName` вызывается.  
  
 Дополнительные сведения об этом методе см. в разделе <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> метод.  
  
 Когда <xref:System.AppDomain.CreateInstanceFrom%2A> метод используется для создания экземпляра в целевой домен приложения, отличные от домена приложения, из которого был сделан вызов, сборка загружается в целевом домене приложения. Тем не менее если экземпляр является оболочку в домен вызывающего приложения, использование распакованного экземпляра определенными способами может вызвать сборка была загружена в домен вызывающего приложения. Например после оболочку экземпляра может быть запрошена сведения об этом типе, чтобы вызывать его методы позднего связывания. Если сборка загружается в домен вызывающего приложения, могут возникать исключения.  
  
-   Если ранее была загружена другая версия той же сборки в домен вызывающего приложения или путь загрузки домена приложения, вызывающего отличается от целевого домена приложения исключения например <xref:System.MissingMethodException> может произойти.  
  
-   Если вызывающий домен приложения выполняет вызовы с ранним связыванием тип экземпляра <xref:System.InvalidCastException> могут возникать при попытке приведения типа экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Не удалось найти <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.TypeLoadException">
          Не удалось найти <paramref name="typeName" /> в <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет достаточно разрешений для вызова этого конструктора.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> не является допустимой сборкой.  
  
 - или -  
  
 В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.NullReferenceException">Этот экземпляр имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">для возможности доступа к каталогу сборки, если сборка не является локальным.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя (включая путь) файла, который содержит сборку, определяющую запрошенный тип. Эта сборка загружается с помощью метода <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</param>
        <param name="ignoreCase">Логическое значение, указывающее, следует ли учитывать регистр при поиске.</param>
        <param name="bindingAttr">Сочетание битовых флагов (от нуля и более), влияющих на поиск конструктора <c>typeName</c>. Если значение параметра <c>bindingAttr</c> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</param>
        <param name="binder">Объект, который допускает привязку, приведение типов аргументов, вызов элементов и извлечение объектов <see cref="T:System.Reflection.MemberInfo" /> путем отражения. Если параметр <c>binder</c> имеет значение NULL, то используется модуль привязки по умолчанию.</param>
        <param name="args">Аргументы для передачи конструктору. Массив аргументов должен соответствовать по числу, порядку и типу параметров вызываемому конструктору. Если предпочтителен конструктор по умолчанию, то объект <c>args</c> должен быть пустым массивом или иметь значение NULL.</param>
        <param name="culture">Сведения о языке и региональных параметрах, которые влияют на приведение <c>args</c> к формальным типам, объявленным для конструктора <c>typeName</c>. Если параметр <c>culture</c> имеет значение <see langword="null" />, используется <see cref="T:System.Globalization.CultureInfo" /> для текущего потока.</param>
        <param name="activationAttributes">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации. Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.    
  
 Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation. </param>
        <summary>Создает новый экземпляр заданного типа, определенного в указанном файле сборки.</summary>
        <returns>Объект, являющийся оболочкой для нового экземпляра, или значение <see langword="null" />, если объект <paramref name="typeName" /> не найден. Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в описании метода <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 Когда <xref:System.AppDomain.CreateInstanceFrom%2A> метод используется для создания экземпляра в целевой домен приложения, отличные от домена приложения, из которого был сделан вызов, сборка загружается в целевом домене приложения. Тем не менее если экземпляр является оболочку в домен вызывающего приложения, использование распакованного экземпляра определенными способами может вызвать сборка была загружена в домен вызывающего приложения. Например после оболочку экземпляра может быть запрошена сведения об этом типе, чтобы вызывать его методы позднего связывания. Если сборка загружается в домен вызывающего приложения, могут возникать исключения.  
  
-   Если ранее была загружена другая версия той же сборки в домен вызывающего приложения или путь загрузки домена приложения, вызывающего отличается от целевого домена приложения исключения например <xref:System.MissingMethodException> может произойти.  
  
-   Если вызывающий домен приложения выполняет вызовы с ранним связыванием тип экземпляра <xref:System.InvalidCastException> могут возникать при попытке приведения типа экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Не удалось найти <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.TypeLoadException">
          Не удалось найти <paramref name="typeName" /> в <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет достаточно разрешений для вызова этого конструктора.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> не является допустимой сборкой.  
  
 - или -  
  
 Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.NullReferenceException">Этот экземпляр имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">для возможности доступа к каталогу сборки, если сборка не является локальным.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя (включая путь) файла, который содержит сборку, определяющую запрошенный тип. Эта сборка загружается с помощью метода <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</param>
        <param name="ignoreCase">Логическое значение, указывающее, следует ли учитывать регистр при поиске.</param>
        <param name="bindingAttr">Сочетание битовых флагов (от нуля и более), влияющих на поиск конструктора <c>typeName</c>. Если значение параметра <c>bindingAttr</c> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</param>
        <param name="binder">Объект, который допускает привязку, приведение типов аргументов, вызов элементов и извлечение объектов <see cref="T:System.Reflection.MemberInfo" /> путем отражения. Если параметр <c>binder</c> имеет значение NULL, то используется модуль привязки по умолчанию.</param>
        <param name="args">Аргументы для передачи конструктору. Массив аргументов должен соответствовать по числу, порядку и типу параметров вызываемому конструктору. Если предпочтителен конструктор по умолчанию, то объект <c>args</c> должен быть пустым массивом или иметь значение NULL.</param>
        <param name="culture">Сведения о языке и региональных параметрах, которые влияют на приведение <c>args</c> к формальным типам, объявленным для конструктора <c>typeName</c>. Если параметр <c>culture</c> имеет значение <see langword="null" />, используется <see cref="T:System.Globalization.CultureInfo" /> для текущего потока.</param>
        <param name="activationAttributes">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации. Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.    
  
 Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation. </param>
        <param name="securityAttributes">Сведения, используемые для авторизации создания <c>typeName</c>.</param>
        <summary>Создает новый экземпляр заданного типа, определенного в указанном файле сборки.</summary>
        <returns>Объект, являющийся оболочкой для нового экземпляра, или значение <see langword="null" />, если объект <paramref name="typeName" /> не найден. Необходимо распаковать возвращенное значение, чтобы получить доступ к реальному объекту.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения об этом методе см. в разделе <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> метод.  
  
 Когда <xref:System.AppDomain.CreateInstanceFrom%2A> метод используется для создания экземпляра в целевой домен приложения, отличные от домена приложения, из которого был сделан вызов, сборка загружается в целевом домене приложения. Тем не менее если экземпляр является оболочку в домен вызывающего приложения, использование распакованного экземпляра определенными способами может вызвать сборка была загружена в домен вызывающего приложения. Например после оболочку экземпляра может быть запрошена сведения об этом типе, чтобы вызывать его методы позднего связывания. Если сборка загружается в домен вызывающего приложения, могут возникать исключения.  
  
-   Если ранее была загружена другая версия той же сборки в домен вызывающего приложения или путь загрузки домена приложения, вызывающего отличается от целевого домена приложения исключения например <xref:System.MissingMethodException> может произойти.  
  
-   Если вызывающий домен приложения выполняет вызовы с ранним связыванием тип экземпляра <xref:System.InvalidCastException> могут возникать при попытке приведения типа экземпляра.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.  
  
 - или -  
  
 <paramref name="securityAttributes" /> не является <see langword="null" />. Если не включена политика разграничения доступа кода для кода предыдущей версии, <paramref name="securityAttributes" /> должно иметь значение <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Не удалось найти <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.TypeLoadException">
          Не удалось найти <paramref name="typeName" /> в <paramref name="assemblyFile" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет достаточно разрешений для вызова этого конструктора.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> не является допустимой сборкой.  
  
 - или -  
  
 В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.NullReferenceException">Этот экземпляр имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">для возможности доступа к каталогу сборки, если сборка не является локальным.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Чтобы получить свидетельство. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFromAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает новый экземпляр заданного типа, определенного в указанном файле сборки.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Имя файла и путь сборки, которая определяет запрошенный тип.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</param>
        <summary>Создает новый экземпляр заданного типа, определенного в указанном файле сборки.</summary>
        <returns>Запрашиваемый объект или значение <see langword="null" />, если объект <paramref name="typeName" /> не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это удобный метод, который объединяет <xref:System.AppDomain.CreateInstanceFrom%2A> и <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Этот метод вызывает конструктор по умолчанию для `typeName`.  
  
 Дополнительные сведения см. в описании метода <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="assemblyName" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Не удалось найти <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.TypeLoadException">
          Не удалось найти <paramref name="typeName" /> в <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Открытый конструктор без параметров не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет достаточно разрешений для вызова этого конструктора.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> не является допустимой сборкой.  
  
 - или -  
  
 В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">для возможности доступа к каталогу сборки, если сборка не является локальным.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Имя файла и путь сборки, которая определяет запрошенный тип.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</param>
        <param name="activationAttributes">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации. Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.    
  
 Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation. </param>
        <summary>Создает новый экземпляр заданного типа, определенного в указанном файле сборки.</summary>
        <returns>Запрашиваемый объект или значение <see langword="null" />, если объект <paramref name="typeName" /> не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это удобный метод, который объединяет <xref:System.AppDomain.CreateInstanceFrom%2A> и <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>. Этот метод вызывает конструктор по умолчанию для `typeName`.  
  
 Дополнительные сведения об этом методе см. в разделе <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="assemblyName" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Не удалось найти <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.TypeLoadException">
          Не удалось найти <paramref name="typeName" /> в <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Открытый конструктор без параметров не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет достаточно разрешений для вызова этого конструктора.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> не является допустимой сборкой.  
  
 - или -  
  
 В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">для возможности доступа к каталогу сборки, если сборка не является локальным.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя файла и путь сборки, которая определяет запрошенный тип.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</param>
        <param name="ignoreCase">Логическое значение, указывающее, следует ли учитывать регистр при поиске.</param>
        <param name="bindingAttr">Сочетание битовых флагов (от нуля и более), влияющих на поиск конструктора <c>typeName</c>. Если значение параметра <c>bindingAttr</c> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</param>
        <param name="binder">Объект, который допускает привязку, приведение типов аргументов, вызов элементов и извлечение объектов <see cref="T:System.Reflection.MemberInfo" /> путем отражения. Если параметр <c>binder</c> имеет значение NULL, то используется модуль привязки по умолчанию.</param>
        <param name="args">Аргументы для передачи конструктору. Массив аргументов должен соответствовать по числу, порядку и типу параметров вызываемому конструктору. Если предпочтителен конструктор по умолчанию, то объект <c>args</c> должен быть пустым массивом или иметь значение NULL.</param>
        <param name="culture">Сведения о языке и региональных параметрах, которые влияют на приведение <c>args</c> к формальным типам, объявленным для конструктора <c>typeName</c>. Если параметр <c>culture</c> имеет значение <see langword="null" />, используется <see cref="T:System.Globalization.CultureInfo" /> для текущего потока.</param>
        <param name="activationAttributes">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации. Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.    
  
 Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation. </param>
        <summary>Создает новый экземпляр заданного типа, определенного в заданном файле сборки, указывая, игнорируется ли регистр имени типа; атрибуты привязки и средство привязки, используемые для выбора создаваемого типа; аргументы конструктора; язык и региональные параметры; и атрибуты активации.</summary>
        <returns>Запрашиваемый объект или значение <see langword="null" />, если объект <paramref name="typeName" /> не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это удобный метод, который объединяет <xref:System.AppDomain.CreateInstanceFrom%2A> и <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Дополнительные сведения об этом методе см. в разделе <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="assemblyName" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Не удалось найти <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.TypeLoadException">
          Не удалось найти <paramref name="typeName" /> в <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет достаточно разрешений для вызова этого конструктора.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> не является допустимой сборкой.  
  
 - или -  
  
 Сборка <paramref name="assemblyName" /> скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">для возможности доступа к каталогу сборки, если сборка не является локальным.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Имя файла и путь сборки, которая определяет запрошенный тип.</param>
        <param name="typeName">Полное имя запрошенного типа, включая пространство имен, но не сборку (см. описание свойства <see cref="P:System.Type.FullName" />).</param>
        <param name="ignoreCase">Логическое значение, указывающее, следует ли учитывать регистр при поиске.</param>
        <param name="bindingAttr">Сочетание битовых флагов (от нуля и более), влияющих на поиск конструктора <c>typeName</c>. Если значение параметра <c>bindingAttr</c> равно нулю, проводится поиск открытых конструкторов с учетом регистра.</param>
        <param name="binder">Объект, который допускает привязку, приведение типов аргументов, вызов элементов и извлечение объектов <see cref="T:System.Reflection.MemberInfo" /> путем отражения. Если параметр <c>binder</c> имеет значение NULL, то используется модуль привязки по умолчанию.</param>
        <param name="args">Аргументы для передачи конструктору. Массив аргументов должен соответствовать по числу, порядку и типу параметров вызываемому конструктору. Если предпочтителен конструктор по умолчанию, то объект <c>args</c> должен быть пустым массивом или иметь значение NULL.</param>
        <param name="culture">Сведения о языке и региональных параметрах, которые влияют на приведение <c>args</c> к формальным типам, объявленным для конструктора <c>typeName</c>. Если параметр <c>culture</c> имеет значение <see langword="null" />, используется <see cref="T:System.Globalization.CultureInfo" /> для текущего потока.</param>
        <param name="activationAttributes">Массив, состоящий из одного или нескольких атрибутов, которые могут участвовать в активации. Обычно это массив, содержащий один объект <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />, определяющий URL-адрес, необходимый для активации удаленного объекта.    
  
 Этот параметр связан с объектами, активируемыми клиентом. Активация клиентом — это устаревшая технология, которая сохраняется с целью обеспечения обратной совместимости; ее не рекомендуется использовать для разработки новых приложений. Сейчас в распределенных приложениях следует использовать Windows Communication Foundation. </param>
        <param name="securityAttributes">Сведения, используемые для авторизации создания <c>typeName</c>.</param>
        <summary>Создает новый экземпляр заданного типа, определенного в указанном файле сборки.</summary>
        <returns>Запрашиваемый объект или значение <see langword="null" />, если объект <paramref name="typeName" /> не найден.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это удобный метод, который объединяет <xref:System.AppDomain.CreateInstanceFrom%2A> и <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.  
  
 Дополнительные сведения об этом методе см. в разделе <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="assemblyName" /> имеет значение <see langword="null" />.  
  
 - или -  
  
 Свойство <paramref name="typeName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException">Вызывающий объект не может предоставить атрибуты активации для объекта, который не является производным от <see cref="T:System.MarshalByRefObject" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          Не удалось найти <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.TypeLoadException">
          Не удалось найти <paramref name="typeName" /> в <paramref name="assemblyName" />.</exception>
        <exception cref="T:System.MissingMethodException">Соответствующий общий конструктор не найден.</exception>
        <exception cref="T:System.MethodAccessException">Вызывающий объект не имеет достаточно разрешений для вызова этого конструктора.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyName" /> не является допустимой сборкой.  
  
 - или -  
  
 В настоящий момент загружена среда CLR версии 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess">для возможности чтения файла, содержащего манифест сборки. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></permission>
        <permission cref="T:System.Net.WebPermission">для возможности доступа к каталогу сборки, если сборка не является локальным.</permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CurrentDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.AppDomain CurrentDomain" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.CurrentDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDomain As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property AppDomain ^ CurrentDomain { AppDomain ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает текущий домен приложения для текущего объекта <see cref="T:System.Threading.Thread" />.</summary>
        <value>Текущий домен приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода создается новый домен приложения. <xref:System.AppDomain.CurrentDomain%2A> Свойство используется для получения <xref:System.AppDomain> объект, представляющий текущий домен приложения. <xref:System.AppDomain.FriendlyName%2A> Предоставляет имя текущего домена приложения, который отображается в командной строке.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineDynamicAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Определяет динамическую сборку в текущем домене приложения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
      </Parameters>
      <Docs>
        <param name="name">Уникальный идентификатор динамической сборки.</param>
        <param name="access">Режим доступа для динамической сборки.</param>
        <summary>Определяет динамическую сборку с указанным именем и режимом доступа.</summary>
        <returns>Динамическая сборка с указанным именем и режимом доступа.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод следует использовать только для определения динамической сборки в текущем домене приложения. Дополнительные сведения см. в разделе <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> перегрузки метода.  
  
> [!NOTE]
>  Во время разработки кода, создающего динамические сборки, рекомендуется использовать перегрузку <xref:System.AppDomain.DefineDynamicAssembly%2A> метод, указывающий свидетельство и разрешения, предоставлять свидетельство требуется динамическая сборка, и включать <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> в `refusedPermissions`. Включая <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> в `refusedPermissions` параметр гарантирует, что будет проверяться MSIL. Ограничение этого метода заключается в том, что она вызывает <xref:System.Security.SecurityException> исключение, когда используется с кодом, который требует полного доверия.  
  
   
  
## Examples  
 В следующем образце показано <xref:System.AppDomain.DefineDynamicAssembly%2A> метод и <xref:System.AppDomain.AssemblyResolve> событий.  
  
 Для этого примера кода необходимо указать полное имя сборки. Сведения о том, как получить полное имя сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойство <see langword="Name" /> параметра <paramref name="name" /> равно <see langword="null" />.  
  
 - или -  
  
 Свойство <see langword="Name" /> параметра <paramref name="name" /> начинается с пробела или содержит прямую либо обратную косую черту.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">Уникальный идентификатор динамической сборки.</param>
        <param name="access">Режим доступа для динамической сборки.</param>
        <param name="assemblyAttributes">Перечислимый список атрибутов, которые будут применены к сборке, или значение <see langword="null" />, если атрибуты отсутствуют.</param>
        <summary>Определяет динамическую сборку с указанным именем, режимом доступа и настраиваемыми атрибутами.</summary>
        <returns>Динамическая сборка с указанным именем и возможностями.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка метода позволяет указать атрибуты, которые не работают правильно, если они будут применены при создании динамической сборки. Например, безопасность атрибуты, такие как <xref:System.Security.SecurityTransparentAttribute> и <xref:System.Security.SecurityCriticalAttribute> не работают правильно, если они добавляются после создания динамической сборки.  
  
 Этот метод следует использовать только для определения динамической сборки в текущем домене приложения. Дополнительные сведения об этом ограничении см. в разделе <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> перегрузки метода.  
  
 Эта перегрузка метода впервые появился в [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
   
  
## Examples  
 В следующем образце кода показано, как создать динамическую сборку, которая имеет <xref:System.Security.SecurityTransparentAttribute>. Атрибут должен быть указан как элемент массива <xref:System.Reflection.Emit.CustomAttributeBuilder> объектов.  
  
 Первым шагом при создании <xref:System.Reflection.Emit.CustomAttributeBuilder> — получить конструктор атрибута. Конструктор не имеет параметров, поэтому <xref:System.Type.GetConstructor%2A> метод вызывается с пустой массив <xref:System.Type> объектов, представляющих типы параметров. Второй шаг заключается в передаче итоговый <xref:System.Reflection.ConstructorInfo> в конструктор для <xref:System.Reflection.Emit.CustomAttributeBuilder> класса, а также пустой массив типа <xref:System.Object> для представления аргументов.  
  
 Итоговый <xref:System.Reflection.Emit.CustomAttributeBuilder> затем передается <xref:System.AppDomain.DefineDynamicAssembly%2A> метод как единственный элемент массива.  
  
 В примере кода определяется модуль и типом в новой динамической сборки, а затем отображает атрибуты этой сборки.  
  
 [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cpp/source.cpp#1)]
 [!code-csharp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cs/source.cs#1)]
 [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойство <see langword="Name" /> параметра <paramref name="name" /> равно <see langword="null" />.  
  
 - или -  
  
 Значение свойства <see langword="Name" /> объекта <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">Уникальный идентификатор динамической сборки.</param>
        <param name="access">Режим, в котором будет осуществляться доступ к динамической сборке.</param>
        <param name="evidence">Свидетельство, предоставляемое для динамической сборки. Используемое свидетельство является постоянным, как конечный набор свидетельств, используемых для разрешения политики.</param>
        <summary>Определяет динамическую сборку с помощью указанного имени, режима доступа и свидетельства.</summary>
        <returns>Динамическая сборка с указанным именем и возможностями.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Только полностью доверенные вызывающие объекты могут предоставлять свои `evidence` при определении динамических <xref:System.Reflection.Assembly>. Среда выполнения будет отображать <xref:System.Security.Policy.Evidence> через политику безопасности для определения предоставленных разрешений. Частично доверенные вызывающие объекты должны предоставлять значение null `evidence`. Если `evidence` — `null`, среда выполнения копирует наборы разрешений, то есть текущего grant или deny наборов, у вызывающего <xref:System.Reflection.Assembly> для динамической <xref:System.Reflection.Assembly> определяемой и помечает политику как разрешенные.  
  
 Если динамический <xref:System.Reflection.Assembly> — сохраняются на диске, последующих загрузок будут основываться на политики, связанные с расположением где <xref:System.Reflection.Assembly> был сохранен.  
  
 Этот метод следует использовать только для определения динамической сборки в текущем домене приложения. Дополнительные сведения см. в разделе <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> перегрузки метода.  
  
> [!NOTE]
>  Во время разработки кода, создающего динамические сборки, рекомендуется использовать перегрузку <xref:System.AppDomain.DefineDynamicAssembly%2A> метод, указывающий свидетельство и разрешения, предоставлять свидетельство требуется динамическая сборка, и включать <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> в `refusedPermissions`. Включая <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> в `refusedPermissions` параметр гарантирует, что будет проверяться MSIL. Ограничение этого метода заключается в том, что она вызывает <xref:System.Security.SecurityException> исключение, когда используется с кодом, который требует полного доверия.  
  
   
  
## Examples  
 В следующем образце показано <xref:System.AppDomain.DefineDynamicAssembly%2A> метод и <xref:System.AppDomain.AssemblyResolve> событий.  
  
 Во-первых, пример кода пытается создать экземпляр `MyDynamicType` путем вызова <xref:System.AppDomain.CreateInstance%2A> метод с недопустимое имя сборки и перехватывает результирующее исключение.  
  
 Затем, в примере кода добавляется обработчик событий для <xref:System.AppDomain.AssemblyResolve> событий, а снова пытается создать экземпляр`MyDynamicType`. При вызове <xref:System.AppDomain.CreateInstance%2A>, <xref:System.AppDomain.AssemblyResolve> событие возникает при недопустимой сборки. Обработчик событий создает динамическую сборку, которая содержит тип с именем `MyDynamicType`, предоставляет тип конструктора без параметров и возвращает новую динамическую сборку. Вызов <xref:System.AppDomain.CreateInstance%2A> затем завершается успешно и конструктор для `MyDynamicType` отображает сообщение на консоль.  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойство <see langword="Name" /> параметра <paramref name="name" /> равно <see langword="null" />.  
  
 - или -  
  
 Свойство <see langword="Name" /> параметра <paramref name="name" /> начинается с пробела или содержит прямую либо обратную косую черту.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки со свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Уникальный идентификатор динамической сборки.</param>
        <param name="access">Режим, в котором будет осуществляться доступ к динамической сборке.</param>
        <param name="dir">Имя папки, в которой будет сохранена сборка. Если параметр <c>dir</c> имеет значение <see langword="null" />, по умолчанию используется текущий каталог.</param>
        <summary>Определяет динамическую сборку с помощью указанного имени, режима доступа и каталога хранения.</summary>
        <returns>Динамическая сборка с указанным именем и возможностями.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод следует использовать только для определения динамической сборки в текущем домене приложения. Дополнительные сведения см. в разделе <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> перегрузки метода.  
  
> [!NOTE]
>  Во время разработки кода, создающего динамические сборки, рекомендуется использовать перегрузку <xref:System.AppDomain.DefineDynamicAssembly%2A> метод, указывающий свидетельство и разрешения, предоставлять свидетельство требуется динамическая сборка, и включать <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> в `refusedPermissions`. Включая <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> в `refusedPermissions` параметр гарантирует, что будет проверяться MSIL. Ограничение этого метода заключается в том, что она вызывает <xref:System.Security.SecurityException> исключение, когда используется с кодом, который требует полного доверия.  
  
   
  
## Examples  
 В следующем образце показано <xref:System.AppDomain.DefineDynamicAssembly%2A> метод и <xref:System.AppDomain.AssemblyResolve> событий.  
  
 Для этого примера кода необходимо указать полное имя сборки. Сведения о том, как получить полное имя сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойство <see langword="Name" /> параметра <paramref name="name" /> равно <see langword="null" />.  
  
 - или -  
  
 Свойство <see langword="Name" /> параметра <paramref name="name" /> начинается с пробела или содержит прямую либо обратную косую черту.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes, System::Security::SecurityContextSource securityContextSource);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="name">Уникальный идентификатор динамической сборки.</param>
        <param name="access">Режим доступа для динамической сборки.</param>
        <param name="assemblyAttributes">Перечислимый список атрибутов, которые будут применены к сборке, или значение <see langword="null" />, если атрибуты отсутствуют.</param>
        <param name="securityContextSource">Источник контекста безопасности.</param>
        <summary>Определяет динамическую сборку с помощью указанного имени, режима доступа и настраиваемых атрибутов, а также используя заданный источник для контекста безопасности.</summary>
        <returns>Динамическая сборка с указанным именем и возможностями.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка метода позволяет указать атрибуты, которые не работают правильно, если они будут применены при создании динамической сборки. Например, безопасность атрибуты, такие как <xref:System.Security.SecurityTransparentAttribute> и <xref:System.Security.SecurityCriticalAttribute> не работают правильно, если они добавляются после создания динамической сборки.  
  
 Этот метод следует использовать только для определения динамической сборки в текущем домене приложения. Дополнительные сведения об этом ограничении см. в разделе <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> перегрузки метода.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойство <see langword="Name" /> параметра <paramref name="name" /> равно <see langword="null" />.  
  
 - или -  
  
 Значение свойства <see langword="Name" /> объекта <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="securityContextSource" /> не является одним из значений перечисления.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name">Уникальный идентификатор динамической сборки.</param>
        <param name="access">Режим, в котором будет осуществляться доступ к динамической сборке.</param>
        <param name="dir">Имя папки, в которой будет сохранена сборка. Если параметр <c>dir</c> имеет значение <see langword="null" />, по умолчанию используется текущий каталог.</param>
        <param name="evidence">Свидетельство, предоставляемое для динамической сборки. Используемое свидетельство является постоянным, как конечный набор свидетельств, используемых для разрешения политики.</param>
        <summary>Определяет динамическую сборку с помощью указанного имени, режима доступа, каталога хранения и свидетельства.</summary>
        <returns>Динамическая сборка с указанным именем и возможностями.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Только полностью доверенные вызывающие объекты могут предоставлять свои `evidence` при определении динамических <xref:System.Reflection.Assembly>. Среда выполнения будет отображать <xref:System.Security.Policy.Evidence> через политику безопасности для определения предоставленных разрешений. Частично доверенные вызывающие объекты должны предоставлять значение null `evidence`. Если `evidence` — `null`, среда выполнения копирует наборы разрешений, то есть текущего grant или deny наборов, у вызывающего <xref:System.Reflection.Assembly> для динамической <xref:System.Reflection.Assembly> определяемой и помечает политику как разрешенные.  
  
 Если динамический <xref:System.Reflection.Assembly> — сохраняются на диске, последующих загрузок будут основываться на политики, связанные с расположением где <xref:System.Reflection.Assembly> был сохранен.  
  
 Этот метод следует использовать только для определения динамической сборки в текущем домене приложения. Дополнительные сведения см. в разделе <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> перегрузки метода.  
  
> [!NOTE]
>  Во время разработки кода, создающего динамические сборки, рекомендуется использовать перегрузку <xref:System.AppDomain.DefineDynamicAssembly%2A> метод, указывающий свидетельство и разрешения, предоставлять свидетельство требуется динамическая сборка, и включать <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> в `refusedPermissions`. Включая <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> в `refusedPermissions` параметр гарантирует, что будет проверяться MSIL. Ограничение этого метода заключается в том, что она вызывает <xref:System.Security.SecurityException> исключение, когда используется с кодом, который требует полного доверия.  
  
   
  
## Examples  
 В следующем образце показано <xref:System.AppDomain.DefineDynamicAssembly%2A> метод и <xref:System.AppDomain.AssemblyResolve> событий.  
  
 Для этого примера кода необходимо указать полное имя сборки. Сведения о том, как получить полное имя сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойство <see langword="Name" /> параметра <paramref name="name" /> равно <see langword="null" />.  
  
 - или -  
  
 Свойство <see langword="Name" /> параметра <paramref name="name" /> начинается с пробела или содержит прямую либо обратную косую черту.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки со свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Уникальный идентификатор динамической сборки.</param>
        <param name="access">Режим, в котором будет осуществляться доступ к динамической сборке.</param>
        <param name="requiredPermissions">Запрос обязательных разрешений.</param>
        <param name="optionalPermissions">Запрос дополнительных разрешений.</param>
        <param name="refusedPermissions">Запрос разрешений, в которых отказано.</param>
        <summary>Определяет динамическую сборку с помощью указанного имени, режима доступа и запросов разрешений.</summary>
        <returns>Динамическая сборка с указанным именем и возможностями.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запросы разрешений, указанный для `requiredPermissions`, `optionalPermissions`, и `refusedPermissions` не используются, если динамическая сборка сохраняется и повторно загружена в память. Для указания запросов разрешений для промежуточную сборку, который никогда не сохраняются на диск, используйте перегрузку <xref:System.AppDomain.DefineDynamicAssembly%2A> которой указано свидетельство и требуемые разрешения и укажите метод <xref:System.Security.Policy.Evidence> объекта.  
  
> [!NOTE]
>  Во время разработки кода, создающего динамические сборки, рекомендуется использовать перегрузку <xref:System.AppDomain.DefineDynamicAssembly%2A> метод, указывающий свидетельство и разрешения, предоставлять свидетельство требуется динамическая сборка, и включать <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> в `refusedPermissions`. Включая <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> в `refusedPermissions` параметр гарантирует, что будет проверяться MSIL. Ограничение этого метода заключается в том, что она вызывает <xref:System.Security.SecurityException> исключение, когда используется с кодом, который требует полного доверия.  
  
 Этот метод следует использовать только для определения динамической сборки в текущем домене приложения. Дополнительные сведения см. в разделе <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> перегрузки метода.  
  
   
  
## Examples  
 В следующем образце показано <xref:System.AppDomain.DefineDynamicAssembly%2A> метод и <xref:System.AppDomain.AssemblyResolve> событий.  
  
 Для этого примера кода необходимо указать полное имя сборки. Сведения о том, как получить полное имя сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойство <see langword="Name" /> параметра <paramref name="name" /> равно <see langword="null" />.  
  
 - или -  
  
 Свойство <see langword="Name" /> параметра <paramref name="name" /> начинается с пробела или содержит прямую либо обратную косую черту.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, isSynchronized As Boolean, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">Уникальный идентификатор динамической сборки.</param>
        <param name="access">Режим, в котором будет осуществляться доступ к динамической сборке.</param>
        <param name="dir">Имя каталога, в котором будет сохранена динамическая сборка. Если параметр <c>dir</c> имеет значение <see langword="null" />, используется текущий каталог.</param>
        <param name="isSynchronized">
          Значение <see langword="true" />, чтобы синхронизировать создание модулей, типов и членов в динамической сборке, в противном случае — значение <see langword="false" />.</param>
        <param name="assemblyAttributes">Перечислимый список атрибутов, которые будут применены к сборке, или значение <see langword="null" />, если атрибуты отсутствуют.</param>
        <summary>Определяет динамическую сборку с помощью указанного имени, режима доступа, каталога хранения и варианта синхронизации.</summary>
        <returns>Динамическая сборка с указанным именем и возможностями.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка метода позволяет указать атрибуты, которые не работают правильно, если они будут применены при создании динамической сборки. Например, безопасность атрибуты, такие как <xref:System.Security.SecurityTransparentAttribute> и <xref:System.Security.SecurityCriticalAttribute> не работают правильно, если они добавляются после создания динамической сборки.  
  
 Если `isSynchronized` — `true`, представленных ниже конечного <xref:System.Reflection.Emit.AssemblyBuilder> будут синхронизированы: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, и <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Если два из этих методов вызываются в разных потоках, один будет блокироваться до завершения выполнения другого.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойство <see langword="Name" /> параметра <paramref name="name" /> равно <see langword="null" />.  
  
 - или -  
  
 Значение свойства <see langword="Name" /> объекта <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Уникальный идентификатор динамической сборки.</param>
        <param name="access">Режим, в котором будет осуществляться доступ к динамической сборке.</param>
        <param name="evidence">Свидетельство, предоставляемое для динамической сборки. Используемое свидетельство является постоянным, как конечный набор свидетельств, используемых для разрешения политики.</param>
        <param name="requiredPermissions">Запрос обязательных разрешений.</param>
        <param name="optionalPermissions">Запрос дополнительных разрешений.</param>
        <param name="refusedPermissions">Запрос разрешений, в которых отказано.</param>
        <summary>Определяет динамическую сборку с помощью указанного имени, режима доступа, свидетельства и запросов разрешений.</summary>
        <returns>Динамическая сборка с указанным именем и возможностями.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запросы разрешений, указанный для `requiredPermissions`, `optionalPermissions`, и `refusedPermissions` используются только в том случае, если `evidence` также указан, или если динамическая сборка сохраняется и повторно загружена в память.  
  
> [!NOTE]
>  Во время разработки кода, создающего динамические сборки, рекомендуется включить <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> в `refusedPermissions`. Включая <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> в `refusedPermissions` параметр гарантирует, что будет проверяться MSIL. Ограничение этого метода заключается в том, что она вызывает <xref:System.Security.SecurityException> исключение, когда используется с кодом, который требует полного доверия.  
  
 Только полностью доверенные вызывающие объекты могут предоставлять свои `evidence` при определении динамических <xref:System.Reflection.Assembly>. Среда выполнения будет отображать <xref:System.Security.Policy.Evidence> через политику безопасности для определения предоставленных разрешений. Частично доверенные вызывающие объекты должны предоставлять значение null `evidence`. Если `evidence` — `null`, среда выполнения копирует наборы разрешений, то есть текущего grant или deny наборов, у вызывающего <xref:System.Reflection.Assembly> для динамической <xref:System.Reflection.Assembly> определяемой и помечает политику как разрешенные.  
  
 Если динамический <xref:System.Reflection.Assembly> — сохраняются на диске, последующих загрузок будут основываться на политики, связанные с расположением где <xref:System.Reflection.Assembly> был сохранен.  
  
 Этот метод следует использовать только для определения динамической сборки в текущем домене приложения. Дополнительные сведения см. в разделе <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> перегрузки метода.  
  
   
  
## Examples  
 В следующем образце показано <xref:System.AppDomain.DefineDynamicAssembly%2A> метод и <xref:System.AppDomain.AssemblyResolve> событий.  
  
 Для этого примера кода необходимо указать полное имя сборки. Сведения о том, как получить полное имя сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойство <see langword="Name" /> параметра <paramref name="name" /> равно <see langword="null" />.  
  
 - или -  
  
 Свойство <see langword="Name" /> параметра <paramref name="name" /> начинается с пробела или содержит прямую либо обратную косую черту.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки со свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Уникальный идентификатор динамической сборки.</param>
        <param name="access">Режим, в котором будет осуществляться доступ к динамической сборке.</param>
        <param name="dir">Имя папки, в которой будет сохранена сборка. Если параметр <c>dir</c> имеет значение <see langword="null" />, по умолчанию используется текущий каталог.</param>
        <param name="requiredPermissions">Запрос обязательных разрешений.</param>
        <param name="optionalPermissions">Запрос дополнительных разрешений.</param>
        <param name="refusedPermissions">Запрос разрешений, в которых отказано.</param>
        <summary>Определяет динамическую сборку с помощью указанного имени, режима доступа, каталога хранения и запросов разрешений.</summary>
        <returns>Динамическая сборка с указанным именем и возможностями.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запросы разрешений, указанный для `requiredPermissions`, `optionalPermissions`, и `refusedPermissions` не используются, если динамическая сборка сохраняется и повторно загружена в память. Для указания запросов разрешений для промежуточную сборку, который никогда не сохраняются на диск, используйте перегрузку <xref:System.AppDomain.DefineDynamicAssembly%2A> которой указано свидетельство и требуемые разрешения и укажите метод <xref:System.Security.Policy.Evidence> объекта.  
  
> [!NOTE]
>  Во время разработки кода, создающего динамические сборки, рекомендуется использовать перегрузку <xref:System.AppDomain.DefineDynamicAssembly%2A> метод, указывающий свидетельство и разрешения, предоставлять свидетельство требуется динамическая сборка, и включать <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> в `refusedPermissions`. Включая <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> в `refusedPermissions` параметр гарантирует, что будет проверяться MSIL. Ограничение этого метода заключается в том, что она вызывает <xref:System.Security.SecurityException> исключение, когда используется с кодом, который требует полного доверия.  
  
 Этот метод следует использовать только для определения динамической сборки в текущем домене приложения. Дополнительные сведения см. в разделе <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> перегрузки метода.  
  
   
  
## Examples  
 В следующем образце показано <xref:System.AppDomain.DefineDynamicAssembly%2A> метод и <xref:System.AppDomain.AssemblyResolve> событий.  
  
 Для этого примера кода необходимо указать полное имя сборки. Сведения о том, как получить полное имя сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойство <see langword="Name" /> параметра <paramref name="name" /> равно <see langword="null" />.  
  
 - или -  
  
 Свойство <see langword="Name" /> параметра <paramref name="name" /> начинается с пробела или содержит прямую либо обратную косую черту.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name">Уникальный идентификатор динамической сборки.</param>
        <param name="access">Режим, в котором будет осуществляться доступ к динамической сборке.</param>
        <param name="dir">Имя папки, в которой будет сохранена сборка. Если параметр <c>dir</c> имеет значение <see langword="null" />, по умолчанию используется текущий каталог.</param>
        <param name="evidence">Свидетельство, предоставляемое для динамической сборки. Используемое свидетельство является постоянным, как конечный набор свидетельств, используемых для разрешения политики.</param>
        <param name="requiredPermissions">Запрос обязательных разрешений.</param>
        <param name="optionalPermissions">Запрос дополнительных разрешений.</param>
        <param name="refusedPermissions">Запрос разрешений, в которых отказано.</param>
        <summary>Определяет динамическую сборку с помощью указанного имени, режима доступа, каталога хранения, свидетельства и запросов разрешений.</summary>
        <returns>Динамическая сборка с указанным именем и возможностями.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запросы разрешений, указанный для `requiredPermissions`, `optionalPermissions`, и `refusedPermissions` используются только в том случае, если `evidence` также указан, или если динамическая сборка сохраняется и повторно загружена в память.  
  
> [!NOTE]
>  Во время разработки кода, создающего динамические сборки, рекомендуется включить <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> в `refusedPermissions`. Включая <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> в `refusedPermissions` параметр гарантирует, что будет проверяться MSIL. Ограничение этого метода заключается в том, что она вызывает <xref:System.Security.SecurityException> исключение, когда используется с кодом, который требует полного доверия.  
  
 Только полностью доверенные вызывающие объекты могут предоставлять свои `evidence` при определении динамических <xref:System.Reflection.Assembly>. Среда выполнения будет отображать <xref:System.Security.Policy.Evidence> через политику безопасности для определения предоставленных разрешений. Частично доверенные вызывающие объекты должны предоставлять значение null `evidence`. Если `evidence` — `null`, среда выполнения копирует наборы разрешений, то есть текущего grant или deny наборов, у вызывающего <xref:System.Reflection.Assembly> для динамической <xref:System.Reflection.Assembly> определяемой и помечает политику как разрешенные.  
  
 Если динамический <xref:System.Reflection.Assembly> — сохраняются на диске, последующих загрузок будут основываться на политики, связанные с расположением где <xref:System.Reflection.Assembly> был сохранен.  
  
 Этот метод следует использовать только для определения динамической сборки в текущем домене приложения. Дополнительные сведения см. в разделе <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> перегрузки метода.  
  
   
  
## Examples  
 В следующем образце показано <xref:System.AppDomain.DefineDynamicAssembly%2A> метод и <xref:System.AppDomain.AssemblyResolve> событий.  
  
 Для этого примера кода необходимо указать полное имя сборки. Сведения о том, как получить полное имя сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойство <see langword="Name" /> параметра <paramref name="name" /> равно <see langword="null" />.  
  
 - или -  
  
 Свойство <see langword="Name" /> параметра <paramref name="name" /> начинается с пробела или содержит прямую либо обратную косую черту.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки со свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Уникальный идентификатор динамической сборки.</param>
        <param name="access">Режим, в котором будет осуществляться доступ к динамической сборке.</param>
        <param name="dir">Имя каталога, в котором будет сохранена динамическая сборка. Если параметр <c>dir</c> имеет значение <see langword="null" />, по умолчанию используется текущий каталог.</param>
        <param name="evidence">Свидетельство, предоставляемое для динамической сборки. Используемое свидетельство является постоянным, как конечный набор свидетельств, используемых для разрешения политики.</param>
        <param name="requiredPermissions">Запрос обязательных разрешений.</param>
        <param name="optionalPermissions">Запрос дополнительных разрешений.</param>
        <param name="refusedPermissions">Запрос разрешений, в которых отказано.</param>
        <param name="isSynchronized">
          Значение <see langword="true" />, чтобы синхронизировать создание модулей, типов и членов в динамической сборке, в противном случае — значение <see langword="false" />.</param>
        <summary>Определяет динамическую сборку с помощью указанного имени, режима доступа, каталога хранения, свидетельства, запросов разрешений и параметра синхронизации.</summary>
        <returns>Динамическая сборка с указанным именем и возможностями.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Запросы разрешений, указанный для `requiredPermissions`, `optionalPermissions`, и `refusedPermissions` используются только в том случае, если `evidence` также указан, или если динамическая сборка сохраняется и повторно загружена в память.  
  
> [!NOTE]
>  Во время разработки кода, создающего динамические сборки, рекомендуется включить <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> в `refusedPermissions`. Включая <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> в `refusedPermissions` параметр гарантирует, что будет проверяться MSIL. Ограничение этого метода заключается в том, что она вызывает <xref:System.Security.SecurityException> исключение, когда используется с кодом, который требует полного доверия.  
  
 Только полностью доверенные вызывающие объекты могут предоставлять свои основания при определении динамического <xref:System.Reflection.Assembly>. Среда выполнения будет отображать <xref:System.Security.Policy.Evidence> через политику безопасности для определения предоставленных разрешений. Частично доверенные вызывающие объекты должны предоставлять `null` для `evidence` параметра. Если `evidence` — `null`, среда выполнения копирует наборы разрешений, то есть текущего grant или deny наборов, у вызывающего <xref:System.Reflection.Assembly> для динамической <xref:System.Reflection.Assembly> определяемой и помечает политику как разрешенные.  
  
 Если динамический <xref:System.Reflection.Assembly> — сохраняются на диске, последующих загрузок будут основываться на политики, связанные с расположением где <xref:System.Reflection.Assembly> был сохранен.  
  
 Если `isSynchronized` — `true`, представленных ниже конечного <xref:System.Reflection.Emit.AssemblyBuilder> будут синхронизированы: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, и <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Если два из этих методов вызываются в разных потоках, один будет блокироваться до завершения работы другого.  
  
   
  
## Examples  
 В следующем образце показано <xref:System.AppDomain.DefineDynamicAssembly%2A> метод и <xref:System.AppDomain.AssemblyResolve> событий.  
  
 Для этого примера кода необходимо указать полное имя сборки. Сведения о том, как получить полное имя сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойство <see langword="Name" /> параметра <paramref name="name" /> равно <see langword="null" />.  
  
 - или -  
  
 Свойство <see langword="Name" /> параметра <paramref name="name" /> начинается с пробела или содержит прямую либо обратную косую черту.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки со свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name">Уникальный идентификатор динамической сборки.</param>
        <param name="access">Режим, в котором будет осуществляться доступ к динамической сборке.</param>
        <param name="dir">Имя каталога, в котором будет сохранена динамическая сборка. Если параметр <c>dir</c> имеет значение <see langword="null" />, используется текущий каталог.</param>
        <param name="evidence">Свидетельство, предоставленное для динамической сборки. Используемое свидетельство является постоянным, как конечный набор свидетельств, используемых для разрешения политики.</param>
        <param name="requiredPermissions">Запрос обязательных разрешений.</param>
        <param name="optionalPermissions">Запрос дополнительных разрешений.</param>
        <param name="refusedPermissions">Запрос разрешений, в которых отказано.</param>
        <param name="isSynchronized">
          Значение <see langword="true" />, чтобы синхронизировать создание модулей, типов и членов в динамической сборке, в противном случае — значение <see langword="false" />.</param>
        <param name="assemblyAttributes">Перечислимый список атрибутов, которые будут применены к сборке, или значение <see langword="null" />, если атрибуты отсутствуют.</param>
        <summary>Определяет динамическую сборку с помощью указанного имени, режима доступа, каталога хранения, свидетельства, запросов разрешений, параметра синхронизации и настраиваемых атрибутов.</summary>
        <returns>Динамическая сборка с указанным именем и возможностями.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка метода позволяет указать атрибуты, которые не работают правильно, если они будут применены при создании динамической сборки. Например, безопасность атрибуты, такие как <xref:System.Security.SecurityTransparentAttribute> и <xref:System.Security.SecurityCriticalAttribute> не работают правильно, если они добавляются после создания динамической сборки.  
  
 Запросы разрешений, указанный для `requiredPermissions`, `optionalPermissions`, и `refusedPermissions` параметры используются только в том случае, если `evidence` параметра, или если динамическая сборка сохраняется и повторно загружена в память.  
  
> [!NOTE]
>  При разработке кода, создающего динамические сборки, мы рекомендуем включать <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> флаг в `refusedPermissions` параметра. Включение этого флага гарантирует, что будет проверяться промежуточного языка MSIL. Эта методика позволит обнаруживать ненамеренное Создание непроверяемого кода, который иначе очень трудно обнаружить. Ограничение этого метода заключается в том, что она вызывает <xref:System.Security.SecurityException> исключение, если он используется с кодом, который требует полного доверия.  
  
 Только полностью доверенные вызывающие объекты могут предоставлять свидетельство при определении динамического <xref:System.Reflection.Assembly>. Среда выполнения отображает <xref:System.Security.Policy.Evidence> через политику безопасности для определения предоставленных разрешений. Частично доверенные вызывающие объекты должны предоставлять `null` для `evidence` параметра. Если `evidence` — `null`, среда выполнения копирует наборы разрешений (то есть текущие разрешающие и запрещающие правила) из вызывающей сборки в динамическую сборку, которая определена и помечает политику как разрешенные.  
  
 Если динамическая сборка сохраняется на диск, последующих загрузок будут основываться на политики, связанные с расположение для сохранения динамической сборки.  
  
 Если `isSynchronized` — `true`, представленных ниже конечного <xref:System.Reflection.Emit.AssemblyBuilder> будут синхронизированы: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, и <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>. Если два из этих методов вызываются в разных потоках, один будет блокироваться до завершения выполнения другого.  
  
 Эта перегрузка метода впервые появился в [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Свойство <see langword="Name" /> параметра <paramref name="name" /> равно <see langword="null" />.  
  
 - или -  
  
 Значение свойства <see langword="Name" /> объекта <paramref name="name" /> начинается с пробела или содержит символ прямой (обратной) косой черты.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки со свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DoCallBack">
      <MemberSignature Language="C#" Value="public void DoCallBack (CrossAppDomainDelegate callBackDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DoCallBack (callBackDelegate As CrossAppDomainDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DoCallBack(CrossAppDomainDelegate ^ callBackDelegate);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DoCallBack(System.CrossAppDomainDelegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBackDelegate" Type="System.CrossAppDomainDelegate" />
      </Parameters>
      <Docs>
        <param name="callBackDelegate">Делегат, определяющий вызываемый метод.</param>
        <summary>Выполняет код в другом домене приложения, который определен заданным делегатом.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `callBackDelegate` можно указать маршалируемыми по значению, <xref:System.MarshalByRefObject>, или <xref:System.ContextBoundObject>.  
  
   
  
## Examples  
 В следующем образце показано использование статического <xref:System.AppDomain.DoCallBack%2A> метод.  
  
 [!code-cpp[AppDomain_DoCallBack#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_static.cpp#1)]
 [!code-csharp[AppDomain_DoCallBack#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_static.cs#1)]
 [!code-vb[AppDomain_DoCallBack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_static.vb#1)]  
  
 В следующем примере демонстрируется использование <xref:System.AppDomain.DoCallBack%2A> метода по значению.  
  
 [!code-cpp[AppDomain_DoCallBack#2](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byval.cpp#2)]
 [!code-csharp[AppDomain_DoCallBack#2](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byval.cs#2)]
 [!code-vb[AppDomain_DoCallBack#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byval.vb#2)]  
  
 В следующем примере демонстрируется использование <xref:System.AppDomain.DoCallBack%2A> метода по ссылке.  
  
 [!code-cpp[AppDomain_DoCallBack#3](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byref.cpp#3)]
 [!code-csharp[AppDomain_DoCallBack#3](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byref.cs#3)]
 [!code-vb[AppDomain_DoCallBack#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byref.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="callBackDelegate" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="DomainManager">
      <MemberSignature Language="C#" Value="public AppDomainManager DomainManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainManager DomainManager" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DomainManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomainManager As AppDomainManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainManager ^ DomainManager { AppDomainManager ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает диспетчер домена, предоставленный средой размещения при инициализации домена приложения.</summary>
        <value>Объект, который представляет диспетчер домена, предоставленный средой размещения при инициализации домена приложения, или значение <see langword="null" />, если диспетчер домена не предоставлен.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Неуправляемый узел среды common language runtime (CLR) можно предоставлять диспетчер домена. Диспетчер домена может участвовать в инициализации нового домена приложения и предоставлять другие диспетчеры, такие как <xref:System.Security.HostSecurityManager>, участвующих в операциях домена приложения.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="DomainUnload">
      <MemberSignature Language="C#" Value="public event EventHandler DomainUnload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DomainUnload" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.DomainUnload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DomainUnload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ DomainUnload;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.DomainUnload</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит непосредственно перед выгрузкой объекта <see cref="T:System.AppDomain" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EventHandler> Делегат для этого события может выполнять любые операции завершения, прежде чем будет выгружен домен приложения.  
  
 Каждый домен приложения, необходимо выполнить обработку при ее выгрузке следует зарегистрировать обработчик событий для этого события. Общий обработчик событий не должны использоваться, так как <xref:System.EventHandler> делегат не идентифицирует выгружаемый домен.  
  
> [!NOTE]
>  Это событие не вызывается в домене приложения по умолчанию.  
  
 Не следует делать предположений о событие будет создано в потоке. События в потоке, чем та, которая называется <xref:System.AppDomain.Unload%2A> метод.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicDirectory">
      <MemberSignature Language="C#" Value="public string DynamicDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DynamicDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicDirectory { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.DynamicDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает каталог, в котором распознаватель сборок производит поиск динамически созданных сборок.</summary>
        <value>Каталог, в котором распознаватель сборок производит поиск динамически созданных сборок.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Чтобы задать динамический каталога, назначьте путь к базовому каталогу <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> свойство <xref:System.AppDomainSetup> объекта, который будет использоваться для создания нового домена приложения. Путь к базовому каталогу, присвойте свойству изменяется путем добавления подкаталога, имя которого простой является хэш-код строки, назначаемые <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> свойства, поэтому имеет базовый каталог *исходный путь* \\ *хэш-код*. Dynamic directory являющийся подкаталогом базового каталога. Его простое имя является значением <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> свойства, поэтому его формат *исходный путь*\\*хэш-код*\\*имя приложения*.  
  
   
  
## Examples  
 Следующий пример создает домен приложения с каталогом для динамических сборок, создается динамическая сборка и сохраняет его в каталоге динамического загружает сборку в домене приложения и использует его.  
  
 В примере создается <xref:System.AppDomainSetup> и устанавливает его <xref:System.AppDomainSetup.ApplicationName%2A> свойства «Пример» и его <xref:System.AppDomainSetup.DynamicBase%2A> свойства «C:\DynamicAssemblyDir». Затем в примере выводится <xref:System.AppDomainSetup.DynamicBase%2A> свойство, чтобы показать, как подкаталог путь, который первоначально был назначен добавленную хэш-код с именем приложения.  
  
> [!NOTE]
>  Базовый каталог, в этом примере предполагается использовать за пределами путь поиска сборок для примера приложения. Необходимо скомпилировать этот пример в другом месте. Удаление базового каталога и всех его подкаталогах при каждом запуске примера.  
  
 В примере создается новый домен приложения с помощью <xref:System.AppDomainSetup> объекта. В этом примере <xref:System.AppDomain.DynamicDirectory%2A> свойства, чтобы получить имя каталога, чтобы можно было создать каталог. (Пример может легко создать каталог заранее путем объединения исходный путь, хэш-код, имя приложения и имя приложения.)  
  
 В примере `GenerateDynamicAssembly` метод, который создает сборку с именем `DynamicHelloWorld.dll` и сохраняет его в каталоге динамического новый домен приложения. Динамическая сборка содержит один тип `HelloWorld`, который имеет статический метод (`Shared` в Visual Basic) с именем `HelloFromAD`. Вызов этого метода имя домена приложения.  
  
 `Example` Класс является производным от <xref:System.MarshalByRefObject>, поэтому в примере можно создать экземпляр класса в новом домене приложения и вызовите его `Test` метод. `Test` Метод загружает динамическую сборку по его отображаемому имени и вызывает статический `HelloFromAD` метод.  
  
 Может показывать, что dynamic directory поиск после обычно осуществляется поиск путем написания кода для сборки с именем `DynamicHelloWorld.dll` и компилирует его в том же каталоге, что в этом примере. Сборка должна иметь класс с именем `HelloWorld` со статическим методом с именем `HelloFromAD`. Этот метод не имеет те же функции, как в примере; он может просто отображать строку на консоль. Эта сборка должна также иметь <xref:System.Reflection.AssemblyVersionAttribute> атрибут, который задает его версию 1.0.0.0. При запуске примера сборки, которые компилируются в текущем каталоге находится перед поиска динамического каталога.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к информации о пути. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает свидетельство <see cref="T:System.Security.Policy.Evidence" />, связанное с этим доменом приложения.</summary>
        <value>Свидетельство, связанное с данным доменом приложений.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки со свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет сборку, содержащуюся в указанном файле.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя файла, содержащего сборку, которую необходимо выполнить.</param>
        <summary>Выполняет сборку, содержащуюся в указанном файле.</summary>
        <returns>Значение, возвращаемое точкой входа сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.  
  
 Этот метод создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.  
  
 Этот метод загружает сборки с помощью <xref:System.Reflection.Assembly.LoadFile%2A> метод. Также можно выполнить с помощью сборок <xref:System.AppDomain.ExecuteAssemblyByName%2A> метод, который загружает сборки с помощью <xref:System.Reflection.Assembly.Load%2A> метод.  
  
 Для создания <xref:System.AppDomain> для загрузки и выполнения, используйте <xref:System.AppDomain.CreateDomain%2A> метод.  
  
   
  
## Examples  
 В следующем образце показано, с помощью одного из перегруженных версий <xref:System.AppDomain.ExecuteAssembly%2A> в двух разных доменах.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> не найден.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> не является допустимой сборкой.  
  
 - или -  
  
 Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="assemblyFile" /> скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.MissingMethodException">Указанная сборка не имеет точку входа.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа на чтение из файла или каталога, а также для доступа к сведениям в сам путь. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">для чтения URI, который начинается с «file://».</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">для выполнения консольного приложения. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя файла, содержащего сборку, которую необходимо выполнить.</param>
        <param name="assemblySecurity">Свидетельство для загрузки сборки.</param>
        <summary>Выполняет сборку, содержащуюся в указанном файле, с использованием заданного свидетельства.</summary>
        <returns>Значение, возвращаемое точкой входа сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.  
  
 <xref:System.AppDomain.ExecuteAssembly%2A> Метод не создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.  
  
 Этот метод загружает сборки с помощью <xref:System.Reflection.Assembly.LoadFile%2A> метод. Также можно выполнить с помощью сборок <xref:System.AppDomain.ExecuteAssemblyByName%2A> метод, который загружает сборки с помощью <xref:System.Reflection.Assembly.Load%2A> метод.  
  
   
  
## Examples  
 В следующем образце показано, с помощью одного из перегруженных версий <xref:System.AppDomain.ExecuteAssembly%2A> в двух разных доменах.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> не найден.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> не является допустимой сборкой.  
  
 - или -  
  
 Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="assemblyFile" /> скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.MissingMethodException">Указанная сборка не имеет точку входа.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки со свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа на чтение из файла или каталога, а также для доступа к сведениям в сам путь. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">для чтения URI, который начинается с «file://».</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">для выполнения консольного приложения. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя файла, содержащего сборку, которую необходимо выполнить.</param>
        <param name="args">Аргументы, передаваемые в точку входа сборки.</param>
        <summary>Выполняет сборку, содержащуюся в указанном файле, с использованием заданных аргументов.</summary>
        <returns>Значение, возвращаемое точкой входа сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.  
  
 Этот метод создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.  
  
 Этот метод загружает сборки с помощью <xref:System.Reflection.Assembly.LoadFile%2A> метод. Также можно выполнить с помощью сборок <xref:System.AppDomain.ExecuteAssemblyByName%2A> метод, который загружает сборки с помощью <xref:System.Reflection.Assembly.Load%2A> метод.  
  
   
  
## Examples  
 В следующем образце показано, с помощью одного из перегруженных версий <xref:System.AppDomain.ExecuteAssembly%2A> в двух разных доменах.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> не найден.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> не является допустимой сборкой.  
  
 - или -  
  
 Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.MissingMethodException">Указанная сборка не имеет точку входа.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа на чтение из файла или каталога, а также для доступа к сведениям в сам путь. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">для чтения URI, который начинается с «file://».</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">для выполнения консольного приложения. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя файла, содержащего сборку, которую необходимо выполнить.</param>
        <param name="assemblySecurity">Предоставленное свидетельство для сборки.</param>
        <param name="args">Аргументы, передаваемые в точку входа сборки.</param>
        <summary>Выполняет сборку, содержащуюся в указанном файле, с использованием заданного свидетельства и аргументов.</summary>
        <returns>Значение, возвращаемое точкой входа сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.  
  
 Этот метод создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.  
  
 Этот метод загружает сборки с помощью <xref:System.Reflection.Assembly.LoadFile%2A> метод. Также можно выполнить с помощью сборок <xref:System.AppDomain.ExecuteAssemblyByName%2A> метод, который загружает сборки с помощью <xref:System.Reflection.Assembly.Load%2A> метод.  
  
   
  
## Examples  
 В следующем образце показано, с помощью одного из перегруженных версий <xref:System.AppDomain.ExecuteAssembly%2A> в двух разных доменах.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> не найден.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> не является допустимой сборкой.  
  
 - или -  
  
 Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="assemblyFile" /> скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> не является <see langword="null" />. Если не включена политика разграничения доступа кода для кода предыдущей версии, <paramref name="assemblySecurity" /> должно иметь значение <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Указанная сборка не имеет точку входа.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки со свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа на чтение из файла или каталога, а также для доступа к сведениям в сам путь. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">для чтения URI, который начинается с «file://».</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">для выполнения консольного приложения. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя файла, содержащего сборку, которую необходимо выполнить.</param>
        <param name="args">Аргументы, передаваемые в точку входа сборки.</param>
        <param name="hashValue">Представляет значение вычисляемого хэш-кода.</param>
        <param name="hashAlgorithm">Представляет хэш-алгоритм, используемый манифестом сборки.</param>
        <summary>Выполняет сборку, содержащуюся в указанном файле, с использованием заданных аргументов, хэш-значения и хэш-алгоритма.</summary>
        <returns>Значение, возвращаемое точкой входа сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.  
  
 Этот метод создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.  
  
 Этот метод загружает сборки с помощью <xref:System.Reflection.Assembly.LoadFile%2A> метод. Также можно выполнить с помощью сборок <xref:System.AppDomain.ExecuteAssemblyByName%2A> метод, который загружает сборки с помощью <xref:System.Reflection.Assembly.Load%2A> метод.  
  
   
  
## Examples  
 В следующем образце показано, с помощью одного из перегруженных версий <xref:System.AppDomain.ExecuteAssembly%2A> в двух разных доменах.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> не найден.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> не является допустимой сборкой.  
  
 - или -  
  
 Сборка <paramref name="assemblyFile" /> была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.MissingMethodException">Указанная сборка не имеет точку входа.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа на чтение из файла или каталога, а также для доступа к сведениям в сам путь. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">для чтения URI, который начинается с «file://».</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">для выполнения консольного приложения. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile">Имя файла, содержащего сборку, которую необходимо выполнить.</param>
        <param name="assemblySecurity">Предоставленное свидетельство для сборки.</param>
        <param name="args">Аргументы, передаваемые в точку входа сборки.</param>
        <param name="hashValue">Представляет значение вычисляемого хэш-кода.</param>
        <param name="hashAlgorithm">Представляет хэш-алгоритм, используемый манифестом сборки.</param>
        <summary>Выполняет сборку, содержащуюся в указанном файле, с использованием заданного свидетельства, аргументов, хэш-значения и хэш-алгоритма.</summary>
        <returns>Значение, возвращаемое точкой входа сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.  
  
 Этот метод создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.  
  
 Этот метод загружает сборки с помощью <xref:System.Reflection.Assembly.LoadFile%2A> метод. Также можно выполнить с помощью сборок <xref:System.AppDomain.ExecuteAssemblyByName%2A> метод, который загружает сборки с помощью <xref:System.Reflection.Assembly.Load%2A> метод.  
  
   
  
## Examples  
 Экран примере показано использование одной из перегрузок <xref:System.AppDomain.ExecuteAssembly%2A> в двух разных доменах.  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="assemblyFile" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyFile" /> не найден.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyFile" /> не является допустимой сборкой.  
  
 - или -  
  
 Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="assemblyFile" /> скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> не является <see langword="null" />. Если не включена политика разграничения доступа кода для кода предыдущей версии, <paramref name="assemblySecurity" /> должно иметь значение <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Указанная сборка не имеет точку входа.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки со свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа на чтение из файла или каталога, а также для доступа к сведениям в сам путь. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">для чтения URI, который начинается с «file://».</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">для выполнения консольного приложения. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssemblyByName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Выполняет сборку.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Отображаемое имя сборки. См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Выполняет сборку, определенную ее отображаемым именем.</summary>
        <returns>Значение, возвращаемое точкой входа сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> Метод предоставляет аналогичные функциональные возможности для <xref:System.AppDomain.ExecuteAssembly%2A> метода, но указывает сборку по отображаемому имени или <xref:System.Reflection.AssemblyName> , а не расположение файла. Таким образом <xref:System.AppDomain.ExecuteAssemblyByName%2A> загружает сборки с <xref:System.Reflection.Assembly.Load%2A> метода, а не с <xref:System.Reflection.Assembly.LoadFile%2A> метод.  
  
 Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.  
  
 Этот метод создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.  
  
 Для создания <xref:System.AppDomain> для загрузки и выполнения, используйте <xref:System.AppDomain.CreateDomain%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="assemblyName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Сборка, заданная параметром <paramref name="assemblyName" />, не найдена.</exception>
        <exception cref="T:System.BadImageFormatException">Сборка, заданная параметром <paramref name="assemblyName" />, недопустимая.  
  
 -или-  
  
 Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка, заданная параметром <paramref name="assemblyName" /> найдена, но ее невозможно загрузить.</exception>
        <exception cref="T:System.MissingMethodException">Указанная сборка не имеет точку входа.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа на чтение из файла или каталога, для доступа к сведениям в самом пути, а также для перенаправления отображаемого имени пути. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">для доступа к веб-сайта, если отображаемое имя перенаправляется на URL-адрес.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">для выполнения консольного приложения. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Объект <see cref="T:System.Reflection.AssemblyName" />, представляющий имя сборки.</param>
        <param name="args">Аргументы командной строки для передачи при запуске процесса.</param>
        <summary>Выполняет сборку с заданным <see cref="T:System.Reflection.AssemblyName" />, используя указанные аргументы.</summary>
        <returns>Значение, возвращаемое точкой входа сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> Метод предоставляет аналогичные функциональные возможности для <xref:System.AppDomain.ExecuteAssembly%2A> метода, но указывает сборку по отображаемому имени или <xref:System.Reflection.AssemblyName> , а не расположение файла. Таким образом <xref:System.AppDomain.ExecuteAssemblyByName%2A> загружает сборки с <xref:System.Reflection.Assembly.Load%2A> метода, а не с <xref:System.Reflection.Assembly.LoadFile%2A> метод.  
  
 Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.  
  
 Этот метод создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Сборка, заданная параметром <paramref name="assemblyName" />, не найдена.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка, заданная параметром <paramref name="assemblyName" /> найдена, но ее невозможно загрузить.</exception>
        <exception cref="T:System.BadImageFormatException">Сборка, заданная параметром <paramref name="assemblyName" />, недопустимая.  
  
 - или -  
  
 Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.MissingMethodException">Указанная сборка не имеет точку входа.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа на чтение из файла или каталога, для доступа к сведениям в самом пути, а также для перенаправления отображаемого имени пути. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">для доступа к веб-сайта, если отображаемое имя перенаправляется на URL-адрес.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">для выполнения консольного приложения. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName">Отображаемое имя сборки. См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Свидетельство для загрузки сборки.</param>
        <summary>Выполняет сборку с заданным отображаемым именем с использованием заданного свидетельства.</summary>
        <returns>Значение, возвращаемое точкой входа сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> Метод предоставляет аналогичные функциональные возможности для <xref:System.AppDomain.ExecuteAssembly%2A> метода, но указывает сборку по отображаемому имени или <xref:System.Reflection.AssemblyName> , а не расположение файла. Таким образом <xref:System.AppDomain.ExecuteAssemblyByName%2A> загружает сборки с <xref:System.Reflection.Assembly.Load%2A> метода, а не с <xref:System.Reflection.Assembly.LoadFile%2A> метод.  
  
 Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.  
  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> Метод не создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.  
  
> [!NOTE]
>  При использовании <xref:System.AppDomain.ExecuteAssemblyByName%2A> метод с <xref:System.Security.Policy.Evidence> параметр части свидетельства объединяются. Фрагменты свидетельства, предоставленные в качестве аргумента для <xref:System.AppDomain.ExecuteAssemblyByName%2A> метод замещают фрагменты свидетельства, предоставленные загрузчиком.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="assemblyName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Сборка, заданная параметром <paramref name="assemblyName" />, не найдена.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка, заданная параметром <paramref name="assemblyName" /> найдена, но ее невозможно загрузить.</exception>
        <exception cref="T:System.BadImageFormatException">Сборка, заданная параметром <paramref name="assemblyName" />, недопустимая.  
  
 -или-  
  
 Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.MissingMethodException">Указанная сборка не имеет точку входа.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа на чтение из файла или каталога, для доступа к сведениям в самом пути, а также для перенаправления отображаемого имени пути. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки со свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">для доступа к веб-сайта, если отображаемое имя перенаправляется на URL-адрес.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">для выполнения консольного приложения. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Отображаемое имя сборки. См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="args">Аргументы командной строки для передачи при запуске процесса.</param>
        <summary>Выполняет сборку с заданным отображаемым именем с использованием заданных аргументов.</summary>
        <returns>Значение, возвращаемое точкой входа сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> Метод предоставляет аналогичные функциональные возможности для <xref:System.AppDomain.ExecuteAssembly%2A> метода, но указывает сборку по отображаемому имени или <xref:System.Reflection.AssemblyName> , а не расположение файла. Таким образом <xref:System.AppDomain.ExecuteAssemblyByName%2A> загружает сборки с <xref:System.Reflection.Assembly.Load%2A> метода, а не с <xref:System.Reflection.Assembly.LoadFile%2A> метод.  
  
 Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.  
  
 Этот метод создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="assemblyName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Сборка, заданная параметром <paramref name="assemblyName" />, не найдена.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка, заданная параметром <paramref name="assemblyName" /> найдена, но ее невозможно загрузить.</exception>
        <exception cref="T:System.BadImageFormatException">Сборка, заданная параметром <paramref name="assemblyName" />, недопустимая.  
  
 - или -  
  
 Сборка <paramref name="assemblyName" /> была скомпилирована в более поздней версии среды CLR, чем версия, загруженная в текущий момент.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.MissingMethodException">Указанная сборка не имеет точку входа.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа на чтение из файла или каталога, для доступа к сведениям в самом пути, а также для перенаправления отображаемого имени пути. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">для доступа к веб-сайта, если отображаемое имя перенаправляется на URL-адрес.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">для выполнения консольного приложения. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Объект <see cref="T:System.Reflection.AssemblyName" />, представляющий имя сборки.</param>
        <param name="assemblySecurity">Свидетельство для загрузки сборки.</param>
        <param name="args">Аргументы командной строки для передачи при запуске процесса.</param>
        <summary>Выполняет сборку с заданным <see cref="T:System.Reflection.AssemblyName" /> с использованием указанного свидетельства и аргументов.</summary>
        <returns>Значение, возвращаемое точкой входа сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> Метод предоставляет аналогичные функциональные возможности для <xref:System.AppDomain.ExecuteAssembly%2A> метода, но указывает сборку по отображаемому имени или <xref:System.Reflection.AssemblyName> , а не расположение файла. Таким образом <xref:System.AppDomain.ExecuteAssemblyByName%2A> загружает сборки с <xref:System.Reflection.Assembly.Load%2A> метода, а не с <xref:System.Reflection.Assembly.LoadFile%2A> метод.  
  
 Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.  
  
 Этот метод создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.  
  
> [!NOTE]
>  При использовании <xref:System.AppDomain.ExecuteAssemblyByName%2A> метод с <xref:System.Security.Policy.Evidence> параметр части свидетельства объединяются. Фрагменты свидетельства, предоставленные в качестве аргумента для <xref:System.AppDomain.ExecuteAssemblyByName%2A> метод замещают фрагменты свидетельства, предоставленные загрузчиком.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Сборка, заданная параметром <paramref name="assemblyName" />, не найдена.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка, заданная параметром <paramref name="assemblyName" /> найдена, но ее невозможно загрузить.</exception>
        <exception cref="T:System.BadImageFormatException">Сборка, заданная параметром <paramref name="assemblyName" />, недопустимая.  
  
 -или-  
  
 Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> не является <see langword="null" />. Если не включена политика разграничения доступа кода для кода предыдущей версии, <paramref name="assemblySecurity" /> должно иметь значение <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Указанная сборка не имеет точку входа.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа на чтение из файла или каталога, для доступа к сведениям в самом пути, а также для перенаправления отображаемого имени пути. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки со свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">для доступа к веб-сайта, если отображаемое имя перенаправляется на URL-адрес.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">для выполнения консольного приложения. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName">Отображаемое имя сборки. См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Свидетельство для загрузки сборки.</param>
        <param name="args">Аргументы командной строки для передачи при запуске процесса.</param>
        <summary>Выполняет сборку с заданным отображаемым именем с использованием заданного свидетельства и аргументов.</summary>
        <returns>Значение, возвращаемое точкой входа сборки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.ExecuteAssemblyByName%2A> Метод предоставляет аналогичные функциональные возможности для <xref:System.AppDomain.ExecuteAssembly%2A> метода, но указывает сборку по отображаемому имени или <xref:System.Reflection.AssemblyName> , а не расположение файла. Таким образом <xref:System.AppDomain.ExecuteAssemblyByName%2A> загружает сборки с <xref:System.Reflection.Assembly.Load%2A> метода, а не с <xref:System.Reflection.Assembly.LoadFile%2A> метод.  
  
 Сборка начинает выполняться в точке входа, указанной в заголовке .NET Framework.  
  
 Этот метод создает новый процесс или домен приложения и не выполняет метод точки входа в новом потоке.  
  
> [!NOTE]
>  При использовании <xref:System.AppDomain.ExecuteAssemblyByName%2A> метод с <xref:System.Security.Policy.Evidence> параметр части свидетельства объединяются. Фрагменты свидетельства, предоставленные в качестве аргумента для <xref:System.AppDomain.ExecuteAssemblyByName%2A> метод замещают фрагменты свидетельства, предоставленные загрузчиком.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="assemblyName" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Сборка, заданная параметром <paramref name="assemblyName" />, не найдена.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка, заданная параметром <paramref name="assemblyName" /> найдена, но ее невозможно загрузить.</exception>
        <exception cref="T:System.BadImageFormatException">Сборка, заданная параметром <paramref name="assemblyName" />, недопустимая.  
  
 -или-  
  
 Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="assemblyName" /> скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="assemblySecurity" /> не является <see langword="null" />. Если не включена политика разграничения доступа кода для кода предыдущей версии, <paramref name="assemblySecurity" /> должно иметь значение <see langword="null" />.</exception>
        <exception cref="T:System.MissingMethodException">Указанная сборка не имеет точку входа.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа на чтение из файла или каталога, для доступа к сведениям в самом пути, а также для перенаправления отображаемого имени пути. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки со свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">для доступа к веб-сайта, если отображаемое имя перенаправляется на URL-адрес.</permission>
        <permission cref="T:System.Security.Permissions.UIPermission">для выполнения консольного приложения. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="FirstChanceException">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.FirstChanceException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FirstChanceException As EventHandler(Of FirstChanceExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Runtime::ExceptionServices::FirstChanceExceptionEventArgs ^&gt; ^ FirstChanceException;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при создании исключения в управляемом коде, перед тем как среда выполнения ищет стек вызовов для обработчика исключений в домене приложений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие является только уведомление. Обработка этого события не обрабатывает исключение и повлиять на последующие обработки исключений в каким-либо образом. После события и обработчики событий был вызван, общеязыковой среды выполнения (CLR) начинает поиск обработчика для исключения. <xref:System.AppDomain.FirstChanceException> домен приложения предоставляет первый шанс проверки любого управляемого исключения.  
  
 События могут обрабатываться в домене приложения. Если поток проходит через несколько доменов приложений при выполнении вызова, это событие возникает в каждом домене приложения, зарегистрированного обработчика событий, прежде чем среда CLR начинает поиск соответствующего обработчика исключений в данном домене приложения. После обработки события поиск выполняется для соответствующего обработчика исключений в данном домене приложения. Если ничего не найдено, событие вызывается в следующем домене приложения.  
  
 Необходимо обрабатывать все исключения, происходящие обработчик для события <xref:System.AppDomain.FirstChanceException> событий. В противном случае <xref:System.AppDomain.FirstChanceException> вызываться рекурсивно. Это может привести к переполнению стека и завершению работы приложения. Рекомендуется реализовать обработчики событий для этого события как области с ограничением выполнения (CER) для предотвращения исключений, связанных с инфраструктурой, например нехватки памяти или переполнение стека во время уведомления об исключениях, влияющие на виртуальной машине обрабатывается.  
  
 Это событие не вызывается для исключений, которые указывают на повреждение состояния процесса, например нарушения прав доступа, если обработчик событий с точки зрения безопасности и не имеет <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> атрибута.  
  
 Общеязыковая среда выполнения приостанавливает прерывания потока во время обрабатывается это событие уведомления.  
  
   
  
## Examples  
 В следующем примере создается набор доменов приложений с именем `AD0` через `AD3`, с `Worker` объекта в каждом домене приложения. Каждый `Worker` объект имеет ссылку на `Worker` объекта в следующий домен приложения, за исключением `Worker` в последнем домене приложения. <xref:System.AppDomain.FirstChanceException> Событие обрабатывается во всех доменах приложений, за исключением `AD1`.  
  
> [!NOTE]
>  Дополнение пример, в котором демонстрируется уведомлений о первичном исключении в нескольких доменах приложений, вы можете найти простых примеров использования в [как: получения уведомлений о первичном исключении](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md).  
  
 При создании доменов приложения домен приложения по умолчанию вызывает `TestException` метод для первого домена приложения. Каждый `Worker` вызывает `TestException` метод для следующего домена приложения, до последнего `Worker` исключение обрабатывается или нет. Таким образом, что текущий поток проходит через все домены приложений, и `TestException` добавляется в стек в каждом домене приложения.  
  
 Когда последний `Worker` объект обрабатывает исключение, <xref:System.AppDomain.FirstChanceException> события только в последнем домене приложения. Домены приложений никогда не получить возможность обработки исключения, поэтому событие не происходит.  
  
 Когда последний `Worker` объекта не обрабатывает исключение, <xref:System.AppDomain.FirstChanceException> события в каждом домене приложения с помощью обработчика событий. После завершения каждого обработчика события стека продолжается для очистки, пока не будет перехвачено исключение домена приложения по умолчанию.  
  
> [!NOTE]
>  Чтобы видеть, как отображение стека увеличивается по мере ближе вызывается событие и чем ближе к домена приложения по умолчанию, измените `e.Exception.Message` для `e.Exception` в `FirstChanceHandler` обработчики событий. Обратите внимание, что при `TestException` вызывается через границы домена приложения, он отображается дважды: один раз для прокси-сервера и один раз для заглушки.  
  
 [!code-csharp[System.AppDomain.FirstChanceException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/cs/example.cs#1)]
 [!code-vb[System.AppDomain.FirstChanceException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="T:System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs" />
        <altmember cref="E:System.AppDomain.UnhandledException" />
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.FriendlyName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает понятное имя этого домена приложения.</summary>
        <value>Понятное имя этого домена приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Понятное имя домена приложения по умолчанию является имя исполняемого файла процесса. Например, если исполняемый файл используется для запуска процесса — `"c:\MyAppDirectory\MyAssembly.exe"`, понятное имя домена приложения по умолчанию — `"MyAssembly.exe"`.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.AppDomain.FriendlyName%2A> свойства, чтобы получить понятное имя текущего домена приложения. Понятное имя для домена приложения по умолчанию называется исполняемый файл приложения. В примере кода также отображает дополнительные сведения о домене приложения.  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly[] GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает сборки, которые были загружены в контекст выполнения этого домена приложения.</summary>
        <returns>Массив сборок в этом домене приложения.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Следующий пример кода использует <xref:System.AppDomain.GetAssemblies%2A> метод, чтобы получить список всех сборок, загруженных в домен приложения. Сборки отображаются на консоль.  
  
 Чтобы запустить этот пример кода, необходимо создать сборку с именем `CustomLibrary.dll`, или измените имя сборки, передаваемое <xref:System.AppDomain.GetAssemblies%2A> метод.  
  
 [!code-cpp[ADGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetAssemblies/CPP/adgetassemblies.cpp#1)]
 [!code-csharp[ADGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetAssemblies/CS/adgetassemblies.cs#1)]
 [!code-vb[ADGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetAssemblies/VB/adgetassemblies.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentThreadId">
      <MemberSignature Language="C#" Value="public static int GetCurrentThreadId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentThreadId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetCurrentThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentThreadId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentThreadId();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает текущий идентификатор потока.</summary>
        <returns>32-битовое целое число со знаком, являющееся идентификатором текущего потока.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> свойство, которое стабильна, даже если .NET Framework размещается в среде, поддерживающей волокна (облегченным потоком).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова этого метода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <altmember cref="T:System.Int32" />
        <altmember cref="P:System.Threading.Thread.ManagedThreadId" />
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetData(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetData (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetData(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetData(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя предопределенного свойства домена приложения или имя определенного вами свойства домена приложения.</param>
        <summary>Возвращает значение, сохраненное в текущем домене приложения для заданного имени.</summary>
        <returns>Значение свойства <paramref name="name" /> или значение <see langword="null" />, если это свойство не существует.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для извлечения значения объекта, содержащегося во внутреннем кэше пар имя данные, описывающие свойства этого экземпляра класса <xref:System.AppDomain>. Обратите внимание, что сравнение `name` с именем пар ключ значение учитывает регистр.  
  
 Кэш автоматически содержит предопределенные системные записи, которые будут вставляться при создании домена приложения. Можно проверить их значения с <xref:System.AppDomain.GetData%2A> метода или эквивалентной <xref:System.AppDomainSetup> свойства.  
  
 Можно добавлять или изменять собственные определяемые пользователем пары имя данные, с <xref:System.AppDomain.SetData%2A> метод и проверять их значения с <xref:System.AppDomain.GetData%2A> метод.  
  
 В следующей таблице описаны `name` для каждого определенного элемента системы и соответствующего <xref:System.AppDomainSetup> свойство.  
  
|Значение атрибута «name»|Свойство.|  
|---------------------|--------------|  
|"APPBASE"|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>|  
|"APP_CONFIG_FILE"|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=nameWithType>|  
|"APP_LAUNCH_URL"|(свойство отсутствует)<br /><br /> «APP_LAUNCH_URL» представляет первоначально запрошенный пользователем до перенаправления URL-адрес. Он доступен только в том случае, когда приложение загружено с помощью браузера, например Internet Explorer. Не все браузеры поддерживают это значение.|  
|"APP_NAME"|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>|  
|"BINPATH_PROBE_ONLY"|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=nameWithType>|  
|"CACHE_BASE"|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>|  
|"CODE_DOWNLOAD_DISABLED"|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>|  
|"DEV_PATH"|(свойство отсутствует)|  
|"DISALLOW_APP"|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_BASE_PROBING"|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=nameWithType>|  
|"DISALLOW_APP_REDIRECTS"|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=nameWithType>|  
|"DYNAMIC_BASE"|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>|  
|«FORCE_CACHE_INSTALL»|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>|  
|«LICENSE_FILE», или строка конкретного приложения|<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=nameWithType>|  
|«LOADER_OPTIMIZATION»|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=nameWithType>|  
|«LOCATION_URI»|(свойство отсутствует)|  
|«PRIVATE_BINPATH»|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>|  
|"REGEX_DEFAULT_MATCH_TIMEOUT"|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=nameWithType><br /><br /> «REGEX_DEFAULT_MATCH_TIMEOUT» не является записью системы, а его значение можно задать путем вызова <xref:System.AppDomain.SetData%2A> метод.|  
|"SHADOW_COPY_DIRS"|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>|  
  
   
  
## Examples  
 Следующий пример создает новый домен приложения, задает системные значение для домена и добавляет пару значение для домена. В примере затем показано, как использовать <xref:System.AppDomain.GetData%2A> метод извлечения данных из этих пар «значение», и отобразить их на консоль.  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям о самом пути, если свойство относится к пути. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="M:System.AppDomain.SetData(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает тип текущего экземпляра.</summary>
        <returns>Тип текущего экземпляра.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает целое число, однозначно идентифицирующее домен приложения в процессе.</summary>
        <value>Целое число, идентифицирующее домен приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода создается второй домен приложения и отображает сведения о домене по умолчанию и нового домена.  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InitializeLifetimeService();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.InitializeLifetimeService</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Предоставляет объекту <see cref="T:System.AppDomain" /> бесконечное время существования, предотвращая создание аренды.</summary>
        <returns>Всегда <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="IsCompatibilitySwitchSet">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsCompatibilitySwitchSet (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; IsCompatibilitySwitchSet(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCompatibilitySwitchSet (value As String) As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; IsCompatibilitySwitchSet(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Проверяемый переключатель совместимости.</param>
        <summary>Возвращает логическое значение, допускающее значения NULL, которое указывает, установлены ли какие-либо переключатели совместимости и, если установлены, установлен ли заданный переключатель совместимости.</summary>
        <returns>Пустая ссылка (<see langword="Nothing" /> в Visual Basic), если переключатели совместимости не установлены; в противном случае логическое значение, указывающее, установлен ли переключатель совместимости, заданный параметром <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод проверяет, является ли заданный переключатель совместимости настроен для текущего домена приложения. Обычно переключатели совместимости восстановить поведение (например, способ строки сортируются), был изменен между версиями .NET Framework.  Задать, вызвав <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType> метод до создания домена приложения.  
  
 Следующая таблица примеры переключатели совместимости, которые могут быть установлены для восстановления поведения предыдущих версий платформы .NET Framework.  
  
|Параметр|Значение|  
|------------|-------------|  
|"NetFx40_LegacySecurityPolicy"|Код доступа (CAS) для [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] включена в этом домене приложения. В разделе [ &lt;NetFx40_LegacySecurityPolicy&gt; элемент](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).|  
|"NetFx40_Legacy20SortingBehavior"|Значения по умолчанию для сортировки строк [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] включены в этом домене приложения. По результатам требует sort00001000.dll должны быть установлены. В разделе [ &lt;CompatSortNLSVersion&gt; элемент](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).|  
|"NetFx40_Legacy40SortingBehavior"|Значения по умолчанию для сортировки строк [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]и Unicode 5.0 включены в этом домене приложения. По результатам требует sort00060101.dll должны быть установлены.|  
|"NetFx40_TimeSpanLegacyFormatMode"|<xref:System.TimeSpan> форматирование поведение для [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] включена в этом домене приложения.  В разделе [ &lt;TimeSpan_LegacyFormatMode&gt; элемент](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) и в разделе «Восстановление форматирование прежних версий TimeSpan» <xref:System.TimeSpan> раздела.|  
|"UseRandomizedStringHashAlgorithm"|Среда выполнения вычисляет хэш-кодов для строк для каждого домена приложения, вместо использования один алгоритм хэширования, который создает согласованные хэш-код в доменах приложений. В разделе [ &lt;UseRandomizedStringHashAlgorithm&gt; элемент](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="IsDefaultAppDomain">
      <MemberSignature Language="C#" Value="public bool IsDefaultAppDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDefaultAppDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsDefaultAppDomain" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDefaultAppDomain () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDefaultAppDomain();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает значение, указывающее, является ли домен приложения используемым по умолчанию доменом для процесса.</summary>
        <returns>
          <see langword="true" />, если текущий объект <see cref="T:System.AppDomain" /> представляет используемый по умолчанию домен приложения для процесса, в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Все управляемые процессы имеется домен приложения по умолчанию. Выполнение начинается в домене по умолчанию.  
  
   
  
## Examples  
 В следующем примере кода создается второй домен приложения и отображает сведения о домене по умолчанию и нового домена.  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalizingForUnload">
      <MemberSignature Language="C#" Value="public bool IsFinalizingForUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFinalizingForUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsFinalizingForUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFinalizingForUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFinalizingForUnload();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Определяет, выгружен ли этот домен приложения, и были ли закрыты средой CLR объекты, которые он содержал.</summary>
        <returns>
          Значение <see langword="true" />, если этот домен приложения выгружен, и среда CLR начала вызов методов завершения, в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод завершения для объекта обеспечивает возможность выполнения некоторых необходимых операций очистки перед сбором мусора. После завершения объект доступен, но в недопустимом состоянии и поэтому непригоден для использования. Со временем завершения сбора мусора и освобождает объект.  
  
 Завершающий метод объекта вызывается в одном из следующих ситуаций: во время сборки мусора, если общеязыковая среда выполнения завершает работу, или при выгрузке домена приложения, содержащего объект. <xref:System.AppDomain.IsFinalizingForUnload%2A> Возвращает `true` только в последнем случае; он не возвращает `true` Если результатом выполнения операции Finalize из процедуры сборки мусора или завершение работы CLR.  
  
> [!NOTE]
>  Чтобы определить, является ли финализации из-за завершения работы среды CLR, используйте <xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType> свойство. Она возвращает `true` в случае завершения связано домен приложения выгружается или среда CLR завершает работу.  
  
 При выполнении метода завершения во время выгрузки домена приложения, может потребоваться доступ к другому объекту, на который ссылается статическое поле и содержит метод завершения. Однако это невозможно сделать надежно так, как объект, к которому осуществляется доступ может быть уже закрыт.  
  
> [!NOTE]
>  Исключением из этого правила является <xref:System.Console> класс, который содержит статические поля, которые ссылаются на объекты потока, но реализовано так, что можно всегда написать системную консоль, даже во время завершения работы домена при выгрузке или системы.  
  
 Используйте этот метод в методе завершения объекта для определения того, выгружается ли домен приложения, который содержит объект. Если это так, может оказаться недоступным любой объект, который ссылается статическое поле и содержит метод завершения.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Environment.HasShutdownStarted" />
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, выполняются ли сборки, загруженные в текущий домен приложения, с полным доверием.</summary>
        <value>
          Значение <see langword="true" />, если сборки, загруженные в текущий домен приложения, выполняются с полным доверием; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод всегда возвращает `true` для домена приложения по умолчанию для приложения, которое выполняется на рабочем столе. Он возвращает `false` для изолированного домена приложения, созданные с помощью <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> перегрузку метода, если разрешения, которые предоставляются в домен приложения эквивалентны полного доверия.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.AppDomain.IsFullyTrusted%2A> свойство и <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> свойства с использованием доменов приложений полностью и частично достоверный. Домен приложения с полным доверием — домена приложения по умолчанию для приложения. Домен приложения с частичным доверием создается с помощью <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> перегрузки метода.  
  
 В этом примере `Worker` класс, производный от <xref:System.MarshalByRefObject>, поэтому он может быть маршалирован через границы домена приложения. В примере создается `Worker` объекта в домене приложения по умолчанию. Затем он вызывает `TestIsFullyTrusted` метод для отображения значения свойства для домена приложения и две сборки, загруженные в домен приложения: mscorlib, которая является частью .NET Framework и примера сборки. Домен приложения является полностью доверенной, поэтому обе сборки являются полностью доверенными.  
  
 В примере создается другой `Worker` объекта в изолированном домене приложения и снова вызывает `TestIsFullyTrusted` метод. Mscorlib всегда является доверенным, даже в домене приложения с частичным доверием, но пример сборки является частичным доверием.  
  
 [!code-csharp[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/cs/example.cs#1)]
 [!code-vb[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHomogenous">
      <MemberSignature Language="C#" Value="public bool IsHomogenous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHomogenous" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsHomogenous" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHomogenous As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHomogenous { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, имеет ли текущий домен приложения набор разрешений, которые предоставляются всем сборкам, загружаемым в домен приложения.</summary>
        <value>
          Значение <see langword="true" />, если текущий домен приложения имеет однородный набор разрешений; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство возвращает `true` для изолированных доменов приложений, созданных с помощью <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> перегрузки метода. Домены изолированного приложения имеет однородный набор разрешений; то есть один и тот же набор разрешений предоставляется всем частично доверенным сборкам, загружаемым в домен приложения. При необходимости изолированный домен приложения имеет список сборок со строгими именами, которые будут исключены из этого набора разрешений и выполняются с полным доверием.  
  
 Полностью доверенный код может использовать <xref:System.AppDomain.PermissionSet%2A> свойство для определения однородного набора разрешений изолированного домена приложения.  
  
 Это свойство также возвращает `true` для домена приложения по умолчанию для настольных приложений, поскольку домен приложения предоставляет полное доверие для всех сборок.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomain.PermissionSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Загружает сборку <see cref="T:System.Reflection.Assembly" /> в этот домен приложения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Массив типа <see langword="byte" />, который является образом в формате COFF, содержащим порожденную сборку.</param>
        <summary>Загружает объект <see cref="T:System.Reflection.Assembly" /> с образом в формате COFF, содержащим порожденный объект <see cref="T:System.Reflection.Assembly" />.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Начиная с версии [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], уровень доверия сборки, которая загружена с помощью этого метода является таким же, как уровень доверия домена приложения.  
  
 Этот метод следует использовать только для загрузки сборки в текущем домене приложения. Этот метод предоставляется для удобства для взаимодействия вызывающих объектов, которые не могут вызывать статический <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> метод. Для загрузки сборок в других доменах приложений, используйте метод, например <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Сведения, общие для всех перегрузок данного метода см. в разделе <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> перегрузки метода.  
  
   
  
## Examples  
 В следующем образце показано использование загрузка необработанной сборки.  
  
 Для этого примера кода необходимо указать полное имя сборки. Сведения о том, как получить полное имя сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="rawAssembly" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> не является допустимой сборкой.  
  
 - или -  
  
 Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="rawAssembly" /> скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа на чтение из файла или каталога, а также для доступа к сведениям в сам путь. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Объект, который описывает сборку, подлежащую загрузке.</param>
        <summary>Загружает сборку <see cref="T:System.Reflection.Assembly" />, заданную ее именем <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод следует использовать только для загрузки сборки в текущем домене приложения. Этот метод предоставляется для удобства для взаимодействия вызывающих объектов, которые не могут вызывать статический <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> метод. Для загрузки сборок в других доменах приложений, используйте метод, например <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Если версия запрошенной сборки уже загружена, этот метод возвращает загруженную сборку, даже если требуется другая версия.  
  
 Частичное имя сборки для указания `assemblyRef` не рекомендуется. (В частичном имени пропущен один или несколько языка и региональных параметров, версии или токен открытого ключа. Для перегрузок, которые принимают строки, а не <xref:System.Reflection.AssemblyName> объекта, «MyAssembly, Version = 1.0.0.0» является примером часть имени и «MyAssembly, Version = 1.0.0.0, язык и региональные параметры = neutral, PublicKeyToken = 18ab3442da84b47» приведен пример полного имени.) Использование частичных имен может отрицательно сказаться на производительности. Кроме того, имя частичной сборки можно загрузить сборку из глобального кэша сборок только в том случае, если точную копию сборок в базовой папке приложения (<xref:System.AppDomain.BaseDirectory%2A> или <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>).  
  
 Если текущий <xref:System.AppDomain> представляет домен приложения `A`и <xref:System.AppDomain.Load%2A> метод вызывается из домена приложения `B`, сборка загружается в оба домена приложения. Например, следующий код загружает `MyAssembly` в новый домен приложения `ChildDomain` и также в домен приложения, в котором выполняется этот код:  
  
 [!code-cpp[System.AppDomain.Load#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.load/cpp/source.cpp#1)]
 [!code-csharp[System.AppDomain.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.load/cs/source.cs#1)]
 [!code-vb[System.AppDomain.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.load/vb/source.vb#1)]  
  
 Сборка загружена в оба домена, так как <xref:System.Reflection.Assembly> не является производным от <xref:System.MarshalByRefObject>и поэтому возвращаемое значение <xref:System.AppDomain.Load%2A> метода не могут быть упакованы. Вместо этого общеязыковая среда выполнения пытается загрузить сборку в вызывающий домен приложения. Сборки, загруженные в двух доменов приложений, может отличаться в том случае, если параметры пути для двух доменов приложений отличаются.  
  
> [!NOTE]
>  Если оба <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> свойство и <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> имеет значение, отображаемое имя используется первая попытка загрузки сборки (включая версии, языка и региональных параметров и т. д., возвращенные <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> свойство). Если файл не найден, <xref:System.Reflection.AssemblyName.CodeBase%2A> свойство используется для поиска сборки. Если сборка найдена с помощью <xref:System.Reflection.AssemblyName.CodeBase%2A>, противопоставляется отображаемое имя сборки. Если совпадение не найдено, <xref:System.IO.FileLoadException> возникает исключение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="assemblyRef" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> не найден.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> не является допустимой сборкой.  
  
 - или -  
  
 Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="assemblyRef" /> скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа на чтение из файла или каталога, а также для доступа к сведениям в сам путь. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Отображаемое имя сборки. См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <summary>Загружает сборку <see cref="T:System.Reflection.Assembly" />, заданную ее отображаемым именем.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод следует использовать только для загрузки сборки в текущем домене приложения. Этот метод предоставляется для удобства для взаимодействия вызывающих объектов, которые не могут вызывать статический <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> метод. Для загрузки сборок в других доменах приложений, используйте метод, например <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Сведения, общие для всех перегрузок данного метода см. в разделе <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> перегрузки метода.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> равно <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> не найден.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> не является допустимой сборкой.  
  
 - или -  
  
 Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="assemblyString" /> скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа на чтение из файла или каталога, а также для доступа к сведениям в сам путь. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">для возможности доступа к каталогу сборки, если сборка не является локальным.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Массив типа <see langword="byte" />, который является образом в формате COFF, содержащим порожденную сборку.</param>
        <param name="rawSymbolStore">Массив типа <see langword="byte" />, содержащий необработанные байты, которые представляют символы для сборки.</param>
        <summary>Загружает объект <see cref="T:System.Reflection.Assembly" /> с образом в формате COFF, содержащим порожденный объект <see cref="T:System.Reflection.Assembly" />. Загружаются также необработанные байты, представляющие символы для <see cref="T:System.Reflection.Assembly" />.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Начиная с версии [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], уровень доверия сборки, которая загружена с помощью этого метода является таким же, как уровень доверия домена приложения.  
  
 Этот метод следует использовать только для загрузки сборки в текущем домене приложения. Этот метод предоставляется для удобства для взаимодействия вызывающих объектов, которые не могут вызывать статический <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> метод. Для загрузки сборок в других доменах приложений, используйте метод, например <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Сведения, общие для всех перегрузок данного метода см. в разделе <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> перегрузки метода.  
  
   
  
## Examples  
 В следующем образце показано использование загрузка необработанной сборки.  
  
 Для этого примера кода необходимо указать полное имя сборки. Сведения о том, как получить полное имя сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="rawAssembly" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> не является допустимой сборкой.  
  
 - или -  
  
 Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="rawAssembly" /> скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Net.WebPermission">для чтения URI, который начинается с «file://».</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа на чтение из файла или каталога, а также для доступа к сведениям в сам путь. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef">Объект, который описывает сборку, подлежащую загрузке.</param>
        <param name="assemblySecurity">Свидетельство для загрузки сборки.</param>
        <summary>Загружает сборку <see cref="T:System.Reflection.Assembly" />, заданную ее именем <see cref="T:System.Reflection.AssemblyName" />.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод следует использовать только для загрузки сборки в текущем домене приложения. Этот метод предоставляется для удобства для взаимодействия вызывающих объектов, которые не могут вызывать статический <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> метод. Для загрузки сборок в других доменах приложений, используйте метод, например <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Сведения, общие для всех перегрузок данного метода см. в разделе <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> перегрузки метода.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyRef" /> равно <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyRef" /> не найден.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyRef" /> не является допустимой сборкой.  
  
 - или -  
  
 Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="assemblyRef" /> скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа на чтение из файла или каталога, а также для доступа к сведениям в сам путь. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки со свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Net.WebPermission">для чтения пути, который не находится в форме «file://» или "\\\UNC\dir\\» или «c:\\».</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString">Отображаемое имя сборки. См. раздел <see cref="P:System.Reflection.Assembly.FullName" />.</param>
        <param name="assemblySecurity">Свидетельство для загрузки сборки.</param>
        <summary>Загружает сборку <see cref="T:System.Reflection.Assembly" />, заданную ее отображаемым именем.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод следует использовать только для загрузки сборки в текущем домене приложения. Этот метод предоставляется для удобства для взаимодействия вызывающих объектов, которые не могут вызывать статический <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> метод. Для загрузки сборок в других доменах приложений, используйте метод, например <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Сведения, общие для всех перегрузок данного метода см. в разделе <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> перегрузки метода.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="assemblyString" /> равно <see langword="null" /></exception>
        <exception cref="T:System.IO.FileNotFoundException">
          <paramref name="assemblyString" /> не найден.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="assemblyString" /> не является допустимой сборкой.  
  
 - или -  
  
 Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="assemblyString" /> скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для загрузки сборки со свидетельством. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа на чтение из файла или каталога, а также для доступа к сведениям в сам путь. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">для чтения пути, который не находится в форме «file://» или "\\\UNC\dir\\» или «c:\\».</permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly">Массив типа <see langword="byte" />, который является образом в формате COFF, содержащим порожденную сборку.</param>
        <param name="rawSymbolStore">Массив типа <see langword="byte" />, содержащий необработанные байты, которые представляют символы для сборки.</param>
        <param name="securityEvidence">Свидетельство для загрузки сборки.</param>
        <summary>Загружает объект <see cref="T:System.Reflection.Assembly" /> с образом в формате COFF, содержащим порожденный объект <see cref="T:System.Reflection.Assembly" />. Загружаются также необработанные байты, представляющие символы для <see cref="T:System.Reflection.Assembly" />.</summary>
        <returns>Загруженная сборка.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Начиная с версии [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], уровень доверия сборки, которая загружена с помощью этого метода является таким же, как уровень доверия домена приложения.  
  
 Этот метод следует использовать только для загрузки сборки в текущем домене приложения. Этот метод предоставляется для удобства для взаимодействия вызывающих объектов, которые не могут вызывать статический <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> метод. Для загрузки сборок в других доменах приложений, используйте метод, например <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.  
  
 Сведения, общие для всех перегрузок данного метода см. в разделе <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> перегрузки метода.  
  
   
  
## Examples  
 В следующем образце показано использование загрузка необработанной сборки.  
  
 Для этого примера кода необходимо указать полное имя сборки. Сведения о том, как получить полное имя сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="rawAssembly" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.BadImageFormatException">
          <paramref name="rawAssembly" /> не является допустимой сборкой.  
  
 - или -  
  
 Сейчас загружена среда CLR 2.0 или более поздней версии. Сборка <paramref name="rawAssembly" /> скомпилирована в более поздней версии.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <exception cref="T:System.IO.FileLoadException">Сборка или модуль был загружен дважды с двумя разными свидетельствами.</exception>
        <exception cref="T:System.NotSupportedException">
          <paramref name="securityEvidence" /> не является <see langword="null" />. Если не включена политика разграничения доступа кода для кода предыдущей версии, <paramref name="securityEvidence" /> должно иметь значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Чтобы получить свидетельство. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа на чтение из файла или каталога, а также для доступа к сведениям в сам путь. Связанные перечисления: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <permission cref="T:System.Net.WebPermission">для чтения пути, который не находится в форме «file://» или "\\\UNC\dir\\» или «c:\\».</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringIsEnabled">
      <MemberSignature Language="C#" Value="public static bool MonitoringIsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MonitoringIsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringIsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MonitoringIsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MonitoringIsEnabled { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, включен ли мониторинг ЦП и памяти доменов приложений для текущего процесса. После того, как мониторинг для процесса включен, отключить его невозможно.</summary>
        <value>
          Значение <see langword="true" />, если мониторинг включен; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это `static` свойство (`Shared` свойство в Visual Basic) управляет мониторинг ЦП и памяти для всех доменов приложений в процессе.  
  
 При попытке присвоить этому свойству значение `false`, <xref:System.ArgumentException> исключения, даже если текущее значение свойства `false`.  
  
 После включения мониторинга можно использовать <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, и <xref:System.AppDomain.MonitoringTotalProcessorTime%2A> экземпляра свойства для наблюдения за использованием ЦП и памяти отдельных доменов приложений.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Текущий процесс предпринял попытку присвоить значение <see langword="false" /> этому свойству.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringSurvivedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringSurvivedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringSurvivedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringSurvivedMemorySize { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает количество байтов, оставшихся после последнего сбора, и про которые известно, что на них ссылается текущий домен приложения.</summary>
        <value>Количество оставшихся байтов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Статистические данные обновляются с каждой сборки мусора. Тем не менее они гарантированно точным только после полной блокирующей сборки; Другими словами происходит коллекции, включающий все поколения и которая останавливает приложения во время сбора. Например <xref:System.GC.Collect?displayProperty=nameWithType> перегрузка метода выполняет полной блокирующей сборки. (Параллельной сборки происходит в фоновом режиме и не блокирует приложение).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see langword="static" /> (<see langword="Shared" /> в Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> установлено равным <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedProcessMemorySize">
      <MemberSignature Language="C#" Value="public static long MonitoringSurvivedProcessMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MonitoringSurvivedProcessMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long MonitoringSurvivedProcessMemorySize { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает общее количество байтов, оставшихся после последнего сбора для всех доменов приложений в процессе.</summary>
        <value>Общее количество оставшихся байтов для процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 После полную блокирующую сборку это число представляет количество байтов в настоящее время сохраняющихся в активном в управляемых кучах. Оно должно быть близким к номера, полученного от <xref:System.GC.GetTotalMemory%2A> метод. После эфемерной сборки мусора это число представляет количество байтов в настоящее время сохраняющихся в активном состоянии в эфемерных поколениях.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see langword="static" /> (<see langword="Shared" /> в Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> установлено равным <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalAllocatedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringTotalAllocatedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalAllocatedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringTotalAllocatedMemorySize { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает общий размер в байтах для всех операций выделения памяти, выполненных доменом приложения с момента его создания, без вычитания собранной памяти.</summary>
        <value>Общий размер для всех операций выделения памяти.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see langword="static" /> (<see langword="Shared" /> в Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> установлено равным <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan MonitoringTotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MonitoringTotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MonitoringTotalProcessorTime { TimeSpan get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает общее процессорное время, использованное всеми потоками при выполнении в текущем домене приложения с момента запуска процесса.</summary>
        <value>Общее процессорное время для текущего домена приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Общее время, указываемые для домена приложения включает время, каждый поток в процессе, затраченное на выполнение в данном домене приложения.  
  
 Поток, который вызывает неуправляемый код по-прежнему связан с доменом приложения и загруженности процессора затраченное на выполнение неуправляемого кода указывается для домена приложения, где был выполнен вызов.  
  
 Когда поток заблокирован или находится в спящем режиме, он не использует время процессора.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see langword="static" /> (<see langword="Shared" /> в Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> установлено равным <see langword="false" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает набор разрешений изолированного домена приложения.</summary>
        <value>Набор разрешений изолированного домена приложения.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Изолированных доменов приложений, созданных с помощью <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> перегрузка метода имеет однородный набор разрешений, то есть один и тот же набор разрешений предоставляется всем частично доверенным сборкам, загружаемым в домен приложения. При необходимости изолированный домен приложения имеет список сборок со строгими именами, которые будут исключены из этого набора разрешений и выполняются с полным доверием.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="P:System.AppDomain.IsHomogenous" />
      </Docs>
    </Member>
    <Member MemberName="ProcessExit">
      <MemberSignature Language="C#" Value="public event EventHandler ProcessExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ProcessExit" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ProcessExit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProcessExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ProcessExit;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ProcessExit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит при завершении работы родительского процесса домена приложения по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.EventHandler> Для этого события может выполнять некоторые операции завершения, такие как закрытие файлов, освобождение хранилища и т. д., перед завершением процесса.  
  
 Начиная с .NET Framework версии 2.0, это событие возникает в каждом домене приложения, которое регистрирует обработчик событий.  
  
> [!NOTE]
>  Общее время выполнения всех <xref:System.AppDomain.ProcessExit> обработчики событий ограничено, так же, как общее время выполнения всех методов завершения ограничено при завершении процесса. Значение по умолчанию — две секунды. Неуправляемый узел может изменить время выполнения путем вызова [ICLRPolicyManager::SetTimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md) метод с [OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md) значение перечисления.  
  
 В .NET Framework версий 1.0 и 1.1 это событие создается только в домене приложения по умолчанию и только в том случае, если обработчик событий регистрируется в домене приложения по умолчанию.  
  
 Чтобы зарегистрировать обработчик событий для этого события, необходимо иметь необходимые разрешения, или <xref:System.Security.SecurityException> возникает исключение.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyAssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReflectionOnlyAssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ ReflectionOnlyAssemblyResolve;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда разрешение сборки завершается неудачей в контексте, поддерживающем только отражение.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В контексте только для отражения зависимости не разрешаются автоматически. Они должны предварительно или возвращается с помощью обработчика этого события. Это событие возникает, когда сборка имеет зависимость, уже не загружена в контекст только для отражения. Отсутствующая зависимость определяется <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> свойство. <xref:System.ResolveEventHandler> Для этого события должно возвращать сборку, которая удовлетворяет зависимость. Возвращаемая сборка должна быть загружена в контекст только для отражения.  
  
> [!IMPORTANT]
>  Это событие возникает только для отсутствующие зависимости сборки, которая загружается в контекст только для отражения (например, с помощью <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> метода). Оно не возникает, если не удается найти сборку, которая загружается.  
  
 Начиная с версии [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> свойство возвращает сборку, запросившего загрузку сборки, которую не удалось разрешить. Знание идентификатора запрашивающей сборки может оказаться полезным при выявлении правильная версия зависимости, если доступно более одной версии. Дополнительные сведения см. в разделе <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Для этого события <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> свойство возвращает имя сборки, перед применением политики.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ReflectionOnlyGetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function ReflectionOnlyGetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Assembly ^&gt; ^ ReflectionOnlyGetAssemblies();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает сборки, которые были загружены в контекст, поддерживающий только отражение, домена приложения.</summary>
        <returns>Массив объектов <see cref="T:System.Reflection.Assembly" />, представляющих сборки, которые были загружены в контекст домена приложения, поддерживающий только отражение.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает сборки, которые были загружены в контекст только для отражения. Чтобы получить сборок, загруженных для выполнения, используйте <xref:System.AppDomain.GetAssemblies%2A> метод.  
  
   
  
## Examples  
 В следующем примере кода загружает сборки System.dll, контекст выполнения, а затем в контекст только для отражения. <xref:System.AppDomain.GetAssemblies%2A> И <xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A> методы используются для отображения сборок, загруженных в каждом контексте.  
  
 [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CPP/reflectiononly.cpp#1)]
 [!code-csharp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CS/reflectiononly.cs#1)]
 [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/VB/reflectiononly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринимается попытка выполнить операцию в незагруженном домене приложения.</exception>
        <altmember cref="M:System.AppDomain.GetAssemblies" />
      </Docs>
    </Member>
    <Member MemberName="RelativeSearchPath">
      <MemberSignature Language="C#" Value="public string RelativeSearchPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RelativeSearchPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.RelativeSearchPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RelativeSearchPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RelativeSearchPath { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.RelativeSearchPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает путь, к каталогу, находящемуся в базовом каталоге, где распознаватель сборок будет производить поиск закрытых сборок.</summary>
        <value>Путь, к каталогу, находящемуся в базовом каталоге, где распознаватель сборок будет производить поиск закрытых сборок.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Закрытые сборки развертываются в одну и ту же структуру каталогов приложения. Если путь, указанный параметром <xref:System.AppDomain.RelativeSearchPath%2A> свойства не находится в <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>, он обрабатывается.  
  
 Это свойство возвращает значение, заданное с помощью <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к информации о пути. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</permission>
        <altmember cref="P:System.AppDomainSetup.PrivateBinPath" />
      </Docs>
    </Member>
    <Member MemberName="ResourceResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ResourceResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ResourceResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ResourceResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResourceResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ ResourceResolve;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ResourceResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>происходит, когда разрешение ресурса завершается неудачей, из-за того, что он не является допустимым связанным или внедренным ресурсом в сборке.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ResolveEventHandler> Для этого события может попытаться найти сборку, содержащую ресурс и вернуть его.  
  
> [!IMPORTANT]
>  Это событие не происходит, если разрешение завершается неудачей, так как не удалось найти для действительного связанного ресурса. Она возникает, если не удается найти поток ресурса манифеста, но оно не возникает, если не удается найти индивидуальный ключ ресурса.  
  
 Начиная с версии [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> свойство содержит сборку, которая запрошенного ресурса. Дополнительные сведения см. в разделе <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Чтобы зарегистрировать обработчик событий для этого события, необходимо иметь необходимые разрешения, или <xref:System.Security.SecurityException> возникает исключение.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="SetAppDomainPolicy">
      <MemberSignature Language="C#" Value="public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAppDomainPolicy (domainPolicy As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAppDomainPolicy(System::Security::Policy::PolicyLevel ^ domainPolicy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainPolicy" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="domainPolicy">Уровень политики безопасности.</param>
        <summary>Устанавливает уровень политики безопасности для этого домена приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывается до сборка загружается в <xref:System.AppDomain> политика безопасности действовала.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование <xref:System.AppDomain.SetAppDomainPolicy%2A> метод, чтобы задать уровень политики безопасности домена приложения.  
  
 [!code-cpp[ADSetAppDomainPolicy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetAppDomainPolicy/CPP/adsetappdomainpolicy.cpp#1)]
 [!code-csharp[ADSetAppDomainPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetAppDomainPolicy/CS/adsetappdomainpolicy.cs#1)]
 [!code-vb[ADSetAppDomainPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetAppDomainPolicy/VB/adsetappdomainpolicy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="domainPolicy" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">Установленный уровень политики безопасности.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetCachePath">
      <MemberSignature Language="C#" Value="public void SetCachePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCachePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetCachePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCachePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetCachePath(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetCachePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.SetCachePath")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Полный путь к расположению теневых копий.</param>
        <summary>Устанавливает заданный путь каталога в качестве места, куда копируются теневые сборки.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Путь к кэшу учитывается, если <xref:System.AppDomainSetup.ApplicationName%2A> свойство не задано. См. свойство <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>.  
  
 Дополнительные сведения о теневом копировании разделе [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Присваивает значение свойству домена приложения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetData(string name, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetData(System::String ^ name, System::Object ^ data);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetData(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name">Имя пользовательского свойства домена приложения, которое требуется создать или изменить.</param>
        <param name="data">Значение свойства.</param>
        <summary>Устанавливает заданное значение для свойства указанного домена приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод служит для вставки объекта или изменения значения объекта, содержащегося во внутреннем кэше пар имя данные, описывающие свойства этого экземпляра класса <xref:System.AppDomain>.  
  
 Кэш автоматически содержит предопределенные системные записи, которые будут вставляться при создании домена приложения. Не удается добавить или изменить элементы с помощью этого метода. Вызов метода, который пытается изменить записи системы не имеет результата; метод не вызывает исключение. Можно было проверить значения элементов системы с <xref:System.AppDomain.GetData%2A> метода или эквивалентной <xref:System.AppDomainSetup> свойств, описанных в <xref:System.AppDomain.GetData%2A>.  
  
 В качестве значения можно вызвать этот метод, чтобы задать значение интервала времени ожидания по умолчанию для оценки шаблонов регулярных выражений, укажите «REGEX_DEFAULT_MATCH_TIMEOUT» `name` аргумент и <xref:System.TimeSpan> значение, представляющее время ожидания интервал в качестве значения `data` аргумент. Можно также вставить или изменить свои собственные определяемые пользователем пары имя данные с помощью этого метода и проверять их значения с <xref:System.AppDomain.GetData%2A> метод.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование <xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29> метод, чтобы создать новую пару значение. Затем в примере используется <xref:System.AppDomain.GetData%2A> метод для получения значения и отображает его на консоль.  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="M:System.AppDomain.GetData(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data, System.Security.IPermission permission);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data, class System.Security.IPermission permission) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object, permission As IPermission)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetData(System::String ^ name, System::Object ^ data, System::Security::IPermission ^ permission);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="permission" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="name">Имя пользовательского свойства домена приложения, которое требуется создать или изменить.</param>
        <param name="data">Значение свойства.</param>
        <param name="permission">Разрешение, которое нужно запросить у вызывающего кода при извлечении свойства.</param>
        <summary>Присваивает заданное значение заданному свойству домена приложения с заданными разрешениями, которые нужно запросить у вызывающего кода при извлечении свойства.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно используйте для вставки или изменения собственных пользовательских записей во внутреннем кэше пар имя данные, которые описывают свойства домена приложения. При вставке записи можно указать запрос разрешения для принудительного извлечения записи. Кроме того, можно вызвать этот метод, чтобы задать значение интервала времени ожидания по умолчанию для оценки шаблонов регулярных выражений, укажите «REGEX_DEFAULT_MATCH_TIMEOUT» в качестве значения `name` аргумент и <xref:System.TimeSpan> значение, представляющее интервал времени ожидания в качестве значения `data` аргумент.  
  
 Этот метод нельзя использовать для назначения требование безопасности строковое свойство, определенное в системе.  
  
 Кэш автоматически содержит предопределенные системные записи, которые будут вставляться при создании домена приложения. Не удается добавить или изменить элементы с помощью этого метода. Вызов метода, который пытается изменить записи системы не имеет результата; метод не вызывает исключение. Можно было проверить значения элементов системы с <xref:System.AppDomain.GetData%2A> метода или эквивалентной <xref:System.AppDomainSetup> свойства, описанные в разделе "Примечания" <xref:System.AppDomain.GetData%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">
          <paramref name="name" /> задает определяемую системой строку свойства, и <paramref name="permission" /> не равно <see langword="null" />.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetDynamicBase">
      <MemberSignature Language="C#" Value="public void SetDynamicBase (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDynamicBase(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetDynamicBase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDynamicBase (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDynamicBase(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.DynamicBase")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Полный путь, который является базовым каталогом для подкаталогов, в которых хранятся динамические сборки.</param>
        <summary>Устанавливает заданный путь каталога в качестве базового каталога для подкаталогов, в которых сохраняются и становятся доступными динамически созданные файлы.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод устанавливает <xref:System.AppDomainSetup.DynamicBase%2A> свойство внутренней <xref:System.AppDomainSetup> связанного с данным экземпляром.  
  
   
  
## Examples  
 Этот метод устарел и не должен использоваться для разработки новых приложений. В следующем примере показано использование альтернативы устаревшему типу <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> свойство. Объяснение этого примера см. в разделе <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> свойство или <xref:System.AppDomain.DynamicDirectory%2A> свойства.  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="P:System.AppDomainSetup.DynamicBase" />
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalPolicy">
      <MemberSignature Language="C#" Value="public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPrincipalPolicy (policy As PrincipalPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPrincipalPolicy(System::Security::Principal::PrincipalPolicy policy);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Principal.PrincipalPolicy" />
      </Parameters>
      <Docs>
        <param name="policy">Одно из значений <see cref="T:System.Security.Principal.PrincipalPolicy" />, определяющее тип объекта-участника, который необходимо подключить к потоку.</param>
        <summary>Указывает, как участники и объекты удостоверений должны присоединяться к потоку, если поток пытается выполнить привязку к участнику при выполнении в этом домене приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Установка этого значения будут действовать только при выборе перед использованием <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> свойство. Например, если задать <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> для данного участника (например, универсального участника), а затем с помощью <xref:System.AppDomain.SetPrincipalPolicy%2A> метод, чтобы задать <xref:System.Security.Principal.PrincipalPolicy> для <xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>, текущий участник будет по-прежнему универсального участника.  
  
   
  
## Examples  
 В следующем примере показано влияние на потоков с помощью <xref:System.AppDomain.SetPrincipalPolicy%2A> метод, чтобы изменить основной политики домена приложения. Он также показывает эффект от использования <xref:System.AppDomain.SetThreadPrincipal%2A> метод, чтобы изменить участника, который доступен для присоединения к потокам в домене приложения.  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности управления объектом-участником. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyFiles">
      <MemberSignature Language="C#" Value="public void SetShadowCopyFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyFiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetShadowCopyFiles();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyFiles")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Включает теневое копирование.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о теневом копировании см. в разделе [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
   
  
## Examples  
 Этот метод устарел и не должен использоваться для разработки новых приложений.  
  
 [!code-cpp[adproperties#1](~/samples/snippets/cpp/VS_Snippets_CLR/adproperties/CPP/adproperties.cpp#1)]
 [!code-csharp[adproperties#1](~/samples/snippets/csharp/VS_Snippets_CLR/adproperties/CS/adproperties.cs#1)]
 [!code-vb[adproperties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/adproperties/VB/adproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyPath">
      <MemberSignature Language="C#" Value="public void SetShadowCopyPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowCopyPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyPath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetShadowCopyPath(System::String ^ path);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetShadowCopyPath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Список имен каталогов, разделенных точкой с запятой.</param>
        <summary>Устанавливает заданный путь каталога в качестве места для теневого копирования сборок.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию теневая копия включает все сборки, найденные в процессе поиска. <xref:System.AppDomain.SetShadowCopyPath%2A> Метод ограничивает теневого копирования сборок в каталогах, указанных в `path`.  
  
 <xref:System.AppDomain.SetShadowCopyPath%2A> Метод не задает дополнительные каталоги для поиска сборок. Для теневого копирования сборок уже должен находиться в пути поиска, например в разделе <xref:System.AppDomain.BaseDirectory%2A>. <xref:System.AppDomain.SetShadowCopyPath%2A> Метод указывает, какие пути поиска, имеют право быть теневого копирования.  
  
 Этот метод устанавливает <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> свойство внутренней <xref:System.AppDomainSetup> связанного с данным экземпляром.  
  
 Дополнительные сведения о теневом копировании см. в разделе [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
   
  
## Examples  
 Этот метод устарел и не должен использоваться для разработки новых приложений.  
  
 [!code-cpp[ADShadowCopy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADShadowCopy/CPP/adshadowcopy.cpp#1)]
 [!code-csharp[ADShadowCopy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADShadowCopy/CS/adshadowcopy.cs#1)]
 [!code-vb[ADShadowCopy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADShadowCopy/VB/adshadowcopy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetThreadPrincipal">
      <MemberSignature Language="C#" Value="public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetThreadPrincipal (principal As IPrincipal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetThreadPrincipal(System::Security::Principal::IPrincipal ^ principal);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Principal.IPrincipal" />
      </Parameters>
      <Docs>
        <param name="principal">Объект-участник, который необходимо подключить к потоку.</param>
        <summary>Задает объект-участник по умолчанию, который необходимо присоединять к потокам, в случае если они пытаются выполнить привязку к объекту-участнику во время выполнения в этом домене приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере показано применение <xref:System.AppDomain.SetThreadPrincipal%2A> метод, чтобы изменить участника, который доступен для присоединения потоками, выполняющимися в домене приложения. Здесь также показано влияние на потоков с помощью <xref:System.AppDomain.SetPrincipalPolicy%2A> метод, чтобы изменить основной политики домена приложения.  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="principal" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">Установленный объект-участник потока.</exception>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности управления объектом-участником. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
    <Member MemberName="SetupInformation">
      <MemberSignature Language="C#" Value="public AppDomainSetup SetupInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainSetup SetupInformation" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.SetupInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SetupInformation As AppDomainSetup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainSetup ^ SetupInformation { AppDomainSetup ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainSetup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает сведения о конфигурации домена приложения для этого экземпляра.</summary>
        <value>Сведения об инициализации домена приложения.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public bool ShadowCopyFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShadowCopyFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShadowCopyFiles { bool get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает указание на то, настроен ли домен приложения для теневого копирования файлов.</summary>
        <value>
          Значение <see langword="true" />, если домен приложения настроен для теневого копирования файлов; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения см. в разделе <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> и [теневое копирование сборок](~/docs/framework/app-domains/shadow-copy-assemblies.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Предпринята попытка выполнения операции с выгруженным доменом приложения.</exception>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _AppDomain.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = _AppDomain::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid">Зарезервировано для будущего использования. Должно быть равным IID_NULL.</param>
        <param name="rgszNames">Переданный массив имен, которые необходимо сопоставить.</param>
        <param name="cNames">Количество сопоставляемых имен.</param>
        <param name="lcid">Контекст языкового стандарта для интерпретации имен.</param>
        <param name="rgDispId">Массив, зарезервированный вызывающим объектом, куда помещаются идентификаторы, соответствующие именам.</param>
        <summary>Сопоставляет набор имен соответствующему набору идентификаторов диспетчеризации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::GetIDsOfNames`, см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _AppDomain.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = _AppDomain::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo">Возвращаемые сведения о типе.</param>
        <param name="lcid">Идентификатор языкового стандарта для сведений о типе.</param>
        <param name="ppTInfo">Получает указатель на объект с запрошенными сведениями о типе.</param>
        <summary>Возвращает сведения о типе объекта, которые затем могут использоваться для получения сведений о типе интерфейса.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::GetTypeInfo`, см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _AppDomain.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = _AppDomain::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo">Указатель, по которому записывается число предоставляемых объектом интерфейсов, предназначенных для получения сведений о типе.</param>
        <summary>Возвращает количество предоставляемых объектом интерфейсов для доступа к сведениям о типе (0 или 1).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::GetTypeInfoCount`, см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.Invoke">
      <MemberSignature Language="C#" Value="void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _AppDomain.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = _AppDomain::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid&amp;" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember">Идентифицирует член.</param>
        <param name="riid">Зарезервировано для будущего использования. Должно быть равным IID_NULL.</param>
        <param name="lcid">Контекст языкового стандарта, в котором следует интерпретировать аргументы.</param>
        <param name="wFlags">Флаги, описывающие контекст вызова.</param>
        <param name="pDispParams">Указатель на структуру, содержащую массив аргументов, массив DISPID для именованных аргументов, а также счетчики количества элементов в массивах.</param>
        <param name="pVarResult">Указатель, по которому будет сохранен результат.</param>
        <param name="pExcepInfo">Указатель на структуру, содержащую сведения об исключении.</param>
        <param name="puArgErr">Индекс первого аргумента, вызвавшего ошибку.</param>
        <summary>Предоставляет доступ к открытым свойствам и методам объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод предназначен для обеспечения доступа к управляемым классам из неуправляемого кода и не должен вызываться из управляемого кода. Дополнительные сведения о `IDispatch::Invoke`, см. в библиотеке MSDN.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">Доступ с поздним связыванием с помощью COM-интерфейса <c>IDispatch</c> не поддерживается.</exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает строку, включающую понятное имя домена приложения и политики контекста.</summary>
        <returns>Строка, полученная путем сцепления литеральной строки "Name:", понятного имени домена приложения и либо строкового представления политик контекста, либо строки "Политики контекста отсутствуют".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере кода отображается значение, возвращаемое <xref:System.AppDomain.ToString%2A> метод.  
  
 [!code-cpp[ADToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADToString/CPP/adtostring.cpp#1)]
 [!code-csharp[ADToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADToString/CS/adtostring.cs#1)]
 [!code-vb[ADToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADToString/VB/adtostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException">Домен приложения, представленный текущим <see cref="T:System.AppDomain" />, выгружен.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler TypeResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler TypeResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.TypeResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TypeResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ TypeResolve;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.TypeResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, когда разрешении типа завершается неудачей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.AppDomain.TypeResolve> Событие происходит, когда общеязыковая среда выполнения не удается определить сборку, можно создать требуемый тип. Это может произойти, если тип определен в динамической сборке или тип не определен в динамической сборке, но среда выполнения не знает, какой тип определен в сборке. Последнее может случиться при <xref:System.Type.GetType%2A?displayProperty=nameWithType> вызывается с именем типа, которое не содержит полное имя сборки.  
  
 <xref:System.ResolveEventHandler> Для этого события может попытаться найти и создать тип.  
  
 Тем не менее <xref:System.AppDomain.TypeResolve> событие не происходит, если среда выполнения знает, что невозможно найти тип в определенных сборок. Например это событие не происходит, если тип не найден в статической сборке, так как среда выполнения знает, что нельзя динамически добавлять типы в статические сборки.  
  
 Начиная с версии [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> свойство содержит сборку, которая запрошенный тип. Дополнительные сведения см. в разделе <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.  
  
 Чтобы зарегистрировать обработчик событий для этого события, необходимо иметь необходимые разрешения, или <xref:System.Security.SecurityException> возникает исключение.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
   
  
## Examples  
 В следующем образце показано <xref:System.AppDomain.TypeResolve> событий.  
  
 Для этого примера кода необходимо указать полное имя сборки. Сведения о том, как получить полное имя сборки см. в разделе [имена сборок](~/docs/framework/app-domains/assembly-names.md).  
  
 [!code-cpp[AppDomain_TypeResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_TypeResolve/CPP/typeresolve.cpp#1)]
 [!code-csharp[AppDomain_TypeResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_TypeResolve/CS/typeresolve.cs#1)]
 [!code-vb[AppDomain_TypeResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_TypeResolve/VB/typeresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.UnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledException As UnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event UnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.UnhandledException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Происходит, если выброшенное исключение остается не перехваченным.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие предоставляет уведомление о неперехваченных исключений. Это позволяет приложению записать в журнал сведения об исключении, прежде чем обработчик по умолчанию система выдает исключение для пользователя и завершает работу приложения. Если доступно достаточно сведений о состоянии приложения, можно выполнить другие действия, такие как сохранение данных программы для последующего восстановления. Следует соблюдать осторожность, так как данные программы могут быть повреждены, если исключение не обработано.  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1, завершение приложения и параметры отладки отображаются для пользователя перед вызовом данного события, а не после.  
  
 Это событие можно обрабатывать в любом домене приложения. Тем не менее событие не происходит обязательно в домене приложения, где произошло исключение. Исключение не обрабатывается, только в том случае, если всего стека для потока не находит обработчик, поэтому первым делом событие может возникать в домене приложения, где происходит поток был очищен.  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1 это событие возникает только для домена приложения по умолчанию, который создается системой при запуске приложения. Если приложение создает дополнительные домены приложений, указывается делегат для этого события в этих доменах приложений не оказывает влияния.  
  
 Если <xref:System.AppDomain.UnhandledException> событие обрабатывается в домене приложения по умолчанию, оно генерируется там для любого необработанное исключение в любом потоке, независимо от того, какой домен приложения запущен в поток. Если поток запущен в домене приложения, который имеет обработчик событий для <xref:System.AppDomain.UnhandledException>, это событие возникает в этом домене приложения. Если этот домен не по умолчанию домен приложения, и есть обработчик событий в домене приложения по умолчанию, событие возникает в обоих доменах приложений.  
  
 Например предположим, что поток запускается в домен приложения «AD1», вызывает метод в домене приложения «AD2» и оттуда вызывает метод в домене приложения «AD3», где возникает исключение. Первый домен приложения, в котором <xref:System.AppDomain.UnhandledException> событие может возникнуть — «AD1». Если этот домен не по умолчанию домен приложения, можно также вызывать событие в домене приложения по умолчанию.  
  
> [!NOTE]
>  Общеязыковая среда выполнения приостанавливает прерывания потока при обработчики событий для <xref:System.AppDomain.UnhandledException> выполнении события.  
  
 Если обработчик событий имеет <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> атрибут с соответствующими флагами, обработчик событий будет считаться области ограниченного выполнения.  
  
 Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], это событие не создается для исключения, привести к повреждению состояния процесса, таких как переполнение стека или нарушение прав доступа, если обработчик событий с точки зрения безопасности и не имеет <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> атрибута.  
  
 В .NET Framework версий 1.0 и 1.1 необработанное исключение, возникающее в потоке, отличном от основного потока приложения, перехватывается средой выполнения и таким образом, не приводит к завершению работы приложения. Таким образом, существует возможность <xref:System.AppDomain.UnhandledException> событие без завершения приложения. Начиная с .NET Framework версии 2.0, эта поддержка необработанных исключений в дочерних потоках удалена, поскольку Суммарный эффект таких сбоев автоматической включены снижение производительности, повреждение данных и блокировки, которые трудно Отладка. Дополнительные сведения, включая список случаев, в которых среда выполнения не будет завершен, в разделе [исключения в управляемых потоках](~/docs/standard/threading/exceptions-in-managed-threads.md).  
  
 Чтобы зарегистрировать обработчик событий для этого события, необходимо иметь необходимые разрешения, или <xref:System.Security.SecurityException> возникает исключение.  
  
 Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
## <a name="other-events-for-unhandled-exceptions"></a>Другие события для необработанных исключений  
 Для некоторых моделей приложений, <xref:System.AppDomain.UnhandledException> событие возможность прерывания в другие события при возникновении необработанного исключения в основной поток приложения.  
  
 В приложениях, использующих Windows Forms, необработанных исключений в причина потока основного приложения <xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType> вызова события. Если это событие обрабатывается, поведение по умолчанию является что необработанное исключение вышел из приложения, несмотря на то, что приложение остается в неизвестном состоянии. В этом случае <xref:System.AppDomain.UnhandledException> событие не происходит. Это поведение можно изменить с помощью файла конфигурации приложения или с помощью <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType> метод, чтобы изменить режим <xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType> перед <xref:System.Windows.Forms.Application.ThreadException> подключить обработчик событий. Это относится только к основного потока приложения. <xref:System.AppDomain.UnhandledException> События для необработанных исключений в других потоках.  
  
 Начиная с Microsoft Visual Studio 2005, приложение Visual Basic .NET framework предоставляет еще одно событие для необработанных исключений в основном потоке приложения. В разделе <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType> событий. Это событие имеет объект аргументов события с тем же именем, как объект аргументы события, используемые <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>, но с разными свойствами. В частности, этот объект аргументы событий имеет <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> свойство, которое позволяет приложению продолжать выполнение, необработанное исключение игнорируется (и так как приложение в неизвестном состоянии). В этом случае <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> событие не происходит.  
  
   
  
## Examples  
 Демонстрирует используется <xref:System.AppDomain.UnhandledException> событий. Он определяет обработчик событий `MyHandler`, который вызывается, когда необработанное исключение в домене приложения по умолчанию. Затем он создает два исключения. Первым обрабатывается **try/catch** блока. Второй не обрабатывается и вызывает `MyHandle` подпрограммы перед завершением работы приложения.  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public static void Unload (AppDomain domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unload(class System.AppDomain domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Unload(System.AppDomain)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unload (domain As AppDomain)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unload(AppDomain ^ domain);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
      </Parameters>
      <Docs>
        <param name="domain">Домен приложения, который нужно выгрузить.</param>
        <summary>Выгружает заданный домен приложения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В .NET Framework версии 2.0 имеется поток для выгрузки доменов приложений. Это повышает надежность, особенно в том случае, если платформа .NET Framework размещается. Если поток вызывает <xref:System.AppDomain.Unload%2A>, целевой домен помечен для выгрузки. Выделенный поток пытается выгрузить домен и все потоки в домене, которые были прерваны. Если поток не будет прерываться, например из-за выполнения неуправляемого кода или выполнения `finally` блока, то после определенного периода времени <xref:System.CannotUnloadAppDomainException> исключение в потоке, который изначально вызвал <xref:System.AppDomain.Unload%2A>. Если поток, который не будет прерван в конечном итоге завершается, целевой домен не выгружается. Таким образом, в .NET Framework версии 2.0 `domain` не гарантируется выгрузить, поскольку может быть невозможно завершить работу выполняющихся потоков.  
  
> [!NOTE]
>  В некоторых случаях вызов <xref:System.AppDomain.Unload%2A> вызывает немедленный <xref:System.CannotUnloadAppDomainException>, например если он вызывается в методе завершения.  
  
 Потоки в `domain` завершаются с помощью <xref:System.Threading.Thread.Abort%2A> метод, который вызывает <xref:System.Threading.ThreadAbortException> в потоке. Несмотря на то, что поток должен завершаться быстро, он может занимать непредсказуемое количество времени в `finally` предложения.  
  
## <a name="version-compatibility"></a>Совместимость версий  
 В .NET Framework версий 1.0 и 1.1, если поток, который вызывает <xref:System.AppDomain.Unload%2A> работает в `domain`, другой поток запускается для выполнения операции выгрузки. Если `domain` не может быть выгружен, <xref:System.CannotUnloadAppDomainException> исключение в этом потоке не в исходный поток, который вызвал <xref:System.AppDomain.Unload%2A>. Тем не менее если поток, вызывающий <xref:System.AppDomain.Unload%2A> выполняется вне `domain`, что поток получает исключение.  
  
   
  
## Examples  
 В следующем примере кода показано, как выгрузить домен приложения.  
  
 [!code-cpp[ADUnload#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADUnload/CPP/adunload.cpp#1)]
 [!code-csharp[ADUnload#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADUnload/CS/adunload.cs#1)]
 [!code-vb[ADUnload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADUnload/VB/adunload.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="domain" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.CannotUnloadAppDomainException">
          Домен, определенный параметром <paramref name="domain" />, не может быть выгружен.</exception>
        <exception cref="T:System.Exception">Во время выполнения выгрузки произошла ошибка.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">Чтобы добавить обработчик событий для этого события. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />. Действие по обеспечению безопасности: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</permission>
      </Docs>
    </Member>
  </Members>
</Type>