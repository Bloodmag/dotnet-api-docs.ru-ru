<Type Name="Console" FullName="System.Console">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b006f3d9b207ce1cfdf984f93be8c753b8e073cc" />
    <Meta Name="ms.sourcegitcommit" Value="058bfa0b75b777d3171411d35da8f11617fc06b0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="05/04/2018" />
    <Meta Name="ms.locfileid" Value="33659647" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Console" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed Console extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Console" />
  <TypeSignature Language="VB.NET" Value="Public Class Console" />
  <TypeSignature Language="C++ CLI" Value="public ref class Console abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Console</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Предоставляет стандартные потоки для консольных приложений: входной, выходной и поток сообщений об ошибках. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Консоль является окном операционной системы, в котором пользователи взаимодействуют с операционной системой или с помощью текстовых консольного приложения путем набора текстового ввода с клавиатуры и чтения текстового вывода с экрана компьютера. Например в операционной системе Windows консоль называется окно командной строки и принимает команды MS-DOS. <xref:System.Console> Класс обеспечивает базовую поддержку для приложений, чтение знаков из и записи их на консоль.  
  
 Дополнительные сведения о разработке с помощью <xref:System.Console> класса, в следующих разделах:  
  
-   [Потоки ввода-вывода консоли](#Streams)  
  
-   [Буфер экрана и окно консоли](#Buffer)  
  
-   [Поддержка Юникода для консоли](#Unicode)  
  
-   [Стандартные операции](#Operations)  
  
-   [Заметки о .NET core](#Core)  
  
<a name="Streams"></a>   
## <a name="console-io-streams"></a>Потоки ввода-вывода консоли  
 При запуске консольного приложения, операционная система автоматически связывает три потока ввода-вывода с помощью консоли: стандартный входной поток, в стандартный выходной поток и в стандартный поток вывода ошибок. Приложение может считывать пользовательский ввод из стандартного входного потока; Запишите данные в стандартный выходной поток; и запись данных об ошибках в стандартный поток вывода ошибок. Эти потоки представлены в приложении в качестве значения <xref:System.Console.In%2A?displayProperty=nameWithType>, <xref:System.Console.Out%2A?displayProperty=nameWithType>, и <xref:System.Console.Error%2A?displayProperty=nameWithType> свойства.  
  
 По умолчанию значение <xref:System.Console.In%2A> свойство <xref:System.IO.TextReader?displayProperty=nameWithType> , представляющий клавиатуры и значения <xref:System.Console.Out%2A> и <xref:System.Console.Error%2A> свойства <xref:System.IO.TextWriter?displayProperty=nameWithType> объекты, представляющие окна консоли. Тем не менее эти свойства можно задать в потоки, которые не представляют окна консоли или клавиатуры; Например эти свойства можно задать в потоки, которые представляют файлы. Чтобы перенаправить стандартный ввод, стандартный вывод или стандартный поток ошибок, вызовите <xref:System.Console.SetIn%2A?displayProperty=nameWithType>, <xref:System.Console.SetOut%2A?displayProperty=nameWithType>, или <xref:System.Console.SetError%2A?displayProperty=nameWithType> метода, соответственно. Операции ввода-вывода, которые используют эти потоки синхронизируются, что означает, что несколько потоков чтения или записи данных в потоки. Это означает, что методы, которые обычно асинхронно, такие как <xref:System.IO.TextReader.ReadLineAsync%2A?displayProperty=nameWithType>, выполняются синхронно, если объект представляет поток консоли.  
  
> [!NOTE]
>  Не используйте <xref:System.Console> класса для отображения вывода в автоматической установки приложений, таких как сервер приложений. Вызовы методов, например <xref:System.Console.Write%2A?displayProperty=nameWithType> и <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> не оказывают влияния в приложений графического пользовательского интерфейса.  
  
 <xref:System.Console> члены класса, которые нормально работать при основной поток направляется на консоль может создания исключения, если поток перенаправлен, например, в файл. В приложениях для перехвата <xref:System.IO.IOException?displayProperty=nameWithType> исключения, если можно перенаправлять стандартный поток. Можно также использовать <xref:System.Console.IsOutputRedirected%2A>, <xref:System.Console.IsInputRedirected%2A>, и <xref:System.Console.IsErrorRedirected%2A> свойства, чтобы определить, перенаправляется ли перед выполнением операции, которая создает стандартный поток <xref:System.IO.IOException?displayProperty=nameWithType> исключение.  
  
 Иногда бывает удобно для явного вызова членов объектов потока, представленный <xref:System.Console.In%2A>, <xref:System.Console.Out%2A>, и <xref:System.Console.Error%2A> свойства. Например, по умолчанию <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> метод считывает входные данные из стандартного входного потока. Аналогичным образом <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> метод записывает данные в стандартный выходной поток данных следуют строки по умолчанию завершения, который является символом возврата каретки и перевода строки («\r\n»). Тем не менее <xref:System.Console> класс не предоставляет соответствующего метода для записи данных в стандартный выходной поток ошибок или свойства для изменения признака конца строки для данных, записанных в поток.  
  
 Эти проблемы можно устранить, установив <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> свойство <xref:System.Console.Out%2A> или <xref:System.Console.Error%2A> свойства другого признака конца строки. Например следующая инструкция C# устанавливает завершения строки, в стандартный выходной поток ошибок для двух символы возврата каретки и перевода последовательности строки:  
  
 `Console.Error.NewLine = "\r\n\r\n";`  
  
 Затем можно явным образом вызвать <xref:System.IO.TextWriter.WriteLine%2A> метод объекта error выходной поток, как в следующей инструкции C#:  
  
 `Console.Error.WriteLine();`  
  
<a name="Buffer"></a>   
## <a name="screen-buffer-and-console-window"></a>Буфер экрана и окно консоли  
 Два тесно связанных функций консоли являются буфер экрана и окно консоли. Текст фактически считывается или записывается в потоки, принадлежащие консоли, но могут быть чтение и запись данных в область, принадлежащие консоли, называемой буфера экрана. Буфер экрана является атрибутом консоли и организованы в виде прямоугольной сетки строк и столбцов, где каждый пересечения сетки или символьной ячейке содержит один символ. Каждый символ имеет собственный цвет, а каждая ячейка символ имеет собственный цвет фона.  
  
 Буфера экрана просматривается через прямоугольную область, называемую в окне консоли. В окне консоли является еще одним атрибутом консоли; Это не сама консоль, которая является окном операционной системы. В окне консоли организованы в строки и столбцы, меньше или равен размеру буфера экрана и могут выполняться в виде буфера экрана. Если буфер экрана больше, чем в окне консоли, автоматически отображаются полосы прокрутки, в окне консоли может быть перемещен за буферной области экрана.  
  
 Курсор указывает позицию буфера экрана, где в настоящее время чтения или записи текста. Курсор можно скрывать или делать видимыми, а его высота можно изменить. Если курсор видим, положение окна консоли перемещается автоматически, чтобы он всегда в представлении.  
  
 Точку отсчета для координаты ячейки символов в буфере экрана является верхний левый угол и положение курсора и окна консоли измеряется относительно этого начала координат. Отсчитываемый от нуля индексов используйте для указания позиции; Таким образом можно определить самая верхняя строка как строки и крайний слева столбец как столбец 0. Максимальное значение для индексы строки и столбца — <xref:System.Int16.MaxValue?displayProperty=nameWithType>.  
  
<a name="Unicode"></a>   
## <a name="unicode-support-for-the-console"></a>Поддержка Юникода для консоли  
 В общем случае консоль считывает входные данные и записывает выходные данные с помощью текущей кодовой странице консоли, который определяет язык системы по умолчанию. Кодовая страница может обрабатывать только подмножество доступных символов Юникода, поэтому при попытке отображения символов, которые не сопоставлены с конкретной кодовой страницы, консоль не будет возможность отобразить все символы или неточно представлять. Приведенный ниже пример иллюстрирует данную проблему. Он пытается отображать символы кириллицы алфавита от U + 0410 U + 044F на консоль. При запуске примера в системе, которая использует консоль кодовую страницу 437 каждый символ заменяется знак вопроса (?), так как символы в кодовой странице 437 не сопоставляются символы кириллицы.  
  
 [!code-csharp[System.Console.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/unicode1.cs#1)]
 [!code-vb[System.Console.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/unicode1.vb#1)]  
  
 Помимо поддержки кодовых страниц, <xref:System.Console> с кодировкой UTF-8 поддерживает класс <xref:System.Text.UTF8Encoding> класса. Начиная с .NET Framework 4.5 <xref:System.Console> класс также поддерживает с кодировкой UTF-16 <xref:System.Text.UnicodeEncoding> класса. Для отображения символов Юникода в консоль. задать <xref:System.Console.OutputEncoding%2A> значение <xref:System.Text.UTF8Encoding> или <xref:System.Text.UnicodeEncoding>.  
  
 Поддержка символов Юникода требует кодировщик распознавать определенный символ Юникода, а также требует шрифта с глифы, необходимые для подготовки к просмотру этим символом. Чтобы успешно отобразить символов Юникода в консоль, шрифта консоли должно быть присвоено не растровых или как Consolas в качестве используемого или Lucida Console шрифтом TrueType. В следующем примере показано, как можно программно изменить шрифт из растровый шрифт для Lucida Console.  
  
 [!code-csharp[System.Console.Class.Unsafe#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class.unsafe/cs/setfont1.cs#3)]
 [!code-vb[System.Console.Class.Unsafe#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class.unsafe/vb/setfont1.vb#3)]  
  
 Тем не менее шрифты TrueType можно отобразить только подмножество глифов. Например шрифт Lucida Console отображает только 643 из примерно 64 000 доступны символы от U + 0021 до U + FB02. Чтобы увидеть, что символы определенного шрифта поддерживает, откройте **шрифты** панели управления выберите **поиска символа** и выберите шрифт, чьи кодировки, вы хотите подробно ** Шрифт** список **символов** окна.  
  
 Windows использует связь шрифтов для отображения глифов, которые недоступны в определенном шрифте. Сведения о связь, чтобы отобразить дополнительные наборы знаков шрифтов, в разделе [Глобализация шаг за шагом: шрифты](http://go.microsoft.com/fwlink/?LinkId=229111). В подразделе реестра HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\FontLink\SystemLink определяются связанных шрифтов. Каждый элемент, связанный с этого подраздела соответствует имени базового шрифта и его значение — массив строк, определяющий файлы шрифтов и шрифты, которые связаны с базового шрифта. Каждый элемент массива определяет связанный шрифта и принимает форму *файл шрифт*,*имя шрифта*. В следующем примере показано, как программным образом можно определить связанный шрифта SimSun найден в файле шрифта simsun.ttc, отображающий упрощенный Хан символов с именем.  
  
 [!code-csharp[System.Console.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/fontlink1.cs#2)]
 [!code-vb[System.Console.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/fontlink1.vb#2)]  
  
 Поддержка Юникода для консоли имеет следующие ограничения:  
  
-   Кодировка UTF-32, не поддерживается. Поддерживаются только Юникод, кодировки UTF-8 и UTF-16, представляются <xref:System.Text.UTF8Encoding> и <xref:System.Text.UnicodeEncoding> классов, соответственно.  
  
-   Двунаправленный вывода не поддерживается.  
  
-   Отображение символов вне основное многоязычное поле (т. е суррогатных пар) не поддерживается, даже если они определены в файле связанных шрифтов.  
  
-   Отображение символов в сложных сценариях не поддерживается.  
  
-   Объединение последовательностей символов (то есть символы, состоящие из базового символа и одного или более несамостоятельных знаков) отображаются в виде отдельных символов. Чтобы обойти это ограничение, вы можете нормализовать строка, отображаемая, вызвав <xref:System.String.Normalize%2A?displayProperty=nameWithType> метод перед отправкой вывод на консоль. В следующем примере строка, содержащая символ объединения последовательности 0061 U + U + 0308 выводится на консоль, как два символа, прежде чем выходную строку нормализован и как один символ после <xref:System.String.Normalize%2A?displayProperty=nameWithType> вызывается метод.  
  
     [!code-csharp[System.Console.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/normalize1.cs#5)]
     [!code-vb[System.Console.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/normalize1.vb#5)]  
  
     Обратите внимание, что нормализации хорошим решением только в том случае, если последовательность символов в стандарте для составными форму, которая соответствует конкретным combining содержит символ Юникода.  
  
-   Если шрифт предоставляет глиф кодовой точки в частной области, будет отображаться Этот глиф. Тем не менее поскольку символы в поле частным зависят от приложения, это может оказаться ожидаемый глифа.  
  
 Следующий пример отображает диапазон знаков Юникода, в консоли. Пример принимает три параметра командной строки: начало диапазона для отображения конца диапазона для отображения и следует ли применять кодирование текущей консоли (`false`) или кодировку UTF-16 (`true`). Предполагается, что консоль использует является шрифтом TrueType.  
  
 [!code-csharp[System.Console.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.class/cs/example3.cs#4)]
 [!code-vb[System.Console.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.class/vb/example3.vb#4)]  
  
<a name="Operations"></a>   
## <a name="common-operations"></a>Стандартные операции  
 <xref:System.Console> Класс содержит следующие методы для записи выходных данных консоли и чтения ввод данных на консоли:  
  
-   Перегруженные версии <xref:System.Console.ReadKey%2A> метод считывать отдельному символу.  
  
-   <xref:System.Console.ReadLine%2A> Метод считывает строку входных данных.  
  
-   <xref:System.Console.Write%2A> Перегрузки метода преобразования экземпляра типа значения, массив символов или набор объектов в форматированном или неформатированном виде строку и затем написать эту строку на консоль.  
  
-   Набор параллельного <xref:System.Console.WriteLine%2A> выходные данные, то строка как перегрузки метода <xref:System.Console.Write%2A> перегрузки метода, но также добавить признака конца строки.  
  
 <xref:System.Console> Класс также содержит методы и свойства для выполнения следующих операций:  
  
-   Возвращает или задает размер буфера экрана. <xref:System.Console.BufferHeight%2A> И <xref:System.Console.BufferWidth%2A> свойства позволяют получить или задать буфера высоты и ширины, соответственно и <xref:System.Console.SetBufferSize%2A> позволяет задать размер буфера в одном вызове метода.  
  
-   Возвращает или задает размер окна консоли. <xref:System.Console.WindowHeight%2A> И <xref:System.Console.WindowWidth%2A> свойства позволяют получить или задать ширину и высоту окна соответственно и <xref:System.Console.SetWindowSize%2A> метод позволяет задать минимальный размер окна в одном вызове метода.  
  
-   Возвращает или задает размер курсора. <xref:System.Console.CursorSize%2A> Указывает высоту курсора в символьной ячейке.  
  
-   Возвращает или задает позицию окна консоли относительно буфера экрана. <xref:System.Console.WindowTop%2A> И <xref:System.Console.WindowLeft%2A> свойства позволяют получить или задать верхняя строка и крайний слева столбец буфера экрана, который отображается в окне консоли, и <xref:System.Console.SetWindowPosition%2A> метод позволяет задавать эти значения в одном вызове метода.  
  
-   Возвращает или задает положение курсора путем получения или установки <xref:System.Console.CursorTop%2A> и <xref:System.Console.CursorLeft%2A> свойства или набора позицию курсора путем вызова <xref:System.Console.SetCursorPosition%2A> метод.  
  
-   Переместить или удалить данные в буфере экрана путем вызова <xref:System.Console.MoveBufferArea%2A> или <xref:System.Console.Clear%2A> метод.  
  
-   Получить или задать цвета фона и текста с помощью <xref:System.Console.ForegroundColor%2A> и <xref:System.Console.BackgroundColor%2A> свойства, или восстановить их по умолчанию цвета фона и переднего плана путем вызова <xref:System.Console.ResetColor%2A> метод.  
  
-   Воспроизвести звуковой сигнал через динамик консоли вызывая <xref:System.Console.Beep%2A> метод.  
  
<a name="Core"></a>   
## <a name="includenetcoreincludesnet-core-mdmd-notes"></a>[!INCLUDE[net_core](~/includes/net-core-md.md)] Примечания  
 В платформе .NET Framework, на рабочем столе <xref:System.Console> класс использует кодировку, возвращенных `GetConsoleCP` и `GetConsoleOutputCP`, который обычно является кодовой страницы кодировки. Например, в системах с языком и региональными параметрами является английский (США), кодовую страницу 437 приведен кодировку, используемую по умолчанию. Тем не менее [!INCLUDE[net_core](~/includes/net-core-md.md)] может сделать доступными только ограниченный набор кодировок. Если это так, <xref:System.Text.Encoding.UTF8%2A?displayProperty=nameWithType> используется в качестве кодировки по умолчанию для консоли.  
  
 Если приложение зависит от конкретного кода кодировок страниц, вы по-прежнему их можно сделать доступными, выполнив указанные ниже *перед* вызова любых <xref:System.Console> методов:  
  
1.  Добавьте ссылку на сборку System.Text.Encoding.CodePages.dll в проект.  
  
2.  Получить <xref:System.Text.EncodingProvider> объекта из <xref:System.Text.CodePagesEncodingProvider.Instance%2A?displayProperty=nameWithType> свойство.  
  
3.  Передайте <xref:System.Text.EncodingProvider> объект <xref:System.Text.Encoding.RegisterProvider%2A?displayProperty=nameWithType> метод для установки дополнительных кодировок, поддерживаемых поставщиком кодировки доступен.  
  
 <xref:System.Console> Класса будет автоматически использовать кодировку системы по умолчанию вместо UTF-8, при условии, что вы зарегистрировали кодировки поставщика перед вызовом любого <xref:System.Console> методов вывода.  
  
   
  
## Examples  
 Следующий пример демонстрирует считывания данных и записи данных в стандартных входных и выходных потоков. Обратите внимание, что эти потоки можно перенаправить с помощью <xref:System.Console.SetIn%2A> и <xref:System.Console.SetOut%2A> методы.  
  
 [!code-cpp[Classic Console Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Console Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Console Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Console Example/CS/source.cs#1)]
 [!code-vb[Classic Console Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Console Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Данный тип потокобезопасен.</threadsafe>
  </Docs>
  <Members>
    <Member MemberName="BackgroundColor">
      <MemberSignature Language="C#" Value="public static ConsoleColor BackgroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.ConsoleColor BackgroundColor" />
      <MemberSignature Language="DocId" Value="P:System.Console.BackgroundColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BackgroundColor As ConsoleColor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property ConsoleColor BackgroundColor { ConsoleColor get(); void set(ConsoleColor value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ConsoleColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает цвет фона консоли.</summary>
        <value>Значение из перечисления , задающее фоновый цвет консоли, то есть цвет, на фоне которого выводятся символы. Значением по умолчанию является Black.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Изменение <xref:System.Console.BackgroundColor%2A> свойство затрагивает только выходные данные, записывается на отдельный символ ячейки после изменения цвета фона. Чтобы изменить цвет фона в окне консоли в целом, установите <xref:System.Console.BackgroundColor%2A> свойство и вызвать <xref:System.Console.Clear%2A> метод. Ниже приведен пример.  
  
 [!code-csharp[System.Console.BackgroundColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.backgroundcolor/cs/backgroundcolor1.cs#1)]
 [!code-vb[System.Console.BackgroundColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.backgroundcolor/vb/backgroundcolor1.vb#1)]  
  
 Операция получения для приложения Windows, в котором консоли не существует, возвращает <xref:System.ConsoleColor.Black?displayProperty=nameWithType>.  
  
   
  
## Examples  
 Следующий пример сохраняет значения <xref:System.ConsoleColor> перечисления в массив и сохраняет текущие значения <xref:System.Console.BackgroundColor%2A> и <xref:System.Console.ForegroundColor%2A> свойства к переменным. Затем изменяет цвет переднего плана для каждого цвета в <xref:System.ConsoleColor> перечисление, за исключением того, как цвет, соответствующий текущий фоновый рисунок и он изменяет цвет фона для каждого цвета в <xref:System.ConsoleColor> перечисление, за исключением того, цвет, который соответствует текущий переднего плана. (Если цвет совпадает с цветом фона, текст не отображается.) Наконец, он вызывает <xref:System.Console.ResetColor%2A> метод восстановления исходного цвета консоли.  
  
 [!code-csharp[System.ConsoleColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/foregroundcolor3.cs#1)]
 [!code-vb[System.ConsoleColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/foregroundcolor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Цвет, указанный в операции SET, не является допустимым членом <see cref="T:System.ConsoleColor" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Beep">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Воспроизводит звуковой сигнал через динамик консоли.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Beep() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Beep" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Beep ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Воспроизводит звуковой сигнал через динамик консоли.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию воспроизводит звуковой сигнал с частотой 800 Гц и длительностью 200 миллисекунд.  
  
> [!NOTE]
>  <xref:System.Console.Beep%2A> Метод не поддерживается на 64-разрядные выпуски Windows Vista и Windows XP.  
  
 <xref:System.Console.Beep%2A> Создает оболочку для вызова функции Windows [сигнал функция](https://msdn.microsoft.com/library/windows/desktop/ms679277.aspx). Ли <xref:System.Console.Beep%2A> выводятся звука в версиях Windows до Windows 7, зависит от наличия микросхемой 8254 программируемый интервальный таймер. Начиная с Windows 7, зависят от звуковое устройство по умолчанию.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Console.Beep%2A> метод. В примере, принимает число от 1 до 9 в качестве аргумента командной строки и воспроизводит звуковой сигнал соответствующее количество раз.  
  
 [!code-cpp[console.beep#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.beep/CPP/beep.cpp#1)]
 [!code-csharp[console.beep#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.beep/CS/beep.cs#1)]
 [!code-vb[console.beep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.beep/VB/beep.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.HostProtectionException">Этот метод выполнен на сервере, например SQL Server, который не разрешает доступ к интерфейсу пользователя.</exception>
      </Docs>
    </Member>
    <Member MemberName="Beep">
      <MemberSignature Language="C#" Value="public static void Beep (int frequency, int duration);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Beep(int32 frequency, int32 duration) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Beep(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Beep (frequency As Integer, duration As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Beep(int frequency, int duration);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="frequency" Type="System.Int32" />
        <Parameter Name="duration" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="frequency">Частота сигнала в диапазоне от 37 до 32767 Гц.</param>
        <param name="duration">Длительность сигнала в миллисекундах.</param>
        <summary>Воспроизводит звуковой сигнал заданной частоты и длительности через динамик консоли.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Console.Beep%2A> Создает оболочку для вызова функции Windows [сигнал функция](https://msdn.microsoft.com/library/windows/desktop/ms679277.aspx). Ли <xref:System.Console.Beep%2A> выводятся звука в версиях Windows до Windows 7, зависит от наличия микросхемой 8254 программируемый интервальный таймер. Начиная с Windows 7, зависят от звуковое устройство по умолчанию.  
  
> [!NOTE]
>  <xref:System.Console.Beep%2A> Метод не поддерживается на 64-разрядные выпуски Windows Vista и Windows XP.  
  
   
  
## Examples  
 В этом примере демонстрируется <xref:System.Console.Beep%2A> метод с помощью воспроизведения первого сказать песню через динамик консоли.  
  
 [!code-cpp[console.beep2#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.beep2/CPP/b2.cpp#1)]
 [!code-csharp[console.beep2#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.beep2/CS/b2.cs#1)]
 [!code-vb[console.beep2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.beep2/VB/b2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="frequency" /> меньше 37 или больше 32767 Гц.  
  
 - или -  
  
 <paramref name="duration" /> меньше или равно нулю.</exception>
        <exception cref="T:System.Security.HostProtectionException">Этот метод выполнен на сервере, например SQL Server, который не разрешает доступ к консоли.</exception>
      </Docs>
    </Member>
    <Member MemberName="BufferHeight">
      <MemberSignature Language="C#" Value="public static int BufferHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 BufferHeight" />
      <MemberSignature Language="DocId" Value="P:System.Console.BufferHeight" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BufferHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int BufferHeight { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает высоту буферной области.</summary>
        <value>Текущая высота буферной области в строках.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство определяет количество строк (или строки), сохраненного в буфере, доступ к которому режим окна консоли. Напротив <xref:System.Console.WindowHeight%2A> свойство определяет количество строк, отображаемых в окне консоли в определенный момент времени. Если число фактически записанных в буфер строк превышает количество строк, определенного параметром <xref:System.Console.WindowHeight%2A> свойства, окно может прокручиваться по вертикали, чтобы он отображал непрерывного количества строк, которые равны <xref:System.Console.WindowHeight%2A> свойство и они расположены в любом месте в буфере.  
  
 Если в операции задания уменьшает значение <xref:System.Console.BufferHeight%2A> свойства верхней строки удаляются. Например если от 300 до 250 уменьшается количество строк, от 0 до 49 строки удаляются, а также для существующих строк 50 до 299 становятся линий 0 до 249.  
  
   
  
## Examples  
 В этом примере демонстрируется <xref:System.Console.BufferHeight%2A> и <xref:System.Console.BufferWidth%2A> свойства. Пример сообщает размеры окна операционной системы, задать размер буфера 300 строк и 85 столбцов.  
  
 [!code-cpp[console.bufferHW#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.bufferHW/CPP/hw.cpp#1)]
 [!code-csharp[console.bufferHW#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.bufferHW/CS/hw.cs#1)]
 [!code-vb[console.bufferHW#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.bufferHW/VB/hw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение в операции задания меньше или равно нулю.  
  
 - или -  
  
 Значение в операции задания больше или равно <see cref="F:System.Int16.MaxValue" />.  
  
 - или -  
  
 Значение в операции задания меньше суммы <see cref="P:System.Console.WindowTop" /> + <see cref="P:System.Console.WindowHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="BufferWidth">
      <MemberSignature Language="C#" Value="public static int BufferWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 BufferWidth" />
      <MemberSignature Language="DocId" Value="P:System.Console.BufferWidth" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property BufferWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int BufferWidth { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает ширину буферной области.</summary>
        <value>Текущая ширина буферной области в столбцах.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если в операции задания уменьшает значение <xref:System.Console.BufferWidth%2A> свойства правые столбцы будут удалены. Например если от 80 до 60 уменьшается количество столбцов, столбцы 60 до 79 каждой строки будут удалены.  
  
   
  
## Examples  
 В этом примере демонстрируется <xref:System.Console.BufferHeight%2A> и <xref:System.Console.BufferWidth%2A> свойства. Пример сообщает размеры окна операционной системы, задать размер буфера 300 строк и 85 столбцов.  
  
 [!code-cpp[console.bufferHW#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.bufferHW/CPP/hw.cpp#1)]
 [!code-csharp[console.bufferHW#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.bufferHW/CS/hw.cs#1)]
 [!code-vb[console.bufferHW#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.bufferHW/VB/hw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение в операции задания меньше или равно нулю.  
  
 - или -  
  
 Значение в операции задания больше или равно <see cref="F:System.Int16.MaxValue" />.  
  
 - или -  
  
 Значение в операции задания меньше суммы <see cref="P:System.Console.WindowLeft" /> + <see cref="P:System.Console.WindowWidth" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CancelKeyPress">
      <MemberSignature Language="C#" Value="public static event ConsoleCancelEventHandler CancelKeyPress;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ConsoleCancelEventHandler CancelKeyPress" />
      <MemberSignature Language="DocId" Value="E:System.Console.CancelKeyPress" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event CancelKeyPress As ConsoleCancelEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event ConsoleCancelEventHandler ^ CancelKeyPress;" />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ConsoleCancelEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возникает при одновременном нажатии клавиши-модификатора <see cref="F:System.ConsoleModifiers.Control" /> (Ctrl) и либо клавиши консоли <see cref="F:System.ConsoleKey.C" /> (C), либо клавиши Break (Ctrl+C или Ctrl+Break).</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это событие используется в сочетании с <xref:System.ConsoleCancelEventHandler?displayProperty=nameWithType> и <xref:System.ConsoleCancelEventArgs?displayProperty=nameWithType>. <xref:System.Console.CancelKeyPress> Событий позволяет консольное приложение для перехвата сигнал Ctrl + C, чтобы обработчик событий мог решать, следует ли продолжать выполнение, или завершать работу. Дополнительные сведения об обработке событий см. в разделе [обработка и вызов событий](~/docs/standard/events/index.md).  
  
 Когда пользователь нажимает сочетание клавиш Ctrl + C или Ctrl + Break <xref:System.Console.CancelKeyPress> событие и приложения <xref:System.ConsoleCancelEventHandler> выполняется обработчик событий. Обработчик событий передается <xref:System.ConsoleCancelEventArgs> объекта, имеющего два полезных свойств:  
  
-   <xref:System.ConsoleCancelEventArgs.SpecialKey%2A>, который позволяет определить, был ли вызван обработчик, в результате пользователь, нажав Ctrl + C (значение свойства <xref:System.ConsoleSpecialKey.ControlC?displayProperty=nameWithType>) или Ctrl + Break (значение свойства <xref:System.ConsoleSpecialKey.ControlBreak?displayProperty=nameWithType>).  
  
-   <xref:System.ConsoleCancelEventArgs.Cancel%2A>, который позволяет определить, как в приложение следует ответить пользователю нажав клавиши Ctrl + C или Ctrl + Break. По умолчанию <xref:System.ConsoleCancelEventArgs.Cancel%2A> свойство `false`, какая причины программа выполнения завершение при выходе из обработчика событий. Изменение свойства на `true` указывает, что приложение следует продолжить выполнение.  
  
> [!TIP]
>  Если приложение имеет простой требования, можно использовать <xref:System.Console.TreatControlCAsInput%2A> свойство вместо этого события. Настраивая это свойство `false`, убедитесь, что приложение всегда завершает работу при нажатии клавиш Ctrl + C. Присвойте ему значение `true`, вы можете обеспечить, нажав Ctrl + C не будет прерван приложения.  
  
 Обработчик событий для этого события выполняется в потоке пула потоков.  
  
   
  
## Examples  
 В следующем примере показано, как <xref:System.Console.CancelKeyPress> использовать событие. При нажатии клавиши Ctrl + C, операции чтения прерывается и `myHandler` вызывается обработчик события. После входа в обработчик событий <xref:System.ConsoleCancelEventArgs.Cancel%2A?displayProperty=nameWithType> свойство `false`, что означает, что текущий процесс будет прерван при завершает обработчик события. Тем не менее, задает обработчик событий <xref:System.ConsoleCancelEventArgs.Cancel%2A?displayProperty=nameWithType> свойства `true`, что означает, что процесс не будет прерван и продолжит операцию чтения.  
  
 [!code-cpp[console.cancelkeypress#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cancelkeypress/cpp/ckp.cpp#1)]
 [!code-csharp[console.cancelkeypress#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cancelkeypress/cs/ckp.cs#1)]
 [!code-vb[console.cancelkeypress#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cancelkeypress/vb/ckp.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="T:System.ConsoleCancelEventArgs" />
        <altmember cref="T:System.ConsoleCancelEventHandler" />
        <altmember cref="P:System.Console.TreatControlCAsInput" />
      </Docs>
    </Member>
    <Member MemberName="CapsLock">
      <MemberSignature Language="C#" Value="public static bool CapsLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CapsLock" />
      <MemberSignature Language="DocId" Value="P:System.Console.CapsLock" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CapsLock As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CapsLock { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, включен или отключен режим CAPS LOCK клавиатуры.</summary>
        <value>
          Значение <see langword="true" />, если режим CAPS LOCK включен; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public static void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Clear();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Удаляет из буфера консоли и ее окна отображаемую информацию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 С помощью <xref:System.Console.Clear%2A> метод эквивалентен вызов MS-DOS `cls` команду в окне командной строки. При <xref:System.Console.Clear%2A> вызове метода, курсор автоматически перемещается в левом верхнем углу окна и содержимое буфера экрана задаются в пустые значения, с помощью текущего цветов текста и фона.  
  
> [!NOTE]
>  Попытка вызова <xref:System.Console.Clear%2A> вызывает метод, если консольное приложение Вывод перенаправляется в файл <xref:System.IO.IOException>. Чтобы избежать этого, всегда заключайте вызов <xref:System.Console.Clear%2A> метод в `try`...`catch` блок.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Console.Clear%2A> метод, чтобы удалить консоль перед выполнением цикла, предлагает пользователю выбрать цвет переднего плана и фона и введите строку для отображения. Если пользователь не выйти из программы, восстанавливаются исходные фона и цвета консоли и <xref:System.Console.Clear%2A> метод вызывается повторно до повторного выполнения цикла.  
  
 [!code-csharp[System.Console.Clear#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.clear/cs/clear1.cs#1)]
 [!code-vb[System.Console.Clear#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.clear/vb/clear1.vb#1)]  
  
 Пример использует `GetKeyPress` метод, чтобы проверить сделанного пользователем выбора цвета переднего плана и фона.  
  
 В этом примере демонстрируется <xref:System.Console.CursorLeft%2A> и <xref:System.Console.CursorTop%2A> свойства и <xref:System.Console.SetCursorPosition%2A> и <xref:System.Console.Clear%2A> методы. Примере курсор, который определяет, где произойдет следующая запись, для рисования 5 символов прямоугольником, 5 символов с помощью сочетания «+», «&#124;», и «-» строки. Обратите внимание, что прямоугольник можно нарисовать за меньшее число шагов, используя сочетание других строк.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
      </Docs>
    </Member>
    <Member MemberName="CursorLeft">
      <MemberSignature Language="C#" Value="public static int CursorLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CursorLeft" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorLeft As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CursorLeft { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает позицию столбца курсора в буферной области.</summary>
        <value>Текущая позиция курсора в столбцах.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере демонстрируется <xref:System.Console.CursorLeft%2A> и <xref:System.Console.CursorTop%2A> свойства и <xref:System.Console.SetCursorPosition%2A> и <xref:System.Console.Clear%2A> методы. Примере курсор, который определяет, где произойдет следующая запись, для рисования 5 символов прямоугольником, 5 символов с помощью сочетания «+», «&#124;», и «-» строки. Обратите внимание, что прямоугольник можно нарисовать за меньшее число шагов, используя сочетание других строк.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение в операции задания меньше нуля.  
  
 - или -  
  
 Значение в операции задания больше или равно <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CursorSize">
      <MemberSignature Language="C#" Value="public static int CursorSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CursorSize" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CursorSize { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает высоту курсора в символьной ячейке.</summary>
        <value>Размер курсора, выраженный как процент от высоты символьной ячейки. Данное свойство принимает значения в диапазоне от 1 до 100.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Внешний вид курсора может меняться от горизонтальную линию снизу ячейки, если значение свойства равно 1, для полного заполнения ячейки, когда значение свойства равно 100.  
  
   
  
## Examples  
 В этом примере демонстрируется <xref:System.Console.CursorSize%2A> свойство. В примере увеличивается размер курсора при каждом клавиши консоли нажата, а затем восстанавливает его исходный размер курсор перед завершением работы.  
  
 [!code-cpp[console.cursorsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorsize/CPP/csize.cpp#1)]
 [!code-csharp[console.cursorsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorsize/CS/csize.cs#1)]
 [!code-vb[console.cursorsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorsize/VB/csize.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение, указанное в операции задания, меньше 1 или больше 100.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CursorTop">
      <MemberSignature Language="C#" Value="public static int CursorTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CursorTop" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorTop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorTop As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CursorTop { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает позицию строки курсора в буферной области.</summary>
        <value>Текущая позиция курсора в строках.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере демонстрируется <xref:System.Console.CursorLeft%2A> и <xref:System.Console.CursorTop%2A> свойства и <xref:System.Console.SetCursorPosition%2A> и <xref:System.Console.Clear%2A> методы. Примере курсор, который определяет, где произойдет следующая запись, для рисования 5 символов прямоугольником, 5 символов с помощью сочетания «+», «&#124;», и «-» строки. Обратите внимание, что прямоугольник можно нарисовать за меньшее число шагов, используя сочетание других строк.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение в операции задания меньше нуля.  
  
 - или -  
  
 Значение в операции задания больше или равно <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CursorVisible">
      <MemberSignature Language="C#" Value="public static bool CursorVisible { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool CursorVisible" />
      <MemberSignature Language="DocId" Value="P:System.Console.CursorVisible" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CursorVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool CursorVisible { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, видим ли курсор.</summary>
        <value>
          Значение <see langword="true" />, если курсор видим; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере демонстрируется <xref:System.Console.CursorVisible%2A> свойство. В примере создается курсор видимым, если первый столбец входных данных является знаком «+» или невидимым, если входное значение "-" символов.  
  
 [!code-cpp[console.cursorvis#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorvis/CPP/vis.cpp#1)]
 [!code-csharp[console.cursorvis#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorvis/CS/vis.cs#1)]
 [!code-vb[console.cursorvis#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorvis/VB/vis.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Error">
      <MemberSignature Language="C#" Value="public static System.IO.TextWriter Error { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IO.TextWriter Error" />
      <MemberSignature Language="DocId" Value="P:System.Console.Error" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Error As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::IO::TextWriter ^ Error { System::IO::TextWriter ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает стандартный выходной поток сообщений об ошибках.</summary>
        <value>Объект <see cref="T:System.IO.TextWriter" />, предоставляющий стандартный поток вывода ошибок.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это стандартный поток ошибок по умолчанию имеет значение на консоль. Это можно сделать в другой поток с <xref:System.Console.SetError%2A> метод. После перенаправления в стандартный поток ошибок может быть получена путем вызова <xref:System.Console.OpenStandardError%2A> метод.  
  
 В консольных приложениях, выходные данные которого информационное часто перенаправляется в файл, поток через стандартную ошибку <xref:System.Console.Error%2A> свойство может использоваться для отображения сведений на консоль, даже если перенаправлены выходные данные. В следующем примере отображаются таблицы продуктов для 10 номеров по одному, начиная с 1. После каждого набора 10 номеров <xref:System.Console.Error%2A> свойство позволяет запрашивать у пользователя, следует ли отображать следующего набора. Если стандартный вывод перенаправляется в файл, у пользователя запрашивается по-прежнему ли процедура должна создать следующий набор продуктов.  
  
 [!code-csharp[System.Console.Error#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.error/cs/error1.cs#1)]
 [!code-vb[System.Console.Error#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.error/vb/error1.vb#1)]  
  
   
  
## Examples  
 Следующий пример — это программа командной строки с именем ExpandTabs, который заменяет символы табуляции в текстовом файле четыре пробела, значения, определяемого `tabSize` переменной. Он перенаправляет стандартный ввод и вывод потоки в файлы, но использует <xref:System.Console.Error%2A> свойство для записи в стандартный поток ошибок на консоль. Его можно запустить из командной строки, указав имя файла, содержащего символы табуляции и имя выходного файла.  
  
 [!code-cpp[Console-EXPANDTABSEX#1](~/samples/snippets/cpp/VS_Snippets_CLR/Console-EXPANDTABSEX/CPP/expandtabsex.cpp#1)]
 [!code-csharp[Console-EXPANDTABSEX#1](~/samples/snippets/csharp/VS_Snippets_CLR/Console-EXPANDTABSEX/CS/expandtabsex.cs#1)]
 [!code-vb[Console-EXPANDTABSEX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Console-EXPANDTABSEX/VB/expandtabsex.vb#1)]  
  
 Следующий пример является простым текстовым средство просмотра файлов, отображающее содержимое одного или нескольких текстовых файлов на консоль. Если аргументы командной строки, или если все файлы, передаваемые в качестве аргументов командной строки не существуют, в примере вызывается <xref:System.Console.SetError%2A> вызывает метод, чтобы перенаправить сведения об ошибке в файле <xref:System.Console.OpenStandardError%2A> метод в процессе повторного запроса в стандартную ошибку Указывает, что сведения об ошибке была записана в файл и потока.  
  
 [!code-csharp[System.Console.OpenStandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.openstandarderror/cs/viewtextfile.cs#1)]
 [!code-vb[System.Console.OpenStandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.openstandarderror/vb/viewtextfile.vb#1)]  
  
 Обратите внимание, что <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> свойству `true` до повторного запроса в поток ошибок. Это гарантирует, что выходные данные будут быть немедленно выводятся на консоль, а не в буфер.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.In" />
        <altmember cref="P:System.Console.Out" />
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="ForegroundColor">
      <MemberSignature Language="C#" Value="public static ConsoleColor ForegroundColor { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.ConsoleColor ForegroundColor" />
      <MemberSignature Language="DocId" Value="P:System.Console.ForegroundColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ForegroundColor As ConsoleColor" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property ConsoleColor ForegroundColor { ConsoleColor get(); void set(ConsoleColor value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ConsoleColor</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает цвет фона консоли.</summary>
        <value>Значение из перечисления <see cref="T:System.ConsoleColor" />, задающее цвет переднего плана консоли, то есть цвет, которым выводятся символы. По умолчанию задано значение Gray.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операция получения для приложения Windows, в котором консоли не существует, возвращает <xref:System.ConsoleColor.Gray>.  
  
   
  
## Examples  
 В следующем примере проверяется, является ли цвет фона консоли черный, и если это так, он изменяет цвет фона на красный и черный цвет переднего плана.  
  
 [!code-csharp[System.ConsoleColor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/Example2.cs#2)] 
 [!code-vb[System.ConsoleColor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/Example2.vb#2)]  
  
 Следующий пример сохраняет значения <xref:System.ConsoleColor> перечисления в массив и сохраняет текущие значения <xref:System.Console.BackgroundColor%2A> и <xref:System.Console.ForegroundColor%2A> свойства к переменным. Затем изменяет цвет переднего плана для каждого цвета в <xref:System.ConsoleColor> перечисление, за исключением того, как цвет, соответствующий текущий фоновый рисунок и он изменяет цвет фона для каждого цвета в <xref:System.ConsoleColor> перечисление, за исключением того, цвет, который соответствует текущий переднего плана. (Если цвет совпадает с цветом фона, текст не отображается.) Наконец, он вызывает <xref:System.Console.ResetColor%2A> метод восстановления исходного цвета консоли.  
  
 [!code-csharp[System.ConsoleColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/foregroundcolor3.cs#1)]
 [!code-vb[System.ConsoleColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/foregroundcolor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Цвет, указанный в операции SET, не является допустимым членом <see cref="T:System.ConsoleColor" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="In">
      <MemberSignature Language="C#" Value="public static System.IO.TextReader In { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IO.TextReader In" />
      <MemberSignature Language="DocId" Value="P:System.Console.In" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property In As TextReader" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::IO::TextReader ^ In { System::IO::TextReader ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextReader</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает стандартный входной поток.</summary>
        <value>Объект <see cref="T:System.IO.TextReader" />, представляющий стандартный входной поток.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этому свойству присвоено стандартный входной поток по умолчанию. Это свойство можно задать другой поток при помощи <xref:System.Console.SetIn%2A> метод.  
  
 Операции чтения на стандартный входной поток выполняются синхронно. То есть они заблокирован до завершения указанной операции чтения. Это верно даже если асинхронный метод, такой как <xref:System.IO.TextReader.ReadLineAsync%2A>, будет вызван на <xref:System.IO.TextReader> объект, возвращаемый <xref:System.Console.In%2A> свойство.  
  
   
  
## Examples  
 Следующий пример иллюстрирует использование `In` свойство.  
  
 [!code-cpp[consolein#1](~/samples/snippets/cpp/VS_Snippets_CLR/consolein/CPP/consolein.cpp#1)]
 [!code-csharp[consolein#1](~/samples/snippets/csharp/VS_Snippets_CLR/consolein/CS/consolein.cs#1)]
 [!code-vb[consolein#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/consolein/VB/consolein.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Console.OpenStandardInput" />
        <altmember cref="P:System.Console.IsInputRedirected" />
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.Out" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
      </Docs>
    </Member>
    <Member MemberName="InputEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding InputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding InputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Console.InputEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property InputEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ InputEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает кодировку консоли, используемую при чтении входных данных.</summary>
        <value>Кодировка консоли, используемая при чтении ввода.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Консоль использует кодировку ввода для преобразования ввода с клавиатуры в соответствующий символ. Кодировка ввода включает кодовую страницу, которая сопоставляет 256 кодов клавиш к отдельным символам. Разные кодовые страницы включают разные специальные символы, как правило, настроенные для языка или группы языков.  
  
 Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], операция получения свойства могут возвращать кэшированное значение, а не на консоль текущей кодировки входных данных. Это может произойти, если значение <xref:System.Console.InputEncoding%2A> свойство изменяется каким-либо образом, отличные от присвоения <xref:System.Console.InputEncoding%2A> свойства, например вызов Windows `SetConsoleCP` или с помощью `chcp` из сценария PowerShell.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение свойства в операции задания — <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Во время выполнения этой операции произошла ошибка.</exception>
        <exception cref="T:System.Security.SecurityException">У приложения нет разрешения на выполнение этой операции.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для чтения и записи окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="T:System.Text.Encoding" />
      </Docs>
    </Member>
    <Member MemberName="IsErrorRedirected">
      <MemberSignature Language="C#" Value="public static bool IsErrorRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsErrorRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Console.IsErrorRedirected" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsErrorRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsErrorRedirected { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, показывающее, был ли перенаправлен выходной поток ошибок от стандартного потока ошибок.</summary>
        <value>
          Значение <see langword="true" />, если выходные сообщения об ошибках перенаправляются; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
        <altmember cref="M:System.Console.OpenStandardError" />
      </Docs>
    </Member>
    <Member MemberName="IsInputRedirected">
      <MemberSignature Language="C#" Value="public static bool IsInputRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsInputRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Console.IsInputRedirected" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsInputRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsInputRedirected { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, показывающее, был ли перенаправлены ли входные данные от стандартного входного потока.</summary>
        <value>
          Значение <see langword="true" />, если входные данные перенаправляются; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Console.In" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
        <altmember cref="M:System.Console.OpenStandardInput" />
      </Docs>
    </Member>
    <Member MemberName="IsOutputRedirected">
      <MemberSignature Language="C#" Value="public static bool IsOutputRedirected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool IsOutputRedirected" />
      <MemberSignature Language="DocId" Value="P:System.Console.IsOutputRedirected" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property IsOutputRedirected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool IsOutputRedirected { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, показывающее, был ли перенаправлены выходные данные от стандартного выходного потока.</summary>
        <value>
          Значение <see langword="true" />, если выходные данные перенаправляются; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Console.Out" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
        <altmember cref="M:System.Console.OpenStandardError" />
      </Docs>
    </Member>
    <Member MemberName="KeyAvailable">
      <MemberSignature Language="C#" Value="public static bool KeyAvailable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool KeyAvailable" />
      <MemberSignature Language="DocId" Value="P:System.Console.KeyAvailable" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property KeyAvailable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool KeyAvailable { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает значение, указывающее, доступно ли нажатие клавиши во входном потоке.</summary>
        <value>
          Значение <see langword="true" />, если нажатие клавиши доступно; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение свойства возвращается немедленно; то есть <xref:System.Console.KeyAvailable%2A> свойства не блокируется входных данных до нажатие клавиши доступно.  
  
 Используйте <xref:System.Console.KeyAvailable%2A> свойства в сочетании с единственным <xref:System.Console.ReadKey%2A> метода, не <xref:System.Console.Read%2A> или <xref:System.Console.ReadLine%2A> методы.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование <xref:System.Console.KeyAvailable%2A> свойством, чтобы создать цикл, который выполняется, пока не нажата клавиша.  
  
 [!code-cpp[console.keyavailable#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.keyavailable/CPP/ka.cpp#1)]
 [!code-csharp[console.keyavailable#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.keyavailable/CS/ka.cs#1)]
 [!code-vb[console.keyavailable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.keyavailable/VB/ka.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.InvalidOperationException">Стандартный ввод перенаправляется в файл вместо клавиатуры.</exception>
      </Docs>
    </Member>
    <Member MemberName="LargestWindowHeight">
      <MemberSignature Language="C#" Value="public static int LargestWindowHeight { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 LargestWindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Console.LargestWindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LargestWindowHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int LargestWindowHeight { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает максимальное число строк окна консоли с учетом текущего шрифта и разрешения экрана.</summary>
        <value>Максимально возможная высота окна консоли измеряется в строках.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LargestWindowWidth">
      <MemberSignature Language="C#" Value="public static int LargestWindowWidth { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 LargestWindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Console.LargestWindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property LargestWindowWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int LargestWindowWidth { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает максимальное число столбцов окна консоли с учетом текущего шрифта и разрешения экрана.</summary>
        <value>Максимально возможная ширина окна консоли измеряется в столбцах.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveBufferArea">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Копирует заданную исходную область буфера экрана в заданную область назначения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveBufferArea">
      <MemberSignature Language="C#" Value="public static void MoveBufferArea (int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveBufferArea(int32 sourceLeft, int32 sourceTop, int32 sourceWidth, int32 sourceHeight, int32 targetLeft, int32 targetTop) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.MoveBufferArea(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveBufferArea (sourceLeft As Integer, sourceTop As Integer, sourceWidth As Integer, sourceHeight As Integer, targetLeft As Integer, targetTop As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceLeft" Type="System.Int32" />
        <Parameter Name="sourceTop" Type="System.Int32" />
        <Parameter Name="sourceWidth" Type="System.Int32" />
        <Parameter Name="sourceHeight" Type="System.Int32" />
        <Parameter Name="targetLeft" Type="System.Int32" />
        <Parameter Name="targetTop" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="sourceLeft">Крайний слева столбец исходной области.</param>
        <param name="sourceTop">Самая верхняя строка исходной области.</param>
        <param name="sourceWidth">Общее число столбцов в исходной области.</param>
        <param name="sourceHeight">Общее число строк в исходной области.</param>
        <param name="targetLeft">Крайний слева столбец области назначения.</param>
        <param name="targetTop">Самая верхняя строка области назначения.</param>
        <summary>Копирует заданную исходную область буфера экрана в заданную область назначения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если параметры источника и назначения задают позицию за границами текущего буфера экрана, копируется только часть исходной области, которая помещается в область назначения. То есть исходная область обрезается по размеру текущего буфера экрана.  
  
 <xref:System.Console.MoveBufferArea%2A> Копирует исходной области в области назначения. Область назначения не пересекается с исходной областью, исходная область заполняется пробелами с использованием текущих цветов переднего плана и фона. В противном случае пересекаемых часть исходной области не заполняется.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Один или несколько параметров имеют значение меньше нуля.  
  
 - или -  
  
 Параметр <paramref name="sourceLeft" /> или <paramref name="targetLeft" /> больше или равен <see cref="P:System.Console.BufferWidth" />.  
  
 - или -  
  
 Параметр <paramref name="sourceTop" /> или <paramref name="targetTop" /> больше или равен <see cref="P:System.Console.BufferHeight" />.  
  
 - или -  
  
 <paramref name="sourceTop" /> + <paramref name="sourceHeight" /> больше или равно <see cref="P:System.Console.BufferHeight" />.  
  
 - или -  
  
 <paramref name="sourceLeft" /> + <paramref name="sourceWidth" /> больше или равно <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="MoveBufferArea">
      <MemberSignature Language="C#" Value="public static void MoveBufferArea (int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MoveBufferArea(int32 sourceLeft, int32 sourceTop, int32 sourceWidth, int32 sourceHeight, int32 targetLeft, int32 targetTop, char sourceChar, valuetype System.ConsoleColor sourceForeColor, valuetype System.ConsoleColor sourceBackColor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.MoveBufferArea(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Char,System.ConsoleColor,System.ConsoleColor)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MoveBufferArea (sourceLeft As Integer, sourceTop As Integer, sourceWidth As Integer, sourceHeight As Integer, targetLeft As Integer, targetTop As Integer, sourceChar As Char, sourceForeColor As ConsoleColor, sourceBackColor As ConsoleColor)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MoveBufferArea(int sourceLeft, int sourceTop, int sourceWidth, int sourceHeight, int targetLeft, int targetTop, char sourceChar, ConsoleColor sourceForeColor, ConsoleColor sourceBackColor);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sourceLeft" Type="System.Int32" />
        <Parameter Name="sourceTop" Type="System.Int32" />
        <Parameter Name="sourceWidth" Type="System.Int32" />
        <Parameter Name="sourceHeight" Type="System.Int32" />
        <Parameter Name="targetLeft" Type="System.Int32" />
        <Parameter Name="targetTop" Type="System.Int32" />
        <Parameter Name="sourceChar" Type="System.Char" />
        <Parameter Name="sourceForeColor" Type="System.ConsoleColor" />
        <Parameter Name="sourceBackColor" Type="System.ConsoleColor" />
      </Parameters>
      <Docs>
        <param name="sourceLeft">Крайний слева столбец исходной области.</param>
        <param name="sourceTop">Самая верхняя строка исходной области.</param>
        <param name="sourceWidth">Общее число столбцов в исходной области.</param>
        <param name="sourceHeight">Общее число строк в исходной области.</param>
        <param name="targetLeft">Крайний слева столбец области назначения.</param>
        <param name="targetTop">Самая верхняя строка области назначения.</param>
        <param name="sourceChar">Символ, используемый для заполнения исходной области.</param>
        <param name="sourceForeColor">Цвет переднего плана, используемый для заполнения исходной области.</param>
        <param name="sourceBackColor">Цвет фона, используемый для заполнения исходной области.</param>
        <summary>Копирует заданную исходную область буфера экрана в заданную область назначения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если параметры источника и назначения задают позицию за границами текущего буфера экрана, копируется только часть исходной области, которая помещается в область назначения. То есть исходная область обрезается по размеру текущего буфера экрана.  
  
 <xref:System.Console.MoveBufferArea%2A> Копирует исходной области в области назначения. Если область назначения не пересекается с исходной областью, исходная область заполняется символ, указанный `sourceChar`, с помощью цвета, определяемые `sourceForeColor` и `sourceBackColor`. В противном случае пересекаемых часть исходной области не заполняется.  
  
 <xref:System.Console.MoveBufferArea%2A> Метод не выполняет никаких действий при `sourceWidth` или `sourceHeight` равно нулю.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Один или несколько параметров имеют значение меньше нуля.  
  
 - или -  
  
 Параметр <paramref name="sourceLeft" /> или <paramref name="targetLeft" /> больше или равен <see cref="P:System.Console.BufferWidth" />.  
  
 - или -  
  
 Параметр <paramref name="sourceTop" /> или <paramref name="targetTop" /> больше или равен <see cref="P:System.Console.BufferHeight" />.  
  
 - или -  
  
 <paramref name="sourceTop" /> + <paramref name="sourceHeight" /> больше или равно <see cref="P:System.Console.BufferHeight" />.  
  
 - или -  
  
 <paramref name="sourceLeft" /> + <paramref name="sourceWidth" /> больше или равно <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.ArgumentException">Один или более параметров цвета не являются членами перечисления <see cref="T:System.ConsoleColor" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NumberLock">
      <MemberSignature Language="C#" Value="public static bool NumberLock { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool NumberLock" />
      <MemberSignature Language="DocId" Value="P:System.Console.NumberLock" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NumberLock As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool NumberLock { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, включен или отключен режим NUM LOCK клавиатуры.</summary>
        <value>
          Значение <see langword="true" />, если клавиша NUM LOCK включена; значение <see langword="false" />, если клавиша NUM LOCK выключена.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenStandardError">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает стандартный поток сообщений об ошибках.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenStandardError">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardError ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardError() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardError" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardError () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardError();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает стандартный поток сообщений об ошибках.</summary>
        <returns>Стандартный поток сообщений об ошибках.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть использован для повторного запроса стандартного потока ошибок после его изменения <xref:System.Console.SetError%2A> метод.  
  
   
  
## Examples  
 Следующий пример является простым текстовым средство просмотра файлов, отображающее содержимое одного или нескольких текстовых файлов на консоль. Если аргументы командной строки, или если все файлы, передаваемые в качестве аргументов командной строки не существуют, в примере вызывается <xref:System.Console.SetError%2A> вызывает метод, чтобы перенаправить сведения об ошибке в файле <xref:System.Console.OpenStandardError%2A> метод в процессе повторного запроса в стандартную ошибку Указывает, что сведения об ошибке была записана в файл и потока.  
  
 [!code-csharp[System.Console.OpenStandardError#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.openstandarderror/cs/viewtextfile.cs#1)]
 [!code-vb[System.Console.OpenStandardError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.openstandarderror/vb/viewtextfile.vb#1)]  
  
 Обратите внимание, что <xref:System.IO.StreamWriter.AutoFlush%2A?displayProperty=nameWithType> свойству `true` до повторного запроса в поток ошибок. Это гарантирует, что выходные данные будут быть немедленно выводятся на консоль, а не в буфер.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="OpenStandardError">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardError (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardError(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardError(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardError (bufferSize As Integer) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardError(int bufferSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bufferSize">Размер буфера внутреннего потока.</param>
        <summary>Получает стандартный поток сообщений об ошибках, для которого установлен заданный размер буфера.</summary>
        <returns>Стандартный поток сообщений об ошибках.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть использован для повторного запроса стандартного потока ошибок после его изменения <xref:System.Console.SetError%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение <paramref name="bufferSize" /> не больше нуля.</exception>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="M:System.Console.SetError(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenStandardInput">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает стандартный входной поток.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenStandardInput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardInput ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardInput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardInput" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardInput () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardInput();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает стандартный входной поток.</summary>
        <returns>Стандартный входной поток.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод можно использовать для повторного запроса стандартного входного потока после его изменения <xref:System.Console.SetIn%2A> метод.  
  
   
  
## Examples  
 Следующий пример иллюстрирует использование `OpenStandardInput` свойство.  
  
 [!code-cpp[System.Console.OpenStandartInput#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CPP/decode.cpp#1)]
 [!code-csharp[System.Console.OpenStandartInput#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CS/decode.cs#1)]
 [!code-vb[System.Console.OpenStandartInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.OpenStandartInput/VB/decode.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.In" />
        <altmember cref="P:System.Console.IsInputRedirected" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
      </Docs>
    </Member>
    <Member MemberName="OpenStandardInput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardInput (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardInput(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardInput (bufferSize As Integer) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardInput(int bufferSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bufferSize">Размер буфера внутреннего потока.</param>
        <summary>Получает стандартный входной поток, для которого установлен заданный размер буфера.</summary>
        <returns>Стандартный входной поток.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть использован для повторного запроса в стандартный выходной поток после его изменения <xref:System.Console.SetIn%2A> метод.  
  
   
  
## Examples  
 Следующий пример иллюстрирует использование `OpenStandardInput` свойство.  
  
 [!code-cpp[System.Console.OpenStandartInput#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CPP/decode.cpp#1)]
 [!code-csharp[System.Console.OpenStandartInput#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.OpenStandartInput/CS/decode.cs#1)]
 [!code-vb[System.Console.OpenStandartInput#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.OpenStandartInput/VB/decode.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение <paramref name="bufferSize" /> не больше нуля.</exception>
        <altmember cref="P:System.Console.In" />
        <altmember cref="P:System.Console.IsInputRedirected" />
        <altmember cref="M:System.Console.SetIn(System.IO.TextReader)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenStandardOutput">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает стандартный выходной поток.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenStandardOutput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardOutput ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardOutput() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardOutput" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardOutput () As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardOutput();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает стандартный выходной поток.</summary>
        <returns>Стандартный выходной поток.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть использован для повторного запроса в стандартный выходной поток после его изменения <xref:System.Console.SetOut%2A> метод.  
  
   
  
## Examples  
 В следующем примере показано использование метода <xref:System.Console.OpenStandardOutput%2A>. Он заменяет 4 последовательных пробела в строке символом табуляции. Чтобы запустить ее, необходимо указать два аргумента командной строки. Первый аргумент — это имя существующего текстового файла, в который требуется перенаправить стандартный входной поток. Второй аргумент — это имя файла, в который требуется перенаправить стандартный выходной поток. Не требуется, чтобы этот файл существовал. Если да, его содержимое будут перезаписано.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.Out" />
        <altmember cref="P:System.Console.IsOutputRedirected" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="OpenStandardOutput">
      <MemberSignature Language="C#" Value="public static System.IO.Stream OpenStandardOutput (int bufferSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IO.Stream OpenStandardOutput(int32 bufferSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.OpenStandardOutput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenStandardOutput (bufferSize As Integer) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IO::Stream ^ OpenStandardOutput(int bufferSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bufferSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="bufferSize">Размер буфера внутреннего потока.</param>
        <summary>Получает стандартный выходной поток, для которого установлен заданный размер буфера.</summary>
        <returns>Стандартный выходной поток.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод может быть использован для повторного запроса в стандартный выходной поток после его изменения <xref:System.Console.SetOut%2A> метод.  
  
   
  
## Examples  
 В следующем примере показано использование метода <xref:System.Console.OpenStandardOutput%2A>. Он заменяет 4 последовательных пробела в строке символом табуляции. Чтобы запустить ее, необходимо указать два аргумента командной строки. Первый аргумент — это имя существующего текстового файла, в который требуется перенаправить стандартный входной поток. Второй аргумент — это имя файла, в который требуется перенаправить стандартный выходной поток. Не требуется, чтобы этот файл существовал. Если да, его содержимое будут перезаписано.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение <paramref name="bufferSize" /> не больше нуля.</exception>
        <altmember cref="P:System.Console.Out" />
        <altmember cref="P:System.Console.IsOutputRedirected" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="Out">
      <MemberSignature Language="C#" Value="public static System.IO.TextWriter Out { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IO.TextWriter Out" />
      <MemberSignature Language="DocId" Value="P:System.Console.Out" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Out As TextWriter" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::IO::TextWriter ^ Out { System::IO::TextWriter ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.TextWriter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает стандартный выходной поток.</summary>
        <value>Объект <see cref="T:System.IO.TextWriter" />, представляющий стандартный выходной поток.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство имеет значение в стандартный выходной поток по умолчанию. Это свойство можно задать другой поток при помощи <xref:System.Console.SetOut%2A> метод.  
  
 Обратите внимание, что вызовы `Console.Out.WriteLine` метода — вызовы в соответствующий <xref:System.Console.WriteLine%2A> методы.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Console.Out%2A> свойство для отображения массив, содержащий имена файлов в текущем каталоге приложения, чтобы на стандартное устройство вывода. Затем задает стандартный вывод в файл с именем Files.txt и перечислены в файле элементы массива. Наконец он задает выходные данные в стандартный выходной поток и снова не отображает элементы массива на стандартное устройство вывода.  
  
 [!code-csharp[System.Console.Out#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.out/cs/out1.cs#1)]
 [!code-vb[System.Console.Out#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.out/vb/out1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Console.Error" />
        <altmember cref="P:System.Console.In" />
        <altmember cref="M:System.Console.SetOut(System.IO.TextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="OutputEncoding">
      <MemberSignature Language="C#" Value="public static System.Text.Encoding OutputEncoding { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Text.Encoding OutputEncoding" />
      <MemberSignature Language="DocId" Value="P:System.Console.OutputEncoding" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property OutputEncoding As Encoding" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Text::Encoding ^ OutputEncoding { System::Text::Encoding ^ get(); void set(System::Text::Encoding ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Text.Encoding</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает кодировку консоли, используемую при записи выходных данных.</summary>
        <value>Кодировка консоли, используемая при записи вывода.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Консоль использует кодировку вывода для преобразования символов, записываемых приложением, в соответствующие символы для отображения консоли. Кодовая страница по умолчанию, который использует консоль определяется языкового стандарта системы.  
  
 Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], операция получения свойства могут возвращать кэшированное значение вместо текущего кодирования вывода на консоль. Это может произойти, если значение <xref:System.Console.OutputEncoding%2A> свойство изменяется каким-либо образом, отличные от присвоения <xref:System.Console.OutputEncoding%2A> свойства, например вызов Windows `SetConsoleOutputCP` функции.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Значение свойства в операции задания — <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Во время выполнения этой операции произошла ошибка.</exception>
        <exception cref="T:System.Security.SecurityException">У приложения нет разрешения на выполнение этой операции.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для чтения и записи окон верхнего уровня и дочерние окна.  Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage">
          <para>Кодировок Юникода <see cref="T:System.Console" /> с кодировкой UTF-8 поддерживает класс <see cref="T:System.Text.UTF8Encoding" /> класс и, начиная с [!INCLUDE[net_v45](~/includes/net-v45-md.md)], он поддерживает с кодировкой UTF-16 <see cref="T:System.Text.UnicodeEncoding" /> класса. Кодировка UTF-32 с <see cref="T:System.Text.UTF32Encoding" /> класс не поддерживается. Выполняется настройка выходных данных кодировку UTF-32 возникает исключение <see cref="T:System.IO.IOException" />.  
  
 Обратите внимание, что успешно отображения символов Юникода в консоль требуется следующее:  
  
-   Консоль необходимо использовать является шрифтом TrueType, например Lucida Console или Consolas, в качестве используемого для отображения символов.  
  
-   Шрифт, используемый консолью необходимо определить определенного глифов или глифов для отображения. Консоль можно воспользоваться преимуществами связь для отображения глифов из связанных шрифтов, если базового шрифта не содержит определение для этого глифа шрифтов.  
  
 Дополнительные сведения о поддержке Юникода в кодировку консоли, см. в подразделе «Юникод поддерживает для консоль» <see cref="T:System.Console" /> класса.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Read">
      <MemberSignature Language="C#" Value="public static int Read ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Read() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Read" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Read () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Read();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Читает следующий символ из стандартного входного потока.</summary>
        <returns>Следующий символ из входного потока или значение минус единица (-1), если доступных для чтения символов не осталось.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Console.Read%2A> Метод блокируется до ввода входных символов; она завершается при нажатии клавиши <xref:System.ConsoleKey.Enter> ключа. Нажатие клавиши Enter добавляет последовательность завершения строки, зависящей от платформы во входные данные (например, Windows добавляется последовательность перевода строки возврат каретки). Последующие вызовы <xref:System.Console.Read%2A> метод получения вашего ввод по одному символу за раз. После получения последним символом <xref:System.Console.Read%2A> блокирует возврат еще раз и цикл повторяется.  
  
> [!IMPORTANT]
>  <xref:System.Console.ReadLine%2A> Метод, или <xref:System.Console.KeyAvailable%2A> свойство и <xref:System.Console.ReadKey%2A> метод предпочтительнее <xref:System.Console.Read%2A> метод.  
  
 Обратите внимание, что метод не возвращает значение -1, если не выполнить одно из следующих действий:  
  
-   Одновременно нажмите клавиши <xref:System.ConsoleModifiers.Control> клавиши-модификатора и <xref:System.ConsoleKey.Z> клавиши консоли (Ctrl + Z), который сигнализирует условие конечного файла.  
  
-   Нажмите клавишу эквивалентным ключом, который сигнализирует end of file условия, такого как функциональную клавишу F6 в Windows.  
  
-   Перенаправление входного потока к источнику, такому как текстовый файл, которого содержится символ фактического конечного файла.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Console.Read%2A> метод.  
  
 [!code-cpp[console.read#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.read/CPP/read.cpp#1)]
 [!code-csharp[console.read#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.read/CS/read.cs#1)]
 [!code-vb[console.read#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.read/VB/read.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadKey">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получает следующий нажатый пользователем символ или функциональную клавишу.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadKey">
      <MemberSignature Language="C#" Value="public static ConsoleKeyInfo ReadKey ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ConsoleKeyInfo ReadKey() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ReadKey" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadKey () As ConsoleKeyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ConsoleKeyInfo ReadKey();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ConsoleKeyInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Получает следующий нажатый пользователем символ или функциональную клавишу. Нажатая клавиша отображается в окне консоли.</summary>
        <returns>Объект, описывающий константу <see cref="T:System.ConsoleKey" /> и символ Юникода (при наличии), соответствующий нажатой клавише консоли. Этот объект <see cref="T:System.ConsoleKeyInfo" /> также описывает в битовой комбинации значений <see cref="T:System.ConsoleModifiers" />, нажимались ли клавиши-модификаторы (одна или несколько) Shift, Alt или Ctrl одновременно с клавишей консоли.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Console.ReadKey%2A> Метод ожидает, то есть блоков выполнения потока <xref:System.Console.ReadKey%2A> метод, пока не нажата символ или функциональную клавишу. Символ или функциональную клавишу может быть нажата в сочетании с одного или нескольких Alt, Ctrl или Shift клавиши-модификаторы. Тем не менее, нажав клавиши-модификатора сам по себе не приведет к <xref:System.Console.ReadKey%2A> метод для возврата.  
  
 В зависимости от приложения, может потребоваться использовать <xref:System.Console.ReadKey%2A> в сочетании с <xref:System.Console.KeyAvailable%2A> свойство.  
  
 <xref:System.Console.ReadKey%2A> Метод выполняет чтение с клавиатуры, даже если стандартный ввод перенаправляется в файл с <xref:System.Console.SetIn%2A> метод.  
  
   
  
## Examples  
 Одно из наиболее распространенные способы применения <xref:System.Console.ReadKey> имеет метод для остановки выполнения программы, пока пользователь нажимает клавишу и приложение завершает или отображает дополнительное окно сведений. В следующем примере используется <xref:System.Console.ReadKey> метод для ожидания пользователя нажатия клавиши ВВОД перед завершением работы приложения.  
  
 [!code-csharp[System.Console.ReadKey#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Console.ReadKey/cs/ReadKey1.cs#1)]
 [!code-vb[System.Console.ReadKey#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Console.ReadKey/vb/ReadKey1.vb#1)]  
  
 Обратите внимание, что этой перегрузке <xref:System.Console.ReadKey%2A> метод по умолчанию отображает все отображаемые ключи, пользователь нажимает на консоль. Чтобы отключить их, вызовите <xref:System.Console.ReadKey%2A> метод с `intercept` аргумент `true`.  
  
 В следующем примере используется <xref:System.Console.ReadKey> метод для отображения сведений о ключе, какой пользователь нажал...  
  
 [!code-cpp[console.readkey1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.readkey1/CPP/rk.cpp#1)]
 [!code-csharp[console.readkey1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.readkey1/CS/rk.cs#1)]
 [!code-vb[console.readkey1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.readkey1/VB/rk.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Console.In" /> перенаправлено из потока, отличного от консоли.</exception>
        <altmember cref="T:System.ConsoleKey" />
        <altmember cref="P:System.Console.KeyAvailable" />
        <altmember cref="P:System.Console.TreatControlCAsInput" />
        <altmember cref="E:System.Console.CancelKeyPress" />
      </Docs>
    </Member>
    <Member MemberName="ReadKey">
      <MemberSignature Language="C#" Value="public static ConsoleKeyInfo ReadKey (bool intercept);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.ConsoleKeyInfo ReadKey(bool intercept) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ReadKey(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadKey (intercept As Boolean) As ConsoleKeyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static ConsoleKeyInfo ReadKey(bool intercept);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ConsoleKeyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="intercept" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="intercept">Определяет, следует ли отображать нажатую клавишу в окне консоли. Значение <see langword="true" />, чтобы не отображать нажатую клавишу; в противном случае — значение <see langword="false" />.</param>
        <summary>Получает следующий нажатый пользователем символ или функциональную клавишу. Нажатая клавиша может быть отображена в окне консоли.</summary>
        <returns>Объект, описывающий константу <see cref="T:System.ConsoleKey" /> и символ Юникода (при наличии), соответствующий нажатой клавише консоли. Этот объект <see cref="T:System.ConsoleKeyInfo" /> также описывает в битовой комбинации значений <see cref="T:System.ConsoleModifiers" />, нажимались ли клавиши-модификаторы (одна или несколько) Shift, Alt или Ctrl одновременно с клавишей консоли.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Console.ReadKey%2A> Метод ожидает, то есть блоков выполнения потока <xref:System.Console.ReadKey%2A> метод, пока не нажата символ или функциональную клавишу. Символ или функциональную клавишу может быть нажата в сочетании с одного или нескольких Alt, Ctrl или Shift клавиши-модификаторы. Тем не менее, нажав клавиши-модификатора сам по себе не приведет к <xref:System.Console.ReadKey%2A> метод для возврата.  
  
 Если `intercept` параметр `true`, нажатая клавиша перехватывается и не отображается в окне консоли; в противном случае, нажатая клавиша отображается.  
  
 В зависимости от приложения, может потребоваться использовать <xref:System.Console.ReadKey%2A> в сочетании с <xref:System.Console.KeyAvailable%2A> свойство.  
  
 <xref:System.Console.ReadKey%2A> Метод выполняет чтение с клавиатуры, даже если стандартный ввод перенаправляется в файл с <xref:System.Console.SetIn%2A> метод.  
  
   
  
## Examples  
 Одно из наиболее распространенные способы применения <xref:System.Console.ReadKey%2A> имеет метод для остановки выполнения программы, пока пользователь нажимает клавишу и приложение завершает или отображает дополнительное окно сведений. В следующем примере используется <xref:System.Console.ReadKey%28System.Boolean%29> метод для ожидания пользователя нажатия клавиши ВВОД перед завершением работы приложения. Обратите внимание, что если пользователь нажимает любую другую клавишу, он не переносится на консоль.  
  
 [!code-csharp[System.Console.ReadKey#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Console.ReadKey/cs/ReadKey2.cs#2)]
 [!code-vb[System.Console.ReadKey#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Console.ReadKey/vb/ReadKey2.vb#2)]  
  
 В следующем примере используется <xref:System.Console.ReadKey%28System.Boolean%29> метод для отображения сведений о ключе нажатия пользователем клавиши вывод на экран разделу на консоль.  
  
 [!code-cpp[console.readkey2#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.readkey2/CPP/rkbool.cpp#1)]
 [!code-csharp[console.readkey2#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.readkey2/CS/rkbool.cs#1)]
 [!code-vb[console.readkey2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.readkey2/VB/rkbool.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Свойство <see cref="P:System.Console.In" /> перенаправлено из потока, отличного от консоли.</exception>
        <altmember cref="T:System.ConsoleKey" />
        <altmember cref="P:System.Console.KeyAvailable" />
        <altmember cref="P:System.Console.TreatControlCAsInput" />
        <altmember cref="E:System.Console.CancelKeyPress" />
      </Docs>
    </Member>
    <Member MemberName="ReadLine">
      <MemberSignature Language="C#" Value="public static string ReadLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ReadLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ReadLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReadLine () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ReadLine();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Считывает следующую строку символов из стандартного входного потока.</summary>
        <returns>Следующая строка символов из входного потока или значение <see langword="null" />, если больше нет доступных строк.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Console.ReadLine%2A> Метод считывает строку из стандартного входного потока. (Для определения строки, см. в абзаце после перечисленные ниже.) Это означает следующее.  
  
-   Если стандартное устройство ввода клавиатуры, <xref:System.Console.ReadLine%2A> метод блокируется до нажатия пользователем **ввод** ключа.  
  
     Одно из наиболее распространенные способы применения <xref:System.Console.ReadLine%2A> метод: Чтобы приостановить выполнение программы до очистки консоль и отображения новых сведений для его или попросить пользователя нажатия клавиши ВВОД перед завершением работы приложения. Это показано в следующем примере.  
  
     [!code-cpp[System.Console.ReadLine#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.ReadLine/cpp/ReadLineSimple.cpp#6)]
     [!code-csharp[System.Console.ReadLine#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.ReadLine/cs/ReadLineSimple.cs#6)]
     [!code-vb[System.Console.ReadLine#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.ReadLine/vb/ReadLineSimple.vb#6)]  
  
-   Если стандартный ввод перенаправляется в файл <xref:System.Console.ReadLine%2A> метод считывает строку текста из файла. Например ниже приведен пример текстовый файл с именем ReadLine1.txt:  
  
    ```  
  
    This is the first line.  
    This is the second line.  
    This is the third line.  
    This is the fourth line.  
  
    ```  
  
     В следующем примере используется <xref:System.Console.ReadLine%2A> метод при чтении ввода, переадресован из файла. Завершает операцию чтения, если метод возвращает `null`, указывающая, что строки не остаются для чтения.  
  
     [!code-csharp[System.Console.ReadLine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.ReadLine/cs/ReadLine3.cs#3)]
     [!code-vb[System.Console.ReadLine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.ReadLine/vb/ReadLine3.vb#3)]  
  
     После компиляции примера для исполняемого именованный ReadLine1.exe, можно запустить ее из командной строки с помощью синтаксиса  
  
    ```  
    ReadLine1 < ReadLine1.txt  
    ```  
  
     Прочтите содержимое файла и отобразить их на консоль.  
  
 Строка определяется как последовательность символов возврата каретки (шестнадцатеричный код 0x000d), перевод строки (шестнадцатеричное представление 0x000a) или значение <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> свойства. Возвращаемая строка не содержит знаков конца строки. По умолчанию этот метод считывает входные данные из входного буфера до 256 символов. Так как в нем <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> символы, метод может считывать строки, содержащие до 254 символов. Для считывания больше строк, вызвать <xref:System.Console.OpenStandardInput%28System.Int32%29> метод.  
  
 <xref:System.Console.ReadLine%2A> Метод выполняется синхронно. То есть он будет заблокирован до чтения строки или нажатии сочетания клавиш Ctrl + Z. <xref:System.Console.In%2A> Возвращает <xref:System.IO.TextReader> объект, представляющий стандартный входной поток и имеет оба синхронной <xref:System.IO.TextReader.ReadLine%2A?displayProperty=nameWithType> метод и асинхронную <xref:System.IO.TextReader.ReadLineAsync%2A?displayProperty=nameWithType> метод. Тем не менее, при использовании в качестве консоли стандартный входной поток, <xref:System.IO.TextReader.ReadLineAsync%2A?displayProperty=nameWithType> выполняется синхронно, а не асинхронно и возвращает `Task<String>` только после завершения операции чтения.  
  
 Если этот метод создает исключение <xref:System.OutOfMemoryException> исключение, позиция средства чтения в основном потоке <xref:System.IO.Stream> объекта увеличивается число знаков, которое может считывать метод, но знаки, уже считанные во внутренний <xref:System.Console.ReadLine%2A> являются буфера удаляются. Так как позицию средства чтения в потоке нельзя изменить, уже считанные символы неустранимой и доступны только при повторной инициализации <xref:System.IO.TextReader>. Если начальная позиция в потоке неизвестна или поток не поддерживает поиск, базовый <xref:System.IO.Stream> также необходимо инициализировать повторно. Чтобы избежать такой ситуации и создать надежный код, следует использовать <xref:System.Console.KeyAvailable%2A> свойство и <xref:System.Console.ReadKey%2A> метод и хранилище считанные знаки в предварительно выделенный буфер.  
  
 Если символ Ctrl + Z нажата, когда метод является чтение входных данных с помощью консоли, метод возвращает `null`. Это позволяет параметр для предотвращения дальнейших клавиатуры ввода пользователем при <xref:System.Console.ReadLine%2A> метод вызывается в цикле. В следующем примере показан этот сценарий.  
  
 [!code-cpp[System.Console.ReadLine#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.ReadLine/cpp/readline2.cpp#1)]
 [!code-csharp[System.Console.ReadLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.ReadLine/cs/ReadLine2.cs#1)]
 [!code-vb[System.Console.ReadLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.ReadLine/vb/ReadLine2.vb#1)]  
  
   
  
## Examples  
 В следующем примере требуется два аргумента командной строки: имя существующего текстового файла и имя файла для записи выходных данных. Открывает существующий текстовый файл и перенаправляет стандартный ввод с клавиатуры в файл. Также перенаправляет стандартный вывод из консоли в выходной файл. Затем он использует <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> метод при чтении каждой строки в файле, заменяет последовательность каждые четыре пробела символом табуляции и использует <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> метод для записи результата в выходной файл.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.OutOfMemoryException">Не хватает памяти для выделения буфера под возвращаемую строку.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Количество символов в следующей строке символов больше, чем <see cref="F:System.Int32.MaxValue" />.</exception>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="ResetColor">
      <MemberSignature Language="C#" Value="public static void ResetColor ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetColor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.ResetColor" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetColor ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetColor();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Устанавливает для цветов фона и текста консоли их значения по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Цвета переднего плана и фона, восстанавливаются цвета, которые существовали во время начала текущего процесса. Дополнительные сведения см. в разделе <xref:System.Console.ForegroundColor%2A> и <xref:System.Console.BackgroundColor%2A> свойства.  
  
   
  
## Examples  
 Следующий пример сохраняет значения <xref:System.ConsoleColor> перечисления в массив и сохраняет текущие значения <xref:System.Console.BackgroundColor%2A> и <xref:System.Console.ForegroundColor%2A> свойства к переменным. Затем изменяет цвет переднего плана для каждого цвета в <xref:System.ConsoleColor> перечисление, за исключением того, как цвет, соответствующий текущий фоновый рисунок и он изменяет цвет фона для каждого цвета в <xref:System.ConsoleColor> перечисление, за исключением того, цвет, который соответствует текущий переднего плана. (Если цвет совпадает с цветом фона, текст не отображается.) Наконец, он вызывает <xref:System.Console.ResetColor%2A> метод восстановления исходного цвета консоли.  
  
 [!code-csharp[System.ConsoleColor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.consolecolor/cs/foregroundcolor3.cs#1)]
 [!code-vb[System.ConsoleColor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.consolecolor/vb/foregroundcolor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetBufferSize">
      <MemberSignature Language="C#" Value="public static void SetBufferSize (int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetBufferSize(int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetBufferSize(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetBufferSize (width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetBufferSize(int width, int height);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="width">Ширина области буфера в столбцах.</param>
        <param name="height">Высота области буфера в строках.</param>
        <summary>Устанавливает заданные значения высоты и ширины буферной области экрана.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере демонстрируется <xref:System.Console.WindowLeft%2A>, <xref:System.Console.WindowTop%2A>, <xref:System.Console.WindowWidth%2A>, <xref:System.Console.WindowHeight%2A>, <xref:System.Console.BufferWidth%2A>, <xref:System.Console.BufferHeight%2A>, и <xref:System.Console.CursorVisible%2A> его свойства и <xref:System.Console.SetWindowPosition%2A>, <xref:System.Console.SetBufferSize%2A>, и <xref:System.Console.ReadKey%2A> методы. В примере рисуется сетка в буфере экрана, исходя из ширины буфера экрана. Затем в примере показано перемещение окна консоли в ответ на который стрелка вверх, нажатия клавиш консоли Стрелка вправо, Стрелка влево или вправо. Сетка помогает видеть перемещение окна консоли относительно буфера экрана.  
  
 [!code-cpp[console.windowLT#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.windowLT/CPP/wlt.cpp#1)]
 [!code-csharp[console.windowLT#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.windowLT/CS/wlt.cs#1)]
 [!code-vb[console.windowLT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.windowLT/VB/wlt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="height" /> или <paramref name="width" /> меньше или равно нулю.  
  
 - или -  
  
 Параметр <paramref name="height" /> или <paramref name="width" /> больше или равен <see cref="F:System.Int16.MaxValue" />.  
  
 - или -  
  
 <paramref name="width" /> меньше <see cref="P:System.Console.WindowLeft" /> + <see cref="P:System.Console.WindowWidth" />.  
  
 - или -  
  
 <paramref name="height" /> меньше <see cref="P:System.Console.WindowTop" /> + <see cref="P:System.Console.WindowHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCursorPosition">
      <MemberSignature Language="C#" Value="public static void SetCursorPosition (int left, int top);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetCursorPosition(int32 left, int32 top) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetCursorPosition(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetCursorPosition (left As Integer, top As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetCursorPosition(int left, int top);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="left">Позиция столбца курсора. Столбцы нумеруются как слева направо, начинается с 0.</param>
        <param name="top">Позиция строки курсора. Строки пронумерованы сверху вниз, начиная с 0.</param>
        <summary>Устанавливает положение курсора.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Console.SetCursorPosition%2A> метод, чтобы указать, где начинается следующей операции записи в окне консоли. Если заданная позиция курсора находится вне области, видимых в настоящее время в окне консоли, начало координат этого окна автоматически изменения, чтобы сделать видимым курсора.  
  
 Курсор автоматически перемещается в следующую позицию символа, каждый раз символ записывается в окно консоли. Если курсор находится в правую нижнюю позицию окна консоли, следующая операция записи вызовет окно консоли для прокрутки, курсор остается видимым. Если вы хотите записать символ в правую нижнюю позицию без прокрутки, используйте окно консоли <xref:System.Console.MoveBufferArea%2A> способ перемещения символа в эту позицию.  
  
   
  
## Examples  
 В этом примере демонстрируется <xref:System.Console.CursorLeft%2A> и <xref:System.Console.CursorTop%2A> свойства и <xref:System.Console.SetCursorPosition%2A> и <xref:System.Console.Clear%2A> методы. Примере курсор, который определяет, где произойдет следующая запись, для рисования 5 символов прямоугольником, 5 символов с помощью сочетания «+», «&#124;», и «-» строки. Обратите внимание, что прямоугольник можно нарисовать за меньшее число шагов, используя сочетание других строк.  
  
 [!code-cpp[console.cursorLTS#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.cursorLTS/CPP/lts.cpp#1)]
 [!code-csharp[console.cursorLTS#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.cursorLTS/CS/lts.cs#1)]
 [!code-vb[console.cursorLTS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.cursorLTS/VB/lts.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="left" /> или <paramref name="top" /> меньше нуля.  
  
 - или -  
  
 Значение <paramref name="left" /> больше или равно <see cref="P:System.Console.BufferWidth" />.  
  
 - или -  
  
 Значение <paramref name="top" /> больше или равно <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetError">
      <MemberSignature Language="C#" Value="public static void SetError (System.IO.TextWriter newError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetError(class System.IO.TextWriter newError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetError(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetError (newError As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetError(System::IO::TextWriter ^ newError);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newError" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="newError">Поток, являющийся новым стандартным потоком сообщений об ошибках.</param>
        <summary>Присваивает свойству <see cref="P:System.Console.Error" /> указанный объект <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Console.Error%2A> задано значение в стандартный выходной поток ошибок.  
  
 Объект <xref:System.IO.StreamWriter> , инкапсулирующий <xref:System.IO.FileStream> может использоваться для отправки сообщений об ошибках в файл.  
  
   
  
## Examples  
 Приведенный ниже показано, как перенаправлять стандартный поток ошибок в файл.  
  
 [!code-cpp[System.Console.SetError#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.SetError/cpp/seterror1.cpp#1)]
 [!code-csharp[System.Console.SetError#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.SetError/cs/SetError1.cs#1)]
 [!code-vb[System.Console.SetError#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.SetError/vb/SetError1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="newError" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="P:System.Console.IsErrorRedirected" />
        <altmember cref="P:System.Console.Error" />
      </Docs>
    </Member>
    <Member MemberName="SetIn">
      <MemberSignature Language="C#" Value="public static void SetIn (System.IO.TextReader newIn);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetIn(class System.IO.TextReader newIn) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetIn(System.IO.TextReader)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetIn (newIn As TextReader)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetIn(System::IO::TextReader ^ newIn);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newIn" Type="System.IO.TextReader" />
      </Parameters>
      <Docs>
        <param name="newIn">Поток, являющийся новым стандартным входным потоком.</param>
        <summary>Присваивает свойству <see cref="P:System.Console.In" /> указанный объект <see cref="T:System.IO.TextReader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Console.In%2A> задано значение стандартного входного потока.  
  
 Объект <xref:System.IO.StreamReader> , инкапсулирующий <xref:System.IO.FileStream> может использоваться для получения входных данных из файла.  
  
   
  
## Examples  
 В следующем примере показано использование метода <xref:System.Console.SetIn%2A>. Он заменяет 4 последовательных пробела в строке символом табуляции. Чтобы запустить ее, необходимо указать два аргумента командной строки. Первый аргумент — это имя существующего текстового файла, в который требуется перенаправить стандартный входной поток. Второй аргумент — это имя файла, в который требуется перенаправить стандартный выходной поток. Не требуется, чтобы этот файл существовал. Если да, его содержимое будут перезаписано.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="newIn" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.TextReader" />
        <altmember cref="P:System.Console.In" />
      </Docs>
    </Member>
    <Member MemberName="SetOut">
      <MemberSignature Language="C#" Value="public static void SetOut (System.IO.TextWriter newOut);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetOut(class System.IO.TextWriter newOut) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetOut(System.IO.TextWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetOut (newOut As TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetOut(System::IO::TextWriter ^ newOut);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="newOut" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="newOut">Поток, являющийся новым стандартным выходным потоком.</param>
        <summary>Присваивает свойству <see cref="P:System.Console.Out" /> указанный объект <see cref="T:System.IO.TextWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию <xref:System.Console.Out%2A> задано значение в стандартный выходной поток.  
  
 Объект <xref:System.IO.StreamWriter> , инкапсулирующий <xref:System.IO.FileStream> может использоваться для отправки выходных данных в файл. Пример:  
  
 [!code-cpp[System.Console.SetOut#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.console.setout/cpp/source.cpp#1)]
 [!code-csharp[System.Console.SetOut#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.setout/cs/source.cs#1)]
 [!code-vb[System.Console.SetOut#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.setout/vb/source.vb#1)]  
  
   
  
## Examples  
 В следующем примере показано использование метода <xref:System.Console.SetOut%2A>. Он заменяет 4 последовательных пробела в строке символом табуляции. Чтобы запустить ее, необходимо указать два аргумента командной строки. Первый аргумент — это имя существующего текстового файла, в который требуется перенаправить стандартный входной поток. Второй аргумент — это имя файла, в который требуется перенаправить стандартный выходной поток. Не требуется, чтобы этот файл существовал. Если да, его содержимое будут перезаписано.  
  
 [!code-cpp[System.Console-INSERTTABS#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CPP/inserttabs.cpp#1)]
 [!code-csharp[System.Console-INSERTTABS#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-INSERTTABS/CS/inserttabs.cs#1)]
 [!code-vb[System.Console-INSERTTABS#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-INSERTTABS/VB/inserttabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="newOut" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для вызова неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <altmember cref="T:System.IO.TextWriter" />
        <altmember cref="P:System.Console.Out" />
      </Docs>
    </Member>
    <Member MemberName="SetWindowPosition">
      <MemberSignature Language="C#" Value="public static void SetWindowPosition (int left, int top);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetWindowPosition(int32 left, int32 top) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetWindowPosition(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetWindowPosition (left As Integer, top As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetWindowPosition(int left, int top);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int32" />
        <Parameter Name="top" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="left">Позиция столбца верхнего левого угла окна консоли.</param>
        <param name="top">Позиция строки верхнего левого угла окна консоли.</param>
        <summary>Задает позицию окна консоли относительно буфера экрана.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В окне операционной системы отображаются в окне консоли, а в окне консоли отображается часть буфера экрана. <xref:System.Console.SetWindowPosition%2A> Метод влияет на позицию окна консоли относительно буфера экрана, но не влияет на положение окна операционной системы относительно рабочего стола.  
  
 Консоль и операционной системы windows обычно не влияют друг с другом. Однако буфера экрана не может быть отображен в текущих границах окна консоли, операционная система автоматически добавляет полосы прокрутки окна операционной системы. В этом случае перемещение полос прокрутки окна операционной системы влияет на позицию окна консоли, и перемещение окна консоли с <xref:System.Console.SetWindowPosition%2A> метод влияет на положение полосы прокрутки окна операционной системы.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Console.WindowLeft%2A>, <xref:System.Console.WindowTop%2A>, <xref:System.Console.WindowWidth%2A>, <xref:System.Console.WindowHeight%2A>, <xref:System.Console.BufferWidth%2A>, <xref:System.Console.BufferHeight%2A>, и <xref:System.Console.CursorVisible%2A> его свойства и <xref:System.Console.SetWindowPosition%2A>, <xref:System.Console.SetBufferSize%2A>, и <xref:System.Console.ReadKey%2A> методы. В примере рисуется сетка в буфере экрана, исходя из ширины буфера экрана. Затем в примере показано перемещение окна консоли в ответ на который стрелка вверх, нажатия клавиш консоли Стрелка вправо, Стрелка влево или вправо. Сетка помогает видеть перемещение окна консоли относительно буфера экрана.  
  
 [!code-cpp[console.windowLT#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.windowLT/CPP/wlt.cpp#1)]
 [!code-csharp[console.windowLT#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.windowLT/CS/wlt.cs#1)]
 [!code-vb[console.windowLT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.windowLT/VB/wlt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="left" /> или <paramref name="top" /> меньше нуля.  
  
 - или -  
  
 <paramref name="left" /> + <see cref="P:System.Console.WindowWidth" /> больше <see cref="P:System.Console.BufferWidth" />.  
  
 - или -  
  
 <paramref name="top" /> + <see cref="P:System.Console.WindowHeight" /> больше <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SetWindowSize">
      <MemberSignature Language="C#" Value="public static void SetWindowSize (int width, int height);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetWindowSize(int32 width, int32 height) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.SetWindowSize(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetWindowSize (width As Integer, height As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetWindowSize(int width, int height);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="width" Type="System.Int32" />
        <Parameter Name="height" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="width">Ширина окна консоли измеряется столбцами.</param>
        <param name="height">Высота окна консоли измеряется строками.</param>
        <summary>Устанавливает заданные значения высоты и ширины окна консоли.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере демонстрируется <xref:System.Console.SetWindowSize%2A> метода и <xref:System.Console.WindowWidth%2A> и <xref:System.Console.WindowHeight%2A> свойства. Необходимо запустить пример, чтобы увидеть полный эффект от изменения размера окна консоли.  
  
 В примере выводятся размеры окна консоли, установленные равными 85 столбцам и 43 строкам, а затем ожидает нажатия клавиши. При любой клавиши размеры окна консоли уменьшаются вдвое, выводятся новые размеры и код ожидает другой клавиши. Наконец когда клавиша нажата, восстанавливаются исходные размеры окна консоли и кода данного примера завершается.  
  
 [!code-cpp[console.setwindowsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.setwindowsize/CPP/sws.cpp#1)]
 [!code-csharp[console.setwindowsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.setwindowsize/CS/sws.cs#1)]
 [!code-vb[console.setwindowsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.setwindowsize/VB/sws.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="width" /> или <paramref name="height" /> меньше или равно нулю.  
  
 - или -  
  
 <paramref name="width" /> плюс <see cref="P:System.Console.WindowLeft" /> или <paramref name="height" /> плюс <see cref="P:System.Console.WindowTop" /> больше или равно <see cref="F:System.Int16.MaxValue" />.  
  
 - или -  
  
 Значение <paramref name="width" /> или <paramref name="height" /> больше наибольшей возможной ширины или высоты окна для текущего разрешения экрана и шрифта консоли.</exception>
        <exception cref="T:System.Security.SecurityException">Пользователь не имеет разрешений на выполнение этого действия.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="Title">
      <MemberSignature Language="C#" Value="public static string Title { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string Title" />
      <MemberSignature Language="DocId" Value="P:System.Console.Title" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Title As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ Title { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает заголовок для отображения в строке заголовка консоли.</summary>
        <value>Строка для отображения в строке заголовка консоли. Максимальная длина строки заголовка — 24500 символов.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В этом примере демонстрируется <xref:System.Console.Title%2A> свойство. В примере содержится заголовок текущей окна операционной системы, ожидает нажатие клавиши, а затем отображает новый заголовок.  
  
 [!code-cpp[console.title#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.title/CPP/mytitle.cpp#1)]
 [!code-csharp[console.title#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.title/CS/mytitle.cs#1)]
 [!code-vb[console.title#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.title/VB/mytitle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">В операции get длина полученного заголовка превышает 24 500 символов.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">В операции set длина указанного заголовка превышает 24 500 символов.</exception>
        <exception cref="T:System.ArgumentNullException">В операции set указанный заголовок имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TreatControlCAsInput">
      <MemberSignature Language="C#" Value="public static bool TreatControlCAsInput { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool TreatControlCAsInput" />
      <MemberSignature Language="DocId" Value="P:System.Console.TreatControlCAsInput" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property TreatControlCAsInput As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool TreatControlCAsInput { bool get(); void set(bool value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает или задает значение, указывающее, интерпретируется ли комбинация клавиши-модификатора <see cref="F:System.ConsoleModifiers.Control" /> и клавиши консоли <see cref="F:System.ConsoleKey.C" /> (Ctrl+C) как обычный ввод или как прерывание, которое обрабатывается операционной системой.</summary>
        <value>
          Значение <see langword="true" />, если сочетание клавиш CTRL+C интерпретируется как обычный ввод; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение <xref:System.Console.TreatControlCAsInput%2A> свойство `false` и нажатии Ctrl + C, нажатых клавиш не хранятся в буфере ввода и операционная система прекращает выполнение текущего выполняемого процесса. Это значение по умолчанию.  
  
> [!CAUTION]
>  Использовать это свойство осмотрительно, так как значения этого свойства `true` имеет существенное влияние. Большинство пользователи ожидают, что сочетание клавиш Ctrl + C, чтобы завершить консольное приложение. При отключении эффект Ctrl + C, пользователю придется использовать завершить работу приложения, который является менее известное сочетание клавиш Ctrl + Break.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Console.TreatControlCAsInput%2A> свойство.  
  
 [!code-cpp[console.readkey1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.readkey1/CPP/rk.cpp#1)]
 [!code-csharp[console.readkey1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.readkey1/CS/rk.cs#1)]
 [!code-vb[console.readkey1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.readkey1/VB/rk.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Не удалось получить или задать режим ввода входного буфера консоли.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="F:System.ConsoleModifiers.Control" />
        <altmember cref="F:System.ConsoleKey.C" />
        <altmember cref="E:System.Console.CancelKeyPress" />
      </Docs>
    </Member>
    <Member MemberName="WindowHeight">
      <MemberSignature Language="C#" Value="public static int WindowHeight { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowHeight" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowHeight" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowHeight As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowHeight { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает высоту области окна консоли.</summary>
        <value>Высота окна консоли измеряется строками.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Попытка задать значение <xref:System.Console.WindowHeight%2A> при перенаправлении вывода вызывает либо <xref:System.ArgumentOutOfRangeException> или <xref:System.IO.IOException> исключение. Чтобы предотвратить исключение, можно задать значение этого свойства только в том случае, если <xref:System.Console.IsOutputRedirected%2A> возвращает `false`.  
  
   
  
## Examples  
 В этом примере демонстрируется <xref:System.Console.SetWindowSize%2A> метода и <xref:System.Console.WindowWidth%2A> и <xref:System.Console.WindowHeight%2A> свойства. Необходимо запустить пример, чтобы увидеть полный эффект от изменения размера окна консоли.  
  
 В примере выводятся размеры окна консоли, установленные равными 85 столбцам и 43 строкам, а затем ожидает нажатие клавиши. При любой клавиши размеры окна консоли уменьшаются вдвое, выводятся новые размеры и код ожидает другой клавиши. Наконец когда клавиша нажата восстанавливаются исходные размеры окна консоли и кода данного примера завершается.  
  
 [!code-cpp[console.setwindowsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.setwindowsize/CPP/sws.cpp#1)]
 [!code-csharp[console.setwindowsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.setwindowsize/CS/sws.cs#1)]
 [!code-vb[console.setwindowsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.setwindowsize/VB/sws.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение свойства <see cref="P:System.Console.WindowWidth" /> или <see cref="P:System.Console.WindowHeight" /> больше или равно 0.  
  
 - или -  
  
 Сумма значений свойств <see cref="P:System.Console.WindowHeight" /> и <see cref="P:System.Console.WindowTop" /> больше или равна <see cref="F:System.Int16.MaxValue" />.  
  
 - или -  
  
 Значение свойства <see cref="P:System.Console.WindowWidth" /> или <see cref="P:System.Console.WindowHeight" /> больше наибольшей возможной ширины или высоты окна для текущего шрифта консоли и разрешения экрана.</exception>
        <exception cref="T:System.IO.IOException">Ошибка при чтении или записи данных.</exception>
      </Docs>
    </Member>
    <Member MemberName="WindowLeft">
      <MemberSignature Language="C#" Value="public static int WindowLeft { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowLeft" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowLeft" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowLeft As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowLeft { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает позицию левого края области окна консоли относительно буфера экрана.</summary>
        <value>Позиция левого края области окна консоли измеряется столбцами.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Консоль представляет прямоугольное окно в большей области буфера. Окна и буфере измеряются вертикально по их количеству строк и горизонтально по их количеству столбцов. Измерений буферной области определяются <xref:System.Console.BufferHeight%2A> и <xref:System.Console.BufferWidth%2A> свойства. Размеры области консоли, определяются <xref:System.Console.WindowHeight%2A> и <xref:System.Console.WindowWidth%2A> свойства. <xref:System.Console.WindowLeft%2A> Свойство определяет, какой столбец буферной области отображается в первом столбце окна консоли. Значение <xref:System.Console.WindowLeft%2A> свойства допустимы значения от 0 до <xref:System.Console.BufferWidth%2A>  -  <xref:System.Console.WindowWidth%2A>. Попытка присвоить значение за пределами этого диапазона возникает исключение <xref:System.ArgumentOutOfRangeException>.  
  
 При первом открытии окна консоли, значение по умолчанию <xref:System.Console.WindowLeft%2A> свойство имеет значение 0, который указывает, что первый столбец, показанный в консоли соответствует первому столбцу (столбцу с нулевой позицией) в буферной области. Ширину окна консоли и области буфера по умолчанию равно 80. Это означает, что <xref:System.Console.WindowLeft%2A> свойство можно изменять только в том случае, если окно консоли станет уже или области буфера.  
  
 Обратите внимание, что если ширина буферной области превышает ширину окна консоли значение <xref:System.Console.WindowLeft%2A> свойства автоматически корректируется при использовании пользователем горизонтальной полосы прокрутки для определения отношения в буферной области.  
  
 Попытка задать значение <xref:System.Console.WindowLeft%2A> свойство при выводе результата не перенаправлен вызывает <xref:System.IO.IOException> исключение. Чтобы избежать возникновения исключения, можно задать значение этого свойства только в том случае, если <xref:System.Console.IsOutputRedirected%2A> возвращает `false`.  
  
   
  
## Examples  
 В следующем примере открывается окно консоли столбца 80 и определяет область буфера шириной 120 столбцов. Отображает сведения об окне и размере буфера и ждет пользователю нажать клавишу со стрелкой влево или Стрелка вправо. В первом случае он уменьшает значение <xref:System.Console.WindowLeft%2A> свойства на единицу, если результат является допустимым значением. В последнем случае оно увеличивается значение <xref:System.Console.WindowLeft%2A> свойства на единицу, если результат должен быть допустимым. Обратите внимание, что пример не должен обрабатывать <xref:System.ArgumentOutOfRangeException>, так как он проверяет, что значение, присваиваемое <xref:System.Console.WindowLeft%2A> свойство не является отрицательным и не приводит к сумме <xref:System.Console.WindowLeft%2A> и <xref:System.Console.WindowWidth%2A> свойства к превышению <xref:System.Console.BufferWidth%2A> значение свойства.  
  
 [!code-cpp[System.Console.WindowLeft#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.console.windowleft/cpp/windowleft1.cpp#1)]
 [!code-csharp[System.Console.WindowLeft#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.windowleft/cs/windowleft1.cs#1)]
 [!code-vb[System.Console.WindowLeft#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.windowleft/vb/windowleft1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">В операции задания назначаемое значение меньше нуля.  
  
 - или -  
  
 В результате назначения сумма <see cref="P:System.Console.WindowLeft" /> и <see cref="P:System.Console.WindowWidth" /> превысит <see cref="P:System.Console.BufferWidth" />.</exception>
        <exception cref="T:System.IO.IOException">Ошибка при чтении или записи данных.</exception>
      </Docs>
    </Member>
    <Member MemberName="WindowTop">
      <MemberSignature Language="C#" Value="public static int WindowTop { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowTop" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowTop" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowTop As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowTop { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает позицию верхнего края области окна консоли относительно буфера экрана.</summary>
        <value>Позиция верхнего края области окна консоли измеряется строками.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Консоль представляет прямоугольное окно в большей области буфера. Окна и буфере измеряются вертикально по их количеству строк и горизонтально по их количеству столбцов. Измерений буферной области определяются <xref:System.Console.BufferHeight%2A> и <xref:System.Console.BufferWidth%2A> свойства. Размеры области консоли, определяются <xref:System.Console.WindowHeight%2A> и <xref:System.Console.WindowWidth%2A> свойства. <xref:System.Console.WindowTop%2A> Свойство определяет, какая строка буферной области отображается в первом столбце окна консоли. Значение <xref:System.Console.WindowTop%2A> свойства допустимы значения от 0 до <xref:System.Console.BufferHeight%2A>  -  <xref:System.Console.WindowHeight%2A>. Попытка присвоить значение за пределами этого диапазона возникает исключение <xref:System.ArgumentOutOfRangeException>.  
  
 Попытка задать значение <xref:System.Console.WindowTop%2A> свойство при выводе результата не перенаправлен вызывает <xref:System.IO.IOException> исключение. Чтобы избежать возникновения исключения, можно задать значение этого свойства только в том случае, если <xref:System.Console.IsOutputRedirected%2A> возвращает `false`.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Console.WindowLeft%2A>, <xref:System.Console.WindowTop%2A>, <xref:System.Console.WindowWidth%2A>, <xref:System.Console.WindowHeight%2A>, <xref:System.Console.BufferWidth%2A>, <xref:System.Console.BufferHeight%2A>, и <xref:System.Console.CursorVisible%2A> его свойства и <xref:System.Console.SetWindowPosition%2A>, <xref:System.Console.SetBufferSize%2A>, и <xref:System.Console.ReadKey%2A> методы. В примере рисуется сетка в буфере экрана, исходя из ширины буфера экрана. Затем в примере показано перемещение окна консоли в ответ на который стрелка вверх, нажатия клавиш консоли Стрелка вправо, Стрелка влево или вправо. Сетка помогает видеть перемещение окна консоли относительно буфера экрана.  
  
 [!code-cpp[console.windowLT#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.windowLT/CPP/wlt.cpp#1)]
 [!code-csharp[console.windowLT#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.windowLT/CS/wlt.cs#1)]
 [!code-vb[console.windowLT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.windowLT/VB/wlt.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">В операции задания назначаемое значение меньше нуля.  
  
 - или -  
  
 В результате назначения сумма <see cref="P:System.Console.WindowTop" /> и <see cref="P:System.Console.WindowHeight" /> превысит <see cref="P:System.Console.BufferHeight" />.</exception>
        <exception cref="T:System.IO.IOException">Ошибка при чтении или записи данных.</exception>
      </Docs>
    </Member>
    <Member MemberName="WindowWidth">
      <MemberSignature Language="C#" Value="public static int WindowWidth { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 WindowWidth" />
      <MemberSignature Language="DocId" Value="P:System.Console.WindowWidth" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property WindowWidth As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int WindowWidth { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает ширину окна консоли.</summary>
        <value>Ширина окна консоли измеряется столбцами.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Попытка задать значение <xref:System.Console.WindowWidth%2A> при перенаправлении вывода вызывает либо <xref:System.ArgumentOutOfRangeException> или <xref:System.IO.IOException> исключение. Чтобы предотвратить исключение, можно задать значение этого свойства только в том случае, если <xref:System.Console.IsOutputRedirected%2A> возвращает `false`.  
  
   
  
## Examples  
 В этом примере демонстрируется <xref:System.Console.SetWindowSize%2A> метода и <xref:System.Console.WindowWidth%2A> и <xref:System.Console.WindowHeight%2A> свойства. Необходимо запустить пример, чтобы увидеть полный эффект от изменения размера окна консоли.  
  
 В примере выводятся размеры окна консоли, установленные равными 85 столбцам и 43 строкам, а затем ожидает нажатие клавиши. При любой клавиши размеры окна консоли уменьшаются вдвое, выводятся новые размеры и код ожидает другой клавиши. Наконец когда клавиша нажата восстанавливаются исходные размеры окна консоли и кода данного примера завершается.  
  
 [!code-cpp[console.setwindowsize#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.setwindowsize/CPP/sws.cpp#1)]
 [!code-csharp[console.setwindowsize#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.setwindowsize/CS/sws.cs#1)]
 [!code-vb[console.setwindowsize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.setwindowsize/VB/sws.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение свойства <see cref="P:System.Console.WindowWidth" /> или <see cref="P:System.Console.WindowHeight" /> больше или равно 0.  
  
 - или -  
  
 Сумма значений свойств <see cref="P:System.Console.WindowHeight" /> и <see cref="P:System.Console.WindowTop" /> больше или равна <see cref="F:System.Int16.MaxValue" />.  
  
 - или -  
  
 Значение свойства <see cref="P:System.Console.WindowWidth" /> или <see cref="P:System.Console.WindowHeight" /> больше наибольшей возможной ширины или высоты окна для текущего шрифта консоли и разрешения экрана.</exception>
        <exception cref="T:System.IO.IOException">Ошибка при чтении или записи данных.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Write">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Записывает текстовое представление заданного значения или значений в стандартный выходной поток.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(bool value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного логического значения в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.Boolean.ToString%2A?displayProperty=nameWithType>, возвращающего значение <xref:System.Boolean.TrueString?displayProperty=nameWithType> или <xref:System.Boolean.FalseString?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает значение заданного знака Юникода в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (char[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(char[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (buffer As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(cli::array &lt;char&gt; ^ buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив знаков Юникода.</param>
        <summary>Записывает заданный массив знаков Юникода в стандартный выходной поток.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного значения <see cref="T:System.Decimal" /> в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.Decimal.ToString%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного значения двойной точности с плавающей запятой в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.Double.ToString%2A?displayProperty=nameWithType> метод.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного 32-битового целого числа со знаком в стандартный поток вывода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.Int32.ToString%2A?displayProperty=nameWithType> метод.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного 64-битового целого числа со знаком в стандартный поток вывода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.Int64.ToString%2A?displayProperty=nameWithType> метод.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Записываемое значение или <see langword="null" />.</param>
        <summary>Записывает текстовое представление заданного объекта в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `value` — `null`, ничего не записывается, и исключение не возникает. В противном случае `ToString` метод `value` вызывается для получения строкового представления, а результирующая строка записывается в стандартный выходной поток.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного значения одинарной точности с плавающей запятой в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.Single.ToString%2A?displayProperty=nameWithType> метод.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает заданное строковое значение в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение равно `null`, ничего не записывается в стандартный выходной поток.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного 32-битового целого числа без знака в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> метод.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного 64-битового целого числа без знака в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> метод.  
  
   
  
## Examples  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Объект для записи с использованием <c>format</c>.</param>
        <summary>Записывает текстовое представление заданного объекта в стандартный выходной поток, используя заданные сведения о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составное форматирование](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework, чтобы преобразовать значение объекта в его текстовое представление и встроить это представление в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр состоит из нуля или больше текста, перемежаемых ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют объекту в списке параметров данного метода. В процессе форматирования каждый элемент формата заменяется текстовое представление значения соответствующего объекта.  
  
 Синтаксис элементов форматирования `{` *индекс*[`,`*выравнивание*] [`:`*formatString*]`}`, который указывает Обязательный индекса, необязательно длину и выравнивание форматированного текста и необязательная строка символов описателя формата, определяющих способ форматирования значения соответствующего объекта.  
  
 Платформа .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах о форматировании.  
  
-   Дополнительные сведения о составного форматирования, поддерживаемые методами, такими как <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>и некоторые перегрузки <xref:System.Console.WriteLine%2A>, в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения об описателях числового формата см. в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о дате и времени описатели формата см. в разделе [стандартной строки даты и времени формат](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательских строк даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения об описателях форматов перечисления см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 В следующем примере с помощью метода `WriteLine` демонстрируются стандартные описатели форматирования чисел, дат и значений перечислимых типов.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)] 
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 В следующем примере показано использование метода <xref:System.Console.Write%2A>.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, params object[] arg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object[] arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, ParamArray arg As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ arg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg">Массив объектов для записи с использованием <c>format</c>.</param>
        <summary>Записывает текстовое представление заданного массива объектов в стандартный выходной поток, используя заданные сведения о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составное форматирование](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework, чтобы преобразовать значение объекта в его текстовое представление и встроить это представление в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр состоит из нуля или больше текста, перемежаемых ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют объекту в списке параметров данного метода. В процессе форматирования каждый элемент формата заменяется текстовое представление значения соответствующего объекта.  
  
 Синтаксис элементов форматирования `{` *индекс*[`,`*выравнивание*] [`:`*formatString*]`}`, который указывает Обязательный индекса, необязательно длину и выравнивание форматированного текста и необязательная строка символов описателя формата, определяющих способ форматирования значения соответствующего объекта.  
  
 Платформа .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах о форматировании.  
  
-   Дополнительные сведения о составного форматирования, поддерживаемые методами, такими как <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>и некоторые перегрузки <xref:System.Console.WriteLine%2A>, в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения об описателях числового формата см. в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о дате и времени описатели формата см. в разделе [стандартной строки даты и времени формат](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательских строк даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения об описателях форматов перечисления см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 `arg` Параметр является массивом параметров. Аргументы могут быть переданы в метод, как массив или как список из пяти или более элементов. В примерах показаны обе формы вызова метода.  
  
   
  
## Examples  
 В следующем примере определяется `Person` класс ряд свойств, предоставляющих сведения о пользователе. Его `GetDescription` метод возвращает массив, содержащий все значения свойств, кроме одного. Затем в примере используется массив, возвращаемый методом `GetDescription` метод для отображения значений объекта пользователя.  
  
 [!code-csharp[System.Console.Write#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.write/cs/WriteParams1.cs#1)]
 [!code-vb[System.Console.Write#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.write/vb/WriteParams1.vb#1)]  
  
 Обратите внимание, что в примере вызывается <xref:System.Console.Write%28System.String%2CSystem.Object%5B%5D%29> метод вместо <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29> метода, так как он пытается отобразить значение `Person.Remarks` свойства в той же строке. Чтобы сделать это, он проверяет значение <xref:System.Console.CursorLeft%2A> и <xref:System.Console.WindowWidth%2A> свойства, чтобы определить, является ли достаточно места для замечания по размеру.  Если нет, она отображает строку. В противном случае он записывает строку, отступы три пробела и отображает замечания.  
  
 Следующий пример идентичен первому, за исключением того, что он передает список пяти элементов в качестве `arg` аргумент вместо массива параметров.  
  
 [!code-csharp[System.Console.Write#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.console.write/cs/WriteParams2.cs#2)]
 [!code-vb[System.Console.Write#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.console.write/vb/WriteParams2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="format" /> или <paramref name="arg" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage">
          <para>Этот метод не вызывается кодом C++. Компилятор C++ разрешает вызовы к [System.Console.Write](xref:System.Console.Write*) включать строки и список четырьмя или более параметров объекта как вызов <see cref="M:System.Console.Write(System.String,System.Object,System.Object,System.Object,System.Object)" />. Он разрешает вызовы к [System.Console.Write](xref:System.Console.Write*) строки и массив объектов, содержащих как вызов <see cref="M:System.Console.Write(System.String,System.Object)" />.</para>
        </block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив знаков Юникода.</param>
        <param name="index">Начальная позиция в массиве <c>buffer</c>.</param>
        <param name="count">Количество символов для записи.</param>
        <summary>Записывает заданный дочерний массив знаков Юникода в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод записывает `count` символов, начиная с позиции `index` из `buffer` в стандартный выходной поток.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException">
          Сумма <paramref name="index" /> и <paramref name="count" /> указывает позицию, которая не находится в <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object, arg1 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для записи с использованием <c>format</c>.</param>
        <param name="arg1">Второй объект для записи с использованием <c>format</c>.</param>
        <summary>Записывает текстовые представления заданных объектов в стандартный выходной поток, используя заданные сведения о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составное форматирование](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework, чтобы преобразовать значение объекта в его текстовое представление и встроить это представление в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр состоит из нуля или больше текста, перемежаемых ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют объекту в списке параметров данного метода. В процессе форматирования каждый элемент формата заменяется текстовое представление значения соответствующего объекта.  
  
 Синтаксис элементов форматирования `{` *индекс*[`,`*выравнивание*] [`:`*formatString*]`}`, который указывает Обязательный индекса, необязательно длину и выравнивание форматированного текста и необязательная строка символов описателя формата, определяющих способ форматирования значения соответствующего объекта.  
  
 Платформа .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах о форматировании.  
  
-   Дополнительные сведения о составного форматирования, поддерживаемые методами, такими как <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>и некоторые перегрузки <xref:System.Console.WriteLine%2A>, в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения об описателях числового формата см. в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о дате и времени описатели формата см. в разделе [стандартной строки даты и времени формат](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательских строк даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения об описателях форматов перечисления см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 В следующем примере с помощью метода `WriteLine` демонстрируются стандартные описатели форматирования чисел, дат и значений перечислимых типов.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object, arg1 As Object, arg2 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для записи с использованием <c>format</c>.</param>
        <param name="arg1">Второй объект для записи с использованием <c>format</c>.</param>
        <param name="arg2">Третий объект для записи с использованием <c>format</c>.</param>
        <summary>Записывает текстовые представления заданных объектов в стандартный выходной поток, используя заданные сведения о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составное форматирование](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework, чтобы преобразовать значение объекта в его текстовое представление и встроить это представление в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр состоит из нуля или больше текста, перемежаемых ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют объекту в списке параметров данного метода. В процессе форматирования каждый элемент формата заменяется текстовое представление значения соответствующего объекта.  
  
 Синтаксис элементов форматирования `{` *индекс*[`,`*выравнивание*] [`:`*formatString*]`}`, который указывает Обязательный индекса, необязательно длину и выравнивание форматированного текста и необязательная строка символов описателя формата, определяющих способ форматирования значения соответствующего объекта.  
  
 Платформа .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах о форматировании.  
  
-   Дополнительные сведения о составного форматирования, поддерживаемые методами, такими как <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>и некоторые перегрузки <xref:System.Console.WriteLine%2A>, в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения об описателях числового формата см. в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о дате и времени описатели формата см. в разделе [стандартной строки даты и времени формат](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательских строк даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения об описателях форматов перечисления см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 В следующем примере с помощью метода `WriteLine` демонстрируются стандартные описатели форматирования чисел, дат и значений перечислимых типов.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 В следующем примере показано использование метода `Write`.  
  
 [!code-cpp[System.Console-REFORMAT#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console-REFORMAT/CPP/reformat.cpp#1)]
 [!code-csharp[System.Console-REFORMAT#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console-REFORMAT/CS/reformat.cs#1)]
 [!code-vb[System.Console-REFORMAT#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console-REFORMAT/VB/reformat.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (string format, object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Write(string format, object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.Write(System.String,System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Write (format As String, arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для записи с использованием <c>format</c>.</param>
        <param name="arg1">Второй объект для записи с использованием <c>format</c>.</param>
        <param name="arg2">Третий объект для записи с использованием <c>format</c>.</param>
        <param name="arg3">Четвертый объект для записи с использованием <c>format</c>.</param>
        <summary>Записывает текстовое представление заданных объектов и список параметров переменной длины в стандартный выходной поток, используя заданные сведения о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Этот интерфейс API CLS-несовместим. CLS-совместимая альтернатива — <xref:System.Console.Write%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>. Компиляторы C# и Visual Basic автоматически разрешить вызов этого метода, как вызов <xref:System.Console.Write%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 Этот метод использует [составное форматирование](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework, чтобы преобразовать значение объекта в его текстовое представление и встроить это представление в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр состоит из нуля или больше текста, перемежаемых ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют объекту в списке параметров данного метода. В процессе форматирования каждый элемент формата заменяется текстовое представление значения соответствующего объекта.  
  
 Синтаксис элементов форматирования `{` *индекс*[`,`*выравнивание*] [`:`*formatString*]`}`, который указывает Обязательный индекса, необязательно длину и выравнивание форматированного текста и необязательная строка символов описателя формата, определяющих способ форматирования значения соответствующего объекта.  
  
 Платформа .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах о форматировании.  
  
-   Дополнительные сведения о составного форматирования, поддерживаемые методами, такими как <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>и некоторые перегрузки <xref:System.Console.WriteLine%2A>, в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения об описателях числового формата см. в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о дате и времени описатели формата см. в разделе [стандартной строки даты и времени формат](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательских строк даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения об описателях форматов перечисления см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 В следующем примере показано использование переменной параметров с <xref:System.Console.Write%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> метод. Метод вызывается с Строка составного формата и пятью элементами формата.  
  
 [!code-cpp[System.Console.Write#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.console.write/cpp/con_write.cpp#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage">
          <para>Этот метод помечен атрибутом <see langword="vararg" /> ключевое слово, которое означает, что он поддерживает переменное число параметров. Метод может вызываться из Visual C++, но не может вызываться из кода C# или Visual Basic. Компиляторы C# и Visual Basic разрешить вызовы <see cref="M:System.Console.Write(System.String,System.Object,System.Object,System.Object,System.Object)" /> как вызов <see cref="M:System.Console.Write(System.String,System.Object[])" />.</para>
        </block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.WriteLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WriteLine">
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Записывает указанные данные с текущим признаком конца строки в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию признаком конца строки является строкой, значение которого является возврат каретки, перевода строки («\r\n» в C# или `vbCrLf` в Visual Basic). Признак конца строки можно изменить, задав <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> свойство <xref:System.Console.Out%2A> свойство в другую строку.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Записывает текущий признак конца строки в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По умолчанию признаком конца строки является строкой, значение которого является возврат каретки, перевода строки («\r\n» в C# или `vbCrLf` в Visual Basic). Признак конца строки можно изменить, задав <xref:System.IO.TextWriter.NewLine%2A?displayProperty=nameWithType> свойство <xref:System.Console.Out%2A> свойство в другую строку. Иллюстрация приведена в примере.  
  
   
  
## Examples  
 В примере изменяется признак конца строки со значением по умолчанию «\r\n» или `vbCrLf` для «\r\n\r\n» или `vbCrLf`  +  `vbCrLf`. Затем он вызывает <xref:System.Console.WriteLine> и <xref:System.Console.WriteLine%28System.String%29> методов для отображения вывода на консоль.  
  
 [!code-cpp[System.Console.WriteLine#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/newline1.cpp#2)]
 [!code-csharp[System.Console.WriteLine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/newline1.cs#2)]
 [!code-vb[System.Console.WriteLine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/newline1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
        <altmember cref="P:System.IO.TextWriter.NewLine" />
        <altmember cref="P:System.Console.Out" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (bool value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(bool value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(bool value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного логического значения с текущим признаком конца строки в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.Boolean.ToString%2A?displayProperty=nameWithType> метод.  
  
 Дополнительные сведения о признак конца строки, в разделе «Примечания» <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 Следующий пример приводит к возникновению ошибки десять случайных целых чисел и использует <xref:System.Console.WriteLine%28System.Boolean%29?displayProperty=nameWithType> метод для указания того, являются ли они даже.  
  
 [!code-cpp[System.Console.WriteLine#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/writeline_boolean1.cpp#4)]
 [!code-csharp[System.Console.WriteLine#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/writeline_boolean1.cs#4)]
 [!code-vb[System.Console.WriteLine#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/writeline_boolean1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (char value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(char value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(char value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает заданный знак Юникода, за которым следует текущий признак конца строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о признак конца строки, в разделе «Примечания» <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 В следующем примере представлен калькулятора совет, вычисляет совет 18% и использует <xref:System.Console.WriteLine%2A> метод для отображения сумму издержек, исходный объем совет и общую сумму. Пример является консольным приложением, которое пользователь должен ввести сумму исходной стоимости как параметр командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (char[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(char[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Char[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (buffer As Char())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(cli::array &lt;char&gt; ^ buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив знаков Юникода.</param>
        <summary>Записывает заданный массив знаков Юникода, за которым следует текущий признак конца строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о признак конца строки, в разделе «Примечания» <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::Decimal value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление указанного значения <see cref="T:System.Decimal" />, за которым следует текущий знак завершения строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.Decimal.ToString%2A?displayProperty=nameWithType> метод.  
  
 Дополнительные сведения о признак конца строки, в разделе «Примечания» <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 В следующем примере представлен калькулятора совет, вычисляет совет 18% и использует <xref:System.Console.WriteLine%2A> метод для отображения сумму издержек, исходный объем совет и общую сумму. Пример является консольным приложением, которое пользователь должен ввести сумму исходной стоимости как параметр командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(double value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного значения двойной точности с плавающей запятой, за которым следует признак конца строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.Double.ToString%2A?displayProperty=nameWithType> метод.  
  
 Дополнительные сведения о признак конца строки, в разделе «Примечания» <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 В следующем примере представлен калькулятора совет, вычисляет совет 18% и использует <xref:System.Console.WriteLine%2A> метод для отображения сумму издержек, исходный объем совет и общую сумму. Пример является консольным приложением, которое пользователь должен ввести сумму исходной стоимости как параметр командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного 32-битового целого числа со знаком, за которым следует текущий знак завершения строки, в стандартный поток вывода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.Int32.ToString%2A?displayProperty=nameWithType> метод.  
  
 Дополнительные сведения о признак конца строки, в разделе «Примечания» <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 В следующем примере представлен калькулятора совет, вычисляет совет 18% и использует <xref:System.Console.WriteLine%2A> метод для отображения сумму издержек, исходный объем совет и общую сумму. Пример является консольным приложением, которое пользователь должен ввести сумму исходной стоимости как параметр командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного 64-битового целого числа со знаком, за которым следует текущий знак завершения строки, в стандартный поток вывода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.Int64.ToString%2A?displayProperty=nameWithType> метод.  
  
 Дополнительные сведения о признак конца строки, в разделе «Примечания» <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 В следующем примере представлен калькулятора совет, вычисляет совет 18% и использует <xref:System.Console.WriteLine%2A> метод для отображения сумму издержек, исходный объем совет и общую сумму. Пример является консольным приложением, которое пользователь должен ввести сумму исходной стоимости как параметр командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::Object ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного объекта, за которым следует текущий признак конца строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `value` имеет значение `null`, записывается только признак конца строки. В противном случае `ToString` метод `value` вызывается для получения строкового представления, а результирующая строка записывается в стандартный выходной поток.  
  
 Дополнительные сведения о признак конца строки, в разделе «Примечания» <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Console.WriteLine%28System.Object%29> метод для отображения каждого значения в массиве объектов на консоль.  
  
 [!code-cpp[System.Console.WriteLine#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/writeline_obj1.cpp#3)]
 [!code-csharp[System.Console.WriteLine#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/writeline_obj1.cs#3)]
 [!code-vb[System.Console.WriteLine#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/writeline_obj1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(float value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного значения одинарной точности с плавающей запятой, за которым следует признак конца строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.Single.ToString%2A?displayProperty=nameWithType> метод.  
  
 Дополнительные сведения о признак конца строки, в разделе «Примечания» <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 В следующем примере представлен калькулятора совет, вычисляет совет 18% и использует <xref:System.Console.WriteLine%2A> метод для отображения сумму издержек, исходный объем совет и общую сумму. Пример является консольным приложением, которое пользователь должен ввести сумму исходной стоимости как параметр командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает заданное строковое значение, за которым следует текущий признак конца строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если значение равно `null`, записывается только признак конца строки, в стандартный выходной поток.  
  
 Дополнительные сведения о признак конца строки, в разделе «Примечания» <xref:System.Console.WriteLine> метод.  
  
   
  
## Examples  
 В примере изменяется признак конца строки со значением по умолчанию «\r\n» или `vbCrLf` для «\r\n\r\n» или `vbCrLf`  +  `vbCrLf`. Затем он вызывает <xref:System.Console.WriteLine> и <xref:System.Console.WriteLine%28System.String%29> методов для отображения вывода на консоль.  
  
 [!code-cpp[System.Console.WriteLine#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/newline1.cpp#2)]
 [!code-csharp[System.Console.WriteLine#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/newline1.cs#2)]
 [!code-vb[System.Console.WriteLine#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/newline1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::UInt32 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного 32-битового целого числа без знака, за которым следует текущий признак конца строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.UInt32.ToString%2A?displayProperty=nameWithType> метод.  
  
 Дополнительные сведения о признак конца строки, в разделе «Примечания» <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 В следующем примере представлен калькулятора совет, вычисляет совет 18% и использует <xref:System.Console.WriteLine%2A> метод для отображения сумму издержек, исходный объем совет и общую сумму. Пример является консольным приложением, которое пользователь должен ввести сумму исходной стоимости как параметр командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::UInt64 value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Значение для записи.</param>
        <summary>Записывает текстовое представление заданного 64-битового целого числа без знака, за которым следует текущий признак конца строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Текстовое представление `value` получается при вызове метода <xref:System.UInt64.ToString%2A?displayProperty=nameWithType> метод.  
  
 Дополнительные сведения о признак конца строки, в разделе «Примечания» <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 В следующем примере представлен калькулятора совет, вычисляет совет 18% и использует <xref:System.Console.WriteLine%2A> метод для отображения сумму издержек, исходный объем совет и общую сумму. Пример является консольным приложением, которое пользователь должен ввести сумму исходной стоимости как параметр командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Объект для записи с использованием <c>format</c>.</param>
        <summary>Записывает текстовое представление заданного объекта, за которым следует текущий признак конца строки, в стандартный выходной поток с использованием заданных сведений о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составное форматирование](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework, чтобы преобразовать значение объекта в его текстовое представление и встроить это представление в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр состоит из нуля или больше текста, перемежаемых ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют объекту в списке параметров данного метода. В процессе форматирования каждый элемент формата заменяется текстовое представление значения соответствующего объекта.  
  
 Синтаксис элементов форматирования `{` *индекс*[`,`*выравнивание*] [`:`*formatString*]`}`, который указывает Обязательный индекса, необязательно длину и выравнивание форматированного текста и необязательная строка символов описателя формата, определяющих способ форматирования значения соответствующего объекта.  
  
 Платформа .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах о форматировании.  
  
-   Дополнительные сведения о составного форматирования, поддерживаемые методами, такими как <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>и некоторые перегрузки <xref:System.Console.WriteLine%2A>, в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения об описателях числового формата см. в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о дате и времени описатели формата см. в разделе [стандартной строки даты и времени формат](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательских строк даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения об описателях форматов перечисления см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 Дополнительные сведения о признак конца строки, в разделе «Примечания» <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 В следующем примере вызывается <xref:System.Console.WriteLine%28System.String%2CSystem.Object%29> метод для отображения пяти формируется случайным образом <xref:System.Boolean> значения.  
  
 [!code-csharp[System.Console.WriteLine#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/WriteLine6.cs#6)]
 [!code-vb[System.Console.WriteLine#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/WriteLine6.vb#6)]  
  
 В следующем примере вызывается <xref:System.Console.WriteLine%28System.String%2CSystem.Object%29> метод для отображения текущей даты.   Обратите внимание, что формат элементов в `format` «D» использует аргумент [стандартных форматов даты и времени строка](~/docs/standard/base-types/standard-date-and-time-format-strings.md) для отображения даты в длинном формате даты текущего языка и региональных параметров.  
  
 [!code-csharp[System.Console.WriteLine#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/WriteLine7.cs#7)]
 [!code-vb[System.Console.WriteLine#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/WriteLine7.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, params object[] arg);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object[] arg) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, ParamArray arg As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, ... cli::array &lt;System::Object ^&gt; ^ arg);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg">Массив объектов для записи с использованием <c>format</c>.</param>
        <summary>Записывает текстовые представления заданного массива объектов, за которым следует текущий признак конца строки, в стандартный выходной поток с использованием заданных сведений о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составное форматирование](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework, чтобы преобразовать значение объекта в его текстовое представление и встроить это представление в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр состоит из нуля или больше текста, перемежаемых ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют объекту в списке параметров данного метода. В процессе форматирования каждый элемент формата заменяется текстовое представление значения соответствующего объекта.  
  
 Синтаксис элементов форматирования `{` *индекс*[`,`*выравнивание*] [`:`*formatString*]`}`, который указывает Обязательный индекса, необязательно длину и выравнивание форматированного текста и необязательная строка символов описателя формата, определяющих способ форматирования значения соответствующего объекта.  
  
 Платформа .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах о форматировании.  
  
-   Дополнительные сведения о составного форматирования, поддерживаемые методами, такими как <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>и некоторые перегрузки <xref:System.Console.WriteLine%2A>, в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения об описателях числового формата см. в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о дате и времени описатели формата см. в разделе [стандартной строки даты и времени формат](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательских строк даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения об описателях форматов перечисления см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 Дополнительные сведения о признак конца строки, в разделе «Примечания» <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 В следующем примере демонстрируются стандартные описатели форматирования чисел, дат и значений перечислимых типов.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 В следующем примере представлен калькулятора совет, вычисляет совет 18% и использует <xref:System.Console.WriteLine%2A> метод для отображения сумму издержек, исходный объем совет и общую сумму. Пример является консольным приложением, которое пользователь должен ввести сумму исходной стоимости как параметр командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException">
          Параметр <paramref name="format" /> или <paramref name="arg" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage">
          <para>Этот метод не вызывается кодом C++. Компилятор C++ разрешает вызовы к [System.Console.WriteLine](xref:System.Console.WriteLine*) включать строки и список четырьмя или более параметров объекта как вызов <see cref="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)" />. Он разрешает вызовы к [System.Console.WriteLine](xref:System.Console.WriteLine*) строки и массив объектов, содержащих как вызов <see cref="M:System.Console.WriteLine(System.String,System.Object)" />.</para>
        </block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (char[] buffer, int index, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(char[] buffer, int32 index, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.Char[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (buffer As Char(), index As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(cli::array &lt;char&gt; ^ buffer, int index, int count);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Char[]" />
        <Parameter Name="index" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив знаков Юникода.</param>
        <param name="index">Начальная позиция в массиве <c>buffer</c>.</param>
        <param name="count">Количество символов для записи.</param>
        <summary>Записывает заданный подмассив знаков Юникода, за которым следует текущий признак конца строки, в стандартный выходной поток.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод записывает `count` символов, начиная с позиции `index` из `buffer` в стандартный выходной поток.  
  
 Дополнительные сведения о признак конца строки, в разделе «Примечания» <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="index" /> или <paramref name="count" /> меньше нуля.</exception>
        <exception cref="T:System.ArgumentException">
          Сумма <paramref name="index" /> и <paramref name="count" /> указывает позицию, которая не находится в <paramref name="buffer" />.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0, object arg1);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0, object arg1) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object, arg1 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для записи с использованием <c>format</c>.</param>
        <param name="arg1">Второй объект для записи с использованием <c>format</c>.</param>
        <summary>Записывает текстовые представления заданных объектов, за которыми следует текущий признак конца строки, в стандартный выходной поток с использованием заданных сведений о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составное форматирование](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework, чтобы преобразовать значение объекта в его текстовое представление и встроить это представление в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр состоит из нуля или больше текста, перемежаемых ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют объекту в списке параметров данного метода. В процессе форматирования каждый элемент формата заменяется текстовое представление значения соответствующего объекта.  
  
 Синтаксис элементов форматирования `{` *индекс*[`,`*выравнивание*] [`:`*formatString*]`}`, который указывает Обязательный индекса, необязательно длину и выравнивание форматированного текста и необязательная строка символов описателя формата, определяющих способ форматирования значения соответствующего объекта.  
  
 Платформа .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах о форматировании.  
  
-   Дополнительные сведения о составного форматирования, поддерживаемые методами, такими как <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>и некоторые перегрузки <xref:System.Console.WriteLine%2A>, в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения об описателях числового формата см. в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о дате и времени описатели формата см. в разделе [стандартной строки даты и времени формат](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательских строк даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения об описателях форматов перечисления см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 Дополнительные сведения о признак конца строки, в разделе «Примечания» <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 В следующем примере демонстрируются стандартные описатели форматирования чисел, дат и значений перечислимых типов.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 В следующем примере представлен калькулятора совет, вычисляет совет 18% и использует <xref:System.Console.WriteLine%2A> метод для отображения сумму издержек, исходный объем совет и общую сумму. Пример является консольным приложением, которое пользователь должен ввести сумму исходной стоимости как параметр командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0, object arg1, object arg2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0, object arg1, object arg2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object, arg1 As Object, arg2 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Console</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для записи с использованием <c>format</c>.</param>
        <param name="arg1">Второй объект для записи с использованием <c>format</c>.</param>
        <param name="arg2">Третий объект для записи с использованием <c>format</c>.</param>
        <summary>Записывает текстовые представления заданных объектов, за которыми следует текущий признак конца строки, в стандартный выходной поток с использованием заданных сведений о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод использует [составное форматирование](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework, чтобы преобразовать значение объекта в его текстовое представление и встроить это представление в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр состоит из нуля или больше текста, перемежаемых ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют объекту в списке параметров данного метода. В процессе форматирования каждый элемент формата заменяется текстовое представление значения соответствующего объекта.  
  
 Синтаксис элементов форматирования `{` *индекс*[`,`*выравнивание*] [`:`*formatString*]`}`, который указывает Обязательный индекса, необязательно длину и выравнивание форматированного текста и необязательная строка символов описателя формата, определяющих способ форматирования значения соответствующего объекта.  
  
 Платформа .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах о форматировании.  
  
-   Дополнительные сведения о составного форматирования, поддерживаемые методами, такими как <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>и некоторые перегрузки <xref:System.Console.WriteLine%2A>, в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения об описателях числового формата см. в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о дате и времени описатели формата см. в разделе [стандартной строки даты и времени формат](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательских строк даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения об описателях форматов перечисления см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 Дополнительные сведения о признак конца строки, в разделе «Примечания» <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 В следующем примере демонстрируются стандартные описатели форматирования чисел, дат и значений перечислимых типов.  
  
 [!code-cpp[console.writelineFmt1#1](~/samples/snippets/cpp/VS_Snippets_CLR/console.writelineFmt1/cpp/wl.cpp#1)] 
 [!code-csharp[console.writelineFmt1#1](~/samples/snippets/csharp/VS_Snippets_CLR/console.writelineFmt1/cs/wl.cs#1)]
 [!code-vb[console.writelineFmt1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/console.writelineFmt1/vb/wl.vb#1)]  
  
 В следующем примере представлен калькулятора совет, вычисляет совет 18% и использует <xref:System.Console.WriteLine%2A> метод для отображения сумму издержек, исходный объем совет и общую сумму. Пример является консольным приложением, которое пользователь должен ввести сумму исходной стоимости как параметр командной строки.  
  
 [!code-csharp[System.Console.WriteLine#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Console.WriteLine/CS/tipcalc.cs#1)]
 [!code-vb[System.Console.WriteLine#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Console.WriteLine/VB/tipcalc.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (string format, object arg0, object arg1, object arg2, object arg3);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WriteLine(string format, object arg0, object arg1, object arg2, object arg3) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WriteLine (format As String, arg0 As Object, arg1 As Object, arg2 As Object, arg3 As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(System::String ^ format, System::Object ^ arg0, System::Object ^ arg1, System::Object ^ arg2, System::Object ^ arg3);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="arg0" Type="System.Object" />
        <Parameter Name="arg1" Type="System.Object" />
        <Parameter Name="arg2" Type="System.Object" />
        <Parameter Name="arg3" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="format">Строка составного формата.</param>
        <param name="arg0">Первый объект для записи с использованием <c>format</c>.</param>
        <param name="arg1">Второй объект для записи с использованием <c>format</c>.</param>
        <param name="arg2">Третий объект для записи с использованием <c>format</c>.</param>
        <param name="arg3">Четвертый объект для записи с использованием <c>format</c>.</param>
        <summary>Записывает текстовые представления заданных объектов и список параметров переменной длины, за которыми следует текущий признак конца строки, в стандартный выходной поток с использованием заданных сведений о форматировании.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  Этот интерфейс API CLS-несовместим. CLS-совместимая альтернатива — <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>. Компиляторы C# и Visual Basic автоматически разрешить вызов этого метода, как вызов <xref:System.Console.WriteLine%28System.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>.  
  
 Этот метод использует [составное форматирование](~/docs/standard/base-types/composite-formatting.md) платформы .NET Framework, чтобы преобразовать значение объекта в его текстовое представление и встроить это представление в строку. Результирующая строка записывается в поток вывода.  
  
 `format` Параметр состоит из нуля или больше текста, перемежаемых ноль или более индексированные местозаполнители, называются элементами форматирования, которые соответствуют объекту в списке параметров данного метода. В процессе форматирования каждый элемент формата заменяется текстовое представление значения соответствующего объекта.  
  
 Синтаксис элементов форматирования `{` *индекс*[`,`*выравнивание*] [`:`*formatString*]`}`, который указывает Обязательный индекса, необязательно длину и выравнивание форматированного текста и необязательная строка символов описателя формата, определяющих способ форматирования значения соответствующего объекта.  
  
 Платформа .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах о форматировании.  
  
-   Дополнительные сведения о составного форматирования, поддерживаемые методами, такими как <xref:System.String.Format%2A>, <xref:System.Text.StringBuilder.AppendFormat%2A>и некоторые перегрузки <xref:System.Console.WriteLine%2A>, в разделе [составное форматирование](~/docs/standard/base-types/composite-formatting.md).  
  
-   Дополнительные сведения об описателях числового формата см. в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о дате и времени описатели формата см. в разделе [стандартной строки даты и времени формат](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательских строк даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md).  
  
-   Дополнительные сведения об описателях форматов перечисления см. в разделе [строки форматов перечисления](~/docs/standard/base-types/enumeration-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 Дополнительные сведения о признак конца строки, в разделе «Примечания» <xref:System.Console.WriteLine%2A> метод, который не принимает никаких параметров.  
  
   
  
## Examples  
 В следующем примере показано использование аргументов, переменных и <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%2CSystem.Object%2CSystem.Object%29> метод. Метод вызывается с Строка составного формата и пятью элементами формата.  
  
 [!code-cpp[System.Console.WriteLine#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Console.WriteLine/CPP/writeline_vararg.cpp#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="format" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Недопустимая спецификация формата в <paramref name="format" />.</exception>
        <permission cref="T:System.Security.Permissions.UIPermission">для изменения безопасных окон верхнего уровня и дочерние окна. Связанное перечисление: <see cref="F:System.Security.Permissions.UIPermissionWindow.SafeTopLevelWindows" /></permission>
        <block subset="none" type="usage">
          <para>Этот метод помечен атрибутом <see langword="vararg" /> ключевое слово, которое означает, что он поддерживает переменное число параметров. Метод может вызываться из Visual C++, но не может вызываться из кода C# или Visual Basic. Компиляторы C# и Visual Basic разрешить вызовы <see cref="M:System.Console.WriteLine(System.String,System.Object,System.Object,System.Object,System.Object)" /> как вызов <see cref="M:System.Console.WriteLine(System.String,System.Object[])" />.</para>
        </block>
        <altmember cref="M:System.Console.Read" />
        <altmember cref="M:System.Console.ReadLine" />
        <altmember cref="M:System.Console.Write(System.String,System.Object)" />
      </Docs>
    </Member>
  </Members>
</Type>