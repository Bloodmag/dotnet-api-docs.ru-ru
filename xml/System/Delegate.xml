<Type Name="Delegate" FullName="System.Delegate">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7d0456aa37bceeab49a6fac813bdba77750d99b8" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37481534" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Delegate : ICloneable, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Delegate extends System.Object implements class System.ICloneable, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Delegate" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Delegate&#xA;Implements ICloneable, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Delegate abstract : ICloneable, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type Delegate = class&#xA;    interface ICloneable&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ICloneable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Represents a delegate, which is a data structure that refers to a static method or to a class instance and an instance method of that class.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Delegate> Класс является базовым классом для типов делегатов. Однако только система и компиляторы могут явно наследовать <xref:System.Delegate> класс или из <xref:System.MulticastDelegate> класса. Допускается также не наследовать новый тип является типом делегата. <xref:System.Delegate> Класс не является типом делегата; это класс, используемый для получения типов делегата.  
  
 Большинство языков реализовать `delegate` ключевое слово и компиляторы для этих языков, могут наследовать <xref:System.MulticastDelegate> класса; таким образом, пользователи должны использовать `delegate` ключевое слово языка.  
  
> [!NOTE]
>  Среда CLR предоставляет `Invoke` метод для каждого типа делегата с сигнатурой делегата. У вас нет явно вызвать этот метод из C#, Visual Basic или Visual C++, поскольку компиляторы вызывают его автоматически. `Invoke` Метод полезен в [отражения](~/docs/framework/reflection-and-codedom/reflection.md) , если требуется найти сигнатуре типа делегата.  
  
 Среда CLR предоставляет каждый тип делегата с `BeginInvoke` и `EndInvoke` методы, для поддержки асинхронного вызова делегата. Дополнительные сведения об этих методах см. в разделе [асинхронный вызов синхронных методов](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
 Объявление типа делегата устанавливает контракт, определяющий сигнатуру одного или нескольких методов. Делегат — это экземпляр типа делегата, который есть ссылки на:  
  
-   Метод экземпляра типа и может быть назначен для типа целевого объекта.  
  
-   Метод экземпляра типа, скрытые `this` параметр в списке формальных параметров. Считается, что делегат является делегат открытого экземпляра.  
  
-   Статический метод.  
  
-   Статический метод и целевым объектом может быть назначен к первому параметру метода. Делегат называют закрытым в отношении своего первого аргумента.  
  
 Дополнительные сведения о привязке делегата, см. в разделе <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> перегрузки метода.  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1 делегат может представлять метод только в том случае, если подпись метода точно соответствует сигнатуре, указанной в типе делегата. Таким образом поддерживаются только первый и третий элементы в списке выше, и первый элемент требует точного соответствия типов.  
  
 Когда делегат представляет метод экземпляра, закрытый в отношении своего первого аргумента (наиболее распространенный случай), делегат содержит ссылку на точку входа метода и ссылку на объект, называемый целевым, которые имеют тип, может быть назначен для типа, который определен метод. Если делегат представляет открытый метод экземпляра, он хранит ссылку на точку входа метода. Сигнатура делегата должна содержать скрытого `this` параметр в списке формальных параметров; таким образом, делегат имеет ссылку на целевой объект и целевой объект указывается при вызове делегата.  
  
 Когда делегат представляет статический метод, делегат содержит ссылку на точку входа метода. Когда делегат представляет статический метод, закрытый в отношении своего первого аргумента, делегат сохраняет ссылку на точку входа метода и ссылку на целевой объект может быть назначен типу первого аргумента метода. При вызове делегата первый аргумент статического метода получает целевой объект.  
  
 Список вызовов делегата представляет упорядоченный набор делегатов, в которых каждый элемент списка вызывает один из методов, представленный делегатом. Список вызовов может содержать повторяющиеся методы. Во время вызова методы вызываются в порядке, в котором они появляются в списке вызовов. Делегат пытается вызвать все методы в своем списке вызовов; дубликаты вызываются в том случае, когда каждый раз, они отображаются в списке вызовов. Делегаты являются неизменными. После создания списка вызовов делегата остается неизменным.  
  
 Делегаты называются групповыми или combinable, так как делегат может вызывать один или несколько методов и могут использоваться в операции объединения.  
  
 Объединение операций, таких как <xref:System.Delegate.Combine%2A> и <xref:System.Delegate.Remove%2A>, не изменяют существующие делегатов. Вместо этого такие операции возвращают новый делегат, который содержит результаты операции, делегат без изменений или `null`. Возвращает операцию объединения `null` когда результатом операции является делегатом, который не ссылается хотя бы один метод. Операцию объединения возвращает делегат без изменений, если запрошенная операция не влияет.  
  
> [!NOTE]
>  Управляемые языки используйте <xref:System.Delegate.Combine%2A> и <xref:System.Delegate.Remove%2A> методы для реализации операций делегата. К ним относятся `AddHandler` и `RemoveHandler` операторы объявления в Visual Basic и операторов += и-= на типы делегатов в C#.  
  
 Начиная с [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], универсальный делегат типы могут иметь параметры вариантного типа. Параметры контравариантного типа может использоваться как типы параметров делегата, а параметр ковариантного типа может использоваться в качестве возвращаемого типа. Эта функция позволяет универсальный метод-делегат типами, полученными из одного определения универсального типа, чтобы быть совместимы по назначению Если аргументов их типа являются ссылочными типами в отношение наследования, как описано в [ковариации и Контрвариантность](~/docs/standard/generics/covariance-and-contravariance.md).  
  
> [!NOTE]
>  Универсальные делегаты, которые совместимы с назначения за вариативности, не обязательно combinable. Чтобы быть комбинируемыми, типы должны в точности совпадать. Например, предположим, что класс с именем `Derived` является производным от класса с именем `Base`. Делегат типа `Action<Base>` (`Action(Of Base)` в Visual Basic) можно назначить переменной типа `Action<Derived>`, но не могут сочетаться два делегата, так как типы не совпадают.  
  
 Если вызываемый метод вызывает исключение, выполнение этого метода прекращается, исключение передается обратно в вызывающий объект делегата и остальные методы в списке вызова не вызываются. Перехват исключения в вызывающий объект не изменяет это поведение.  
  
 Если подпись методы, вызываемые через делегат содержит возвращаемое значение, делегат возвращает возвращаемое значение последнего элемента в списке вызовов. Когда сигнатура включает параметр, который передается по ссылке, конечное значение параметра является результатом каждый метод в списке вызовов, последовательное выполнение и обновление значения параметра.  
  
 Ближайшим эквивалентом делегата в C или C++ является указатель на функцию. Делегат может представлять статический метод или метод экземпляра. Когда делегат представляет метод экземпляра, он сохраняет не только ссылку на точку входа метода, но ссылка на экземпляр класса. В отличие от указателей функций делегаты являются объектно-ориентированными и строго типизированным.  
  
   
  
## Examples  
 В следующем примере показано, как определить делегат с именем `myMethodDelegate`. Экземпляры этого делегата создаются для метода экземпляра и статический метод вложенного `mySampleClass` класса. Делегат для метода экземпляра требуется экземпляр `mySampleClass`. `mySampleClass` Экземпляр сохраняется в переменной с именем `mySC`.  
  
 [!code-cpp[Classic Delegate Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Delegate Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Delegate Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Delegate Example/CS/source.cs#1)]
 [!code-vb[Classic Delegate Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Delegate Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.MulticastDelegate" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new delegate.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Object,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Object, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : obj * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">The class instance on which the delegate invokes <c>method</c>.</param>
        <param name="method">The name of the instance method that the delegate represents.</param>
        <summary>Initializes a delegate that invokes the specified instance method on the specified class instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор не может использоваться в коде приложения. Для создания делегата путем указания имени метода экземпляра, используйте перегрузку <xref:System.Delegate.CreateDelegate%2A> метод, который задает имя метода и целевым объектом. Например <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%29> перегрузку метода создает делегат для метода экземпляра с заданным именем.  
  
 Этот конструктор создает делегаты для методов экземпляра только. Метод экземпляра — это метод, который связан с экземпляром класса. статический метод — это метод, который связан с самим классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">There was an error binding to the target method.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Delegate (Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.#ctor(System.Type,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (target As Type, method As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Delegate(Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="new Delegate : Type * string -&gt; Delegate" Usage="new System.Delegate (target, method)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">The <see cref="T:System.Type" /> representing the class that defines <c>method</c>.</param>
        <param name="method">The name of the static method that the delegate represents.</param>
        <summary>Initializes a delegate that invokes the specified static method from the specified class.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор не может использоваться в коде приложения. Для создания делегата, указав имя статического метода, используйте перегрузку <xref:System.Delegate.CreateDelegate%2A> метод, который задает имя метода, но не указывает на целевой объект. Например <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%29> перегруженная версия метода создает статический делегат для метода с указанным именем.  
  
 Этот конструктор создает делегаты только для статических методов. Метод экземпляра — это метод, который связан с экземпляром класса. статический метод — это метод, который связан с самим классом.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="target" /> represents an open generic type.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public virtual object Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Clone () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Clone();" />
      <MemberSignature Language="F#" Value="abstract member Clone : unit -&gt; obj&#xA;override this.Clone : unit -&gt; obj" Usage="delegate.Clone " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.ICloneable.Clone</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Creates a shallow copy of the delegate.</summary>
        <returns>A shallow copy of the delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Клон имеет такую же <xref:System.Type>, целевой объект, метод и список вызовов, что и исходный делегат.  
  
 Неполная копия создает новый экземпляр того же типа, что и исходный объект, а затем копирует нестатические поля исходного объекта. Если поле является типом значения, выполняется копию бит за битом поля. Если поле является ссылочным типом, ссылка копируется, а не объект, который указывает ссылка; Следовательно ссылки в исходном объекте и в клоне указывают на тот же объект. Напротив глубокую копию объекта дублирует все, что прямо или косвенно ссылаться на поля в объекте.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Combine">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Concatenates the invocation lists of the specified multicast (combinable) delegates.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (params Delegate[] delegates);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate[] delegates) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (ParamArray delegates As Delegate()) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(... cli::array &lt;Delegate ^&gt; ^ delegates);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate[] -&gt; Delegate" Usage="System.Delegate.Combine delegates" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegates" Type="System.Delegate[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="delegates">The array of delegates to combine.</param>
        <summary>Concatenates the invocation lists of an array of delegates.</summary>
        <returns>A new delegate with an invocation list that concatenates the invocation lists of the delegates in the <paramref name="delegates" /> array. Returns <see langword="null" /> if <paramref name="delegates" /> is <see langword="null" />, if <paramref name="delegates" /> contains zero elements, or if every entry in <paramref name="delegates" /> is <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `delegates` массив содержит элементы, являющиеся `null`, эти элементы игнорируются.  
  
 Список вызовов, который может содержать повторяющиеся записи; то есть записи, которые ссылаются на один и тот же метод на тот же объект.  
  
> [!NOTE]
>  Универсальные делегаты, которые совместимы с назначения за вариативности, не обязательно combinable. Чтобы быть комбинируемыми, типы должны в точности совпадать. Например, предположим, что класс с именем `Derived` является производным от класса с именем `Base`. Делегат типа `Action<Base>` (`Action(Of Base)` в Visual Basic) можно назначить переменной типа `Action<Derived>`, как описано в [Ковариация и контравариация](~/docs/standard/generics/covariance-and-contravariance.md), но не могут сочетаться два делегата, так как типы не полностью совпадают.  
  
 <xref:System.Delegate.Combine%2A> полезно для создания обработчиков событий, которое происходит вызов несколько методов время события.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Not all the non-null entries in <paramref name="delegates" /> are instances of the same delegate type.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="Combine">
      <MemberSignature Language="C#" Value="public static Delegate Combine (Delegate a, Delegate b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Combine(class System.Delegate a, class System.Delegate b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Combine (a As Delegate, b As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Combine(Delegate ^ a, Delegate ^ b);" />
      <MemberSignature Language="F#" Value="static member Combine : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Combine (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Delegate" />
        <Parameter Name="b" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="a">The delegate whose invocation list comes first.</param>
        <param name="b">The delegate whose invocation list comes last.</param>
        <summary>Concatenates the invocation lists of two delegates.</summary>
        <returns>A new delegate with an invocation list that concatenates the invocation lists of <paramref name="a" /> and <paramref name="b" /> in that order. Returns <paramref name="a" /> if <paramref name="b" /> is <see langword="null" />, returns <paramref name="b" /> if <paramref name="a" /> is a null reference, and returns a null reference if both <paramref name="a" /> and <paramref name="b" /> are null references.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Список вызовов, который может содержать повторяющиеся записи; то есть записи, которые ссылаются на один и тот же метод на тот же объект.  
  
> [!NOTE]
>  Универсальные делегаты, которые совместимы с назначения за вариативности, не обязательно combinable. Чтобы быть комбинируемыми, типы должны в точности совпадать. Например, предположим, что класс с именем `Derived` является производным от класса с именем `Base`. Делегат типа `Action<Base>` (`Action(Of Base)` в Visual Basic) можно назначить переменной типа `Action<Derived>`, как описано в [Ковариация и контравариация](~/docs/standard/generics/covariance-and-contravariance.md), но не могут сочетаться два делегата, так как типы не полностью совпадают.  
  
 <xref:System.Delegate.Combine%2A> полезно для создания обработчиков событий, которое происходит вызов несколько методов время события.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Both <paramref name="a" /> and <paramref name="b" /> are not <see langword="null" />, and <paramref name="a" /> and <paramref name="b" /> are not instances of the same delegate type.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="M:System.Delegate.CombineImpl(System.Delegate)" />
      </Docs>
    </Member>
    <Member MemberName="CombineImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate CombineImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate CombineImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CombineImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function CombineImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ CombineImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member CombineImpl : Delegate -&gt; Delegate&#xA;override this.CombineImpl : Delegate -&gt; Delegate" Usage="delegate.CombineImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">The multicast (combinable) delegate whose invocation list to append to the end of the invocation list of the current multicast (combinable) delegate.</param>
        <summary>Concatenates the invocation lists of the specified multicast (combinable) delegate and the current multicast (combinable) delegate.</summary>
        <returns>A new multicast (combinable) delegate with an invocation list that concatenates the invocation list of the current multicast (combinable) delegate and the invocation list of <paramref name="d" />, or the current multicast (combinable) delegate if <paramref name="d" /> is <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод применим только в том случае, если текущий делегат является многоадресным (комбинируемый).  
  
 Текущая реализация просто вызывает <xref:System.MulticastNotSupportedException>.  
  
 Список вызовов, который может содержать повторяющиеся записи; то есть записи, которые ссылаются на один и тот же метод на тот же объект.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MulticastNotSupportedException">Always thrown.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Combine(System.Delegate,System.Delegate)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates a delegate of the specified type.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="method">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent. Only static methods are supported in the .NET Framework version 1.0 and 1.1.</param>
        <summary>Creates a delegate of the specified type to represent the specified static method.</summary>
        <returns>A delegate of the specified type to represent the specified static method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В .NET Framework версий 1.0 и 1.1 перегрузка метода создает делегаты только для статических методов. В .NET Framework версии 2.0 перегрузка метода также можно создать открытый экземпляр метода делегатов. то есть методы экземпляра делегатов, которые явным образом предоставить скрытые первый аргумент. Подробное описание см. в разделе Дополнительные Общие <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> перегрузку метода, который позволяет создать все комбинации открытых или закрытых делегатов для экземпляров или статических методов и при необходимости укажите в качестве первого аргумента.  
  
> [!NOTE]
>  Эта перегрузка метода следует использовать при делегат не закрыт в отношении своего первого аргумента, так как она работает немного быстрее в этом случае.  
  
 Эта перегрузка метода эквивалентен вызову <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> перегрузку метода с указанием `true` для `throwOnBindFailure`.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к методам не являющиеся открытыми, если вызывающий объект получил <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг и если набор прав неоткрытые методы ограничена вызывающего предоставить набор или подмножество его. (См. в разделе [соображения о безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Совместимые типы параметров и типом возвращаемого значения  
 В .NET Framework версии 2.0 типы параметров и тип возвращаемого значения делегата, созданного с помощью этой перегрузки метода должны быть совместимы с типами параметров и возвращаемого типа метода, представленного делегатом; типы не должны полностью совпадать. Это значение представляет это ослабление поведение привязки в .NET Framework версий 1.0 и 1.1, где типы должны в точности совпадать.  
  
 Если тип параметра делегата является более строгим, чем тип параметра метода, то параметр делегата совместим с соответствующим параметром метода, так как это гарантирует, что аргумент, переданный делегату, может быть безопасно передан методу.  
  
 Аналогичным образом, тип возвращаемого значения делегата совместим с типом возвращаемого значения метода, если тип возвращаемого значения метода является более строгим, чем тип возвращаемого значения делегата, так как это гарантирует, что возвращаемое значение метода может быть безопасно приведено к типу возвращаемого значения делегата.  
  
 Например, делегат с параметром типа <xref:System.Collections.Hashtable> и типом возвращаемого значения <xref:System.Object> может представлять метод с параметром типа <xref:System.Object> и возвращаемым значением типа <xref:System.Collections.Hashtable>.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода. В первом примере показано два типа делегатов, которые могут быть созданы с помощью этой перегрузки метода: Откройте метода экземпляра, а через статический метод.  
  
 Во втором примере кода демонстрируются совместимые типы параметров и возвращаемых типов.  
  
 **Пример 1**  
  
 В следующем примере кода показаны два способа, делегата могут создаваться при использовании перегруженной версии <xref:System.Delegate.CreateDelegate%2A> метод.  
  
> [!NOTE]
>  Существуют две перегрузки <xref:System.Delegate.CreateDelegate%2A> , заданный метод <xref:System.Reflection.MethodInfo> , но первый аргумент; их функциональные возможности за исключением того, что один позволяет указать, следует ли создавать неудачно, а другой всегда создает исключение. Данный пример кода использует обе перегрузки.  
  
 В примере объявляется класс `C` со статическим методом `M2` и метод экземпляра `M1`, и два типа делегата: `D1` принимает экземпляр `C` и типа string, и `D2` принимает строку.  
  
 Второй класс с именем `Example` содержит код, создающий делегаты.  
  
-   Делегат типа `D1`, представляющий открытый метод экземпляра, создается для метода экземпляра `M1`. Экземпляр должен передаваться при вызове делегата.  
  
-   Делегат типа `D2`, представляющий открытый статический метод, он создается статический метод `M2`.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Пример 2**  
  
 В следующем примере кода демонстрируется совместимость типов параметров и возвращаемых типов.  
  
 В примере определяется базовый класс, именуемый `Base` и класс с именем `Derived` , наследуемый от класса `Base`. Производный класс содержит `static` (`Shared` в Visual Basic) метод с именем `MyMethod` с одним параметром типа `Base` и типом возвращаемого значения `Derived`. В примере также определяется делегат с именем `Example` , имеющий один параметр типа `Derived` и типом возвращаемого значения `Base`.  
  
 В примере кода показано, что делегат с именем `Example` может использоваться для представления метода `MyMethod`. Метод может быть привязан к делегату, так как:  
  
-   Тип параметра делегата (`Derived`) является более строгим, чем тип параметра `MyMethod` (`Base`), так как это всегда безопасно передать аргумент делегата `MyMethod`.  
  
-   Тип возвращаемого значения `MyMethod` (`Derived`) является более строгим, чем тип параметра делегата (`Base`), чтобы он всегда можно безопасно привести тип возвращаемого значения метода в возвращаемый тип делегата.  
  
 В примере кода не дает результатов.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> is not a static method, and the .NET Framework version is 1.0 or 1.1.  -or-  <paramref name="method" /> cannot be bound.  -or-  <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="firstArgument">The object to which the delegate is bound, or <see langword="null" /> to treat <c>method</c> as <see langword="static" /> (<see langword="Shared" /> in Visual Basic).</param>
        <param name="method">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</param>
        <summary>Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument.</summary>
        <returns>A delegate of the specified type that represents the specified static or instance method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов перегрузки этого метода эквивалентен вызову <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> перегрузку метода с указанием `true` для `throwOnBindFailure`. Эти две перегрузки предоставляют самый гибкий способ создания делегатов. Их можно использовать для создания делегатов для статических методов или методов экземпляра и при необходимости укажите первый аргумент.  
  
> [!NOTE]
>  Если первый аргумент не указан, используйте <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> перегрузку метода для повышения производительности.  
  
 Тип делегата и метода, должны иметь совместимые типы возвращаемых значений. То есть тип возвращаемого значения `method` должен быть назначен тип возвращаемого значения `type`.  
  
 Если `firstArgument` будет указано, оно передается `method` каждый раз при вызове делегата; `firstArgument` говорят, что для привязки делегата, и делегат называется закрытым в отношении своего первого аргумента. Если `method` — `static` (`Shared` в Visual Basic), аргумент, предоставленный при вызове делегата список включает все параметры, кроме первого, если `method` является методом экземпляра, затем `firstArgument` передается со скрытым экземпляром параметр (представленный `this` в C#, либо by `Me` в Visual Basic).  
  
 Если `firstArgument` предоставляется, первый параметр `method` должен быть ссылочным типом, и `firstArgument` должны быть совместимы с этим типом.  
  
> [!IMPORTANT]
>  Если `method` — `static` (`Shared` в Visual Basic) и ее первый параметр имеет тип <xref:System.Object> или <xref:System.ValueType>, затем `firstArgument` может быть типом значения. В этом случае `firstArgument` упаковывается автоматически. Автоматическая упаковка-преобразование не происходит для других аргументов, как в C# или Visual Basic функции вызвать.  
  
 Если `firstArgument` является пустой ссылкой и `method` является методом экземпляра, результат зависит от сигнатуры делегата `type` и `method`:  
  
-   Если подпись `type` явно включает в себя скрытый первый параметр `method`, говорят, что для представления открытый метод экземпляра делегата. При вызове делегата первый аргумент в списке аргументов передается в параметр скрытым экземпляром `method`.  
  
-   Если подписи `method` и `type` совпадают (то есть всех типов параметров совместимы), то делегат называется закрытым в отношении пустой ссылкой. Вызов делегата аналогично вызову метода экземпляра в неопределенном экземпляре, который не является особенно удобно, что необходимо сделать.  
  
 Если `firstArgument` является пустой ссылкой и `method` является статическим, результат зависит от сигнатуры делегата `type` и `method`:  
  
-   Если подпись `method` и `type` совпадают (то есть всех типов параметров совместимы), делегат называют представляющим открытый статический метод. Это наиболее распространенный случай для статических методов. В этом случае можно получить немного более высокую производительность с помощью <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> перегрузки метода.  
  
-   Если подпись `type` начинается со вторым параметром `method` и остальные типы параметров совместимы, то делегат называется закрытым в отношении пустой ссылкой. При вызове делегата, для первого параметра передается пустая ссылка `method`.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к методам не являющиеся открытыми, если вызывающий объект получил <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг и если набор прав неоткрытые методы ограничена вызывающего предоставить набор или подмножество его. (См. в разделе [соображения о безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Совместимые типы параметров и типом возвращаемого значения  
 Типы параметров и тип возвращаемого значения делегата должны быть совместимы с типами параметров и возвращаемого типа метода, представленного делегатом; типы не должны полностью совпадать.  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1 должны полностью совпадать типы.  
  
 Если тип параметра делегата является более строгим, чем тип параметра метода, то параметр делегата совместим с соответствующим параметром метода, так как это гарантирует, что аргумент, переданный делегату, может быть безопасно передан методу.  
  
 Аналогичным образом, тип возвращаемого значения делегата совместим с типом возвращаемого значения метода, если тип возвращаемого значения метода является более строгим, чем тип возвращаемого значения делегата, так как это гарантирует, что возвращаемое значение метода может быть безопасно приведено к типу возвращаемого значения делегата.  
  
 Например, делегат с параметром типа <xref:System.Collections.Hashtable> и типом возвращаемого значения <xref:System.Object> может представлять метод с параметром типа <xref:System.Object> и возвращаемым значением типа <xref:System.Collections.Hashtable>.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Определение методов делегата может представлять  
 Другой полезный способ представить гибкие Эта перегрузка <xref:System.Delegate.CreateDelegate%2A> — это то, что любой делегат может представлять четыре различных сочетаний сигнатуру метода и тип метода (статический или экземпляр). Рассмотрим тип делегата `D` с одним аргументом типа `C`. Ниже описаны методы `D` может представлять, игнорируя тип возвращаемого значения, так как он должен соответствовать во всех случаях:  
  
-   `D` может представлять любой метод экземпляра, который имеет ровно один аргумент типа `C`, независимо от того, какой тип принадлежит метод экземпляра. Когда <xref:System.Delegate.CreateDelegate%2A> вызове `firstArgument` является экземпляром типа `method` принадлежит, и результирующий делегат называется закрытым в отношении этого экземпляра. (Разумеется, `D` также может быть закрыт на ссылку на null Если `firstArgument` является пустой ссылкой.)  
  
-   `D` может представлять метод экземпляра `C` , не имеет аргументов. Когда <xref:System.Delegate.CreateDelegate%2A> вызове `firstArgument` является пустой ссылкой. Результирующий делегат представляет открытый метод экземпляра и экземпляр `C` должен указываться каждый раз, он вызывается.  
  
-   `D` может представлять статический метод, который принимает один аргумент типа `C`, и что метод может принадлежать к любому типу. Когда <xref:System.Delegate.CreateDelegate%2A> вызове `firstArgument` является пустой ссылкой. Результирующий делегат представляет открытый статический метод и экземпляр `C` должен указываться каждый раз, он вызывается.  
  
-   `D` может представлять статический метод, который принадлежит к типу `F` и имеет два аргумента типа `F` и тип `C`. Когда <xref:System.Delegate.CreateDelegate%2A> вызове `firstArgument` является экземпляром класса `F`. Результирующий делегат представляет статический метод, который закрывается в отношении этого экземпляра `F`. Обратите внимание, что в случае, когда `F` и `C` относятся к одному типу, статический метод имеет два аргумента этого типа. (В этом случае `D` закрыт в отношении ссылкой на null, если `firstArgument` является пустой ссылкой.)  
  
   
  
## Examples  
 Этот раздел содержит три примера кода. В первом примере показано четыре вида делегатов, которые могут быть созданы: закрытые методом экземпляра, открытый в отношении метода экземпляра, открытый в отношении статический метод и закрытый в отношении статического метода.  
  
 Во втором примере кода демонстрируются совместимые типы параметров и возвращаемых типов.  
  
 В третьем примере код определяет единственный тип делегата и показано, что все методы, которые он может представлять.  
  
 **Пример 1**  
  
 В следующем примере кода демонстрируется четыре способа делегата могут создаваться при использовании перегруженной версии <xref:System.Delegate.CreateDelegate%2A> метод.  
  
> [!NOTE]
>  Существуют две перегрузки <xref:System.Delegate.CreateDelegate%2A> , заданный метод `firstArgument` и <xref:System.Reflection.MethodInfo>; их функциональные возможности за исключением того, что один позволяет указать, следует ли создавать неудачно, а другой всегда создает исключение. Данный пример кода использует обе перегрузки.  
  
 В примере объявляется класс `C` со статическим методом `M2` и метод экземпляра `M1`, и три типа делегатов: `D1` принимает экземпляр `C` строку и `D2` принимает строку и `D3`не имеет аргументов.  
  
 Второй класс с именем `Example` содержит код, создающий делегаты.  
  
-   Делегат типа `D2`закрытых через экземпляр `C`, создается для метода экземпляра `M1`. Он вызывается с другими строками, чтобы показать, что привязанный экземпляр `C` всегда используется.  
  
-   Делегат типа `D1`, представляющий открытый метод экземпляра, создается для метода экземпляра `M1`. Экземпляр должен передаваться при вызове делегата.  
  
-   Делегат типа `D2`, представляющий открытый статический метод, он создается статический метод `M2`.  
  
-   Наконец, делегат типа `D3`, закрытый в отношении строки, создается для статического метода `M2`. Метод вызывается, чтобы показать, что он использует связанную строку.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Пример 2**  
  
 В следующем примере кода демонстрируется совместимость типов параметров и возвращаемых типов.  
  
> [!NOTE]
>  Данный пример кода использует <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> перегрузки метода. Использование других перегрузок, принимающих <xref:System.Reflection.MethodInfo> похож.  
  
 В примере определяется базовый класс, именуемый `Base` и класс с именем `Derived` , наследуемый от класса `Base`. Производный класс содержит `static` (`Shared` в Visual Basic) метод с именем `MyMethod` с одним параметром типа `Base` и типом возвращаемого значения `Derived`. В примере также определяется делегат с именем `Example` , имеющий один параметр типа `Derived` и типом возвращаемого значения `Base`.  
  
 В примере кода показано, что делегат с именем `Example` может использоваться для представления метода `MyMethod`. Метод может быть привязан к делегату, так как:  
  
-   Тип параметра делегата (`Derived`) является более строгим, чем тип параметра `MyMethod` (`Base`), так как это всегда безопасно передать аргумент делегата `MyMethod`.  
  
-   Тип возвращаемого значения `MyMethod` (`Derived`) является более строгим, чем тип параметра делегата (`Base`), чтобы он всегда можно безопасно привести тип возвращаемого значения метода в возвращаемый тип делегата.  
  
 В примере кода не дает результатов.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Пример 3**  
  
 В следующем примере кода показаны все методы могут представлять один тип делегата, с помощью <xref:System.Delegate.CreateDelegate%2A> метод для создания делегатов.  
  
> [!NOTE]
>  Существуют две перегрузки <xref:System.Delegate.CreateDelegate%2A> , заданный метод `firstArgument` и <xref:System.Reflection.MethodInfo>; их функциональные возможности за исключением того, что один позволяет указать, следует ли создавать неудачно, а другой всегда создает исключение. Данный пример кода использует обе перегрузки.  
  
 В примере кода определяется два класса `C` и `F`и тип делегата `D` с одним аргументом типа `C`. Классы иметь совпадающие статических методов и методов экземпляра `M1`, `M3`, и `M4`и класс `C` также содержит метод экземпляра `M2` , не имеет аргументов.  
  
 Третий класс с именем `Example` содержит код, создающий делегаты.  
  
-   Делегаты создаются для экземпляра метода `M1` типа `C` и тип `F`; каждый из них закрыт через экземпляр соответствующего типа. Метод `M1` типа `C` отображает `ID` свойства связанного экземпляра и аргумента.  
  
-   Делегат создается для метода `M2` типа `C`. Это делегат открытого экземпляра, в котором аргумент делегата представляет скрытый первый аргумент метода экземпляра. Метод не имеет аргументов. Он называется, как будто это статический метод.  
  
-   Делегаты создаются для статического метода `M3` типа `C` и тип `F`; это открытые статические делегаты.  
  
-   Наконец, делегаты создаются для статического метода `M4` типа `C` и тип `F`; каждый метод имеет объявляющий тип в качестве первого аргумента, и предоставляется экземпляр типа, поэтому делегаты закрыты в отношении своих первых аргументов . Метод `M4` типа `C` отображает `ID` свойства связанного экземпляра и аргумента.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> cannot be bound.  -or-  <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The class instance on which <c>method</c> is invoked.</param>
        <param name="method">The name of the instance method that the delegate is to represent.</param>
        <summary>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</summary>
        <returns>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает делегаты для методов экземпляра только. Метод экземпляра — это метод, который связан с экземпляром класса. статический метод — это метод, который связан с самим классом.  
  
 Эта перегрузка метода эквивалентен вызову <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> перегрузку метода, указав `false` для `ignoreCase` и `true` для `throwOnBindFailure`.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к методам не являющиеся открытыми, если вызывающий объект получил <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг и если набор прав неоткрытые методы ограничена вызывающего предоставить набор или подмножество его. (См. в разделе [соображения о безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> is not an instance method.  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="method">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</param>
        <summary>Creates a delegate of the specified type to represent the specified static method, with the specified behavior on failure to bind.</summary>
        <returns>A delegate of the specified type to represent the specified static method.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эту перегрузку метода можно создать открытый статический метод делегаты и открытые делегаты методов экземпляра, то есть методы экземпляра делегаты, которые предоставляют скрытый первый аргумент. Подробное описание см. в разделе Дополнительные Общие <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> перегрузку метода, который позволяет создавать все комбинации открытых или закрытых делегатов для экземпляра или статические методы.  
  
> [!NOTE]
>  Эта перегрузка метода следует использовать при делегат не закрыт в отношении своего первого аргумента, так как она работает немного быстрее в этом случае.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к методам не являющиеся открытыми, если вызывающий объект получил <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг и если набор прав неоткрытые методы ограничена вызывающего предоставить набор или подмножество его. (См. в разделе [соображения о безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Совместимые типы параметров и типом возвращаемого значения  
 Типы параметров и тип возвращаемого значения делегата должны быть совместимы с типами параметров и возвращаемого типа метода, представленного делегатом; типы не должны полностью совпадать.  
  
> [!NOTE]
>  В .NET Framework версий 1.0 и 1.1 должны полностью совпадать типы.  
  
 Если тип параметра делегата является более строгим, чем тип параметра метода, то параметр делегата совместим с соответствующим параметром метода, так как это гарантирует, что аргумент, переданный делегату, может быть безопасно передан методу.  
  
 Аналогичным образом, тип возвращаемого значения делегата совместим с типом возвращаемого значения метода, если тип возвращаемого значения метода является более строгим, чем тип возвращаемого значения делегата, так как это гарантирует, что возвращаемое значение метода может быть безопасно приведено к типу возвращаемого значения делегата.  
  
 Например, делегат с параметром типа <xref:System.Collections.Hashtable> и типом возвращаемого значения <xref:System.Object> может представлять метод с параметром типа <xref:System.Object> и возвращаемым значением типа <xref:System.Collections.Hashtable>.  
  
   
  
## Examples  
 Этот раздел содержит два примера кода. В первом примере показано два типа делегатов, которые могут быть созданы с помощью этой перегрузки метода: Откройте метода экземпляра, а через статический метод.  
  
 Во втором примере кода демонстрируются совместимые типы параметров и возвращаемых типов.  
  
 **Пример 1**  
  
 В следующем примере кода показаны два способа, делегата могут создаваться при использовании перегруженной версии <xref:System.Delegate.CreateDelegate%2A> метод.  
  
> [!NOTE]
>  Существуют две перегрузки <xref:System.Delegate.CreateDelegate%2A> , заданный метод <xref:System.Reflection.MethodInfo> , но первый аргумент; их функциональные возможности за исключением того, что один позволяет указать, следует ли создавать неудачно, а другой всегда создает исключение. Данный пример кода использует обе перегрузки.  
  
 В примере объявляется класс `C` со статическим методом `M2` и метод экземпляра `M1`, и два типа делегата: `D1` принимает экземпляр `C` и типа string, и `D2` принимает строку.  
  
 Второй класс с именем `Example` содержит код, создающий делегаты.  
  
-   Делегат типа `D1`, представляющий открытый метод экземпляра, создается для метода экземпляра `M1`. Экземпляр должен передаваться при вызове делегата.  
  
-   Делегат типа `D2`, представляющий открытый статический метод, он создается статический метод `M2`.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Пример 2**  
  
 В следующем примере кода демонстрируется совместимость типов параметров и возвращаемых типов.  
  
> [!NOTE]
>  Данный пример кода использует <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> перегрузки метода. Использование других перегрузок, принимающих <xref:System.Reflection.MethodInfo> похож.  
  
 В примере определяется базовый класс, именуемый `Base` и класс с именем `Derived` , наследуемый от класса `Base`. Производный класс содержит `static` (`Shared` в Visual Basic) метод с именем `MyMethod` с одним параметром типа `Base` и типом возвращаемого значения `Derived`. В примере также определяется делегат с именем `Example` , имеющий один параметр типа `Derived` и типом возвращаемого значения `Base`.  
  
 В примере кода показано, что делегат с именем `Example` может использоваться для представления метода `MyMethod`. Метод может быть привязан к делегату, так как:  
  
-   Тип параметра делегата (`Derived`) является более строгим, чем тип параметра `MyMethod` (`Base`), так как это всегда безопасно передать аргумент делегата `MyMethod`.  
  
-   Тип возвращаемого значения `MyMethod` (`Derived`) является более строгим, чем тип параметра делегата (`Base`), чтобы он всегда можно безопасно привести тип возвращаемого значения метода в возвращаемый тип делегата.  
  
 В примере кода не дает результатов.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> cannot be bound, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.  -or-  <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The <see cref="T:System.Type" /> representing the class that implements <c>method</c>.</param>
        <param name="method">The name of the static method that the delegate is to represent.</param>
        <summary>Creates a delegate of the specified type that represents the specified static method of the specified class.</summary>
        <returns>A delegate of the specified type that represents the specified static method of the specified class.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает делегаты только для статических методов. Метод экземпляра — это метод, который связан с экземпляром класса. статический метод — это метод, который связан с самим классом.  
  
 Эта перегрузка метода эквивалентен вызову <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> перегрузку метода, указав `false` для `ignoreCase` и `true` для `throwOnBindFailure`.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к методам не являющиеся открытыми, если вызывающий объект получил <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг и если набор прав неоткрытые методы ограничена вызывающего предоставить набор или подмножество его. (См. в разделе [соображения о безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="target" /> is not a <see langword="RuntimeType" />.  -or-  <paramref name="target" /> is an open generic type. That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.  -or-  <paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object firstArgument, System.Reflection.MethodInfo method, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object firstArgument, class System.Reflection.MethodInfo method, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.Reflection.MethodInfo,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ firstArgument, System::Reflection::MethodInfo ^ method, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * System.Reflection.MethodInfo * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, firstArgument, method, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="firstArgument" Type="System.Object" />
        <Parameter Name="method" Type="System.Reflection.MethodInfo" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">A <see cref="T:System.Type" /> representing the type of delegate to create.</param>
        <param name="firstArgument">An <see cref="T:System.Object" /> that is the first argument of the method the delegate represents. For instance methods, it must be compatible with the instance type.</param>
        <param name="method">The <see cref="T:System.Reflection.MethodInfo" /> describing the static or instance method the delegate is to represent.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</param>
        <summary>Creates a delegate of the specified type that represents the specified static or instance method, with the specified first argument and the specified behavior on failure to bind.</summary>
        <returns>A delegate of the specified type that represents the specified static or instance method, or <see langword="null" /> if <paramref name="throwOnBindFailure" /> is <see langword="false" /> and the delegate cannot be bound to <paramref name="method" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка метода и <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.Reflection.MethodInfo%29> перегрузку метода, который всегда создает исключение в случае сбоя процесса привязки, предоставляют самый гибкий способ для создания делегатов. Их можно использовать для создания делегатов для статических методов или методов экземпляра с или без первого аргумента.  
  
> [!NOTE]
>  Если первый аргумент не указан, используйте <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> перегрузку метода для повышения производительности.  
  
 Тип делегата и метода, должны иметь совместимые типы возвращаемых значений. То есть тип возвращаемого значения `method` должен быть назначен тип возвращаемого значения `type`.  
  
 Если `firstArgument` будет указано, оно передается `method` каждый раз при вызове делегата; `firstArgument` говорят, что для привязки делегата, и делегат называется закрытым в отношении своего первого аргумента. Если `method` — `static` (`Shared` в Visual Basic), аргумент, предоставленный при вызове делегата список включает все параметры, кроме первого, если `method` является методом экземпляра, затем `firstArgument` передается со скрытым экземпляром параметр (представленный `this` в C#, либо by `Me` в Visual Basic).  
  
 Если `firstArgument` предоставляется, первый параметр `method` должен быть ссылочным типом, и `firstArgument` должны быть совместимы с этим типом.  
  
> [!IMPORTANT]
>  Если `method` — `static` (`Shared` в Visual Basic) и ее первый параметр имеет тип <xref:System.Object> или <xref:System.ValueType>, затем `firstArgument` может быть типом значения. В этом случае `firstArgument` упаковывается автоматически. Автоматическая упаковка-преобразование не происходит для других аргументов, как в C# или Visual Basic функции вызвать.  
  
 Если `firstArgument` является пустой ссылкой и `method` является методом экземпляра, результат зависит от сигнатуры делегата `type` и `method`:  
  
-   Если подпись `type` явно включает в себя скрытый первый параметр `method`, говорят, что для представления открытый метод экземпляра делегата. При вызове делегата первый аргумент в списке аргументов передается в параметр скрытым экземпляром `method`.  
  
-   Если подписи `method` и `type` совпадают (то есть всех типов параметров совместимы), то делегат называется закрытым в отношении пустой ссылкой. Вызов делегата аналогично вызову метода экземпляра в неопределенном экземпляре, который не является особенно удобно, что необходимо сделать.  
  
 Если `firstArgument` является пустой ссылкой и `method` является статическим, результат зависит от сигнатуры делегата `type` и `method`:  
  
-   Если подпись `method` и `type` совпадают (то есть всех типов параметров совместимы), делегат называют представляющим открытый статический метод. Это наиболее распространенный случай для статических методов. В этом случае можно получить немного более высокую производительность с помощью <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%2CSystem.Boolean%29> перегрузки метода.  
  
-   Если подпись `type` начинается со вторым параметром `method` и остальные типы параметров совместимы, то делегат называется закрытым в отношении пустой ссылкой. При вызове делегата, для первого параметра передается пустая ссылка `method`.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к методам не являющиеся открытыми, если вызывающий объект получил <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг и если набор прав неоткрытые методы ограничена вызывающего предоставить набор или подмножество его. (См. в разделе [соображения о безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
## <a name="compatible-parameter-types-and-return-type"></a>Совместимые типы параметров и типом возвращаемого значения  
 Типы параметров и тип возвращаемого значения делегата должны быть совместимы с типами параметров и возвращаемого типа метода, представленного делегатом; типы не должны полностью совпадать.  
  
> [!NOTE]
>  В .NET Framework версии 1.0 и 1.1 должен полностью совпадать типы.  
  
 Если тип параметра делегата является более строгим, чем тип параметра метода, то параметр делегата совместим с соответствующим параметром метода, так как это гарантирует, что аргумент, переданный делегату, может быть безопасно передан методу.  
  
 Аналогичным образом, тип возвращаемого значения делегата совместим с типом возвращаемого значения метода, если тип возвращаемого значения метода является более строгим, чем тип возвращаемого значения делегата, так как это гарантирует, что возвращаемое значение метода может быть безопасно приведено к типу возвращаемого значения делегата.  
  
 Например, делегат с параметром типа <xref:System.Collections.Hashtable> и типом возвращаемого значения <xref:System.Object> может представлять метод с параметром типа <xref:System.Object> и возвращаемым значением типа <xref:System.Collections.Hashtable>.  
  
## <a name="determining-the-methods-a-delegate-can-represent"></a>Определение методов делегата может представлять  
 Другой полезный способ представить гибкие Эта перегрузка <xref:System.Delegate.CreateDelegate%2A> — это то, что любой делегат может представлять четыре различных сочетаний сигнатуру метода и тип метода (статический или экземпляр). Рассмотрим тип делегата `D` с одним аргументом типа `C`. Ниже описаны методы `D` может представлять, игнорируя тип возвращаемого значения, так как он должен соответствовать во всех случаях:  
  
-   `D` может представлять любой метод экземпляра, который имеет ровно один аргумент типа `C`, независимо от того, какой тип принадлежит метод экземпляра. Когда <xref:System.Delegate.CreateDelegate%2A> вызове `firstArgument` является экземпляром типа `method` принадлежит, и результирующий делегат называется закрытым в отношении этого экземпляра. (Разумеется, `D` также может быть закрыт на ссылку на null Если `firstArgument` является `null`.)  
  
-   `D` может представлять метод экземпляра `C` , не имеет аргументов. Когда <xref:System.Delegate.CreateDelegate%2A> вызове `firstArgument` является пустой ссылкой. Результирующий делегат представляет открытый метод экземпляра и экземпляр `C` должен указываться каждый раз, он вызывается.  
  
-   `D` может представлять статический метод, который принимает один аргумент типа `C`, и что метод может принадлежать к любому типу. Когда <xref:System.Delegate.CreateDelegate%2A> вызове `firstArgument` является пустой ссылкой. Результирующий делегат представляет открытый статический метод и экземпляр `C` должен указываться каждый раз, он вызывается.  
  
-   `D` может представлять статический метод, который принадлежит к типу `F` и имеет два аргумента типа `F` и тип `C`. Когда <xref:System.Delegate.CreateDelegate%2A> вызове `firstArgument` является экземпляром класса `F`. Результирующий делегат представляет статический метод, который закрывается в отношении этого экземпляра `F`. Обратите внимание, что в случае, когда `F` и `C` относятся к одному типу, статический метод имеет два аргумента этого типа. (В этом случае `D` закрыт в отношении ссылкой на null, если `firstArgument` является `null`.)  
  
   
  
## Examples  
 Этот раздел содержит три примера кода. В первом примере показано четыре вида делегатов, которые могут быть созданы: закрытые методом экземпляра, открытый в отношении метода экземпляра, открытый в отношении статический метод и закрытый в отношении статического метода.  
  
 Во втором примере кода демонстрируются совместимые типы параметров и возвращаемых типов.  
  
 В третьем примере код определяет единственный тип делегата и показано, что все методы, которые он может представлять.  
  
 **Пример 1**  
  
 В следующем примере кода демонстрируется четыре способа делегата могут создаваться при использовании перегруженной версии <xref:System.Delegate.CreateDelegate%2A> метод.  
  
> [!NOTE]
>  Существуют две перегрузки <xref:System.Delegate.CreateDelegate%2A> , заданный метод `firstArgument` и <xref:System.Reflection.MethodInfo>; их функциональные возможности за исключением того, что один позволяет указать, следует ли создавать неудачно, а другой всегда создает исключение. Данный пример кода использует обе перегрузки.  
  
 В примере объявляется класс `C` со статическим методом `M2` и метод экземпляра `M1`, и три типа делегатов: `D1` принимает экземпляр `C` строку и `D2` принимает строку и `D3`не имеет аргументов.  
  
 Второй класс с именем `Example` содержит код, создающий делегаты.  
  
-   Делегат типа `D2`закрытых через экземпляр `C`, создается для метода экземпляра `M1`. Он вызывается с другими строками, чтобы показать, что привязанный экземпляр `C` всегда используется.  
  
-   Делегат типа `D1`, представляющий открытый метод экземпляра, создается для метода экземпляра `M1`. Экземпляр должен передаваться при вызове делегата.  
  
-   Делегат типа `D2`, представляющий открытый статический метод, он создается статический метод `M2`.  
  
-   Наконец, делегат типа `D3`, закрытый в отношении строки, создается для статического метода `M2`. Метод вызывается, чтобы показать, что он использует связанную строку.  
  
 [!code-csharp[Delegate.CreateDelegateTOM#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM/cs/openClosedOver.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM/VB/openClosedOver.vb#1)]  
  
 **Пример 2**  
  
 В следующем примере кода демонстрируется совместимость типов параметров и возвращаемых типов.  
  
> [!NOTE]
>  Данный пример кода использует <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Reflection.MethodInfo%29> перегрузки метода. Использование других перегрузок, принимающих <xref:System.Reflection.MethodInfo> похож.  
  
 В примере определяется базовый класс, именуемый `Base` и класс с именем `Derived` , наследуемый от класса `Base`. Производный класс содержит `static` (`Shared` в Visual Basic) метод с именем `MyMethod` с одним параметром типа `Base` и типом возвращаемого значения `Derived`. В примере также определяется делегат с именем `Example` , имеющий один параметр типа `Derived` и типом возвращаемого значения `Base`.  
  
 В примере кода показано, что делегат с именем `Example` может использоваться для представления метода `MyMethod`. Метод может быть привязан к делегату, так как:  
  
-   Тип параметра делегата (`Derived`) является более строгим, чем тип параметра `MyMethod` (`Base`), так как это всегда безопасно передать аргумент делегата `MyMethod`.  
  
-   Тип возвращаемого значения `MyMethod` (`Derived`) является более строгим, чем тип параметра делегата (`Base`), чтобы он всегда можно безопасно привести тип возвращаемого значения метода в возвращаемый тип делегата.  
  
 В примере кода не дает результатов.  
  
 [!code-cpp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/cpp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cpp/source.cpp#1)]
 [!code-csharp[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegate_RelaxedFit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegate_RelaxedFit/vb/source.vb#1)]  
  
 **Пример 3**  
  
 В следующем примере кода показано, все методы, которые могут представлять один тип делегата.  
  
> [!NOTE]
>  Существуют две перегрузки <xref:System.Delegate.CreateDelegate%2A> , заданный метод `firstArgument` и <xref:System.Reflection.MethodInfo>; их функциональные возможности за исключением того, что один позволяет указать, следует ли создавать неудачно, а другой всегда создает исключение. Данный пример кода использует обе перегрузки.  
  
 В примере кода определяется два класса `C` и `F`и тип делегата `D` с одним аргументом типа `C`. Классы иметь совпадающие статических методов и методов экземпляра `M1`, `M3`, и `M4`и класс `C` также содержит метод экземпляра `M2` , не имеет аргументов.  
  
 Третий класс с именем `Example` содержит код, создающий делегаты.  
  
-   Делегаты создаются для экземпляра метода `M1` типа `C` и тип `F`; каждый из них закрыт через экземпляр соответствующего типа. Метод `M1` типа `C` отображает `ID` свойства связанного экземпляра и аргумента.  
  
-   Делегат создается для метода `M2` типа `C`. Это делегат открытого экземпляра, в котором аргумент делегата представляет скрытый первый аргумент метода экземпляра. Метод не имеет аргументов.  
  
-   Делегаты создаются для статического метода `M3` типа `C` и тип `F`; это открытые статические делегаты.  
  
-   Наконец, делегаты создаются для статического метода `M4` типа `C` и тип `F`; каждый метод имеет объявляющий тип в качестве первого аргумента, и предоставляется экземпляр типа, поэтому делегаты закрыты в отношении своих первых аргументов . Метод `M4` типа `C` отображает `ID` свойства связанного экземпляра и аргумента.  
  
 [!code-csharp[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/cs/source.cs#1)]
 [!code-vb[Delegate.CreateDelegateTOM_2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Delegate.CreateDelegateTOM_2/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> cannot be bound, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.  -or-  <paramref name="method" /> is not a <see langword="RuntimeMethodInfo" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Reflection.MethodInfo" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The class instance on which <c>method</c> is invoked.</param>
        <param name="method">The name of the instance method that the delegate is to represent.</param>
        <param name="ignoreCase">A Boolean indicating whether to ignore the case when comparing the name of the method.</param>
        <summary>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance with the specified case-sensitivity.</summary>
        <returns>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает делегаты для методов экземпляра только. Метод экземпляра — это метод, который связан с экземпляром класса. статический метод — это метод, который связан с самим классом.  
  
 Эта перегрузка метода эквивалентен вызову <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Object%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> перегрузку метода, указав `true` для `throwOnBindFailure`.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к методам не являющиеся открытыми, если вызывающий объект получил <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг и если набор прав неоткрытые методы ограничена вызывающего предоставить набор или подмножество его. (См. в разделе [соображения о безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> is not an instance method.  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The <see cref="T:System.Type" /> representing the class that implements <c>method</c>.</param>
        <param name="method">The name of the static method that the delegate is to represent.</param>
        <param name="ignoreCase">A Boolean indicating whether to ignore the case when comparing the name of the method.</param>
        <summary>Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity.</summary>
        <returns>A delegate of the specified type that represents the specified static method of the specified class.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает делегаты только для статических методов. Метод экземпляра — это метод, который связан с экземпляром класса. статический метод — это метод, который связан с самим классом.  
  
 Эта перегрузка метода эквивалентен вызову <xref:System.Delegate.CreateDelegate%28System.Type%2CSystem.Type%2CSystem.String%2CSystem.Boolean%2CSystem.Boolean%29> перегрузку метода, указав `true` для `throwOnBindFailure`.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к методам не являющиеся открытыми, если вызывающий объект получил <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг и если набор прав неоткрытые методы ограничена вызывающего предоставить набор или подмножество его. (См. в разделе [соображения о безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="target" /> is not a <see langword="RuntimeType" />.  -or-  <paramref name="target" /> is an open generic type. That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.  -or-  <paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Object,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, System::Object ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * obj * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The class instance on which <c>method</c> is invoked.</param>
        <param name="method">The name of the instance method that the delegate is to represent.</param>
        <param name="ignoreCase">A Boolean indicating whether to ignore the case when comparing the name of the method.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</param>
        <summary>Creates a delegate of the specified type that represents the specified instance method to invoke on the specified class instance, with the specified case-sensitivity and the specified behavior on failure to bind.</summary>
        <returns>A delegate of the specified type that represents the specified instance method to invoke on the specified class instance.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает делегаты для методов экземпляра только. Метод экземпляра — это метод, который связан с экземпляром класса. статический метод — это метод, который связан с самим классом.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к методам не являющиеся открытыми, если вызывающий объект получил <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг и если набор прав неоткрытые методы ограничена вызывающего предоставить набор или подмножество его. (См. в разделе [соображения о безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="method" /> is not an instance method.  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public static Delegate CreateDelegate (Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate CreateDelegate(class System.Type type, class System.Type target, string method, bool ignoreCase, bool throwOnBindFailure) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.CreateDelegate(System.Type,System.Type,System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ CreateDelegate(Type ^ type, Type ^ target, System::String ^ method, bool ignoreCase, bool throwOnBindFailure);" />
      <MemberSignature Language="F#" Value="static member CreateDelegate : Type * Type * string * bool * bool -&gt; Delegate" Usage="System.Delegate.CreateDelegate (type, target, method, ignoreCase, throwOnBindFailure)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="target" Type="System.Type" />
        <Parameter Name="method" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="throwOnBindFailure" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="type">The <see cref="T:System.Type" /> of delegate to create.</param>
        <param name="target">The <see cref="T:System.Type" /> representing the class that implements <c>method</c>.</param>
        <param name="method">The name of the static method that the delegate is to represent.</param>
        <param name="ignoreCase">A Boolean indicating whether to ignore the case when comparing the name of the method.</param>
        <param name="throwOnBindFailure">
          <see langword="true" /> to throw an exception if <c>method</c> cannot be bound; otherwise, <see langword="false" />.</param>
        <summary>Creates a delegate of the specified type that represents the specified static method of the specified class, with the specified case-sensitivity and the specified behavior on failure to bind.</summary>
        <returns>A delegate of the specified type that represents the specified static method of the specified class.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод создает делегаты только для статических методов. Метод экземпляра — это метод, который связан с экземпляром класса. статический метод — это метод, который связан с самим классом.  
  
> [!NOTE]
>  Начиная с [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], этот метод можно использовать для доступа к методам не являющиеся открытыми, если вызывающий объект получил <xref:System.Security.Permissions.ReflectionPermission> с <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> флаг и если набор прав неоткрытые методы ограничена вызывающего предоставить набор или подмножество его. (См. в разделе [соображения о безопасности для отражения](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)  
>   
>  Для применения этих функциональных возможностей приложение должно использовать [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] или более поздние версии.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="type" /> is <see langword="null" />.  -or-  <paramref name="target" /> is <see langword="null" />.  -or-  <paramref name="method" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="type" /> does not inherit <see cref="T:System.MulticastDelegate" />.  -or-  <paramref name="type" /> is not a <see langword="RuntimeType" />. See [Runtime Types in Reflection](http://msdn.microsoft.com/library/c1439fb5-cf76-475d-a9d2-fe64ba858858).  -or-  <paramref name="target" /> is not a <see langword="RuntimeType" />.  -or-  <paramref name="target" /> is an open generic type. That is, its <see cref="P:System.Type.ContainsGenericParameters" /> property is <see langword="true" />.  -or-  <paramref name="method" /> is not a <see langword="static" /> method (<see langword="Shared" /> method in Visual Basic).  -or-  <paramref name="method" /> cannot be bound, for example because it cannot be found, and <paramref name="throwOnBindFailure" /> is <see langword="true" />.</exception>
        <exception cref="T:System.MissingMethodException">The <see langword="Invoke" /> method of <paramref name="type" /> is not found.</exception>
        <exception cref="T:System.MethodAccessException">The caller does not have the permissions necessary to access <paramref name="method" />.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" />.</permission>
        <altmember cref="T:System.Type" />
        <altmember cref="T:System.MulticastDelegate" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvoke">
      <MemberSignature Language="C#" Value="public object DynamicInvoke (params object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object DynamicInvoke(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvoke(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DynamicInvoke (ParamArray args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ DynamicInvoke(... cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.DynamicInvoke : obj[] -&gt; obj" Usage="delegate.DynamicInvoke args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="args">An array of objects that are the arguments to pass to the method represented by the current delegate.  -or-  <see langword="null" />, if the method represented by the current delegate does not require arguments.</param>
        <summary>Dynamically invokes (late-bound) the method represented by the current delegate.</summary>
        <returns>The object returned by the method represented by the delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод вызывает метод <xref:System.Delegate.DynamicInvokeImpl%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).  -or-  The number, order, or type of parameters listed in <paramref name="args" /> is invalid.</exception>
        <exception cref="T:System.ArgumentException">The method represented by the delegate is invoked on an object or a class that does not support it.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">The method represented by the delegate is an instance method and the target object is <see langword="null" />.  -or-  One of the encapsulated methods throws an exception.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="DynamicInvokeImpl">
      <MemberSignature Language="C#" Value="protected virtual object DynamicInvokeImpl (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance object DynamicInvokeImpl(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.DynamicInvokeImpl(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function DynamicInvokeImpl (args As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Object ^ DynamicInvokeImpl(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member DynamicInvokeImpl : obj[] -&gt; obj&#xA;override this.DynamicInvokeImpl : obj[] -&gt; obj" Usage="delegate.DynamicInvokeImpl args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args">An array of objects that are the arguments to pass to the method represented by the current delegate.  -or-  <see langword="null" />, if the method represented by the current delegate does not require arguments.</param>
        <summary>Dynamically invokes (late-bound) the method represented by the current delegate.</summary>
        <returns>The object returned by the method represented by the delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод реализует метод <xref:System.Delegate.DynamicInvoke%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).  -or-  The number, order, or type of parameters listed in <paramref name="args" /> is invalid.</exception>
        <exception cref="T:System.ArgumentException">The method represented by the delegate is invoked on an object or a class that does not support it.</exception>
        <exception cref="T:System.Reflection.TargetInvocationException">The method represented by the delegate is an instance method and the target object is <see langword="null" />.  -or-  One of the encapsulated methods throws an exception.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.DynamicInvoke(System.Object[])" />
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="delegate.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">The object to compare with the current delegate.</param>
        <summary>Determines whether the specified object and the current delegate are of the same type and share the same targets, methods, and invocation list.</summary>
        <returns>
          <see langword="true" /> if <paramref name="obj" /> and the current delegate have the same targets, methods, and invocation list; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если два делегата не того же типа, они не считаются равными.  
  
> [!IMPORTANT]
>  В .NET Framework версий 1.0 и 1.1 два делегата были считаются равными, если их целевые объекты, методы и списки вызовов равны, даже если были делегаты различных типов.  
  
 Методы и целевые объекты сравниваются на предмет равенства следующим образом:  
  
-   Если два сравниваемых метода являются статическими и не тот же метод на тот же класс, методы считаются равными и целевые объекты считаются равными.  
  
-   Если два сравниваемых метода являются методами экземпляра и представляют один и тот же метод на тот же объект, методы считаются равными и целевые объекты считаются равными.  
  
-   В противном случае методы, не считаются равными и целевые объекты не считаются равными.  
  
 Два списка вызовов, считаются идентичными только в том случае, если они имеют порядке и соответствующие элементы двух списков представляют один и тот же метод и целевой объект.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Object" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="delegate.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a hash code for the delegate.</summary>
        <returns>A hash code for the delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Возвращаемое значение этого метода не должны сохраняться по двум причинам. Во-первых хэш-функции класса может быть изменена для создания лучшего распределения. Во-вторых реализация по умолчанию этого класса не гарантирует, что то же значение будет возвращаться разные экземпляры.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Object.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="GetInvocationList">
      <MemberSignature Language="C#" Value="public virtual Delegate[] GetInvocationList ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate[] GetInvocationList() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetInvocationList" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInvocationList () As Delegate()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Delegate ^&gt; ^ GetInvocationList();" />
      <MemberSignature Language="F#" Value="abstract member GetInvocationList : unit -&gt; Delegate[]&#xA;override this.GetInvocationList : unit -&gt; Delegate[]" Usage="delegate.GetInvocationList " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns the invocation list of the delegate.</summary>
        <returns>An array of delegates representing the invocation list of the current delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый из делегатов в массиве представляет ровно один метод.  
  
 Порядок делегатов в массиве является том же порядке, в котором текущий делегат вызывает методы, которые представляют эти делегаты.  
  
   
  
## Examples  
 В следующем примере присваивается три метода к делегату. Затем он вызывает <xref:System.Delegate.GetInvocationList%2A> метод для получения общего числа методов, назначенный делегату, выполнение делегатов в обратном порядке, а также выполнять методы, имя которого не включают подстроки «File».  
  
 [!code-csharp[System.Delegate.GetInvocationList#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/cs/GetInvocationList1.cs#1)]
 [!code-vb[System.Delegate.GetInvocationList#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Delegate.GetInvocationList/vb/GetInvocationList1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetMethodImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetMethodImpl () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : unit -&gt; System.Reflection.MethodInfo" Usage="delegate.GetMethodImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gets the static method represented by the current delegate.</summary>
        <returns>A <see cref="T:System.Reflection.MethodInfo" /> describing the static method represented by the current delegate.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод применим только в том случае, если текущий делегат представляет статический метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Delegate.Method" />
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="delegate.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">Not supported.</param>
        <param name="context">Not supported.</param>
        <summary>Not supported.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">This method is not supported.</exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
        <altmember cref="T:System.Runtime.Serialization.SerializationInfo" />
        <altmember cref="T:System.Runtime.Serialization.StreamingContext" />
      </Docs>
    </Member>
    <Member MemberName="Method">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo Method { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo Method" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Method" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Method As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::MethodInfo ^ Method { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Method : System.Reflection.MethodInfo" Usage="System.Delegate.Method" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the method represented by the delegate.</summary>
        <value>Объект <see cref="T:System.Reflection.MethodInfo" /> описывающий метод, представленный делегатом.</value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Delegate.GetMethodImpl" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Equality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Delegate * Delegate -&gt; bool" Usage="d1 = d2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">The first delegate to compare.</param>
        <param name="d2">The second delegate to compare.</param>
        <summary>Determines whether the specified delegates are equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="d1" /> is equal to <paramref name="d2" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Два делегата одного типа с одинаковые целевые объекты, методы и списки вызовов, считаются равными.  
  
 Если два делегата не того же типа, они не считаются равными.  
  
> [!IMPORTANT]
>  В .NET Framework версий 1.0 и 1.1 два делегата были считаются равными, если их целевые объекты, методы и списки вызовов равны, даже если были делегаты различных типов.  
  
 Методы и целевые объекты сравниваются на предмет равенства следующим образом:  
  
-   Если два сравниваемых метода являются статическими и не тот же метод на тот же класс, методы считаются равными и целевые объекты считаются равными.  
  
-   Если два сравниваемых метода являются методами экземпляра и представляют один и тот же метод на тот же объект, методы считаются равными и целевые объекты считаются равными.  
  
-   В противном случае методы, не считаются равными и целевые объекты не считаются равными.  
  
 Два списка вызовов, считаются идентичными, если они имеют порядке и соответствующие элементы двух списков представляют один и тот же метод и целевой объект.  
  
 Имеет эквивалентный метод для этого оператора <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Delegate d1, Delegate d2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Delegate d1, class System.Delegate d2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.op_Inequality(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (d1 As Delegate, d2 As Delegate) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Delegate ^ d1, Delegate ^ d2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Delegate * Delegate -&gt; bool" Usage="System.Delegate.op_Inequality (d1, d2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d1" Type="System.Delegate" />
        <Parameter Name="d2" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d1">The first delegate to compare.</param>
        <param name="d2">The second delegate to compare.</param>
        <summary>Determines whether the specified delegates are not equal.</summary>
        <returns>
          <see langword="true" /> if <paramref name="d1" /> is not equal to <paramref name="d2" />; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Два делегата считаются неравными, если они принадлежат разным типам или имеют различные методы, целевые объекты или списки вызовов.  
  
 Если два делегата не того же типа, они не считаются равными.  
  
> [!IMPORTANT]
>  В .NET Framework версий 1.0 и 1.1 два делегата считаются равными, если их целевые объекты, методы и списки вызовов, даже если были делегаты различных типов.  
  
 Методы и целевые объекты сравниваются на предмет равенства следующим образом:  
  
-   Если два сравниваемых метода являются статическими и не тот же метод на тот же класс, методы считаются равными и целевые объекты считаются равными.  
  
-   Если два сравниваемых метода являются методами экземпляра и представляют один и тот же метод на тот же объект, методы считаются равными и целевые объекты считаются равными.  
  
-   В противном случае методы, не считаются равными и целевые объекты не считаются равными.  
  
 Два списка вызовов не равны, если они имеют различные размеры, если они упорядочены по-разному, или в том случае, если хотя бы один элемент из одного списка представляет метод или целевой объект, отличный от представленного соответствующим элементом в другом списке.  
  
 Имеет эквивалентный метод для этого оператора <xref:System.Delegate.Equals%28System.Object%29?displayProperty=nameWithType>]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public static Delegate Remove (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate Remove(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remove (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ Remove(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member Remove : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.Remove (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">The delegate from which to remove the invocation list of <c>value</c>.</param>
        <param name="value">The delegate that supplies the invocation list to remove from the invocation list of <c>source</c>.</param>
        <summary>Removes the last occurrence of the invocation list of a delegate from the invocation list of another delegate.</summary>
        <returns>A new delegate with an invocation list formed by taking the invocation list of <paramref name="source" /> and removing the last occurrence of the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the invocation list of <paramref name="source" />. Returns <paramref name="source" /> if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the invocation list of <paramref name="source" />. Returns a null reference if the invocation list of <paramref name="value" /> is equal to the invocation list of <paramref name="source" /> or if <paramref name="source" /> is a null reference.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если список вызовов `value` соответствует набор смежных элементов в списке вызовов `source`, затем список вызовов `value` говорят, что в списке вызовов `source`. Если список вызовов `value` встречается более одного раза в списке вызовов `source`, удаляется последнее вхождение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <exception cref="T:System.ArgumentException">The delegate types do not match.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveAll">
      <MemberSignature Language="C#" Value="public static Delegate RemoveAll (Delegate source, Delegate value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Delegate RemoveAll(class System.Delegate source, class System.Delegate value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveAll(System.Delegate,System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RemoveAll (source As Delegate, value As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Delegate ^ RemoveAll(Delegate ^ source, Delegate ^ value);" />
      <MemberSignature Language="F#" Value="static member RemoveAll : Delegate * Delegate -&gt; Delegate" Usage="System.Delegate.RemoveAll (source, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="source" Type="System.Delegate" />
        <Parameter Name="value" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="source">The delegate from which to remove the invocation list of <c>value</c>.</param>
        <param name="value">The delegate that supplies the invocation list to remove from the invocation list of <c>source</c>.</param>
        <summary>Removes all occurrences of the invocation list of a delegate from the invocation list of another delegate.</summary>
        <returns>A new delegate with an invocation list formed by taking the invocation list of <paramref name="source" /> and removing all occurrences of the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the invocation list of <paramref name="source" />. Returns <paramref name="source" /> if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the invocation list of <paramref name="source" />. Returns a null reference if the invocation list of <paramref name="value" /> is equal to the invocation list of <paramref name="source" />, if <paramref name="source" /> contains only a series of invocation lists that are equal to the invocation list of <paramref name="value" />, or if <paramref name="source" /> is a null reference.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если список вызовов `value` соответствует набор смежных элементов в списке вызовов `source`, затем список вызовов `value` говорят, что в списке вызовов `source`. Если список вызовов `value` встречается более одного раза в списке вызовов `source`, все вхождения удаляются.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <exception cref="T:System.ArgumentException">The delegate types do not match.</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.RemoveImpl(System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RemoveImpl">
      <MemberSignature Language="C#" Value="protected virtual Delegate RemoveImpl (Delegate d);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Delegate RemoveImpl(class System.Delegate d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Delegate.RemoveImpl(System.Delegate)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function RemoveImpl (d As Delegate) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual Delegate ^ RemoveImpl(Delegate ^ d);" />
      <MemberSignature Language="F#" Value="abstract member RemoveImpl : Delegate -&gt; Delegate&#xA;override this.RemoveImpl : Delegate -&gt; Delegate" Usage="delegate.RemoveImpl d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Delegate" />
      </Parameters>
      <Docs>
        <param name="d">The delegate that supplies the invocation list to remove from the invocation list of the current delegate.</param>
        <summary>Removes the invocation list of a delegate from the invocation list of another delegate.</summary>
        <returns>A new delegate with an invocation list formed by taking the invocation list of the current delegate and removing the invocation list of <paramref name="value" />, if the invocation list of <paramref name="value" /> is found within the current delegate's invocation list. Returns the current delegate if <paramref name="value" /> is <see langword="null" /> or if the invocation list of <paramref name="value" /> is not found within the current delegate's invocation list. Returns <see langword="null" /> if the invocation list of <paramref name="value" /> is equal to the current delegate's invocation list.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если список вызовов `value` соответствует набор смежных элементов в списке вызовов текущего делегата, а затем список вызовов `value` происходит в списке вызовов текущего делегата. Если список вызовов `value` встречается более одного раза в списке вызовов текущего делегата, удаляется последнее вхождение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">The caller does not have access to the method represented by the delegate (for example, if the method is private).</exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
        <altmember cref="M:System.Delegate.Remove(System.Delegate,System.Delegate)" />
        <altmember cref="M:System.Delegate.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Delegate.Target" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Target : obj" Usage="System.Delegate.Target" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the class instance on which the current delegate invokes the instance method.</summary>
        <value>Объект, для которого текущий делегат вызывает метод экземпляра, если делегат представляет метод экземпляра; <see langword="null" /> Если делегат представляет статический метод.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод экземпляра — это метод, который связан с экземпляром класса. статический метод — это метод, который связан с самим классом.  
  
 Если делегат вызывает один или несколько методов экземпляра, это свойство возвращает цель последнего метода экземпляра из списка вызовов.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission">При вызове с поздним связыванием через механизмы например <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />. Связанное перечисление: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>