<Type Name="Double" FullName="System.Double">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4bb51935ed74b1ef60e7451850bf1def79a76574" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36431931" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float64 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float64&gt;, class System.IConvertible, class System.IEquatable`1&lt;float64&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Double" />
  <TypeSignature Language="VB.NET" Value="Public Structure Double&#xA;Implements IComparable, IComparable(Of Double), IConvertible, IEquatable(Of Double), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Double : IComparable, IComparable&lt;double&gt;, IConvertible, IEquatable&lt;double&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type double = struct&#xA;    interface IFormattable&#xA;    interface IConvertible" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Double&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет число двойной точности с плавающей запятой.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double> Тип значения представляет 64-разрядное число двойной точности в диапазоне от-1.79769313486232e308 + 1, 79769313486232E308, а также положительный и отрицательный нуль, <xref:System.Double.PositiveInfinity>, <xref:System.Double.NegativeInfinity>и не является числом (<xref:System.Double.NaN>). Он предназначен для представления значений, имеют слишком большой (например, расстояния между планеты или галактики) или очень малые (молекулярные масса вещества в килограмм), которые часто являются неточными (например, расстояние от Земли до другой Солнечной системе), <xref:System.Double> тип соответствует стандарту IEC 60559:1989 (IEEE 754) стандартная двоичной арифметики с плавающей запятой.  
  
 В этом разделе:  
  
-   [Представление с плавающей запятой и точностью](#Precision)  
  
-   [Тестирование на равенство](#Equality)  
  
-   [Значения с плавающей запятой и исключений](#Exceptions)  
  
-   [Преобразования типов и структура с двойной точностью](#Conversions)  
  
-   [Функции с плавающей запятой](#Functionality)  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>Представление с плавающей запятой и точностью  
 <xref:System.Double> Тип данных хранит значения с плавающей запятой двойной точности в 64-разрядных двоичном формате, как показано в следующей таблице:  
  
|Отделение|Биты|  
|----------|----------|  
|Значащей части числа или мантиссы|0-51|  
|Показатель степени|52-62|  
|Знак (0 = положительное, 1 = отрицательное)|63|  
  
 Точно так же как десятичные дроби удается точно представить некоторые дробные значения (такие как 1/3 или <xref:System.Math.PI?displayProperty=nameWithType>), двоичные дроби удается представить некоторые дробных значений. Например 1/10, которое представляется точно.1 десятичной дробью, представленного.001100110011 виде бинарной доли, с помощью шаблона «0011» повторяющийся до бесконечности. В этом случае значение с плавающей запятой предоставляет представление неточный число, которое он представляет. Выполнения дополнительных математических операций на исходное значение с плавающей запятой часто, как правило, чтобы увеличить его недостаточной точности. Например если мы сравним результат умножения.1 по 10 и добавление.1 для.1 девяти раз, видно, что. Кроме того, из-за использования он восемь больше операций, созданных менее точный результат. Обратите внимание, что это несоответствие становится очевидной, только в том случае, если мы можем отобразить два <xref:System.Double> значения с помощью символа «R» [строкой стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md), который при необходимости отображает все 17 значащих цифр, поддерживаемые <xref:System.Double> тип.  
  
 [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
 [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
 Так как некоторые числа невозможно представить точно так, как доли двоичные значения, числа с плавающей запятой можно только приблизительные вещественных чисел.  
  
 Все числа с плавающей запятой, также имеют ограниченное число значащих цифр, который определяет точность значение с плавающей запятой аппроксимирует вещественное число.   Объект <xref:System.Double> значение имеет до 15 знаков после запятой, хотя для внутренних целей поддерживается до 17 знаков. Это означает, что некоторые операции с плавающей запятой не имеет точность, чтобы изменить значение с плавающей запятой. Ниже приведен пример. Он определяет очень большое значение с плавающей запятой, а затем добавляет произведение <xref:System.Double.Epsilon?displayProperty=nameWithType> и один септильонов к нему. Продукт, тем не менее, слишком мал для изменения исходного значения с плавающей запятой. Его наименее значащие цифры — тысячные доли, а наиболее значимую цифру в продукте — 1<sup>-312</sup>.  
  
 [!code-csharp[System.Double.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation2.cs#4)]
 [!code-vb[System.Double.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation2.vb#4)]  
  
 Ограниченную точность числа с плавающей запятой происходит следующее:  
  
-   Два числа с плавающей запятой, казаться равными при определенной точности могут не отличаются, поскольку их менее значащие цифры различаются. В следующем примере складываются ряд чисел и их сумма сравнивается с их ожидаемой суммы. Несмотря на то, что отображаются два значения должны совпадать, вызов `Equals` метод указывает, что они не являются.  
  
     [!code-csharp[System.Double.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Double.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist3.vb#6)]  
  
     Если изменить элементы формата в <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> инструкции от `{0}` и `{1}` для `{0:R}` и `{1:R}` для отображения всех значащих цифр из двух <xref:System.Double> значения, очевидно, что эти два значения не равны из-за потери точности при выполнении операций сложения. В этом случае проблему можно разрешить путем вызова <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType> метод округления <xref:System.Double> значения до требуемой точности перед выполнением сравнения.  
  
-   Математическая операция или сравнение, использующий число с плавающей запятой может не дать разные результаты при использовании десятичного числа, так как двоичное число с плавающей запятой может не равняться десятичное число. Предыдущего примера показано это результат умножения.1 по 10 и добавление.1 раз.  
  
     Если точность в математических операций с дробными важен, можно использовать <xref:System.Decimal> вместо <xref:System.Double> типа. Если точность числовых операций с целыми значениями за пределами диапазона <xref:System.Int64> или <xref:System.UInt64> типов важно использовать <xref:System.Numerics.BigInteger> типа.  
  
-   Значение может не кругового пути, если представлено числом с плавающей запятой. Если некоторой операции, преобразующей исходное число с плавающей запятой в другую форму, применения обратной операции полученный результат обратно в число с плавающей запятой и окончательный число с плавающей запятой не равно исходное значение считается приема-передачи число с плавающей запятой. Обмен данными может завершиться ошибкой, так как один или несколько менее значащих цифр теряются или меняются в результате преобразования. В следующем примере три <xref:System.Double> значения преобразуются в строки и сохранены в файле. Как показывают выходные данные, тем не менее, несмотря на то, что значения выглядят идентичными, восстановленные значения не равны исходные значения.  
  
     [!code-csharp[System.Double.Structure#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist4.cs#7)]
     [!code-vb[System.Double.Structure#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist4.vb#7)]  
  
     В этом случае значения могут быть успешно обхода с помощью «G17» [строкой стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) для сохранения полная точность <xref:System.Double> значения, как показано в следующем примере.  
  
     [!code-csharp[System.Double.Structure#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist5.cs#8)]
     [!code-vb[System.Double.Structure#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist5.vb#8)]  

   > [!IMPORTANT]
   >  При использовании с <xref:System.Double> значением, описатель формата «R» в некоторых случаях не удается успешного обратного преобразования исходного значения. Чтобы убедиться, что <xref:System.Double> значения успешного обратного преобразования, используйте описатель формата «G17».

-   <xref:System.Single> значения имеют меньшую точность, чем <xref:System.Double> значения. Объект <xref:System.Single> значение, которое преобразуется в первый взгляд эквивалентные <xref:System.Double> часто не равно <xref:System.Double> значение из-за различия в точности. В следующем примере результат деления идентичные операций присваивается <xref:System.Double> и <xref:System.Single> значение. После <xref:System.Single> значение приводится к <xref:System.Double>, сравнение двух значений показывает, что они не равны.  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     Чтобы избежать этой проблемы, используйте <xref:System.Double> вместо <xref:System.Single> тип данных, или используйте <xref:System.Math.Round%2A> метод, чтобы оба значения имеют такую же точность.  
  
 Кроме того, результат арифметических операций и операций назначения со <xref:System.Double> значения могут немного отличаться от платформы, из-за потери точности <xref:System.Double> типа. Например, результат назначения литерал <xref:System.Double> значение может отличаться в 32-разрядных и 64-разрядных версиях платформы .NET Framework. Это показано в следующем примере различие при литерала значение - 4.42330604244772E-305 и переменная, значение которого равно - 4.42330604244772E-305, присваиваются <xref:System.Double> переменной. Обратите внимание, что результат <xref:System.Double.Parse%28System.String%29> метод в этом случае не страдают от потери точности.  
  
 [!code-csharp[System.Double.Class.Precision#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.class.precision/cs/precision1.cs#1)]
 [!code-vb[System.Double.Class.Precision#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.class.precision/vb/precision1.vb#1)]  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>Тестирование на равенство  
 Одинаковыми, два <xref:System.Double> значения должны представлять одинаковые значения. Однако из-за различия в точности между значениями, или из-за потери точности, одно или оба значения, значения с плавающей запятой, которые должны быть идентичными часто оказываются считались из-за различий в их менее значащие цифры. В результате вызовы <xref:System.Double.Equals%2A> метод, чтобы определить, равны ли два значения или вызовы <xref:System.Double.CompareTo%2A> метод, чтобы определить связь между двумя <xref:System.Double> значения, часто привести к непредвиденным результатам. Это видно в следующем примере, где два внешне равно <xref:System.Double> значения оказываются были не эквивалентны, поскольку первый имеет 15-знаковая точность, а второй — 17.  
  
 [!code-csharp[System.Double.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Double.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison1.vb#9)]  
  
 Вычисленные значения, выполните разных путей кода и который осуществляется различными способами, часто доказать, что были не эквивалентны. В следующем примере один <xref:System.Double> значение возводится в квадрат, а затем вычисляется квадратный корень восстановить исходное значение. Второй <xref:System.Double> умноженное 3.51 и перед квадратный корень из результат делится 3.51, чтобы восстановить исходное значение в квадрате. Несмотря на то, что отображаются два значения идентичными, вызов <xref:System.Double.Equals%28System.Double%29> метод указывает, что они не равны. С помощью строки стандартного формата «R» для возврата результирующую строку, отображает все значимые цифры каждого значения типа Double показывает, что значение секунд.0000000000001 меньше, чем первый.  
  
 [!code-csharp[System.Double.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Double.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison2.vb#10)]  
  
 В случаях, когда потеря точности может повлиять на результат сравнения, могут использовать любой из следующих способов для вызова <xref:System.Double.Equals%2A> или <xref:System.Double.CompareTo%2A> метод:  
  
-   Вызовите <xref:System.Math.Round%2A?displayProperty=nameWithType> метод, чтобы гарантировать, что оба значения имеют такую же точность. В следующем примере изменяется в предыдущем примере, чтобы использовать этот подход, чтобы эквивалентны двух дробных значений.  
  
     [!code-csharp[System.Double.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Double.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison3.vb#11)]  
  
     Обратите внимание, что проблема точность по-прежнему применяется округление средние значения. Дополнительные сведения см. в описании метода <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType>.  
  
-   Проверка на равенство приблизительное вместо проверки на равенство. Это требует определения либо абсолютной суммы, по которому два значения могут отличаться, но по-прежнему совпадать, или определить относительную величину, на который меньшее значение может отличаться от большего значения.  
  
    > [!WARNING]
    >  <xref:System.Double.Epsilon?displayProperty=nameWithType> Иногда используется в качестве меры абсолютное расстояние между двумя <xref:System.Double> значениями при проверки на равенство.  Тем не менее <xref:System.Double.Epsilon?displayProperty=nameWithType> измеряет наименьшее возможное значение, которое может быть добавляется или вычитается из, <xref:System.Double> , значение которого равно нулю. Большинство положительные и отрицательные <xref:System.Double> значений, значение <xref:System.Double.Epsilon?displayProperty=nameWithType> слишком мал, чтобы быть обнаруженным. Таким образом за исключением значений, равно нулю, не рекомендуется использовать его в тесты на равенство.  
  
     В следующем примере используется последний подход для определения `IsApproximatelyEqual` метод, который проверяет относительная разница между двумя значениями. Результат вызова также сопоставляются `IsApproximatelyEqual` метод и <xref:System.Double.Equals%28System.Double%29> метод.  
  
     [!code-csharp[System.Double.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Double.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>Значения с плавающей запятой и исключений  
 В отличие от операций с целочисленными типами, которые создают исключения в случаях переполнения или недопустимые операции, например при делении на ноль, операций со значениями с плавающей запятой не вызывают исключений. Вместо этого в исключительных ситуациях результат операции с плавающей запятой является ноль, плюс бесконечности, отрицательной бесконечностью или не является числом (NaN):  
  
-   Если результат операции с плавающей запятой слишком мал для конечного формата, результат равен нулю. Это может произойти при умножении двух очень маленьких значений, как показано в следующем примере.  
  
     [!code-csharp[System.Double.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Double.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional1.vb#1)]  
  
-   При величина результата операции с плавающей точкой выходит за пределы типа конечного формата, результатом операции является <xref:System.Double.PositiveInfinity> или <xref:System.Double.NegativeInfinity>, в зависимости от знака результата. Результат операции, которая вызывает переполнение <xref:System.Double.MaxValue?displayProperty=nameWithType> — <xref:System.Double.PositiveInfinity>и результат операции, которая вызывает переполнение <xref:System.Double.MinValue?displayProperty=nameWithType> — <xref:System.Double.NegativeInfinity>, как показано в следующем примере.  
  
     [!code-csharp[System.Double.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Double.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Double.PositiveInfinity> также происходит с деление на ноль с положительным делимое, и <xref:System.Double.NegativeInfinity> полученный в результате деления на ноль с отрицательным делимое.  
  
-   Если операции с плавающей запятой недопустимо, результат операции становится <xref:System.Double.NaN>. Например <xref:System.Double.NaN> результатов из следующих операций:  
  
    -   Деление на ноль с делимое равно нулю. Обратите внимание, в других случаях деления по нулевой результат, либо <xref:System.Double.PositiveInfinity> или <xref:System.Double.NegativeInfinity>.  
  
-   Все операции с плавающей запятой с недопустимые входные данные. Например, вызов <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> метод с отрицательными значениями возвращает <xref:System.Double.NaN>, как происходит вызов <xref:System.Math.Acos%2A?displayProperty=nameWithType> метода со значением, которое больше единицы или менее отрицательное значение.  
  
-   Любая операция с аргументом, значение которого является <xref:System.Double.NaN?displayProperty=nameWithType>.  
  
<a name="Conversions"></a>   
## <a name="type-conversions-and-the-double-structure"></a>Преобразования типов и структура с двойной точностью  
 <xref:System.Double> Структура не определяет любые операторы явного или неявного преобразования; вместо этого преобразования реализуются с помощью компилятора.  
  
 Преобразование значения любого числового типа-примитива <xref:System.Double> расширяющие преобразования и поэтому не требует оператора явного приведения или вызова метода преобразования, если компилятор требует его явным образом. Например, компилятор C# требует оператора приведения для преобразования из <xref:System.Decimal> для <xref:System.Double>, а компилятор Visual Basic не поддерживает. В следующем примере преобразуется минимальное или максимальное значение другие числовые типы-примитивы <xref:System.Double>.  
  
 [!code-csharp[System.Double.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert1.cs#20)]
 [!code-vb[System.Double.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert1.vb#20)]  
  
 Кроме того <xref:System.Single> значения <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, и <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> преобразовать для <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, и <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>соответственно.  
  
 Обратите внимание, что преобразование значения некоторых числовых типов к <xref:System.Double> значение может приводить к потере точности. Как показано в примере, возможна потеря точности при преобразовании <xref:System.Decimal>, <xref:System.Int64>, <xref:System.Single>, и <xref:System.UInt64> значения <xref:System.Double> значения.  
  
 Преобразование <xref:System.Double> значения со значением любого другого типа числовые примитивы сужающего преобразования и требуется оператор приведения (в C#), метод преобразования (в Visual Basic) или вызов <xref:System.Convert> метод. Значения, которые находятся вне диапазона целевого типа данных, определенных для целевого типа `MinValue` и `MaxValue` поведение свойств, как показано в следующей таблице.  
  
|Тип результирующего значения|Результат|  
|-----------------|------------|  
|Любой целочисленный тип|<xref:System.OverflowException> Исключение, если преобразование выполняется в проверяемом контексте.<br /><br /> Если преобразование выполняется в непроверенном контексте (по умолчанию в C#), операции преобразования выполняется успешно, но произойдет переполнение значения.|  
|<xref:System.Decimal>|Исключение <xref:System.OverflowException>.|  
|<xref:System.Single>|<xref:System.Single.NegativeInfinity?displayProperty=nameWithType> для отрицательных значений.<br /><br /> <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> для положительных значений.|  
  
 Кроме того <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, и <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> throw <xref:System.OverflowException> для преобразования в целые числа в проверяемом контексте, но эти значения переполнения при преобразовании к целым числам в непроверенном контексте. Для преобразования в <xref:System.Decimal>, всегда возникает исключение <xref:System.OverflowException>. Для преобразования в <xref:System.Single>, они преобразуются в <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, и <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>соответственно.  
  
 Обратите внимание, что с может привести к потере точности <xref:System.Double> значения другого числового типа. В случае преобразование не интегрированные <xref:System.Double> значения, как показывают выходные данные примера, дробная будут потеряны при <xref:System.Double> значение округляется (как в Visual Basic) или усечен (как в C#). Для преобразования в <xref:System.Decimal> и <xref:System.Single> значения, <xref:System.Double> value не может иметь точное представление в целевой тип данных.  
  
 В следующем примере преобразуется ряд <xref:System.Double> значения в нескольких числовых типов. Преобразования выполняются в проверяемом контексте в Visual Basic (по умолчанию) и в C# (из-за [проверяется](~/docs/csharp/language-reference/keywords/checked.md) ключевое слово). Выходные данные примера показан результат преобразования в обоих checked непроверяемом контексте. Преобразование может быть выполнено в непроверенном контексте в Visual Basic при компиляции с `/removeintchecks+` переключатель компилятора и C#, преобразуйте `checked` инструкции.  
  
 [!code-csharp[System.Double.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/convert2.cs#21)]
 [!code-vb[System.Double.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/convert2.vb#21)]  
  
 Дополнительные сведения о преобразовании числовых типов см. в разделе [преобразование типов в .NET Framework](~/docs/standard/base-types/type-conversion.md) и [таблицы преобразования типов](~/docs/standard/base-types/conversion-tables.md).  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>Функции с плавающей запятой  
 <xref:System.Double> Структуры и связанных типов предоставляют методы для выполнения операций в следующих областях:  
  
-   **Сравнение значений**. Можно вызвать <xref:System.Double.Equals%2A> метод, чтобы определить, является ли два <xref:System.Double> значения равны или <xref:System.Double.CompareTo%2A> метод, чтобы определить связь между двумя значениями.  
  
     <xref:System.Double> Структура также поддерживает полный набор операторов сравнения. Например можно проверки на равенство или неравенство или определить, является ли одно значение больше или равно другому. Если один из операндов имеет числовой тип, отличный от <xref:System.Double>, он преобразуется в <xref:System.Double> перед выполнением сравнения.  
  
    > [!WARNING]
    >  Из-за различия в точности два <xref:System.Double> значения, которые должны быть равны может оказываются считались, что влияет на результат сравнения. В разделе [проверки на равенство](#Equality) Дополнительные сведения о сравнении двух <xref:System.Double> значения.  
  
     Можно также вызвать <xref:System.Double.IsNaN%2A>, <xref:System.Double.IsInfinity%2A>, <xref:System.Double.IsPositiveInfinity%2A>, и <xref:System.Double.IsNegativeInfinity%2A> методов для проверки на эти особые значения.  
  
-   **Математические операции**. Стандартные арифметические операции, такие как сложение, вычитание, умножение и деление, реализуются, языковые компиляторы и инструкции языка CIL (Common Intermediate), а не по <xref:System.Double> методы. Если один из операндов Математическая операция имеет числовой тип, отличный от <xref:System.Double>, он преобразуется в <xref:System.Double> перед выполнением операции. Результатом операции является также <xref:System.Double> значение.  
  
     Другие математические операции можно выполнить с помощью `static` (`Shared` в Visual Basic) методов в <xref:System.Math?displayProperty=nameWithType> класса. Он включает дополнительные методы, обычно используется для выполнения арифметических действий (таких как <xref:System.Math.Abs%2A?displayProperty=nameWithType>, <xref:System.Math.Sign%2A?displayProperty=nameWithType>, и <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>), geometry (такие как <xref:System.Math.Cos%2A?displayProperty=nameWithType> и <xref:System.Math.Sin%2A?displayProperty=nameWithType>) и математического анализа (такие как <xref:System.Math.Log%2A?displayProperty=nameWithType>).  
  
     Можно управлять отдельными битами <xref:System.Double> значение. <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType> Метод сохраняет <xref:System.Double> значение битового шаблона в 64-разрядное целое число. <xref:System.BitConverter.GetBytes%28System.Double%29?displayProperty=nameWithType> Метод возвращает его битов в массив байтов.  
  
-   **Округление**. Округление для часто используется как способ уменьшить влияние различия между значениями, вызванные неполадками представление с плавающей запятой и точностью. Можно провести округление <xref:System.Double> , вызвав <xref:System.Math.Round%2A?displayProperty=nameWithType> метод.  
  
-   **Форматирование**. Вы можете преобразовать <xref:System.Double> значение в строковое представление, вызвав <xref:System.Double.ToString%2A> метода или с помощью составного форматирования. Сведения об управлении строковое представление значения с плавающей запятой в строках формата см. в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md) разделы.  
  
-   **Разбор строк**. Можно преобразовать строковое представление значения с плавающей запятой для <xref:System.Double> значение с помощью вызова <xref:System.Double.Parse%2A> или <xref:System.Double.TryParse%2A> метод. Если операция анализа завершается ошибкой, <xref:System.Double.Parse%2A> метод создает исключение, в то время как <xref:System.Double.TryParse%2A> возвращает `false`.  
  
-   **Преобразование типов**. <xref:System.Double> Структура предоставляет явной реализации интерфейса для <xref:System.IConvertible> интерфейс, который поддерживает преобразование между любые две стандартные типы данных .NET Framework. Языковые компиляторы также поддерживает неявное преобразование значений всех других стандартных числовых типов к <xref:System.Double> значения. Преобразование значения любого Стандартная числового типа, чтобы <xref:System.Double> расширяющие преобразования и не требуют от пользователя приведения оператор или преобразование метода  
  
     Однако преобразование <xref:System.Int64> и <xref:System.Single> значения может приводить к потере точности. В следующей таблице перечислены различия в точности для каждой из этих типов:  
  
    |Тип|Максимальная точность|Внутренняя точность|  
    |----------|-----------------------|------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int64>|19 цифр.|19 цифр.|  
    |<xref:System.Single>|7 десятичных разрядов|9 десятичных цифр.|  
  
     Чаще всего проблема точности влияет на <xref:System.Single> значения, которые преобразуются в <xref:System.Double> значения. В следующем примере, полученных при операции деления идентичные значения не равны, так как одно из значений является одним точности с плавающей запятой, преобразуется <xref:System.Double>.  
  
     [!code-csharp[System.Double.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/representation1.cs#3)]
     [!code-vb[System.Double.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/representation1.vb#3)]  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Double>:  
  
 [!code-cpp[Double Example#1](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#1)]
 [!code-csharp[Double Example#1](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#1)]
 [!code-vb[Double Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Все члены этого типа являются потокобезопасными. Элементы, используемые для изменения состояния экземпляра на самом деле возвращается новый экземпляр инициализирован с новым значением. Как с любым другим типом, чтения и записи к общей переменной, содержащий экземпляр этого типа должны быть защищены блокировкой, чтобы гарантировать потокобезопасность.</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Single" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сравнивает данный экземпляр с указанным объектом или объектом <see cref="T:System.Double" /> и возвращает целое число, указывающее, что значение данного экземпляра меньше, больше или равно значению заданного объекта или объекта <see cref="T:System.Double" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Double) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(double value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : double -&gt; int&#xA;override this.CompareTo : double -&gt; int" Usage="double.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Число двойной точности с плавающей запятой для сравнения.</param>
        <summary>Сравнивает данный экземпляр с заданным числом двойной точности с плавающей запятой и возвращает целое число, которое показывает, является ли значение данного экземпляра меньше, больше или равно значению заданного числа двойной точности с плавающей запятой.</summary>
        <returns>Знаковое число, представляющее относительные значения этого экземпляра и параметра <paramref name="value" />.  
  
 <list type="table"><listheader><term> Возвращаемое значение  </term><description> Описание  </description></listheader><item><term> Меньше нуля  </term><description> Этот экземпляр меньше <paramref name="value" />. -или- Этот экземпляр не является числом (<see cref="F:System.Double.NaN" />), а <paramref name="value" /> является числом.  </description></item><item><term> Ноль  </term><description> Этот экземпляр равен <paramref name="value" />. -или- Этот экземпляр и <paramref name="value" /> не являются числом (<see cref="F:System.Double.NaN" />), <see cref="F:System.Double.PositiveInfinity" /> или <see cref="F:System.Double.NegativeInfinity" />.  </description></item><item><term> Больше нуля  </term><description> Этот экземпляр больше <paramref name="value" />. -или- Этот экземпляр является числом, а <paramref name="value" /> не является числом (<see cref="F:System.Double.NaN" />).  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значения должны быть идентичными одинаковыми. Особенно в том случае, если значения с плавающей запятой, зависят от множества математических операций, чаще всего для к потере точности, а также для значений, чтобы быть практически идентичны, за исключением их менее значащие цифры. По этой причине возвращаемое значение <xref:System.Double.CompareTo%2A> метод в некоторых случаях может показаться странным. Например умножение по определенному значению следуют деления тем же значением следует производить исходное значение. В следующем примере Однако вычисляемое значение оказывается больше, чем исходное значение. Отображение всех значащих цифр из двух значений с помощью символа «R» [строкой стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) указывает, что вычисляемое значение отличается от исходного значения в его менее значащих цифр. Сведения об обработке такие сравнения см. в разделе «Примечания» <xref:System.Double.Equals%28System.Double%29> метод.  
  
 [!code-csharp[System.Double.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Double.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto2.vb#1)]  
  
 Этот метод реализует <xref:System.IComparable%601?displayProperty=nameWithType> интерфейс, а также выполняет немного быстрее, чем <xref:System.Double.CompareTo%2A?displayProperty=nameWithType> метода, так как его не нужно выполнять преобразование `value` параметр объекта.  
  
 Обратите внимание, что, несмотря на то что объект, значение которого равно <xref:System.Double.NaN> не считаются равными, в другой объект, значение которого является <xref:System.Double.NaN> (даже самого) <xref:System.IComparable%601> требуется интерфейс `A.CompareTo(A)` возвращают нуль.  
  
## <a name="widening-conversions"></a>расширяющие преобразования  
 Языках программирования, могут быть доступны для кода <xref:System.Double.CompareTo%2A> метода, где параметр типа имеет меньшее число битов (является более коротким) от экземпляра типа. Это можно сделать, так как некоторые языки программирования выполняют неявное расширяющее преобразование, которое представляет количество бит типа параметра до количества бит типа экземпляра.  
  
 Предположим, что типом экземпляра является <xref:System.Double> и тип параметра является <xref:System.Int32>. Компилятор Microsoft C# создает инструкции для представления значения параметра, как <xref:System.Double> объекта, а затем создает <xref:System.Double.CompareTo%28System.Double%29?displayProperty=nameWithType> метод, который сравнивает значения экземпляра и расширенными представление параметра.  
  
 Обратитесь к документации язык программирования, чтобы определить, выполняет ли компилятор явное расширяющее преобразование числовых типов. Дополнительные сведения см. в разделе [таблицы преобразования типов](~/docs/standard/base-types/conversion-tables.md) раздела.  
  
## <a name="precision-in-comparisons"></a>Точность при сравнении  
 Точность чисел с плавающей запятой за пределы задокументированной точности зависит от реализации и версии платформы .NET Framework. Таким образом сравнения двух определенных чисел может меняться в различных версиях платформы .NET Framework точность внутреннего представления чисел может измениться.  
  
   
  
## Examples  
 В следующем примере кода демонстрируются универсальных и неуниверсальных версии <xref:System.Double.CompareTo%2A> метод для нескольких типов значений и ссылочных типов.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="double.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Объект для сравнения или значение <see langword="null" />.</param>
        <summary>Сравнивает данный экземпляр с указанным объектом и возвращает целое число, которое показывает, является ли значение данного экземпляра меньше, больше или равно значению заданного объекта.</summary>
        <returns>Знаковое число, представляющее относительные значения этого экземпляра и параметра <paramref name="value" />.  
  
 <list type="table"><listheader><term> Значение  </term><description> Описание  </description></listheader><item><term> Отрицательное число  </term><description> Этот экземпляр меньше <paramref name="value" />. -или- Этот экземпляр не является числом (<see cref="F:System.Double.NaN" />), а <paramref name="value" /> является числом.  </description></item><item><term> Ноль  </term><description> Этот экземпляр равен <paramref name="value" />. -или- Этот экземпляр и <paramref name="value" /> равны <see langword="Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" /> или <see cref="F:System.Double.NegativeInfinity" /></description></item><item><term> Положительное число  </term><description> Этот экземпляр больше <paramref name="value" />. -или- Этот экземпляр является числом, а <paramref name="value" /> не является числом (<see cref="F:System.Double.NaN" />).  -или- <paramref name="value" /> равно <see langword="null" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` Параметр должен быть `null` или экземпляром `Double`; в противном случае создается исключение. Любой экземпляр <xref:System.Double>, независимо от его значения, считается больше, чем `null`.  
  
 Значения должны быть идентичными одинаковыми. Особенно в том случае, если значения с плавающей запятой, зависят от множества математических операций, чаще всего для к потере точности, а также для значений, чтобы быть практически идентичны, за исключением их менее значащие цифры. По этой причине возвращаемое значение <xref:System.Double.CompareTo%2A> метод в некоторых случаях может показаться странным. Например умножение по определенному значению следуют деления тем же значением следует производить исходное значение. В следующем примере Однако вычисляемое значение оказывается больше, чем исходное значение. Отображение всех значащих цифр из двух значений с помощью символа «R» [строкой стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) указывает, что вычисляемое значение отличается от исходного значения в его менее значащих цифр. Сведения об обработке такие сравнения см. в разделе «Примечания» <xref:System.Double.Equals%28System.Double%29> метод.  
  
 [!code-csharp[System.Double.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Double.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.compareto/vb/compareto3.vb#2)]  
  
 Этот метод реализуется для поддержки <xref:System.IComparable> интерфейса. Обратите внимание, что, несмотря на то что <xref:System.Double.NaN> не считается равным другому <xref:System.Double.NaN> (даже самого) <xref:System.IComparable> требуется интерфейс `A.CompareTo(A)` возвращают нуль.  
  
## <a name="precision-in-comparisons"></a>Точность при сравнении  
 Точность чисел с плавающей запятой за пределы задокументированной точности зависит от реализации и версии платформы .NET Framework. Таким образом сравнения двух определенных чисел может меняться в различных версиях платформы .NET Framework точность внутреннего представления чисел может измениться.  
  
   
  
## Examples  
 В следующем примере кода показано использование `CompareTo` в контексте `Double`.  
  
 [!code-cpp[System.Double#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#16)]
 [!code-csharp[System.Double#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#16)]
 [!code-vb[System.Double#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> не является объектом <see cref="T:System.Double" />.</exception>
        <altmember cref="M:System.Double.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 Epsilon = float64(4.94065645841247E-324)" />
      <MemberSignature Language="DocId" Value="F:System.Double.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Const Epsilon As Double  = 4.94065645841247E-324" />
      <MemberSignature Language="C++ CLI" Value="public: double Epsilon = 4.94065645841247E-324;" />
      <MemberSignature Language="F#" Value="val mutable Epsilon : double" Usage="System.double.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>4.94065645841247E-324</MemberValue>
      <Docs>
        <summary>Представляет наименьшее положительное значение <see cref="T:System.Double" /> больше нуля. Это поле является константой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение <xref:System.Double.Epsilon> свойство отражает наименьшее положительное <xref:System.Double> значение, которое является существенным для числовых операций или сравнения при значение <xref:System.Double> экземпляра равно нулю. Например, в следующем коде показано, нуля и <xref:System.Double.Epsilon> считаются неравных значений, тогда как нулевой и половина значение <xref:System.Double.Epsilon> считаются равными.  
  
 [!code-csharp[System.Double.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Double.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon.vb#5)]  
  
 Точнее, числа с плавающей точкой формата состоит из одного знака, 52-битной мантиссы или значащую часть и 11-разрядную экспоненту. Как показано в следующем примере, ноль имеет показатель степени -1022 и мантиссы 0. <xref:System.Double.Epsilon> имеет показатель степени -1022 и мантиссы 1. Это означает, что <xref:System.Double.Epsilon> представляет наименьшее положительное <xref:System.Double> значение больше нуля и представляет минимально допустимое значение и наименьшее приращение возможных <xref:System.Double> , показатель степени является -1022.  
  
 [!code-csharp[System.Double.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Double.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/epsilon1.vb#6)]  
  
 Тем не менее <xref:System.Double.Epsilon> свойство не общие измерения точности <xref:System.Double> введите; применяется только к <xref:System.Double> экземпляров, имеющих нулевое значение или экспонента -1022.  
  
> [!NOTE]
>  Значение <xref:System.Double.Epsilon> свойства не эквивалентен epsilon компьютера, который представляет собой верхнюю границу относительный ошибки из-за округления в арифметических операций с плавающей запятой.  
  
 Значение этой константы равно 4, 94065645841247E-324.  
  
 Два очевидно эквивалентные числа с плавающей запятой могут не совпасть из-за различий в их менее значащие цифры. Например, выражение C#, `(double)1/3 == (double)0.33333`, не отличаются, поскольку операция деления в левой части имеет максимальной точности, а константа с правой стороны является точным только для указанных цифр. При создании пользовательского алгоритма, который определяет два числа с плавающей запятой может быть считаются ли равными, мы не рекомендуем основанных на алгоритме на значение <xref:System.Double.Epsilon> константы для установления допустимую предельную разность следует учитывать два значения равны.  (Как правило, что погрешность много раз больше, чем <xref:System.Double.Epsilon>.) Сведения о сравнении двух значений с плавающей запятой двойной точности см. в разделе <xref:System.Double> и <xref:System.Double.Equals%28System.Double%29>.  
  
## <a name="platform-notes"></a>Заметки о платформе  
 В системах ARM, значение <xref:System.Double.Epsilon> константы слишком мал для обнаружения, поэтому оно приравнивается к нулю. Можно определить альтернативный epsilon значение, равное 2, 2250738585072014e-308 вместо него.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает значение, указывающее, представляют ли два экземпляра <see cref="T:System.Double" /> одно и то же значение.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (double obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float64 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(double obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : double -&gt; bool" Usage="double.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="obj">Объект <see cref="T:System.Double" />, сравниваемый с этим экземпляром.</param>
        <summary>Возвращает значение, позволяющее определить, представляют ли этот экземпляр и заданный объект <see cref="T:System.Double" /> одно и то же значение.</summary>
        <returns>Значение <see langword="true" />, если значение параметра <paramref name="obj" /> равно данному экземпляру; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод реализует <xref:System.IEquatable%601?displayProperty=nameWithType> интерфейсов и выполняет немного быстрее, чем <xref:System.Double.Equals%2A> , так как его не нужно выполнять преобразование `obj` параметр объекта.  
  
## <a name="widening-conversions"></a>расширяющие преобразования  
 Языках программирования, могут быть доступны для кода <xref:System.Double.Equals%2A> метода, где параметр типа имеет меньшее число битов (является более коротким) от экземпляра типа. Это можно сделать, так как некоторые языки программирования выполняют неявное расширяющее преобразование, которое представляет количество бит типа параметра до количества бит типа экземпляра.  
  
 Предположим, что типом экземпляра является <xref:System.Double> и тип параметра является <xref:System.Int32>. Компилятор Microsoft C# создает инструкции для представления значения параметра, как <xref:System.Double> объекта, а затем создает <xref:System.Double.Equals%28System.Double%29?displayProperty=nameWithType> метод, который сравнивает значения экземпляра и расширенными представление параметра.  
  
 Обратитесь к документации язык программирования, чтобы определить, выполняет ли компилятор явное расширяющее преобразование числовых типов. Дополнительные сведения см. в разделе [таблицы преобразования типов](~/docs/standard/base-types/conversion-tables.md) раздела.  
  
## <a name="precision-in-comparisons"></a>Точность при сравнении  
 <xref:System.Double.Equals%2A> Метод следует использовать с осторожностью, поскольку два очевидно эквивалентные значения могут быть из-за различий в точности эти два значения равны. В следующем примере сообщается, <xref:System.Double> значение.333333 и <xref:System.Double> значения, возвращаемого путем деления 1 3 не равны.  
  
 [!code-csharp[System.Double.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#1)]
 [!code-vb[System.Double.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#1)]  
  
 Вместо сравнения на равенство, один из способов заключается в определении относительного допустимого поля разницу между двумя значениями (такими как. 001% одного из значений). Если абсолютное значение разницы между двумя значениями меньше или равно значению поля, разница скорее всего, будут из-за различия в точности и, таким образом, значения равны. Следующий пример использует этот метод для сравнения.33333 и 1/3, два <xref:System.Double> значений, которые были не эквивалентны предыдущему примеру кода. В этом случае значения равны.  
  
 [!code-csharp[System.Double.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#2)]
 [!code-vb[System.Double.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#2)]  
  
> [!NOTE]
>  Поскольку <xref:System.Double.Epsilon> определяет минимальное выражение положительного значения, диапазон которого приближается к нулю, граница различия между двумя схожие значения должно быть больше <xref:System.Double.Epsilon>. Как правило, сколько раз больше, чем <xref:System.Double.Epsilon>. По этой причине мы рекомендуем не использовать <xref:System.Double.Epsilon> при сравнении <xref:System.Double> значения на равенство.  
  
 Второй способ заключается в сравнении разность двух чисел с плавающей запятой, абсолютное значение. Если разница, меньше или равно, абсолютное значение числа равны. Если оно больше числа не равны. Один вариант — произвольно выберите абсолютное значение. Это создает проблему, тем не менее, поскольку допустимого поля Разница зависит от масштабов <xref:System.Double> значения. Второй вариант позволяет пользоваться преимуществами является особенностью формате с плавающей запятой: количество возможных значений с плавающей запятой, разделяющий их указывает разницу между целочисленное представление из двух значений с плавающей запятой. Например, разница между 0,0 и <xref:System.Double.Epsilon> равно 1, поскольку <xref:System.Double.Epsilon> является наименьшим представимым значением при работе с <xref:System.Double> , значение которого равно нулю. В следующем примере этот метод используется для сравнения.33333 и 1/3, которые являются двумя <xref:System.Double> значения, которые в предыдущем примере кода с <xref:System.Double.Equals%28System.Double%29> найти метод были не эквивалентны. Обратите внимание, что в этом примере <xref:System.BitConverter.DoubleToInt64Bits%2A?displayProperty=nameWithType> метод для преобразования в представление целое значение с плавающей запятой двойной точности.  
  
 [!code-csharp[System.Double.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Double.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsabs1.vb#1)]  
  
 Точность чисел с плавающей запятой за пределы задокументированной точности зависит от реализации и версии платформы .NET Framework. Таким образом сравнения двух определенных чисел может меняться в различных версиях платформы .NET Framework точность внутреннего представления чисел может измениться.  
  
 Если два <xref:System.Double.NaN?displayProperty=nameWithType> значения проверяются на равенство, вызвав <xref:System.Double.Equals%2A> метода, метод возвращает `true`. Тем не менее если два <xref:System.Double.NaN> значения проверяются на равенство с помощью оператора равенства, оператор возвращает `false`. Если вы хотите определить ли значение <xref:System.Double> не является числом (NaN), альтернативным вариантом является вызов <xref:System.Double.IsNaN%2A> метод.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Разрешение перегрузки компилятор может учитывать видимого различия в поведении между этими двумя <see cref="M:System.Double.Equals(System.Object)" /> перегруженных версий метода. Если неявное преобразование между <paramref name="obj" /> аргумент и <see cref="T:System.Double" /> определен и не имеет тип аргумента <see cref="T:System.Object" />, компиляторы могут выполнять неявное преобразование и вызова <see cref="M:System.Double.Equals(System.Double)" /> метод. В противном случае они вызывают <see cref="M:System.Double.Equals(System.Object)" /> метод, который всегда возвращает <see langword="false" /> при его <paramref name="obj" /> аргумент не <see cref="T:System.Double" /> значение. В следующем примере показано различие в поведении между перегрузки двух методов. В случае всех числовых типов-примитивов за исключением <see cref="T:System.Decimal" /> и в C#, возвращает первое сравнение <see langword="true" /> , поскольку компилятор автоматически выполняет расширяющие преобразования и вызовы <see cref="M:System.Double.Equals(System.Double)" /> метода, в то время как второй сравнения Возвращает <see langword="false" /> , так как компилятор вызывает <see cref="M:System.Double.Equals(System.Object)" /> метод.  [! code-csharp[System.Double.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)] [! code-vb[System.Double.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Double.Equals(System.Object)" />
        <altmember cref="Overload:System.Double.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="double.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект для сравнения с данным экземпляром.</param>
        <summary>Возвращает значение, показывающее, равен ли данный экземпляр заданному объекту.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="obj" /> является экземпляром типа <see cref="T:System.Double" /> и равен значению данного экземпляра; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.Equals%2A> Метод следует использовать с осторожностью, поскольку два очевидно эквивалентные значения могут быть из-за различий в точности эти два значения равны. В следующем примере сообщается, <xref:System.Double> значение.3333 и <xref:System.Double> возвращается путем деления не равны 1 по 3.  
  
 [!code-csharp[System.Double.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Epsilon/cs/Equals_25051.cs#3)]
 [!code-vb[System.Double.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Epsilon/vb/Equals_25051.vb#3)]  
  
 Альтернативные варианты вызова <xref:System.Double.Equals%2A> метода, см. в документации для <xref:System.Double.Equals%28System.Double%29> перегрузки.  
  
> [!NOTE]
>  Поскольку <xref:System.Double.Epsilon> определяет минимальное выражение положительного значения, диапазон которого приближается к нулю, граница различия между двумя схожие значения должно быть больше <xref:System.Double.Epsilon>. Как правило, сколько раз больше, чем <xref:System.Double.Epsilon>.  
  
 Точность чисел с плавающей запятой за пределы задокументированной точности зависит от реализации и версии платформы .NET Framework. Таким образом сравнения двух определенных чисел может меняться в различных версиях платформы .NET Framework точность внутреннего представления чисел может измениться.  
  
 Если два <xref:System.Double.NaN?displayProperty=nameWithType> значения проверяются на равенство, вызвав <xref:System.Double.Equals%2A> метода, метод возвращает `true`. Тем не менее если два <xref:System.Double.NaN> значения проверяются на равенство с помощью оператора равенства, оператор возвращает `false`. Если вы хотите определить ли значение <xref:System.Double> не является числом (NaN), альтернативным вариантом является вызов <xref:System.Double.IsNaN%2A> метод.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Разрешение перегрузки компилятор может учитывать видимого различия в поведении между этими двумя <see cref="M:System.Double.Equals(System.Object)" /> перегруженных версий метода. Если неявное преобразование между <paramref name="obj" /> аргумент и <see cref="T:System.Double" /> определен и не имеет тип аргумента <see cref="T:System.Object" />, компиляторы могут выполнять неявное преобразование и вызова <see cref="M:System.Double.Equals(System.Double)" /> метод. В противном случае они вызывают <see cref="M:System.Double.Equals(System.Object)" /> метод, который всегда возвращает <see langword="false" /> при его <paramref name="obj" /> аргумент не <see cref="T:System.Double" /> значение. В следующем примере показано различие в поведении между перегрузки двух методов. В случае всех числовых типов-примитивов за исключением <see cref="T:System.Decimal" /> и в C#, возвращает первое сравнение <see langword="true" /> , поскольку компилятор автоматически выполняет расширяющие преобразования и вызовы <see cref="M:System.Double.Equals(System.Double)" /> метода, в то время как второй сравнения Возвращает <see langword="false" /> , так как компилятор вызывает <see cref="M:System.Double.Equals(System.Object)" /> метод.  [! code-csharp[System.Double.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.equals/cs/equalsoverl.cs#2)] [! code-vb[System.Double.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Double.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="double.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код данного экземпляра.</summary>
        <returns>Хэш-код в виде 32-разрядного целого числа со знаком.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="double.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает <see cref="T:System.TypeCode" /> для типа значения <see cref="T:System.Double" />.</summary>
        <returns>Константа перечислимого типа, <see cref="F:System.TypeCode.Double" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsFinite(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(double d);" />
      <MemberSignature Language="F#" Value="static member IsFinite : double -&gt; bool" Usage="System.double.IsFinite d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : double -&gt; bool" Usage="System.double.IsInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Число двойной точности с плавающей запятой.</param>
        <summary>Возвращает значение, позволяющее определить, равно ли данное число плюс или минус бесконечности.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="d" /> равен значению <see cref="F:System.Double.PositiveInfinity" /> или <see cref="F:System.Double.NegativeInfinity" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операции с плавающей запятой возвращают <xref:System.Double.PositiveInfinity> или <xref:System.Double.NegativeInfinity> , чтобы указать на условие переполнения.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Double.IsInfinity%2A>:  
  
 [!code-cpp[System.Double#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#11)]
 [!code-csharp[System.Double#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#11)]
 [!code-vb[System.Double#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNaN(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(double d);" />
      <MemberSignature Language="F#" Value="static member IsNaN : double -&gt; bool" Usage="System.double.IsNaN d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Число двойной точности с плавающей запятой.</param>
        <summary>Возвращает значение, показывающее, что указанное значение не является числом (<see cref="F:System.Double.NaN" />).</summary>
        <returns>Значение <see langword="true" />, если значение параметра <paramref name="d" /> равно значению <see cref="F:System.Double.NaN" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операции с плавающей запятой возвращают <xref:System.Double.NaN> сигнала, результат этой операции не определен. Например, деление 0,0 на 0,0 приводит к <xref:System.Double.NaN>.  
  
> [!NOTE]
>  <xref:System.Double.IsNaN%2A> Возвращает `false` Если <xref:System.Double> значение <xref:System.Double.PositiveInfinity> или <xref:System.Double.NegativeInfinity>. Чтобы проверить эти значения, используйте <xref:System.Double.IsInfinity%2A>, <xref:System.Double.IsPositiveInfinity%2A>, и <xref:System.Double.IsNegativeInfinity%2A> методы.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Double.IsNaN%2A>:  
  
 [!code-cpp[System.Double#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#8)]
 [!code-csharp[System.Double#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#8)]
 [!code-vb[System.Double#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Double.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegative(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(double d);" />
      <MemberSignature Language="F#" Value="static member IsNegative : double -&gt; bool" Usage="System.double.IsNegative d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNegativeInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : double -&gt; bool" Usage="System.double.IsNegativeInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Число двойной точности с плавающей запятой.</param>
        <summary>Возвращает значение, позволяющее определить, равно ли данное число минус бесконечности.</summary>
        <returns>Значение <see langword="true" />, если значение параметра <paramref name="d" /> равно значению <see cref="F:System.Double.NegativeInfinity" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операции с плавающей запятой возвращают <xref:System.Double.NegativeInfinity> , чтобы указать на условие переполнения.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Double.IsNegativeInfinity%2A>:  
  
 [!code-cpp[System.Double#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#13)]
 [!code-csharp[System.Double#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#13)]
 [!code-vb[System.Double#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#13)]  
[!code-cpp[System.Double#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#4)]
[!code-csharp[System.Double#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#4)]
[!code-vb[System.Double#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#4)]  
[!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
[!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
[!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsNormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(double d);" />
      <MemberSignature Language="F#" Value="static member IsNormal : double -&gt; bool" Usage="System.double.IsNormal d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsPositiveInfinity(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(double d);" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : double -&gt; bool" Usage="System.double.IsPositiveInfinity d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">Число двойной точности с плавающей запятой.</param>
        <summary>Возвращает значение, показывающее, равно ли данное число плюс бесконечности.</summary>
        <returns>Значение <see langword="true" />, если значение параметра <paramref name="d" /> равно значению <see cref="F:System.Double.PositiveInfinity" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операции с плавающей запятой возвращают <xref:System.Double.PositiveInfinity> , чтобы указать на условие переполнения.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Double.IsPositiveInfinity%2A>:  
  
 [!code-cpp[System.Double#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#12)]
 [!code-csharp[System.Double#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#12)]
 [!code-vb[System.Double#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (double d);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(float64 d) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.IsSubnormal(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (d As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(double d);" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : double -&gt; bool" Usage="System.double.IsSubnormal d" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="d" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="d">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const double MaxValue = 1.79769313486232E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MaxValue = float64(1.79769313486232E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Double  = 1.79769313486232E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MaxValue = 1.79769313486232E+308;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : double" Usage="System.double.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>1.79769313486232E+308</MemberValue>
      <Docs>
        <summary>Представляет наибольшее возможное значение типа <see cref="T:System.Double" />. Это поле является константой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этой константы — положительное 1.7976931348623157E + 308.  
  
 Результат операции, которая превышает <xref:System.Double.MaxValue?displayProperty=nameWithType> — <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>. В следующем примере <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> полученный в результате операции сложения, умножение и возведение в степень, когда результат превышает <xref:System.Double.MaxValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Double.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Double.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Double.MaxValue>:  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const double MinValue = -1.79769313486232E+308;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 MinValue = float64(-1.79769313486232E+308)" />
      <MemberSignature Language="DocId" Value="F:System.Double.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Double  = -1.79769313486232E+308" />
      <MemberSignature Language="C++ CLI" Value="public: double MinValue = -1.79769313486232E+308;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : double" Usage="System.double.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-1.79769313486232E+308</MemberValue>
      <Docs>
        <summary>Представляет минимально допустимое значение типа <see cref="T:System.Double" />. Это поле является константой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этой константы — отрицательное 1.7976931348623157E + 308.  
  
 Результат операции, которое меньше, чем <xref:System.Double.MinValue?displayProperty=nameWithType> — <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>. В следующем примере <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> результатом вычитание и умножение, если результат меньше, чем <xref:System.Double.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Double.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Double.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Double.MinValue>:  
  
 [!code-cpp[Double Example#2](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#2)]
 [!code-csharp[Double Example#2](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#2)]
 [!code-vb[Double Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const double NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NaN = float64(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Const NaN As Double  = NaN" />
      <MemberSignature Language="C++ CLI" Value="public: double NaN = NaN;" />
      <MemberSignature Language="F#" Value="val mutable NaN : double" Usage="System.double.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>Представляет значение, не являющееся числом (<see langword="NaN" />). Это поле является константой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод или оператор возвращает <xref:System.Double.NaN> Если результат операции является неопределенным. Например, результат деления нуля на нуль является <xref:System.Double.NaN>, как показано в следующем примере. (Но Обратите внимание, что деления на ноль ненулевое число возвращает либо <xref:System.Double.PositiveInfinity> или <xref:System.Double.NegativeInfinity>, в зависимости от знак делителя.)  
  
 [!code-csharp[System.Double.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#1)]
 [!code-vb[System.Double.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#1)]  
  
 Кроме того, вызов метода с <xref:System.Double.NaN> значение или операцию над <xref:System.Double.NaN> значение возвращает <xref:System.Double.NaN>, как показано в следующем примере.  
  
 [!code-csharp[System.Double.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/nan1.cs#2)]
 [!code-vb[System.Double.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/nan1.vb#2)]  
  
 Используйте <xref:System.Double.IsNaN%2A> метод, чтобы определить, является ли значение не является числом. <xref:System.Double.op_Equality%2A> Оператор считает, что два <xref:System.Double.NaN> значения были не эквивалентны друг с другом. В общем случае <xref:System.Double> операторы не могут использоваться для сравнения <xref:System.Double.NaN?displayProperty=nameWithType> с другими <xref:System.Double> значения, хотя методы сравнения (например, <xref:System.Double.Equals%2A> и <xref:System.Double.CompareTo%2A>) может. Следующий пример иллюстрирует разницу в поведении между <xref:System.Double> операторы сравнения и методы.  
  
 [!code-csharp[System.Double.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.nan/cs/double.nan4.cs#4)]
 [!code-vb[System.Double.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.nan/vb/double.nan4.vb#4)]  
  
   
  
## Examples  
 В следующем примере демонстрируется применение <xref:System.Double.NaN>.  
  
 [!code-cpp[System.Double#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#7)]
 [!code-csharp[System.Double#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#7)]
 [!code-vb[System.Double#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNaN(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 NegativeInfinity = float64(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const NegativeInfinity As Double  = -Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double NegativeInfinity = -Infinity;" />
      <MemberSignature Language="F#" Value="val mutable NegativeInfinity : double" Usage="System.double.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>Представляет минус бесконечность. Это поле является константой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этой константы — результат деления отрицательного числа на ноль.  
  
 Эта константа возвращается в том случае, если результат операции меньше, чем <xref:System.Double.MinValue>.  
  
 Используйте <xref:System.Double.IsNegativeInfinity%2A> для определения, равно ли значение минус бесконечности.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Double.NegativeInfinity>:  
  
 [!code-cpp[System.Double#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#9)]
 [!code-csharp[System.Double#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#9)]
 [!code-vb[System.Double#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsNegativeInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Equality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : double * double -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, равны ли два заданных значения <see cref="T:System.Double" />.</summary>
        <returns>Значение <see langword="true" />, если <paramref name="left" /> и <paramref name="right" /> равны; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_Equality%2A> Метода определяется оператор равенства для <xref:System.Double> значения.  
  
 Если два <xref:System.Double.NaN?displayProperty=nameWithType> значения проверяются на равенство с помощью оператора равенства, в результате `false`; два <xref:System.Double.NaN?displayProperty=nameWithType> значения не считаются равными. Если они проверяются на равенство, вызвав <xref:System.Double.Equals%2A> , результатом является `true`.  Если вы хотите определить ли значение <xref:System.Double> не является числом (NaN), альтернативным вариантом является вызов <xref:System.Double.IsNaN%2A> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : double * double -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, действительно ли заданное значение <see cref="T:System.Double" /> больше другого заданного значения <see cref="T:System.Double" />.</summary>
        <returns>
          <see langword="true" />, если <paramref name="left" /> больше <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_GreaterThan%2A> Метод определяет операцию больше — не для <xref:System.Double> значения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_GreaterThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : double * double -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, действительно ли заданное значение <see cref="T:System.Double" /> больше или равно другому заданному значению <see cref="T:System.Double" />.</summary>
        <returns>
          <see langword="true" />, если значение <paramref name="left" /> больше или равно значению <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_GreaterThanOrEqual%2A> Метод определяет операцию от оператора больше или равно для <xref:System.Double> значения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_Inequality(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : double * double -&gt; bool" Usage="System.double.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, не равны ли два заданных значения <see cref="T:System.Double" />.</summary>
        <returns>Значение <see langword="true" />, если <paramref name="left" /> и <paramref name="right" /> не равны друг другу; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_Inequality%2A> Метода определяется оператор неравенства для <xref:System.Double> значения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThan(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : double * double -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, действительно ли заданное значение <see cref="T:System.Double" /> меньше другого заданного значения <see cref="T:System.Double" />.</summary>
        <returns>
          <see langword="true" />, если значение <paramref name="left" /> меньше значения <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_LessThan%2A> Метод определяет операцию меньше-оператора для <xref:System.Double> значения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (double left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float64 left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.op_LessThanOrEqual(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Double, right As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(double left, double right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : double * double -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" />
        <Parameter Name="right" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, действительно ли заданное значение <see cref="T:System.Double" /> меньше или равно другому заданному значению <see cref="T:System.Double" />.</summary>
        <returns>
          <see langword="true" />, если значение <paramref name="left" /> меньше или равно значению <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.op_LessThanOrEqual%2A> Метод определяет операцию оператора меньше или равно для <xref:System.Double> значения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразует строковое представление числа в эквивалентное ему число двойной точности с плавающей запятой.</summary>
        <altmember cref="Overload:System.Double.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; double" Usage="System.double.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая преобразуемое число.</param>
        <summary>Преобразует строковое представление числа в эквивалентное ему число двойной точности с плавающей запятой.</summary>
        <returns>Число с плавающей запятой двойной точности, которое эквивалентно числовому значению или символу, заданному параметром <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `s` Параметр может содержать текущего языка и региональных параметров <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>, или строку в формате:  
  
 [*ws*] [*входа*] [*целые числа*[*,*]]*целые числа*[*.* [*дробной части*]] [E [*входа*]*экспоненциальные цифры*] [*ws*]  
  
 Элементы в квадратных скобках ([и]) являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*ws*|Серия символы-разделители.|  
|*sign*|Знак минус (-) файлы символов или символов, знак плюс (+). Можно использовать только знак в начале.|  
|*целые числа*|Последовательность цифр в диапазоне от 0 до 9, задающих целую часть числа. Работает *целые числа* могут быть разделены символом разделителя групп. Например в некоторых странах запятую (,) разделяет групп разрядов. *Целые числа* элемент может отсутствовать Если строка содержит *дробной части* элемента.|  
|,|Разделителя групп разрядов символ-разделитель.|  
|.|Символ десятичной запятой для конкретного языка и региональных параметров.|  
|*дробной части*|Последовательность цифр в диапазоне от 0 до 9, задающих дробную часть числа.|  
|E|«E» или «E» знаком, который указывает, что значение будет представлено в экспоненциальной нотации (научный).|  
|*экспоненциальные цифры*|Последовательность цифр в диапазоне от 0 до 9, задающих экспоненту.|  
  
 `s` Параметр интерпретируется с использованием сочетания <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> и <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> флаги. Это означает, что пробелы и тысяч допускается в качестве разделителей, например, пока не являются символами валют. Для более контролировать, над какой стиль элементы допускаются в `s` для успешного выполнения операции синтаксического анализа, вызовите <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> или <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> метод.  
  
 `s` Параметр интерпретируется с использованием сведений о форматировании в <xref:System.Globalization.NumberFormatInfo> , инициализируемый для языка и региональных параметров текущего потока. Дополнительные сведения см. в разделе <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Синтаксический анализ строки, используя сведения о форматировании для некоторых других языка и региональных параметров, вызовите <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> или <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> метод.  
  
 Как правило если передать <xref:System.Double.Parse%2A?displayProperty=nameWithType> метод строку, которая создается путем вызова <xref:System.Double.ToString%2A?displayProperty=nameWithType> метод, исходные <xref:System.Double> возвращаемое значение. Однако из-за потери точности значения могут не быть равны. Кроме того, при попытке проанализировать строковым представлением любого <xref:System.Double.MinValue> или <xref:System.Double.MaxValue> вызывает <xref:System.OverflowException>, как показано в следующем примере.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Если обнаружен разделитель в `s` параметр во время операции синтаксического анализа и применимые валюты или число десятичных и разделители групп совпадают, предполагается, что разделитель является десятичного разделителя, а не группой разделитель. Дополнительные сведения о разделители см. в разделе <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, и <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 В следующем примере показано использование метода <xref:System.Double.Parse%28System.String%29>.  
  
 [!code-cpp[Double Example#5](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#5)]
 [!code-csharp[Double Example#5](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#5)]
 [!code-vb[Double Example#5](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="s" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Параметр <paramref name="s" /> не представляет число в допустимом формате.</exception>
        <exception cref="T:System.OverflowException">Параметр <paramref name="s" /> представляет число меньше <see cref="F:System.Double.MinValue" /> или больше <see cref="F:System.Double.MaxValue" />.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="M:System.Double.TryParse(System.String,System.Double@)" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; double" Usage="System.double.Parse (s, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая преобразуемое число.</param>
        <param name="style">Побитовое сочетание значений перечисления, определяющих элементы стиля, которые могут присутствовать в параметре <c>s</c>. Типичным задаваемым значением является сочетание <see cref="F:System.Globalization.NumberStyles.Float" /> и <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <summary>Преобразует строковое представление числа указанного стиля в эквивалентное ему число двойной точности с плавающей запятой.</summary>
        <returns>Число с плавающей запятой двойной точности, которое эквивалентно числовому значению или символу, заданному параметром <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `style` Параметр определяет элементы стиля (таких как пробелы, тысячи разделители и символы валют), которые допускаются в `s` параметр для успешного выполнения операции синтаксического анализа. Он должен быть сочетанием одноразрядных флагов из <xref:System.Globalization.NumberStyles> перечисления. Следующие <xref:System.Globalization.NumberStyles> элементы не поддерживаются:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 `s` Параметр может содержать текущего языка и региональных параметров <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, или <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType>. В зависимости от значения `style`, он также может принимать форму:  
  
 [*ws*] [*$*] [*входа*] [*целые числа*[*,*]]* целые числа*[*.* [*дробной части*]] [E [*входа*]*экспоненциальные цифры*] [*ws*]  
  
 Элементы в квадратных скобках ([и]) являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*ws*|Серия символы-разделители. Пробелы могут отображаться в начале `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> флаг, который может находиться в конце `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> флаг.|  
|$|Символ валюты. Его положение в строке определяется <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> и <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> свойств текущего языка и региональных параметров. Символ валюты для текущего языка и региональных параметров могут использоваться в `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> флаг.|  
|*sign*|Знак минус (-) файлы символов или символов, знак плюс (+). Знак может располагаться в начале `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> флаг, который может находиться в конце `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> флаг. Можно использовать круглые скобки в `s` указывает отрицательное значение, если `style` включает <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> флаг.|  
|*целые числа*|Последовательность цифр в диапазоне от 0 до 9, задающих целую часть числа. *Целые числа* элемент может отсутствовать Если строка содержит *дробной части* элемента.|  
|,|Разделитель групп, зависящий от языка и региональных параметров. Символ-разделитель групп текущего языка и региональных параметров могут использоваться в `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> флаг|  
|.|Символ десятичной запятой для конкретного языка и региональных параметров. Символ десятичной точки текущего языка и региональных параметров могут использоваться в `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> флаг.|  
|*дробной части*|Последовательность цифр в диапазоне от 0 до 9, задающих дробную часть числа. Дробных разрядов может встречаться в `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> флаг.|  
|E|«E» или «E» знаком, который указывает, что значение будет представлено в экспоненциальной нотации (научный). `s` Параметр может представлять число в экспоненциальном представлении, если `style` включает <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> флаг.|  
|*экспоненциальные цифры*|Последовательность цифр в диапазоне от 0 до 9, задающих экспоненту.|  
  
 Строка с только цифры (что соответствует <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> стиль) всегда успешно выполняет синтаксический анализ. Оставшиеся <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> члены управляют элементами, которые могут присутствовать, но необязательно должны присутствовать во входной строке. Следующая таблица показывает, как отдельные <xref:System.Globalization.NumberStyles> флаги влияют на элементы, которые могут присутствовать в `s`.  
  
|Значение NumberStyles|Элементы, допустимые в `s` помимо цифр|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*Целые числа* только элемент.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Десятичной запятой (*.*) и *дробной части* элементов.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|«E» или «E» символ, который указывает на экспоненциальное представление. Этот флаг сам по себе поддерживает значения в форме *цифр*E*цифр*; дополнительные флаги необходимы для успешного анализа строки с такими элементами, как положительное или отрицательное подписывает и десятичный разделитель.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws* элемент в начале `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws* элемент в конце `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*Входа* элемент в начале `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*Входа* элемент в конце `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*Входа* элемент в скобки, ограничивающие числовое значение.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Тысяч элемент разделителя (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Элемент валюты ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Все элементы. Однако `s` не может представлять шестнадцатеричное число или число в экспоненциальном представлении.|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws* элемент в начале или конце `s`, *входа* в начале `s`и символ десятичной точки (.). `s` Параметр можно также использовать экспоненциальное представление.|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`, `sign`, Тысячи разделитель (,) и элементы десятичной точки (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Все элементы. Однако `s` не может представлять шестнадцатеричное число.|  
  
 `s` Параметр анализируется с использованием сведений о форматировании в <xref:System.Globalization.NumberFormatInfo> , инициализируемый для текущего языка и региональных параметров системы. Дополнительные сведения см. в разделе <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>.  
  
 Как правило если передать <xref:System.Double.Parse%2A?displayProperty=nameWithType> метод строку, которая создается путем вызова <xref:System.Double.ToString%2A?displayProperty=nameWithType> метод, исходные <xref:System.Double> возвращаемое значение. Однако из-за потери точности значения могут не быть равны. Кроме того, при попытке проанализировать строковым представлением любого <xref:System.Double.MinValue> или <xref:System.Double.MaxValue> вызывает <xref:System.OverflowException>, как показано в следующем примере.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Если обнаружен разделитель в `s` параметр во время операции синтаксического анализа и применимые валюты или число десятичных и разделители групп совпадают, предполагается, что разделитель является десятичного разделителя, а не группой разделитель. Дополнительные сведения о разделители см. в разделе <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, и <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> метода для синтаксического анализа строковые представления <xref:System.Double> значений с использованием региональных параметров en US.  
  
 [!code-csharp[System.Double.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse.cs#1)]
 [!code-vb[System.Double.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="s" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Параметр <paramref name="s" /> не представляет число в допустимом формате.</exception>
        <exception cref="T:System.OverflowException">Параметр <paramref name="s" /> представляет число меньше <see cref="F:System.Double.MinValue" /> или больше <see cref="F:System.Double.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> не является значением <see cref="T:System.Globalization.NumberStyles" />.  -или- <paramref name="style" /> включает значение <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; double" Usage="System.double.Parse (s, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая преобразуемое число.</param>
        <param name="provider">Объект, который предоставляет сведения о форматировании параметра <c>s</c> в зависимости от языка и региональных параметров.</param>
        <summary>Преобразует строковое представление числа, выраженное в заданном формате, связанном с языком и региональными параметрами, в эквивалентное ему число двойной точности с плавающей запятой.</summary>
        <returns>Число с плавающей запятой двойной точности, которое эквивалентно числовому значению или символу, заданному параметром <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> метод обычно используется для преобразования текста можно форматировать в различных способов <xref:System.Double> значение. Например он может использоваться для преобразования текста, введенные пользователем в текстовое поле HTML в числовое значение.  
  
 `s` Параметр интерпретируется с использованием сочетания <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> и <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> флаги. `s` Параметр может содержать <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, или <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> для языка и региональных параметров, заданные `provider`, или он может содержать строку в формате:  
  
 [*ws*] [*входа*]*целые числа*[*.* [*дробной части*]] [E [*входа*]*экспоненциальные цифры*] [*ws*]  
  
 Необязательные элементы заключены в квадратные скобки ([и]). Элементов, содержащих термин «цифры» состоят из последовательности цифр от 0 до 9.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*ws*|Серия символы-разделители.|  
|*sign*|Знак минус (-) файлы символов или символов, знак плюс (+).|  
|*целые числа*|Последовательность цифр в диапазоне от 0 до 9, задающих целую часть числа. Работает *целые числа* могут быть разделены символом разделителя групп. Например в некоторых странах запятую (,) разделяет групп разрядов. *Целые числа* элемент может отсутствовать Если строка содержит *дробной части* элемента.|  
|.|Символ десятичной запятой для конкретного языка и региональных параметров.|  
|*дробной части*|Последовательность цифр в диапазоне от 0 до 9, задающих дробную часть числа.|  
|E|«E» или «E» знаком, который указывает, что значение будет представлено в экспоненциальной нотации (научный).|  
|*экспоненциальные цифры*|Последовательность цифр в диапазоне от 0 до 9, задающих экспоненту.|  
  
 Дополнительные сведения о числовых форматах см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md) раздела.  
  
 `provider` Параметр <xref:System.IFormatProvider> реализация которого <xref:System.IFormatProvider.GetFormat%2A> возвращает <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о культуре, используемый при интерпретации формат `s`. Обычно это <xref:System.Globalization.NumberFormatInfo> или <xref:System.Globalization.CultureInfo> объекта. Если `provider` — `null` или <xref:System.Globalization.NumberFormatInfo> не удается получить, сведения о форматировании для используемых текущую культуру системы.  
  
 Как правило если передать <xref:System.Double.Parse%2A?displayProperty=nameWithType> метод строку, которая создается путем вызова <xref:System.Double.ToString%2A?displayProperty=nameWithType> метод, исходные <xref:System.Double> возвращаемое значение. Однако из-за потери точности значения могут не быть равны. Кроме того, при попытке проанализировать строковым представлением любого <xref:System.Double.MinValue> или <xref:System.Double.MaxValue> вызывает <xref:System.OverflowException>, как показано в следующем примере.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Если обнаружен разделитель в `s` параметр во время операции синтаксического анализа и применимые валюты или число десятичных и разделители групп совпадают, предполагается, что разделитель является десятичного разделителя, а не группой разделитель. Дополнительные сведения о разделители см. в разделе <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, и <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Следующий пример является веб-формы обработчик событий нажатия кнопки. Она использует массив, возвращаемый методом <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> свойства, чтобы определить языковой стандарт пользователя. Затем он создает <xref:System.Globalization.CultureInfo> объект, соответствующий этим языковым стандартом. <xref:System.Globalization.NumberFormatInfo> Объекта, которому принадлежит, <xref:System.Globalization.CultureInfo> объект затем передается <xref:System.Double.Parse%28System.String%2CSystem.IFormatProvider%29> данные метода для преобразования пользователь <xref:System.Double> значение.  
  
 [!code-csharp[ParseMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#2)]
 [!code-vb[ParseMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="s" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Параметр <paramref name="s" /> не представляет число в допустимом формате.</exception>
        <exception cref="T:System.OverflowException">Параметр <paramref name="s" /> представляет число меньше <see cref="F:System.Double.MinValue" /> или больше <see cref="F:System.Double.MaxValue" />.</exception>
        <altmember cref="M:System.Double.ToString" />
        <altmember cref="Overload:System.Double.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As Double" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; double" Usage="System.double.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static double Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; double" Usage="System.double.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая преобразуемое число.</param>
        <param name="style">Побитовое сочетание значений перечисления, определяющих элементы стиля, которые могут присутствовать в параметре <c>s</c>. Обычно указывается значение <see cref="F:System.Globalization.NumberStyles.Float" /> в сочетании со значением <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Объект, который предоставляет сведения о форматировании параметра <c>s</c> в зависимости от языка и региональных параметров.</param>
        <summary>Преобразует строковое представление числа указанного стиля, выраженное в формате, соответствующем определенному языку и региональным параметрам, в эквивалентное ему число двойной точности с плавающей запятой.</summary>
        <returns>Число с плавающей запятой двойной точности, которое эквивалентно числовому значению или символу, заданному параметром <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `style` Параметр определяет элементы стиля (таких как пробелы, тысячи разделители и символы валют), которые допускаются в `s` параметр для успешного выполнения операции синтаксического анализа. Он должен быть сочетанием одноразрядных флагов из <xref:System.Globalization.NumberStyles> перечисления. Следующие <xref:System.Globalization.NumberStyles> элементы не поддерживаются:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 `s` Параметр может содержать <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, или <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> для языка и региональных параметров, заданные `provider`. В зависимости от значения `style`, он также может принимать форму:  
  
 [*ws*] [*$*] [*входа*] [*целые числа*,]*целые числа*[. [ *дробной части*]] [E [*входа*]*экспоненциальные цифры*] [*ws*]  
  
 Элементы, заключенных в квадратные скобки ([и]) являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*ws*|Серия символы-разделители. Пробелы могут отображаться в начале `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> флаг, который может находиться в конце `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> флаг.|  
|$|Символ валюты. Его положение в строке определяется <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> и <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> свойств текущего языка и региональных параметров. Символ валюты для текущего языка и региональных параметров могут использоваться в `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> флаг.|  
|*sign*|Знак минус (-) файлы символов или символов, знак плюс (+). Знак может располагаться в начале `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> флаг, который может находиться в конце `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> флаг. Можно использовать круглые скобки в `s` указывает отрицательное значение, если `style` включает <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> флаг.|  
|*целые числа*|Последовательность цифр в диапазоне от 0 до 9, задающих целую часть числа. *Целые числа* элемент может отсутствовать Если строка содержит *дробной части* элемента.|  
|,|Разделитель групп, зависящий от языка и региональных параметров. Символ-разделитель групп текущего языка и региональных параметров могут использоваться в `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> флаг|  
|.|Символ десятичной запятой для конкретного языка и региональных параметров. Символ десятичной точки текущего языка и региональных параметров могут использоваться в `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> флаг.|  
|*дробной части*|Последовательность цифр в диапазоне от 0 до 9, задающих дробную часть числа. Дробных разрядов может встречаться в `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> флаг.|  
|E|«E» или «E» знаком, который указывает, что значение будет представлено в экспоненциальной нотации (научный). `s` Параметр может представлять число в экспоненциальном представлении, если `style` включает <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> флаг.|  
|*экспоненциальные цифры*|Последовательность цифр в диапазоне от 0 до 9, задающих экспоненту.|  
  
 Строка с только цифры (что соответствует <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> стиль) всегда успешно выполняет синтаксический анализ. Оставшиеся <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> члены управляют элементами, которые могут присутствовать, но необязательно должны присутствовать во входной строке. Следующая таблица показывает, как отдельные <xref:System.Globalization.NumberStyles> флаги влияют на элементы, которые могут присутствовать в `s`.  
  
|Значение NumberStyles|Элементы, допустимые в `s` помимо цифр|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*Целые числа* только элемент.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Десятичной запятой (*.*) и *дробной части* элементов.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|«E» или «E» символ, который указывает на экспоненциальное представление. Этот флаг сам по себе поддерживает значения в форме *цифр*E*цифр*; дополнительные флаги необходимы для успешного анализа строки с такими элементами, как положительное или отрицательное подписывает и десятичный разделитель.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws* элемент в начале `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws* элемент в конце `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*Входа* элемент в начале `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*Входа* элемент в конце `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*Входа* элемент в скобки, ограничивающие числовое значение.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Тысяч элемент разделителя (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Элемент валюты ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Все элементы. Однако `s` не может представлять шестнадцатеричное число или число в экспоненциальном представлении.|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws* элемент в начале или конце `s`, *входа* в начале `s`и символ десятичной точки (.). `s` Параметр можно также использовать экспоненциальное представление.|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`, `sign`, Тысячи разделитель (,) и элементы десятичной точки (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Все элементы. Однако `s` не может представлять шестнадцатеричное число.|  
  
 `provider` Параметр <xref:System.IFormatProvider> реализация которого <xref:System.IFormatProvider.GetFormat%2A> возвращает <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о культуре, используемый при интерпретации формат `s`. Обычно это <xref:System.Globalization.NumberFormatInfo> или <xref:System.Globalization.CultureInfo> объекта. Если `provider` — `null` или <xref:System.Globalization.NumberFormatInfo> не удается получить, сведения о форматировании для используемых текущую культуру системы.  
  
 Как правило если передать <xref:System.Double.Parse%2A?displayProperty=nameWithType> метод строку, которая создается путем вызова <xref:System.Double.ToString%2A?displayProperty=nameWithType> метод, исходные <xref:System.Double> возвращаемое значение. Однако из-за потери точности значения могут не быть равны. Кроме того, при попытке проанализировать строковым представлением любого <xref:System.Double.MinValue> или <xref:System.Double.MaxValue> вызывает <xref:System.OverflowException>, как показано в следующем примере.  
  
 [!code-csharp[System.Double.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/parse2.cs#3)]
 [!code-vb[System.Double.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/parse2.vb#3)]  
  
 Если обнаружен разделитель в `s` параметр во время операции синтаксического анализа и применимые валюты или число десятичных и разделители групп совпадают, предполагается, что разделитель является десятичного разделителя, а не группой разделитель. Дополнительные сведения о разделители см. в разделе <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, и <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Следующий пример иллюстрирует использование <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> метод назначения нескольких строковых представлений значений температуры для `Temperature` объекта.  
  
 [!code-csharp[System.Double.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.Parse/cs/Parse3.cs#2)]
 [!code-vb[System.Double.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.Parse/vb/Parse3.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="s" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> не представляет числовое значение.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> не является значением <see cref="T:System.Globalization.NumberStyles" />.  -или- <paramref name="style" /> является значением <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <exception cref="T:System.OverflowException">Параметр <paramref name="s" /> представляет число меньше <see cref="F:System.Double.MinValue" /> или больше <see cref="F:System.Double.MaxValue" />.</exception>
        <altmember cref="M:System.Double.ToString" />
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const double PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float64 PositiveInfinity = float64(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Double.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const PositiveInfinity As Double  = Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: double PositiveInfinity = Infinity;" />
      <MemberSignature Language="F#" Value="val mutable PositiveInfinity : double" Usage="System.double.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>Представляет плюс бесконечность. Это поле является константой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этой константы — результат деления положительного числа на ноль.  
  
 Эта константа возвращается в том случае, если результат операции больше, чем <xref:System.Double.MaxValue>.  
  
 Используйте <xref:System.Double.IsPositiveInfinity%2A> для определения, равно ли значение плюс бесконечность.  
  
   
  
## Examples  
 В следующем примере кода показано использование <xref:System.Double.PositiveInfinity>:  
  
 [!code-cpp[System.Double#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#10)]
 [!code-csharp[System.Double#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#10)]
 [!code-vb[System.Double#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.IsPositiveInfinity(System.Double)" />
        <altmember cref="M:System.Double.IsInfinity(System.Double)" />
        <altmember cref="F:System.Double.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns>
          <see langword="true" />, если значение текущего экземпляра не равно нулю; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Double> приведен к типу интерфейса <xref:System.IConvertible>. Взамен рекомендуется использовать заключается в вызове <xref:System.Convert.ToBoolean%28System.Double%29?displayProperty=nameWithType> метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.Byte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Double> приведен к типу интерфейса <xref:System.IConvertible>. Взамен рекомендуется использовать заключается в вызове <xref:System.Convert.ToByte%28System.Double%29?displayProperty=nameWithType> метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Данное преобразование не поддерживается. При попытке использовать этот метод выбрасывается исключение <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Данное преобразование не поддерживается. Возвращаемое значение отсутствует.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Во всех случаях.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Данное преобразование не поддерживается. При попытке использовать этот метод возникает исключение <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Данное преобразование не поддерживается. Возвращаемое значение отсутствует.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Во всех случаях.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Double> приведен к типу интерфейса <xref:System.IConvertible>. Взамен рекомендуется использовать заключается в вызове <xref:System.Convert.ToDecimal%28System.Double%29?displayProperty=nameWithType> метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, не измененное.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Double> приведен к типу интерфейса <xref:System.IConvertible>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.Int16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Double> приведен к типу интерфейса <xref:System.IConvertible>. Взамен рекомендуется использовать заключается в вызове <xref:System.Convert.ToInt16%28System.Double%29?displayProperty=nameWithType> метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.Int32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Double> приведен к типу интерфейса <xref:System.IConvertible>. Взамен рекомендуется использовать заключается в вызове <xref:System.Convert.ToInt32%28System.Double%29?displayProperty=nameWithType> метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.Int64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Double> приведен к типу интерфейса <xref:System.IConvertible>. Взамен рекомендуется использовать заключается в вызове <xref:System.Convert.ToInt64%28System.Double%29?displayProperty=nameWithType> метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.SByte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Double> приведен к типу интерфейса <xref:System.IConvertible>. Взамен рекомендуется использовать заключается в вызове <xref:System.Convert.ToSByte%28System.Double%29?displayProperty=nameWithType> метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.Single" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Double> приведен к типу интерфейса <xref:System.IConvertible>. Взамен рекомендуется использовать заключается в вызове <xref:System.Convert.ToSingle%28System.Double%29?displayProperty=nameWithType> метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Тип, к которому необходимо привести это значение <see cref="T:System.Double" />.</param>
        <param name="provider">Реализация интерфейса <see cref="T:System.IFormatProvider" />, предоставляющая сведения о формате возвращаемого значения, связанные с языком и региональными параметрами.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Double> приведен к типу интерфейса <xref:System.IConvertible>. Взамен рекомендуется использовать заключается в вызове `static` (`Shared` в Visual Basic) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.UInt16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Double> приведен к типу интерфейса <xref:System.IConvertible>. Взамен рекомендуется использовать заключается в вызове <xref:System.Convert.ToUInt16%28System.Double%29?displayProperty=nameWithType> метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.UInt32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Double> приведен к типу интерфейса <xref:System.IConvertible>. Взамен рекомендуется использовать заключается в вызове <xref:System.Convert.ToUInt32%28System.Double%29?displayProperty=nameWithType> метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.UInt64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Double> приведен к типу интерфейса <xref:System.IConvertible>. Взамен рекомендуется использовать заключается в вызове <xref:System.Convert.ToUInt64%28System.Double%29?displayProperty=nameWithType> метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразовывает числовое значение данного экземпляра в эквивалентное ему строковое представление.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="double.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Преобразовывает числовое значение данного экземпляра в эквивалентное ему строковое представление.</summary>
        <returns>Строковое представление значения этого экземпляра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString> Форматы метода <xref:System.Double> значение в значение по умолчанию («G» или Общие) формат текущего языка и региональных параметров. Если вы хотите указать другой формат, точность или язык и региональные параметры, использовать другие перегрузки <xref:System.Double.ToString%2A> метод следующим образом:  
  
|Для использования формата|Для языка и региональных параметров|Используйте перегрузку|  
|-------------------|-----------------|----------------------|  
|Формат по умолчанию («G»)|Определенного языка и региональных параметров|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Определенный формат или точности|По умолчанию (текущего) язык и региональные параметры|<xref:System.Double.ToString%28System.String%29>|  
|Определенный формат или точности|Определенного языка и региональных параметров|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Возвращаемое значение может быть <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, или строку в формате:  
  
 целые числа [вход] [. [ дробной части]] [e [вход] экспоненты числа]  
  
 Необязательные элементы заключены в квадратные скобки ([и]). Элементов, содержащих термин «цифры» состоят из последовательности цифр от 0 до 9. Поддерживаются элементы, перечисленные в следующей таблице.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*sign*|Отрицательный знак плюс или.|  
|*целые числа*|Последовательность цифр, обозначающих целую часть числа. Целые числа могут отсутствовать при наличии дробной части.|  
|'*.*'|Символ десятичной запятой для конкретного языка и региональных параметров.|  
|*дробной части*|Последовательность цифр, обозначающих дробную часть числа.|  
|"*e*"|Строчная буква «e», используемая в экспоненциальном представлении (научный).|  
|*экспоненциальные цифры*|Последовательность цифр, обозначающих показатель степени.|  
  
 Примеры возвращаемого значения: «100», «-123456789", «123, 45e + 6", «500», «3,1416», «600», «-0,123» и «-бесконечность».  
  
 .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах форматирования:  
  
-   Дополнительные сведения об описателях числового формата см. в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 В следующем примере используется значение по умолчанию <xref:System.Double.ToString?displayProperty=nameWithType> метод для отображения строковые представления числа <xref:System.Double> значения.  
  
 [!code-csharp[System.Double.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Double.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#1)]  
  
 Следующий пример иллюстрирует использование <xref:System.Double.ToString%2A>.  
  
 [!code-cpp[System.Double#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double/CPP/doublesample.cpp#3)]
 [!code-csharp[System.Double#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double/CS/doublesample.cs#3)]
 [!code-vb[System.Double#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double/VB/doublesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="double.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <summary>Преобразует числовое значение данного экземпляра в эквивалентное ему строковое представление с использованием указанных сведений об особенностях форматирования для данного языка и региональных параметров.</summary>
        <returns>Строковое представление значения данного экземпляра, определяемое параметром <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%28System.IFormatProvider%29> Форматы метода <xref:System.Double> значение в значение по умолчанию («G» или Общие) формат указанного языка и региональных параметров. Если вы хотите указать другой формат или язык и региональные параметры, использовать другие перегрузки <xref:System.Double.ToString%2A> метод следующим образом:  
  
|Для использования формата|Для языка и региональных параметров|Используйте перегрузку|  
|-------------------|-----------------|----------------------|  
|Формат по умолчанию («G»)|По умолчанию (текущий)|<xref:System.Double.ToString>|  
|Определенный формат или точности|По умолчанию (текущего) язык и региональные параметры|<xref:System.Double.ToString%28System.String%29>|  
|Определенный формат или точности|Определенного языка и региональных параметров|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Возвращаемое значение может быть <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, или строку в формате:  
  
 целые числа [вход] [. [ дробной части]] [e [вход] экспоненты числа]  
  
 Необязательные элементы заключены в квадратные скобки ([и]). Элементов, содержащих термин «цифры» состоят из последовательности цифр от 0 до 9. Поддерживаются элементы, перечисленные в следующей таблице.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*sign*|Отрицательный знак плюс или.|  
|*целые числа*|Последовательность цифр, обозначающих целую часть числа. Целые числа могут отсутствовать при наличии дробной части.|  
|'*.*'|Символ десятичной запятой для конкретного языка и региональных параметров.|  
|*дробной части*|Последовательность цифр, обозначающих дробную часть числа.|  
|"*e*"|Строчная буква «e», используемая в экспоненциальном представлении (научный).|  
|*экспоненциальные цифры*|Последовательность цифр, обозначающих показатель степени.|  
  
 Примеры возвращаемого значения: «100», «-123456789", «123, 45e + 6", «500», «3,1416», «600», «-0,123» и «-бесконечность».  
  
 Возвращаемое значение форматируется с помощью спецификатора общего числового формата («G»).  
  
 .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах форматирования:  
  
-   Дополнительные сведения об описателях числового формата см. в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 `provider` Параметр <xref:System.IFormatProvider> реализация которого <xref:System.IFormatProvider.GetFormat%2A> возвращает метод <xref:System.Globalization.NumberFormatInfo> объекта. Как правило `provider` — <xref:System.Globalization.CultureInfo> объекта или <xref:System.Globalization.NumberFormatInfo> объекта. `provider` Параметр предоставляет сведения о культуре, используемый для форматирования. Если `provider` — `null`, возвращаемое значение форматируется с использованием <xref:System.Globalization.NumberFormatInfo> объект для текущего языка и региональных параметров.  
  
   
  
## Examples  
 Следующий пример отображает строковое представление двух <xref:System.Double> значения с помощью <xref:System.Globalization.CultureInfo> объектов, представляющих несколько разных языков и региональных параметров.  
  
 [!code-csharp[System.Double.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#2)]
 [!code-vb[System.Double.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#2)]  
  
 Следующий пример иллюстрирует использование <xref:System.Double.ToString%2A>, принимающий <xref:System.String> и <xref:System.IFormatProvider> в качестве параметров.  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="double.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Строка числового формата.</param>
        <summary>Преобразует числовое значение данного экземпляра в эквивалентное строковое представление с использованием указанного формата.</summary>
        <returns>Строковое представление значения данного экземпляра, определяемое параметром <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%28System.String%29> Форматы метода <xref:System.Double> значение в указанном формате, с использованием правил текущего языка и региональных параметров. Если вы хотите указать другой формат или язык и региональные параметры, использовать другие перегрузки <xref:System.Double.ToString%2A> метод следующим образом:  
  
|Для использования формата|Для языка и региональных параметров|Используйте перегрузку|  
|-------------------|-----------------|----------------------|  
|Формат по умолчанию («G»)|По умолчанию (текущего) язык и региональные параметры|<xref:System.Double.ToString>|  
|Формат по умолчанию («G»)|Определенного языка и региональных параметров|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Определенный формат или точности|Определенного языка и региональных параметров|<xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Возвращаемое значение может быть <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, или строковое представление числа в соответствии с `format`.  
  
 `format` Параметр может быть любой допустимый стандартный описатель числового формата, за исключением D и X, а также любым сочетанием описателях настраиваемого числового формата. Если `format` — `null` или пустая строка, возвращаемое значение форматируется с помощью спецификатора общего числового формата («G»).  
  
 .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах форматирования:  
  
-   Дополнительные сведения об описателях числового формата см. в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 По умолчанию возвращаемое значение содержит только 15-знаковая точность хотя для внутренних целей поддерживается до 17 знаков. Если значение данного экземпляра содержит более 15 цифр <xref:System.Double.ToString%2A> возвращает <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> или <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> вместо ожидаемого числа. Если требуется более высокая точность указать `format` с спецификации формата «G17» всегда возвращается точность или «R», возвращается 15 цифр, если число может быть представлено с этой точностью или 17 знаков, если это число может быть только представлено с наибольшей точностью.  
  
   
  
## Examples  
 В следующем примере определяет числовое значение и форматирует их в виде значения валюты с использованием строки стандартного числового формата «C», так и в виде числового значения до трех десятичных знаков с использованием строки стандартного числового формата «N». Результирующие строки форматируются с использованием соглашений о региональных параметров en US. Дополнительные сведения о строки числовых форматов см. в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
 [!code-csharp[System.Double.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString7.cs#7)]
 [!code-vb[System.Double.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString7.vb#7)]  
  
 В следующем примере показаны некоторые <xref:System.Double> значения с помощью спецификаторов поддерживаемых стандартных числовых форматов, а также три строки настраиваемых числовых форматов. Одно из этих строк настраиваемого формата показывает, как выполнить заполнение <xref:System.Single> значения начальными нулями. Кроме того в примере используется точность описателей с каждой описатель стандартного формата, за исключением «R». Значения точность описателей находятся в диапазоне от 0 до 3. Для преобразования числовых значений в строки, в примере соглашений о форматировании языка и региональных параметров en US.  
  
 [!code-cpp[System.Double.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Double.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Double.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> недопустим.</exception>
        <block subset="none" type="usage">
          <para>В некоторых случаях <see cref="T:System.Double" /> форматировать значения с помощью строки стандартного числового формата «R» do не успешного обратного преобразования при компиляции с использованием <see langword="/platform:x64" /> или <see langword="/platform:anycpu" /> и запуска на 64-разрядных системах. Чтобы обойти эту проблему, можно форматировать значения <see cref="T:System.Double" /> с помощью строки стандартного числового формата "G17". В следующем примере строка формата «R» со <see cref="T:System.Double" /> которого не удается выполнить обратное преобразование не успешно, а также формата «G17» строка для успешного обратного преобразования исходного значения.  [! c# кода [System.Double.ToString#6] (~/samples/snippets/csharp/VS_Snippets_CLR_System или системы. Double.ToString/cs/roundtripex2.cs#6)] [! код vb [System.Double.ToString#6] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System или системы. Double.ToString/vb/roundtripex2.vb#6)]</para>
        </block>
        <altmember cref="M:System.Double.Parse(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="double.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Строка числового формата.</param>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <summary>Преобразует числовое значение данного экземпляра в эквивалентное ему строковое представление с использованием указанного формата и сведений об особенностях форматирования для данного языка и региональных параметров.</summary>
        <returns>Строковое представление значения данного экземпляра, определяемое параметрами <paramref name="format" /> и <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.ToString%28System.String%2CSystem.IFormatProvider%29> Форматы метода <xref:System.Double> значение в указанном формате указанного языка и региональных параметров. Если вы хотите указать другой формат или язык и региональные параметры, использовать другие перегрузки <xref:System.Double.ToString%2A> метод следующим образом:  
  
|Для использования формата|Для языка и региональных параметров|Используйте перегрузку|  
|-------------------|-----------------|----------------------|  
|Формат по умолчанию («G»)|По умолчанию (текущего) язык и региональные параметры|<xref:System.Double.ToString>|  
|Формат по умолчанию («G»)|Определенного языка и региональных параметров|<xref:System.Double.ToString%28System.IFormatProvider%29>|  
|Определенный формат или точности|По умолчанию (текущего) язык и региональные параметры|<xref:System.Double.ToString%28System.String%29>|  
  
 Возвращаемое значение может быть <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, или строковое представление числа в соответствии с `format`.  
  
 `format` Параметр может быть любой допустимый стандартный описатель числового формата, за исключением D и X, а также любым сочетанием описателях настраиваемого числового формата. Если `format` — `null` или пустая строка, возвращаемое значение для данного экземпляра форматируется с помощью спецификатора общего числового формата («G»).  
  
 .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах форматирования:  
  
-   Дополнительные сведения об описателях числового формата см. в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 `provider` Параметр <xref:System.IFormatProvider> реализация которого <xref:System.IFormatProvider.GetFormat%2A> возвращает метод <xref:System.Globalization.NumberFormatInfo> объекта. Как правило `provider` — <xref:System.Globalization.CultureInfo> объекта или <xref:System.Globalization.NumberFormatInfo> объекта. `provider` Параметр предоставляет сведения о культуре, используемый для форматирования. Если `provider` — `null`, возвращаемое значение форматируется с использованием <xref:System.Globalization.NumberFormatInfo> объект для текущего языка и региональных параметров.  
  
 По умолчанию возвращаемое значение содержит только 15-знаковая точность хотя для внутренних целей поддерживается до 17 знаков. Если значение данного экземпляра содержит более 15 цифр <xref:System.Double.ToString%2A> возвращает <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> или <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> вместо ожидаемого числа. Если требуется более высокая точность указать `format` с спецификации формата «G17» всегда возвращается точность или «R», возвращается 15 цифр, если число может быть представлено с этой точностью или 17 знаков, если это число может быть только представлено с наибольшей точностью.  
  
   
  
## Examples  
 В следующем примере отображается <xref:System.Double> с использованием всех описателей стандартных числовых форматов поддерживаемые для нескольких языков и региональных параметров.  
  
 [!code-cpp[System.Double.ToString#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Double.ToString/cpp/tostring1.cpp#4)]
 [!code-csharp[System.Double.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Double.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.ToString/vb/ToString1.vb#4)]  
  
 Следующий пример иллюстрирует использование <xref:System.Double.ToString%2A>, принимающий <xref:System.String> и <xref:System.IFormatProvider> в качестве параметров.  
  
 [!code-cpp[Double Example#4](~/samples/snippets/cpp/VS_Snippets_CLR/Double Example/CPP/source.cpp#4)]
 [!code-csharp[Double Example#4](~/samples/snippets/csharp/VS_Snippets_CLR/Double Example/CS/source.cs#4)]
 [!code-vb[Double Example#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/Double Example/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>В некоторых случаях <see cref="T:System.Double" /> форматировать значения с помощью строки стандартного числового формата «R» do не успешного обратного преобразования при компиляции с использованием <see langword="/platform:x64" /> или <see langword="/platform:anycpu" /> и запуска на 64-разрядных системах. Чтобы обойти эту проблему, можно форматировать значения <see cref="T:System.Double" /> с помощью строки стандартного числового формата "G17". В следующем примере строка формата «R» со <see cref="T:System.Double" /> которого не удается выполнить обратное преобразование не успешно, а также формата «G17» строка для успешного обратного преобразования исходного значения.  [! c# кода [System.Double.ToString#5] (~/samples/snippets/csharp/VS_Snippets_CLR_System или системы. Double.ToString/cs/roundtripex1.cs#5)] [! код vb [System.Double.ToString#5] (~/samples/snippets/visualbasic/VS_Snippets_CLR_System или системы. Double.ToString/vb/roundtripex1.vb#5)]</para>
        </block>
        <altmember cref="M:System.Double.Parse(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="double.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразует строковое представление числа в эквивалентное ему число двойной точности с плавающей запятой. Возвращает значение, указывающее, успешно ли выполнено преобразование.</summary>
        <altmember cref="Overload:System.Double.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.double.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Double&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.double.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Double&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая преобразуемое число.</param>
        <param name="result">При возврате этот метод содержит число двойной точности с плавающей запятой, эквивалентное параметру <c>s</c>, если преобразование завершилось успешно, или нуль, если оно завершилось неудачно. Преобразование завершается неудачно, если значение параметра <c>s</c> равно <see langword="null" /> или <see cref="F:System.String.Empty" />, не является числом допустимого формата или представляет число меньше <see cref="F:System.Double.MinValue" /> или больше <see cref="F:System.Double.MaxValue" />. Этот параметр передается неинициализированным; любое значение, первоначально предоставленное в параметре <c>result</c>, будет перезаписано.</param>
        <summary>Преобразует строковое представление числа в эквивалентное ему число двойной точности с плавающей запятой. Возвращает значение, указывающее, успешно ли выполнено преобразование.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="s" /> успешно преобразован; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка отличается от <xref:System.Double.Parse%28System.String%29?displayProperty=nameWithType> метода, возвращая логическое значение, указывающее, успешно ли выполнена операция анализа вместо проанализированного числового значения. Отпадает необходимость использования обработки исключений для проверки на наличие <xref:System.FormatException> в случае, если `s` является недопустимым и не может быть успешно обработан.  
  
 `s` Параметр может содержать текущего языка и региональных параметров <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> (сравнение строк с учетом регистра), или строку в формате:  
  
 [ws] [вход] [целые числа,] целые числа [. [ дробной части]] [e [вход] экспоненты числа] [ws]  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*ws*|Серия символы-разделители.|  
|*sign*|Отрицательный знак плюс или.|  
|*целые числа*|Последовательность цифр в диапазоне от 0 до 9, задающих целую часть числа. Целые числа могут отсутствовать при наличии дробной части.|  
|*,*|Символ разделителя групп, зависящий от языка и региональных параметров.|  
|*.*|Символ десятичной запятой для конкретного языка и региональных параметров.|  
|*дробной части*|Последовательность цифр в диапазоне от 0 до 9, задающих дробную часть числа.|  
|*E*|Верхнего или нижнего регистра символ «e», который указывает на экспоненциальное представление (научный).|  
|*экспоненциальные цифры*|Последовательность цифр в диапазоне от 0 до 9, задающих экспоненту.|  
  
 Дополнительные сведения о числовых форматах см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 `s` Параметр интерпретируется с использованием сочетания <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> и <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> флаги. Это означает, что пробелы и тысяч разделители разрешены, но не являются символами валют. Для явного определения элементов (такие как символы денежной единицы, тысячи разделители и символы-разделители), могут быть представлены в `s`, используйте <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> перегрузки метода.  
  
 `s` Параметр анализируется с использованием сведений о форматировании в <xref:System.Globalization.NumberFormatInfo> , инициализируемый для текущего языка и региональных параметров системы. Дополнительные сведения см. в разделе <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Для анализа строки с использованием сведений о форматировании для другого языка и региональных параметров, используйте <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> перегрузки метода.  
  
 Как правило если передать <xref:System.Double.TryParse%2A?displayProperty=nameWithType> метод строку, которая создается путем вызова <xref:System.Double.ToString%2A?displayProperty=nameWithType> метод, исходные <xref:System.Double> возвращаемое значение. Однако из-за потери точности значения могут не быть равны. Кроме того, при попытке проанализировать строковым представлением любого <xref:System.Double.MinValue> или <xref:System.Double.MaxValue> вызывает <xref:System.OverflowException>, как показано в следующем примере.  
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  
  
 Если обнаружен разделитель в `s` параметра во время операции синтаксического анализа и разделители десятичных и групповых совпадают, предполагается, что разделитель является десятичного разделителя, а не разделителя групп. Дополнительные сведения о разделители см. в разделе <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, и <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Double.TryParse%28System.String%2CSystem.Double%40%29> метод преобразования строковые представления числовых значений для <xref:System.Double> значения. Предполагается, что текущий язык и региональные параметры en US.  
  
 [!code-csharp[System.Double.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse1a.cs#1)]
 [!code-vb[System.Double.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse1a.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Double.Parse(System.String)" />
        <altmember cref="M:System.Double.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.double.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Double&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out double result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float64&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Double.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Double) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] double % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.double.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Double&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая преобразуемое число.</param>
        <param name="style">Побитовое сочетание значений <see cref="T:System.Globalization.NumberStyles" />, определяющее разрешенный формат параметра <c>s</c>. Обычно указывается значение <see cref="F:System.Globalization.NumberStyles.Float" /> в сочетании со значением <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Интерфейс <see cref="T:System.IFormatProvider" />, который предоставляет сведения о форматировании параметра <c>s</c> для соответствующего языка и региональных параметров.</param>
        <param name="result">При возврате этот метод содержит число двойной точности с плавающей запятой, эквивалентное числовому значению или символу, содержащемуся в параметре <c>s</c>, если преобразование завершилось успешно, или нуль, если оно завершилось неудачно. Преобразование завершается неудачно, если параметр <c>s</c> имеет значение <see langword="null" /> или <see cref="F:System.String.Empty" />, не является значением в формате, совместимом с параметром <c>style</c>, представляет число меньше <see cref="F:System.SByte.MinValue" /> или больше <see cref="F:System.SByte.MaxValue" /> либо если <c>style</c> не является допустимой комбинацией перечисленных констант <see cref="T:System.Globalization.NumberStyles" />. Этот параметр передается неинициализированным; любое значение, первоначально предоставленное в параметре <c>result</c>, будет перезаписано.</param>
        <summary>Преобразует строковое представление числа указанного стиля, выраженное в формате, соответствующем определенному языку и региональным параметрам, в эквивалентное ему число двойной точности с плавающей запятой. Возвращает значение, указывающее, успешно ли выполнено преобразование.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="s" /> успешно преобразован; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Double.TryParse%2A> Метод аналогичен <xref:System.Double.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> за исключением того, этот метод не вызывает исключение при сбое преобразования. Если преобразование прошло успешно, возвращаемое значение равно `true` и `result` параметру присваивается результат преобразования. Если преобразование завершается неудачей, возвращаемым значением является `false` и `result` параметра равным нулю. Это избавляет от необходимости использовать обработку исключений для проверки на наличие <xref:System.FormatException> в случае, если `s` является недопустимым и не может быть успешно обработан.  
  
 `style` Параметр определяет допустимый формат `s` параметр для успешного выполнения операции синтаксического анализа. Он должен быть сочетанием одноразрядных флагов из <xref:System.Globalization.NumberStyles> перечисления. Следующие <xref:System.Globalization.NumberStyles> элементы не поддерживаются:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 `s` Параметр может содержать <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, или <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> языком и региональными параметрами, обозначенном `provider`. Кроме того, в зависимости от значения `style`, `s` параметр может содержать следующие элементы:  
  
 [ws] [$] [вход] [целые числа,] [.доли числа] [e [вход] экспоненты числа] целые числа [ws]  
  
 Элементы в квадратных скобках ([и]) являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*ws*|Необязательный пробел. Пробелы могут отображаться в начале `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> флаг. Он может располагаться в конце `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> флаг.|  
|*$*|Символ валюты. Его положение в строке определяется <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> или <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> свойства <xref:System.Globalization.NumberFormatInfo> объект, возвращаемый <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> метод `provider` параметра. Символ валюты может встречаться в `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> флаг.|  
|*sign*|Необязательный знак. Знак может располагаться в начале `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> флаг, который может находиться в конце `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> флаг. Можно использовать круглые скобки в `s` указывает отрицательное значение, если `style` включает <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> флаг.|  
|*целые числа*|Последовательность цифр в диапазоне от 0 до 9, задающих целую часть числа. Целые числа могут отсутствовать при наличии дробной части.|  
|*,*|Разделителя групп разрядов символ-разделитель. Тысячи текущего языка и региональных параметров может присутствовать разделитель в `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> флаг.|  
|*.*|Символ десятичной запятой для конкретного языка и региональных параметров. Символ десятичной точки текущего языка и региональных параметров могут использоваться в `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> флаг.|  
|*дробной части*|Последовательность цифр в диапазоне от 0 до 9, задающих дробную часть числа. Дробных разрядов может встречаться в `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> флаг.|  
|*e*|E или E символ, который указывает, что `s` может представлять число в экспоненциальном представлении. `s` Параметр может представлять число в экспоненциальном представлении, если стиль включает <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> флаг.|  
|*экспоненциальные цифры*|Последовательность цифр в диапазоне от 0 до 9, задающих экспоненту.|  
  
 Строка с только цифры (что соответствует <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> стиль) всегда успешно выполняет синтаксический анализ. Оставшиеся <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> члены управляют элементами, которые могут быть, но необязательно должны присутствовать во входной строке. Следующая таблица показывает, как отдельные <xref:System.Globalization.NumberStyles> флаги влияют на элементы, которые могут присутствовать в `s`.  
  
|Значение NumberStyles|Допустимые элементы s помимо цифр|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*Целые числа* только элемент.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Языковой элемент *.* и *дробной части* элементов.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|`s` Параметр можно также использовать экспоненциальное представление. Этот флаг сам по себе поддерживает значения в форме *целые числа*E*экспоненциальные цифры*; дополнительные флаги необходимы для успешного анализа строк в экспоненциальной форме с такими элементами, как положительное или отрицательное подписывает и десятичный разделитель.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws* элемент в начале `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws* элемент в конце `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*Входа* элемент в начале `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*Входа* элемент в конце `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*Входа* элемент в скобки, ограничивающие числовое значение.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|*,* Элемент.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|* $ * Элемента.|  
|<xref:System.Globalization.NumberStyles.Currency>|Все. `s` Параметра не может представлять шестнадцатеричное число или число в экспоненциальном представлении.|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws* элемент в начале или конце `s`, *входа* в начале `s`и *.* символ. `s` Параметр можно также использовать экспоненциальное представление.|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`, `sign`, Тысячи разделителя (*,),* и десятичной запятой (*.*) элементов.|  
|<xref:System.Globalization.NumberStyles.Any>|Все стили, кроме `s` не может представлять шестнадцатеричное число.|  
  
 `provider` Параметр <xref:System.IFormatProvider> реализации, такие как <xref:System.Globalization.NumberFormatInfo> или <xref:System.Globalization.CultureInfo> объекта. `provider` Параметр предоставляет сведения о культуре, которые используются в процессе анализа. Если `provider` — `null` или <xref:System.Globalization.NumberFormatInfo> не удается получить объект, используются сведения о формате для текущего языка и региональных параметров.  
  
 Преобразование завершается неудачей, если `s` параметр `null` или числовое значение, `provider` параметр не дает <xref:System.Globalization.NumberFormatInfo> объекта, или `style` параметр не является сочетанием одноразрядных флагов из <xref:System.Globalization.NumberStyles> перечисление.  
  
 Как правило если передать <xref:System.Double.TryParse%2A?displayProperty=nameWithType> метод строку, которая создается путем вызова <xref:System.Double.ToString%2A?displayProperty=nameWithType> метод, исходные <xref:System.Double> возвращаемое значение. Однако из-за потери точности значения могут не быть равны. Кроме того, при попытке проанализировать строковым представлением любого <xref:System.Double.MinValue> или <xref:System.Double.MaxValue> вызывает <xref:System.OverflowException>, как показано в следующем примере.  
  
 [!code-csharp[System.Double.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/tryparse2.cs#3)]
 [!code-vb[System.Double.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/tryparse2.vb#3)]  
  
 Если обнаружен разделитель в `s` параметр во время операции синтаксического анализа и применимые валюты или число десятичных и разделители групп совпадают, предполагается, что разделитель является десятичного разделителя, а не группой разделитель. Дополнительные сведения о разделители см. в разделе <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, и <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Double.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Double%40%29?displayProperty=nameWithType> метода для синтаксического анализа строковое представление числа, определенного стиля и форматируются в соответствии с соглашениями определенного языка и региональных параметров.  
  
 [!code-csharp[System.Double.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Double.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Double.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Double.TryParse/vb/TryParse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> не является значением <see cref="T:System.Globalization.NumberStyles" />.  -или- <paramref name="style" /> включает значение <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <altmember cref="M:System.Double.ToString" />
      </Docs>
    </Member>
  </Members>
</Type>