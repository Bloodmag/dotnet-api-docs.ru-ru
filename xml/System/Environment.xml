<Type Name="Environment" FullName="System.Environment">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b8f2716206a0d7c4bbbc8310b3ec10e214e0d3af" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30730088" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Environment" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Environment extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Environment" />
  <TypeSignature Language="VB.NET" Value="Public Class Environment" />
  <TypeSignature Language="C++ CLI" Value="public ref class Environment abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет сведения о текущей среде и платформе, а также необходимые для управления ими средства. Этот класс не наследуется.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Environment> класс для получения сведений об аргументах командной строки, код выхода, параметров переменных среды, содержимое стека вызовов, времени с момента последней загрузки и версии среды CLR.  
  
   
  
## Examples  
 Ниже приведен пример отображает список сведений о текущей среде.  
  
 [!code-cpp[environment.class#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.class/CPP/env0.cpp#1)]
 [!code-csharp[environment.class#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.class/CS/env0.cs#1)]
 [!code-vb[environment.class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.class/VB/env0.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CommandLine">
      <MemberSignature Language="C#" Value="public static string CommandLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommandLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CommandLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommandLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommandLine { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает командную строку для данного процесса.</summary>
        <value>Строка, содержащая аргументы командной строки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предоставляет доступ к имени программы и все аргументы, заданные в командной строке при запуске текущего процесса.  
  
 Имя программы может содержать сведения о пути, но не требуется, чтобы сделать это. Используйте <xref:System.Environment.GetCommandLineArgs%2A> метод, чтобы получить сведения о командной строки анализируется и хранятся в массиве строк.  
  
 Максимальный размер буфера командной строки не равно определенное количество символов; он зависит от операционной системы Windows, на котором выполняется на компьютере.  
  
   
  
## Examples  
 В следующем примере отображается командной строки.  
  
 [!code-cpp[environment.commandline#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.CommandLine/CPP/commandline.cpp#1)]
 [!code-csharp[environment.commandline#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.CommandLine/CS/commandline.cs#1)]
 [!code-vb[environment.commandline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.CommandLine/VB/commandline.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">доступ для чтения к переменной среды PATH. Связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает полный путь к текущей рабочей папке.</summary>
        <value>Строка, содержащая путь к каталогу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По определению, если этот процесс запускается в корневом каталоге локального или сетевого диска, значение этого свойства является имя диска, а затем косой чертой (например, «C:\\»). Если этот процесс запускается из подкаталога, значение этого свойства — диска и путь без косой чертой (например, «C:\mySubDirectory»).  
  
   
  
## Examples  
 В следующем примере показано задание <xref:System.Environment.CurrentDirectory%2A> свойство.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Попытка задать пустую строку ("").</exception>
        <exception cref="T:System.ArgumentNullException">Попытка установить значение <see langword="null." />.</exception>
        <exception cref="T:System.IO.IOException">Ошибка ввода/вывода.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Попытка установить локальный путь, который не удается найти.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует соответствующее разрешение.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для записи в файлы или каталоги в операции задания. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям в сам путь в операции get. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentManagedThreadId">
      <MemberSignature Language="C#" Value="public static int CurrentManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CurrentManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CurrentManagedThreadId { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает уникальный идентификатор текущего управляемого потока.</summary>
        <value>Целочисленное значение, представляющее уникальный идентификатор для этого управляемого потока.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.Exit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(int exitCode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">Код выхода, возвращаемый операционной системе. Чтобы указать, что процесс прошел успешно, следует использовать 0 (ноль).</param>
        <summary>Завершает этот процесс и возвращает код выхода операционной системе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для `exitCode` параметр, используйте ненулевое значение число для указания ошибки. В вашем приложении может определять собственные коды ошибок в перечислении и возвращать соответствующий код ошибки в сценарии. Например возвращает значение 1, чтобы указать, что отсутствует необходимый файл, а значение 2, чтобы указать, что файл находится в неверном формате. Список кодов выхода, используемый операционной системой Windows см. в разделе [коды системных ошибок](http://msdn.microsoft.com/library/ms681381.aspx) в документации по Windows.  
  
 Вызов <xref:System.Environment.Exit%2A> метод отличается от языка программирования с помощью `return` инструкции одним из следующих способов:  
  
-   <xref:System.Environment.Exit%2A> всегда завершает работу приложения. С помощью `return` инструкции может быть прервано приложения только в том случае, если используется в точку входа приложения, такие как в `Main` метод.  
  
-   <xref:System.Environment.Exit%2A> завершает приложение немедленно, даже если запущены другие потоки. Если `return` вызова инструкции в точке входа приложения, он вызывает приложение завершить работу, только в том случае, когда все основные потоки завершились.  
  
-   <xref:System.Environment.Exit%2A> вызывающая программа должна иметь разрешение на вызов неуправляемого кода. `return` Отличается от инструкции.  
  
-   Если <xref:System.Environment.Exit%2A> вызывается из `try` или `catch` блок кода в любом `finally` блок не выполняется. Если `return` используется инструкция, код в `finally` выполнение блока.  
  
-   Если <xref:System.Environment.Exit%2A> вызывается, когда код в [области ограниченного выполнения](~/docs/framework/performance/constrained-execution-regions.md) работает (CER), не завершится выполнение CER. Если `return` используется инструкция, CER завершает выполнение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">Вызывающий объект не имеет достаточных разрешений на выполнение этой функции.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public static int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ExitCode { int get(); void set(int value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает или задает код выхода из процесса.</summary>
        <value>32-битовое целое число со знаком, содержащее код выхода. Значение по умолчанию 0 (нуль), что соответствует успешно выполненному процессу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `Main` возвращает `void`, это свойство можно использовать для задания код выхода, будет возвращаться вызывающей среде. Если `Main` не возвращает `void`, это свойство учитывается. Начальное значение этого свойства равно нулю.  
  
> [!WARNING]
>  <xref:System.Environment.ExitCode%2A> Свойство является 32-разрядное знаковое целое число. Чтобы запретить свойство возвращает код выхода отрицательное, не следует использовать значения больше или равно 0x80000000.  
  
 Используйте ненулевое число для указания ошибки. В вашем приложении может определять собственные коды ошибок в перечислении и возвращать соответствующий код ошибки в сценарии. Например возвращает значение 1, чтобы указать, что требуемый файл отсутствует и значение 2, чтобы указать, что файл находится в неверном формате. Список кодов выхода, используемый операционной системой Windows см. в разделе [коды системных ошибок](http://msdn.microsoft.com/library/ms681381\(v=vs.85\)) в документации по Windows.  
  
   
  
## Examples  
 Ниже приведен простого приложения с именем Double.exe, удваивается значение integer, переданного в качестве аргумента командной строки. Коды ошибок присваивает значение <xref:System.Environment.ExitCode%2A> свойства для описания ошибок. Обратите внимание, что необходимо добавить ссылку на сборку System.Numerics.dll, чтобы успешно скомпилировать этот пример.  
  
 [!code-csharp[System.Environment.ExitCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double.cs#1)]
 [!code-vb[System.Environment.ExitCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double.vb#1)]  
  
 Пример может быть вызвана из пакетного файла, как указано ниже, что делает его коды ошибок доступны с помощью `ERRORLEVEL` команды.  
  
```  
  
echo off  
Double.exe %1  
If errorlevel 1639 goto NoArg   
if errorlevel 534 goto Overflow  
if errorlevel 160 goto BadArg  
if errorlevel 0 echo Completed Successfully   
goto :EOF  
  
:NoArg  
echo Missing argument  
goto :EOF  
  
: Overflow  
echo Arithmetic overflow  
goto :EOF  
  
:BadArg  
echo Invalid argument  
goto :EOF  
  
```  
  
 Ниже приведен пример содержимого получаемое при вызове пакетного файла.  
  
```Output  
  
>getdouble 123>echo offResult: 246Completed Successfully>getdouble 5912323109093>echo offArithmetic overflow>getdouble>echo offMissing argument>getdouble "a string">echo offInvalid argument  
  
```  
  
 Обратите внимание, что код для Double.exe работает аналогично функции в следующем примере первый из них определяет точку входа с именем `Main` , не имеет возвращаемого значения, тогда как в этом примере определяет точку входа с именем `Main` , возвращает значение типа integer.  
  
 [!code-csharp[System.Environment.ExitCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double1.cs#2)]
 [!code-vb[System.Environment.ExitCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpandEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static string ExpandEnvironmentVariables (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ExpandEnvironmentVariables(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.ExpandEnvironmentVariables(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExpandEnvironmentVariables (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ExpandEnvironmentVariables(System::String ^ name);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Строка, содержащая либо не содержащая имена переменных среды. Каждая переменная среды с двух сторон окружена знаками процента (%).</param>
        <summary>Замещает имя каждой переменной среды, внедренной в указанную строку, строчным эквивалентом значения переменной, а затем возвращает результирующую строку.</summary>
        <returns>Строка, в которой каждая переменная среды замещена ее значением.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для извлечения переменных среды из операционной системы используется COM-взаимодействие. Если переменные среды не удается получить из-за ошибки COM, HRESULT, выясните причину сбоя используется для создания одного из нескольких возможных исключений; то есть исключение зависит от значения HRESULT. Дополнительные сведения об обработке HRESULT см. в разделе «Примечания» <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A?displayProperty=nameWithType> метод.  
  
 Замещаются только заданные переменные среды. Например, предположим, что `name` является «MyENV = % MyENV %». Если переменной среды MyENV задано значение 42, этот метод возвращает «MyENV = 42». Если MyENV не задано, не происходит никаких изменений; Этот метод возвращает «MyENV = % MyENV %».  
  
 Размер возвращаемого значения ограничен 32 КБ.  
  
   
  
## Examples  
 В следующем примере демонстрируется получение системного диска и системные переменные корневой.  
  
 [!code-cpp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CPP/expandenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CS/expandenvironmentvariables.cs#1)]
 [!code-vb[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/VB/expandenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="name" /> имеет значение <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для возможности доступа к переменным среды в <paramref name="name" />. Связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FailFast">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Завершает процесс сразу после записи сообщения в журнал событий приложений Windows, после чего включает сообщение и дополнительные сведения об исключении в отчет об ошибках, отправляемый в корпорацию Майкрософт.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FailFast (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">Сообщение, в котором объясняется причина завершения процесса или содержится значение <see langword="null" />, если объяснение отсутствует.</param>
        <summary>Завершает процесс сразу после записи сообщения в журнал событий приложений Windows, после чего включает сообщение в отчет об ошибках, отправляемый в корпорацию Майкрософт.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод завершает процесс без запуска все активные `try` / `finally` блоков или методов завершения.  
  
 <xref:System.Environment.FailFast%2A> Метод записи `message` строку в журнал событий приложений Windows создает дамп приложения и затем прекращает выполнение текущего процесса. `message` Строка также включается в корпорацию Майкрософт отчеты об ошибках.  
  
 Используйте <xref:System.Environment.FailFast%2A> вместо метода <xref:System.Environment.Exit%2A> метод для завершения приложения поврежденного состояния приложения после восстановления и выполнение приложения `try` / `finally` блоки и методы завершения приведет к повреждению ресурсов программы.  
  
 Данные выводятся в корпорацию Майкрософт с помощью отчетов об ошибках Windows. Дополнительные сведения см. в разделе [отчеты об ошибках Windows: Приступая к работе](http://msdn.microsoft.com/library/windows/hardware/dn641144.aspx).  
  
   
  
## Examples  
 Следующий пример производит запись в журнал событий приложений Windows и прекращает выполнение текущего процесса.  
  
 [!code-csharp[environment.FailFast#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.FailFast/cs/ff.cs#1)]
 [!code-vb[environment.FailFast#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.FailFast/vb/ff.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message, Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message, class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String,System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message, Exception ^ exception);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">Сообщение, в котором объясняется причина завершения процесса или содержится значение <see langword="null" />, если объяснение отсутствует.</param>
        <param name="exception">Исключение, представляющее ошибку, вызвавшую завершение процесса. Обычно это исключение в блоке <see langword="catch" />.</param>
        <summary>Завершает процесс сразу после записи сообщения в журнал событий приложений Windows, после чего включает сообщение и сведения об исключении в отчет об ошибках, отправляемый в корпорацию Майкрософт.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод завершает процесс без запуска все активные `try` / `finally` блоков или методов завершения.  
  
 <xref:System.Environment.FailFast%2A> Метод записи `message` строку в журнал событий приложений Windows создает дамп приложения и затем прекращает выполнение текущего процесса.  
  
 Данные выводятся в корпорацию Майкрософт с помощью отчетов об ошибках Windows. Дополнительные сведения см. в разделе [отчеты об ошибках Windows: Приступая к работе](http://msdn.microsoft.com/library/windows/hardware/dn641144.aspx). Включает в корпорацию Майкрософт отчеты об ошибках `message` и `exception` информации, которая предоставляет сведения, используемые для классификации ошибки. Несмотря на то что `exception` — не обрабатывается, поскольку процесс завершается, контекстные сведения, который вызвал исключение по-прежнему получить.  
  
 Если `exception` — `null`, или если `exception` — не создано, этот метод работает так же, как <xref:System.Environment.FailFast%28System.String%29> перегрузки метода.  
  
 Используйте <xref:System.Environment.FailFast%2A> вместо метода <xref:System.Environment.Exit%2A> метод для завершения приложения поврежденного состояния приложения после восстановления и выполнение приложения `try` / `finally` блоки и методы завершения приведет к повреждению ресурсов программы.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCommandLineArgs">
      <MemberSignature Language="C#" Value="public static string[] GetCommandLineArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetCommandLineArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetCommandLineArgs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCommandLineArgs () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetCommandLineArgs();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает строковый массив, содержащий аргументы командной строки для текущего процесса.</summary>
        <returns>Массив строк, каждый элемент которого содержит аргумент командной строки. Первым элементом является имя исполняемого файла. Последующие элементы, если они существуют, содержат аргументы командной строки.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Первый элемент в массиве содержит имя файла исполняемой программы. Если имя файла не доступен, первый элемент равен <xref:System.String.Empty?displayProperty=nameWithType>. Остальные элементы содержат все дополнительные лексемы, введенные в командной строке.  
  
 Имя файла программы, можно, но не требуется, включают сведения о пути.  
  
 Аргументы командной строки разделяются пробелами. Для добавления пробелов между аргумента можно использовать двойные кавычки (""). Одинарная кавычка ('), однако не предоставляет эту функцию.  
  
 Если двойная кавычка за два или четное число символов обратной косой черты, каждая последующая пара заменяется одной обратной косой чертой, а двойная кавычка удаляется. Если двойных кавычек следует нечетное число обратных косых черт, включая одну, каждая предыдущая пара заменяется одну обратную косую черту и оставшихся обратная косая черта удаляется; Однако в этом случае двойных кавычек не удаляется.  
  
 В следующей таблице показано, как аргументы командной строки могут быть с разделителями и предполагается `MyApp` как текущего выполняемого приложения.  
  
|Введите в командной строке|Результирующие аргументы командной строки|  
|-------------------------------|--------------------------------------|  
|`MyApp alpha beta`|`MyApp, alpha, beta`|  
|`MyApp "alpha with spaces" "beta with spaces"`|`MyApp, alpha with spaces, beta with spaces`|  
|`MyApp 'alpha with spaces' beta`|`MyApp, 'alpha, with, spaces', beta`|  
|`MyApp \\\alpha \\\\"beta`|`MyApp, \\\alpha, \\beta`|  
|`MyApp \\\\\"alpha \"beta`|`MyApp, \\"alpha, "beta`|  
  
 Для получения командной строки в виде одной строки, используйте <xref:System.Environment.CommandLine%2A> свойство.  
  
   
  
## Examples  
 В следующем примере отображается аргументов командной строки для приложения.  
  
 [!code-cpp[Environment.GetCommandLineArgs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CPP/getcommandlineargs.cpp#1)]
 [!code-csharp[Environment.GetCommandLineArgs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CS/getcommandlineargs.cs#1)]
 [!code-vb[Environment.GetCommandLineArgs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetCommandLineArgs/VB/getcommandlineargs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Система не поддерживает аргументы командной строки.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">доступ для чтения к переменной среды PATH. Связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.CommandLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Получение значения переменной среды.</summary>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="variable">Имя переменной среды.</param>
        <summary>Возвращает из текущего процесса значение переменной среды.</summary>
        <returns>Значение переменной среды, заданное параметром <paramref name="variable" /> или значение <see langword="null" />, если переменная среды не найдена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment.GetEnvironmentVariable%28System.String%29> Метод получает переменную среды из текущего процесса только блок среды. Это эквивалентно вызову метода <xref:System.Environment.GetEnvironmentVariable%28System.String%2CSystem.EnvironmentVariableTarget%29> метод с `target` значение <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. Блок среды текущего процесса включает следующие переменные среды:  
  
-   Все для компьютера переменные среды, которые определены во время создания процесса вместе со значениями.  
  
-   Все переменные среды пользователя, которые определены во время процесса создания вместе со значениями.  
  
-   Все переменные, добавляемый блок обработки, пока процесс выполняется с помощью вызова <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> метода или <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> метод с `target` значение <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>.  
  
 Если переменные среды создаются после начала процесса, этот метод можно использовать для получения только те переменные, которые были созданы путем вызова <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> метода или <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> метод с `target` значение.<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>.  
  
 Чтобы получить все переменные среды, а также их значения, вызовите <xref:System.Environment.GetEnvironmentVariables%2A> метод.  
  
 Имена переменных среды не учитывают регистр.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Environment.GetEnvironmentVariable%2A> метод для извлечения `windir` переменной среды, которая содержит путь к каталогу Windows.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 В следующем примере предпринимается для получения значения переменной среды с именем `Test1` из блока среды процесса. Если переменная не существует, в примере создается его и извлекает его значение. Выводится значение переменной. Если пример создания переменной, он вызывает <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> метод с каждым элементом <xref:System.EnvironmentVariableTarget> перечисления для установления того, что переменной можно получить только из текущего процесса блок среды. Наконец Если пример создания переменной, он удаляет его.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="variable" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение для выполнения этой операции.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для обеспечения возможности чтения значения <paramref name="variable" />. Связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String, target As EnvironmentVariableTarget) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable, EnvironmentVariableTarget target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="variable">Имя переменной среды.</param>
        <param name="target">Одно из значений перечисления <see cref="T:System.EnvironmentVariableTarget" />.</param>
        <summary>Возвращает из текущего процесса или раздела реестра операционной системы Windows значение переменной среды для текущего пользователя или локального компьютера.</summary>
        <returns>Значение переменной среды, заданное параметрами <paramref name="variable" /> и <paramref name="target" /> или значение <see langword="null" />, если переменная среды не найдена.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `target` Параметр указывает, является ли переменная среды извлекаются из текущего процесса или раздела реестра операционной системы Windows для текущего пользователя или локального компьютера. Все переменные среды на уровне пользователя и компьютера автоматически копируется в блок среды текущего процесса. Тем не менее переменные среды, добавляемый блок среды текущего процесса сохранения только в течение процесса.  
  
 Чтобы получить все переменные среды, а также их значения, вызовите <xref:System.Environment.GetEnvironmentVariables%2A> метод.  
  
 Имена переменных среды не учитывают регистр.  
  
   
  
## Examples  
 Следующий пример создает переменные среды для целевых объектов процесса, пользователя и компьютера, проверяет ли реестра операционной системы содержит переменные среды пользователя и компьютера, а затем удаляет переменные среды.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="variable" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> не является допустимым значением <see cref="T:System.EnvironmentVariableTarget" />.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение для выполнения этой операции.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для обеспечения возможности чтения значения <paramref name="variable" /> Если <paramref name="target" /> — <see cref="F:System.EnvironmentVariableTarget.Process" /> (соответствующее перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />),  
  
 или  
  
 для полного доступа к переменным среды при <paramref name="target" /> — <see cref="F:System.EnvironmentVariableTarget.User" /> или <see cref="F:System.EnvironmentVariableTarget.Machine" /> (соответствующее перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariables">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает имена всех переменных среды и их значения.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает из текущего процесса имена всех переменных среды и их значения.</summary>
        <returns>Словарь, в котором содержатся имена всех переменных среды и их значения; в противном случае, если переменные среды не найдены, — пустой словарь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Имена и значения переменных среды хранятся в виде пар ключ значение в возвращаемом <xref:System.Collections.IDictionary>.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Environment.GetEnvironmentVariables%2A> метод.  
  
 [!code-cpp[Environment.GetEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CPP/getenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.GetEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CS/getenvironmentvariables.cs#1)]
 [!code-vb[Environment.GetEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetEnvironmentVariables/VB/getenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение для выполнения этой операции.</exception>
        <exception cref="T:System.OutOfMemoryException">Недостаточно памяти буфера.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для возможности чтения имена и значения переменных среды. Связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables (EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables(valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables (target As EnvironmentVariableTarget) As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables(EnvironmentVariableTarget target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="target">Одно из значений перечисления <see cref="T:System.EnvironmentVariableTarget" />.</param>
        <summary>Возвращает из текущего процесса или раздела реестра операционной системы Windows имена и значения всех переменных среды для текущего пользователя или локального компьютера.</summary>
        <returns>Словарь, в котором содержатся имена всех переменных среды и их значения, извлеченные из источника, заданного параметром <paramref name="target" />; в противном случае, если переменные среды не найдены, — пустой словарь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `target` Параметр указывает, является ли источник текущего процесса, раздел реестра для текущего пользователя или раздела реестра для локального компьютера.  
  
 Имена и значения переменных среды хранятся в виде пар ключ/значение в возвращаемом <xref:System.Collections.IDictionary> объекта.  
  
   
  
## Examples  
 Следующий пример создает переменные среды для целевых объектов процесса, пользователя и компьютера, проверяет ли реестра операционной системы содержит переменные среды пользователя и компьютера, а затем удаляет переменные среды.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">У вызывающего оператора нет необходимых разрешений на выполнение этой операции для указанного значения параметра <paramref name="target" />.</exception>
        <exception cref="T:System.ArgumentException">
          Параметр <paramref name="target" /> содержит недопустимое значение.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для возможности чтения имена и значения переменных среды, если <paramref name="target" /> — <see cref="F:System.EnvironmentVariableTarget.Process" /> (соответствующее перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />),  
  
 или  
  
 для полного доступа к переменным среды при <paramref name="target" /> — <see cref="F:System.EnvironmentVariableTarget.User" /> или <see cref="F:System.EnvironmentVariableTarget.Machine" /> (соответствующее перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFolderPath">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает путь к особой системной папке, указанной в заданном перечислении.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" />
      </Parameters>
      <Docs>
        <param name="folder">Перечислимая константа, позволяющая определить особую системную папку.</param>
        <summary>Возвращает путь к особой системной папке, указанной в заданном перечислении.</summary>
        <returns>Путь к указанной особой системной папке, если эта папка физически существует на компьютере; в противном случае — пустая строка ("").  
  
 Папка физически не существует, если она не была создана операционной системой, была удалена или является виртуальным каталогом, таким как "Мой компьютер", которому не сопоставлен физический путь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает путь к особой системной папке, такие как файлы программы, программы, системы или запуска, который может использоваться для доступа к общей информации. По умолчанию специальные папки устанавливаются системой или пользователем, в явном виде при установке версии Windows.  
  
 `folder` Параметр указывает специальную папку для извлечения и должен иметь одно из значений в <xref:System.Environment.SpecialFolder> перечисления; любые другие значения создают исключения.  
  
 Дополнительные сведения о специальных папках см. в разделе [CSIDL](http://go.microsoft.com/fwlink/?LinkId=116664) значения раздела.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование <xref:System.Environment.GetFolderPath%2A> метод для определения и отображения путь, связанный с `folder` параметра.  
  
 [!code-cpp[Environment.GetFolderPath#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetFolderPath/CPP/getfolderpath.cpp#1)]
 [!code-csharp[Environment.GetFolderPath#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetFolderPath/CS/getfolderpath.cs#1)]
 [!code-vb[Environment.GetFolderPath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetFolderPath/VB/getfolderpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Объект <paramref name="folder" /> не является членом <see cref="T:System.Environment.SpecialFolder" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">Текущая платформа не поддерживается.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям в сам путь. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder, Environment.SpecialFolderOption option);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder, valuetype System.Environment/SpecialFolderOption option) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder,System.Environment.SpecialFolderOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder, option As Environment.SpecialFolderOption) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder, Environment::SpecialFolderOption option);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" />
        <Parameter Name="option" Type="System.Environment+SpecialFolderOption" />
      </Parameters>
      <Docs>
        <param name="folder">Перечислимая константа, позволяющая определить особую системную папку.</param>
        <param name="option">Задает параметры, используемые для доступа к особой папке.</param>
        <summary>Возвращает путь к особой системной папке, указанной в заданном перечислении, и использует заданный параметр для доступа к особым папкам.</summary>
        <returns>Путь к указанной особой системной папке, если эта папка физически существует на компьютере; в противном случае — пустая строка ("").  
  
 Папка физически не существует, если она не была создана операционной системой, была удалена или является виртуальным каталогом, таким как "Мой компьютер", которому не сопоставлен физический путь.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает путь к особой системной папке, такие как файлы программы, программы, системы или запуска, который может использоваться для доступа к общей информации. По умолчанию специальные папки устанавливаются системой или пользователем, в явном виде при установке версии Windows.  
  
 `folder` Параметр указывает специальную папку для извлечения и должен иметь одно из значений в <xref:System.Environment.SpecialFolder> перечисления; любые другие значения создают исключения.  
  
 Дополнительные сведения о специальных папках см. в разделе [CSIDL](http://go.microsoft.com/fwlink/?LinkId=116664) значения раздела.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          Объект <paramref name="folder" /> не является элементом <see cref="T:System.Environment.SpecialFolder" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.PlatformNotSupportedException" />
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям в сам путь. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает массив строк, содержащий имена логических дисков текущего компьютера.</summary>
        <returns>Массив строк, в каждом элементе которого содержится имя логического диска. Например, если первым логическим диском является жесткий диск компьютера, первым возвращаемым элементом будет "C:\\".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере показано, как для отображения логических дисков текущего компьютера с помощью <xref:System.Environment.GetLogicalDrives%2A> метод.  
  
 [!code-cpp[Environment.GetLogicalDrives#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetLogicalDrives/CPP/getlogicaldrives.cpp#1)]
 [!code-csharp[Environment.GetLogicalDrives#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetLogicalDrives/CS/getlogicaldrives.cs#1)]
 [!code-vb[Environment.GetLogicalDrives#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetLogicalDrives/VB/getlogicaldrives.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">Ошибка ввода-вывода.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствуют необходимые разрешения.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для полного доступа к ресурсу, защищенному этим разрешением. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public static bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Environment.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool HasShutdownStarted { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, указывающее, выгружается ли текущий домен приложения или среда CLR завершает работу.</summary>
        <value>
          Значение <see langword="true" />, если текущий домен приложения выгружается или среда CLR завершает работу; в противном случае — значение <see langword="false." />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Среда CLR выгрузке домена приложения, запускается методы завершения на все объекты, имеющие метод завершения в этом домене приложения. Когда среда CLR завершает работу, он запускает поток метода завершения на все объекты, имеющие метод завершения. <xref:System.Environment.HasShutdownStarted%2A> Возвращает `true` только после запуска поток метода завершения. Если свойство возвращает `true`, можно определить, является ли домен приложения выгружается или сама среда CLR завершает работу, вызвав <xref:System.AppDomain.IsFinalizingForUnload%2A?displayProperty=nameWithType> метод. Этот метод возвращает `true` Если методы завершения вызываются из-за выгрузки домена приложения или `false` Если среда CLR завершает работу.  
  
 <xref:System.Environment.HasShutdownStarted%2A> Возвращает `false` Если поток метода завершения не был запущен.  
  
 С помощью этого свойства, можно определить, следует ли получить доступ к статическим переменным кода завершения. Если домен приложения или среда CLR завершает работу, может оказаться недоступным любой объект, который имеет метод завершения, и, на который ссылается статическое поле. Это так, как эти объекты могут быть уже завершен.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsFinalizingForUnload" />
      </Docs>
    </Member>
    <Member MemberName="Is64BitOperatingSystem">
      <MemberSignature Language="C#" Value="public static bool Is64BitOperatingSystem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitOperatingSystem" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitOperatingSystem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitOperatingSystem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitOperatingSystem { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет, является ли текущая операционная система 64-разрядной.</summary>
        <value>
          Значение <see langword="true" />, если операционная система является 64-разрядной; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Is64BitProcess">
      <MemberSignature Language="C#" Value="public static bool Is64BitProcess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitProcess" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitProcess As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitProcess { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Определяет, является ли текущий процесс 64-разрядным.</summary>
        <value>
          Значение <see langword="true" />, если процесс является 64-разрядным; в противном случае —значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public static string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает имя NetBIOS данного локального компьютера.</summary>
        <value>Строка, содержащая имя данного компьютера.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Имя этого компьютера устанавливается при запуске системы, при считывании из реестра. Если этот компьютер является узлом кластера, возвращается имя узла.  
  
   
  
## Examples  
 Следующий пример отображает имя компьютера, на котором выполняется пример кода. (Имя компьютера указано в целях безопасности в выходных данных примера.)  
  
 [!code-cpp[environment.machinename#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.MachineName/CPP/machinename.cpp#1)]
 [!code-csharp[environment.machinename#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.MachineName/CS/machinename.cs#1)]
 [!code-vb[environment.machinename#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.MachineName/VB/machinename.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Не удается получить имя этого компьютера.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">доступ для чтения к переменной среды COMPUTERNAME. Связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public static string NewLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.NewLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NewLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ NewLine { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает строку, обозначающую в данной среде начало новой строки.</summary>
        <value>Строка, содержащая "\r\n" для платформ, отличных от Unix, или строка, содержащая "\n" для платформ Unix.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение свойства <xref:System.Environment.NewLine%2A> является константа, настроенная специально для текущей платформы и реализации платформы .NET Framework. Дополнительные сведения об escape-символов в значении свойства см. в разделе [escape-знаки](~/docs/standard/base-types/character-escapes-in-regular-expressions.md).  
  
 Функциональные возможности, предоставляемые <xref:System.Environment.NewLine%2A> часто является определение условий перехода на новую строку, перевод строки, разрыв строки, возврата каретки, CRLF и конец строки.  
  
 <xref:System.Environment.NewLine%2A> можно использовать в сочетании с поддержкой новой строки для конкретного языка, такие как escape-символы '\r' и '\n' в Microsoft C# и C/C++, или `vbCrLf` в Microsoft Visual Basic.  
  
 <xref:System.Environment.NewLine%2A> автоматически добавляется к тексту, обрабатываемых <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> и <xref:System.Text.StringBuilder.AppendLine%2A?displayProperty=nameWithType> методы.  
  
   
  
## Examples  
 В следующем примере отображаются три строки, разделенные знаками новой строки.  
  
 [!code-cpp[environment.newline#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.NewLine/CPP/newline.cpp#1)]
 [!code-csharp[environment.newline#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.NewLine/CS/newline.cs#1)]
 [!code-vb[environment.newline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.NewLine/VB/newline.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OSVersion">
      <MemberSignature Language="C#" Value="public static OperatingSystem OSVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.OperatingSystem OSVersion" />
      <MemberSignature Language="DocId" Value="P:System.Environment.OSVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSVersion As OperatingSystem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property OperatingSystem ^ OSVersion { OperatingSystem ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.OperatingSystem</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.OperatingSystem" />, который содержит идентификатор текущей платформы и номер версии.</summary>
        <value>Объект, который содержит идентификатор платформы и номер версии.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Начиная с Windows 8 <xref:System.Environment.OSVersion%2A> свойство возвращает одинаковые номера основной и дополнительный номера версий для всех платформ Windows. Таким образом что можно получить значение этого свойства, чтобы определить версию операционной системы не рекомендуется.  
  
 Как правило <xref:System.Environment.OSVersion%2A> свойство используется, чтобы убедиться, что приложение работает на некоторые базовые версии операционной системы, в которой был представлен определенную функцию. В случае должен выполнять проверку на версию, проверяя ли возвращаемый текущую версию операционной системы <xref:System.Environment.OSVersion%2A> свойство является одновременно, или больше, чем версию основной операционной системы. Дополнительные сведения см. в разделе <xref:System.Version> разделе, посвященном классу.  
  
 Через Windows 8 <xref:System.Environment.OSVersion%2A> свойство возвращает версии, указанной в Windows [GetVersionEx](http://msdn.microsoft.com/library/windows/desktop/ms724451\(v=vs.85\).aspx) функции. Список версий операционной системы Windows и их соответствующие номера версий см. в разделе [версии операционной системы](https://msdn.microsoft.com/library/windows/desktop/ms724832.aspx) в центре разработчиков Windows.  
  
> [!NOTE]
>  <xref:System.Environment.OSVersion%2A> Свойство возвращает один и тот же номер версии (6.2.0.0) для обоих [!INCLUDE[win8](~/includes/win8-md.md)] и [!INCLUDE[win81](~/includes/win81-md.md)] и тот же номер основной и дополнительный номер версии для Windows 10.  
  
 В некоторых случаях <xref:System.Environment.OSVersion%2A> не может возвратить версию операционной системы, которая соответствует версии, указанной для компонента режима совместимости программ Windows.  
  
   
  
## Examples  
 Следующий пример отображает идентификатор платформы и номер версии сервера, на котором выполняется пример кода.  
  
 [!code-cpp[environment.osversion#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.OSVersion/CPP/osversion.cpp#1)]
 [!code-csharp[environment.osversion#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.OSVersion/CS/osversion.cs#1)]
 [!code-vb[environment.osversion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.OSVersion/VB/osversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Это свойство не смогло получить версию системы.  
  
 - или -  
  
 Полученный идентификатор платформы не является членом <see cref="T:System.PlatformID" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessorCount">
      <MemberSignature Language="C#" Value="public static int ProcessorCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ProcessorCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ProcessorCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProcessorCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ProcessorCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает число процессоров на текущем компьютере.</summary>
        <value>32-битовое целое число со знаком, которое задает количество процессоров на текущем компьютере. Значение по умолчанию отсутствует. Если текущий компьютер содержит несколько групп процессоров, данное свойство возвращает число логических процессоров, доступных для использования средой CLR.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о группах процессоров и логических процессоров см. в разделе [групп процессоров](http://msdn.microsoft.com/library/windows/desktop/dd405503.aspx).  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Environment.ProcessorCount%2A> свойство.  
  
 [!code-cpp[environment.processorcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.processorcount/CPP/pc.cpp#1)]
 [!code-csharp[environment.processorcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.processorcount/CS/pc.cs#1)]
 [!code-vb[environment.processorcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.processorcount/VB/pc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Создает, изменяет или удаляет переменную среды.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="variable">Имя переменной среды.</param>
        <param name="value">Значение, которое необходимо присвоить параметру <c>variable</c>.</param>
        <summary>Создает, изменяет или удаляет переменную среды, хранящуюся в текущем процессе.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода эквивалентен вызову <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> перегрузки со значением <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> для `target` аргумент.  
  
 Если `value` аргумент не является пустым (см. обсуждение удаления переменной среды, далее в этом разделе для определения пустое значение) и именем переменной среды `variable` параметра не существует, среды создается и присваивается содержимое переменной `value`. Это значение изменяется, если он существует. Поскольку в блок среды только текущего процесса определяется переменной среды, он не сохраняется после завершения процесса.  
  
 Если `variable` содержится не начальный шестнадцатеричный символ нуля, символы перед этим нулевым символом, считаются имя переменной среды, и все последующие символы игнорируются.  
  
 Если `value` содержится не начальный шестнадцатеричный символ нуля, символы перед этим нулевым символом присваиваются переменной среды, и все последующие символы игнорируются.  
  
 Если `value` является пустым и переменной среды с именем `variable` существует, удалить переменную среды. Если `variable` не существует, ошибка не происходит, несмотря на то, что не удается выполнить операцию. `value` считается пустым при выполнении любого из следующих условий:  
  
-   Это `null`.  
  
-   Это <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Он состоит из одного символа, значение которого является U + 0000.  
  
   
  
## Examples  
 В следующем примере проверяется, является ли переменная среды с именем `APPDOMAIN` существует в текущем процессе. Если нет, он создает эту службу и задает его значение «True». Если значение `APPDOMAIN` переменной среды: «True», он вызывает метод `Message.Display` метод в новый домен приложения. В противном случае он выполняет `Message.Display` метод в текущем домене приложения.  
  
 [!code-csharp[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/cs/setenvironmentvariable1.cs#1)]
 [!code-vb[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/vb/setenvironmentvariable1.vb#1)]  
  
 При выполнении примера в первый раз сообщение «Выполнение в домене домен2» выводит на консоль. Если значение переменной среды из командной строки с помощью команды:  
  
 `Set AppDomain=False`  
  
 в примере выводится сообщение «выполнение в домене *exeName*.exe», где *exeName* является имя исполняемого файла.  
  
 В следующем примере предпринимается для получения значения переменной среды с именем `Test1` из блока среды процесса. Если переменная не существует, в примере создается переменная и извлекает его значение. Выводится значение переменной. Если пример создания переменной, он вызывает <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> метод с каждым элементом <xref:System.EnvironmentVariableTarget> перечисления для установления того, что переменной можно получить только из текущего процесса блок среды. Наконец Если пример создания переменной, он удаляет его.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="variable" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          В параметре <paramref name="variable" /> содержится строка нулевой длины, начальный шестнадцатеричный символ нуля (0x00) или знак равенства (=).  
  
 - или -  
  
 Длина параметра <paramref name="variable" /> или параметра <paramref name="value" /> больше или равна 32 767 символам.  
  
 - или -  
  
 Во время выполнения этой операции произошла ошибка.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение для выполнения этой операции.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для полного доступа к переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </Member>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String, target As EnvironmentVariableTarget)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value, EnvironmentVariableTarget target);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="variable">Имя переменной среды.</param>
        <param name="value">Значение, которое необходимо присвоить параметру <c>variable</c>.</param>
        <param name="target">Одно из значений перечисления, указывающее местоположение переменной среды.</param>
        <summary>Создает, изменяет или удаляет переменную среды, хранящуюся в текущем процессе или разделе реестра операционной системы Windows, зарезервированном для текущего пользователя или локального компьютера.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> Метод позволяет определять переменную среды, которая доступна для всех процессов, выполняющихся на компьютере ( <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> значение), все процессы выполняются пользователем ( <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> значение), или текущий процесс ( <xref:System.EnvironmentVariableTarget.Process> значение). Переменные для компьютера и пользователя копируется в блок среды текущего процесса. Тем не менее переменные среды, которые являются уникальными для текущего процесса блок среды сохраняются только до завершения процесса.  
  
 Если `value` аргумент не является пустым (см. обсуждение удаления переменной среды, далее в этом разделе для определения пустое значение) и именем переменной среды `variable` параметра не существует, среды создается и присваивается содержимое переменной `value`.  Это значение изменяется, если он существует.  
  
 Если `variable` содержится не начальный шестнадцатеричный символ нуля, символы перед этим нулевым символом, считаются имя переменной среды, и все последующие символы игнорируются.  
  
 Если `value` содержится не начальный шестнадцатеричный символ нуля, символы перед этим нулевым символом присваиваются переменной среды, и все последующие символы игнорируются.  
  
 Если `value` является пустым и переменной среды с именем `variable` существует, удалить переменную среды. `value` считается пустым при выполнении любого из следующих условий:  
  
-   Это `null`.  
  
-   Это <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Он состоит из одного символа, значение которого является U + 0000.  
  
 Если `variable` не существует, ошибка не происходит, несмотря на то, что не удается выполнить операцию. Будьте осторожны при `target` является <xref:System.EnvironmentVariableTarget.Machine>, поскольку можно случайно удалить переменную среды, влияет на весь локальный компьютер, не только текущий процесс или пользователь.  
  
 Если `target` — <xref:System.EnvironmentVariableTarget.User>, переменная среды хранится в реестре локального компьютера в разделе hkey_current_user\environment. Кроме того, он копируется в экземпляры проводника, которые работают как текущего пользователя. Переменная среды затем наследуется любым новым процессом, который запускается пользователем из проводника.  
  
 Аналогично Если `target` — <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, переменная среды хранится в HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment ключ реестра локального компьютера. Кроме того, он копируется в все экземпляры проводника. Переменная среды затем наследуется любым новым процессам, которые запускаются из проводника.  
  
 Если `target` — <xref:System.EnvironmentVariableTarget.User> или <xref:System.EnvironmentVariableTarget.Machine>, другие приложения получают уведомления операции задания по Windows `WM_SETTINGCHANGE` сообщения.  
  
 Если `target` — <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> или <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, рекомендуется, чтобы длина `value` меньше 2048 знаков.  
  
   
  
## Examples  
 В следующем примере создается переменная среды для <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>, <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>, и <xref:System.EnvironmentVariableTarget.Machine> обращается, проверяет ли реестра операционной системы содержит пользователей и переменные окружения на машине, а затем удаляет среду переменные.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="variable" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          В параметре <paramref name="variable" /> содержится строка нулевой длины, начальный шестнадцатеричный символ нуля (0x00) или знак равенства (=).  
  
 - или -  
  
 Длина параметра <paramref name="variable" /> больше или равна 32 767 символам.  
  
 - или -  
  
 Параметр <paramref name="target" /> не является элементом перечисления <see cref="T:System.EnvironmentVariableTarget" />.  
  
 - или -  
  
 Значение параметра <paramref name="target" /> равно <see cref="F:System.EnvironmentVariableTarget.Machine" /> или <see cref="F:System.EnvironmentVariableTarget.User" />, а длина параметра <paramref name="variable" /> больше или равна 255.  
  
 - или -  
  
 Значение параметра <paramref name="target" /> равно <see cref="F:System.EnvironmentVariableTarget.Process" />, а длина параметра <paramref name="value" /> больше или равна 32 767 символам.  
  
 - или -  
  
 Во время выполнения этой операции произошла ошибка.</exception>
        <exception cref="T:System.Security.SecurityException">У вызывающего объекта отсутствует необходимое разрешение для выполнения этой операции.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для полного доступа к переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public static string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Environment.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает текущие сведения о трассировке стека.</summary>
        <value>Строка, содержащая сведения о трассировке стека. Это значение может быть равно <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment.StackTrace%2A> Свойства перечисляет вызовы метода в обратном хронологическом порядке, то есть, самый последний вызов метода описывается первым одну строку сведений о трассировке стека в списке, а для каждого вызова метода в стеке. Однако <xref:System.Environment.StackTrace%2A> свойство может не сообщить столько предполагаемых вызовах методов из-за преобразований кода в процессе оптимизации.  
  
> [!NOTE]
>  Иерархическое представление сведений о трассировке стека в классе, используйте <xref:System.Diagnostics.StackTrace> класса.  
  
 <xref:System.Environment.StackTrace%2A> Свойство форматирует сведения о трассировке стека для каждого вызова метода следующим образом:  
  
 «в `FullClassName`.`MethodName` (`MethodParams`) в `FileName` : строки `LineNumber` »  
  
 Литералу «at» предшествуют три пробела, а вся подстрока, начиная с «в» пропускаются, если символы отладки недоступны. Заполнители, `FullClassName`, `MethodName`, `MethodParams`, `FileName`, и `LineNumber`, заменяются фактическими значениями и определяется следующим образом:  
  
 FullClassName  
 Полное имя класса, включая пространство имен.  
  
 `MethodName`  
 Имя метода.  
  
 `MethodParams`  
 Список пар имен и типов параметров. Каждая пара отделяется запятой («,»). Эти сведения указывается, если `MethodName` не принимает никаких параметров.  
  
 `FileName`  
 Имя исходного файла where `MethodName` объявлен метод. Эти сведения пропускаются, если символы отладки недоступны.  
  
 `LineNumber`  
 Номер строки в `FileName` , содержащий исходный код из `MethodName` для инструкции в стеке вызовов. Эти сведения пропускаются, если символы отладки недоступны.  
  
 <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> Строка завершает каждой строки трассировки стека.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Environment.StackTrace%2A> свойство.  
  
 [!code-cpp[environment.stacktrace#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.StackTrace/CPP/stacktrace.cpp#1)]
 [!code-csharp[environment.stacktrace#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.StackTrace/CS/stacktrace.cs#1)]
 [!code-vb[environment.stacktrace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.StackTrace/VB/stacktrace.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для полного доступа к ресурсу, защищенному с помощью разрешений. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemDirectory">
      <MemberSignature Language="C#" Value="public static string SystemDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string SystemDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SystemDirectory { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает полный путь к системному каталогу.</summary>
        <value>Строка, содержащая путь к каталогу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пример возвращаемого значения является строка «C:\WinNT\System32».  
  
   
  
## Examples  
 Следующий пример отображает каталог системы компьютера, на котором выполняется пример кода. (В системном каталоге опущен в целях безопасности в выходных данных примера.)  
  
 [!code-cpp[environment.systemdirectory#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.SystemDirectory/CPP/systemdirectory.cpp#1)]
 [!code-csharp[environment.systemdirectory#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.SystemDirectory/CS/systemdirectory.cs#1)]
 [!code-vb[environment.systemdirectory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.SystemDirectory/VB/systemdirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям в сам путь. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemPageSize">
      <MemberSignature Language="C#" Value="public static int SystemPageSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 SystemPageSize" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemPageSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemPageSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int SystemPageSize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает количество байтов на странице памяти операционной системы.</summary>
        <value>Количество в байтах в странице памяти системы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эти сведения можно использовать при определении того использовать <xref:System.IO.MemoryMappedFiles.MemoryMappedFileOptions.DelayAllocatePages?displayProperty=nameWithType> параметр при работе с файлами, размещенный в памяти.  
  
 В Windows, это значение является `dwPageSize` члена в `SYSTEM_INFO` структуры.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для доступа к системным и пользовательским переменным среды. Связанные исключения:  
  
 <see cref="P:System.Security.SecurityException.PermissionState" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TickCount">
      <MemberSignature Language="C#" Value="public static int TickCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 TickCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.TickCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TickCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int TickCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает время, истекшее с момента загрузки системы (в миллисекундах).</summary>
        <value>32-битовое целое число со знаком, содержащее время, истекшее с момента с последней загрузки системы (в миллисекундах).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этого свойства является производным от системного таймера и хранится в виде 32-разрядное целое число со знаком. Обратите внимание, что, поскольку он является производным от системного таймера, разрешение <xref:System.Environment.TickCount%2A> свойство ограничено до разрешения системного таймера, которое обычно находится в диапазоне от 10 до 16 миллисекунд.  
  
> [!IMPORTANT]
>  Так как значение <xref:System.Environment.TickCount%2A> значение свойства равно 32-разрядное целое число со знаком, если система работает непрерывно, <xref:System.Environment.TickCount%2A> приводит к увеличению от нуля до <xref:System.Int32.MaxValue?displayProperty=nameWithType> приблизительно 24,9 дней, затем перейти к <xref:System.Int32.MinValue?displayProperty=nameWithType>, который является отрицательным числом, затем увеличьте до нуля в течение следующих 24,9 дней. Эту проблему можно обойти, вызвав Windows [GetTickCount](https://msdn.microsoft.com/library/windows/desktop/ms724408.aspx) функции, которая обнуляется приблизительно дней или вызвав [GetTickCount64](https://msdn.microsoft.com/library/windows/desktop/ms724411.aspx) функции.  
  
 <xref:System.Environment.TickCount%2A> отличается от <xref:System.DateTime.Ticks%2A?displayProperty=nameWithType> свойство, которое представляет количество 100-наносекундных интервалов, прошедших с 1/1/0001 12:00 am.  
  
 Используйте <xref:System.DateTime.Now%2A?displayProperty=nameWithType> свойство для получения текущей локальной даты и времени на этом компьютере.  
  
   
  
## Examples  
 Ниже приведен пример, как получить положительный диапазон значений, возвращаемых <xref:System.Environment.TickCount%2A> свойство. <xref:System.Environment.TickCount%2A> Свойство циклически переключается между <xref:System.Int32.MinValue?displayProperty=nameWithType>, который является отрицательным числом, и <xref:System.Int32.MaxValue?displayProperty=nameWithType> раз 49.8 дней. Этот пример кода удаляет бит знака для получения неотрицательное число, в котором с нуля и <xref:System.Int32.MaxValue> раз 24,9 дней.  
  
 [!code-cpp[environment.tickcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.TickCount/CPP/tickcount.cpp#1)]
 [!code-csharp[environment.tickcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.TickCount/CS/tickcount.cs#1)]
 [!code-vb[environment.tickcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.TickCount/VB/tickcount.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserDomainName">
      <MemberSignature Language="C#" Value="public static string UserDomainName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserDomainName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserDomainName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserDomainName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserDomainName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает имя сетевого домена, связанное с текущим пользователем.</summary>
        <value>Имя сетевого домена, связанное с текущим пользователем.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Учетные данные учетной записи домена для пользователя в формате имени пользователя домена, "\\" символ, а имя пользователя. Используйте <xref:System.Environment.UserDomainName%2A> , чтобы получить имя пользователя домена без указания имени пользователя и <xref:System.Environment.UserName%2A> , чтобы получить имя пользователя без имени домена.  Например, если имя пользователя и имя домена пользователя, CORPORATENETWORK\john <xref:System.Environment.UserDomainName%2A> свойство возвращает «CORPORATENETWORK».  
  
 <xref:System.Environment.UserDomainName%2A> Свойство сначала пытается получить компонент имени домена, имя учетной записи Windows текущего пользователя. Если попытка не удалась, это свойство пытается получить доменного имени, связанного с именем пользователя, предоставляемый <xref:System.Environment.UserName%2A> свойство. Если попытка не удалась, поскольку компьютер не присоединен к домену, то возвращается имя главного компьютера.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Операционная система не поддерживает получение имени сетевого домена.</exception>
        <exception cref="T:System.InvalidOperationException">Не удалось получить имя сетевого домена.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">доступ для чтения к переменной среды USERDOMAIN. Связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserName" />
      </Docs>
    </Member>
    <Member MemberName="UserInteractive">
      <MemberSignature Language="C#" Value="public static bool UserInteractive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UserInteractive" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserInteractive" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserInteractive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UserInteractive { bool get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает значение, позволяющее определить, выполняется ли текущий процесс в режиме взаимодействия с пользователем.</summary>
        <value>
          Значение <see langword="true" />, если текущий процесс выполняется в режиме взаимодействия с пользователем; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment.UserInteractive%2A> Отчетов о свойствах `false` для процесса Windows или в службу, например IIS, который выполняется без пользовательского интерфейса. Если это свойство имеет `false`, не отображать модальные диалоговые окна или сообщения окнам в средах, так как нет графического интерфейса пользователя для взаимодействия с.  
  
   
  
## Examples  
 В следующем примере отображается ли текущий процесс выполняется в режиме взаимодействия с пользователем.  
  
 [!code-cpp[Environment.UserInteractive#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserInteractive/CPP/userinteractive.cpp#1)]
 [!code-csharp[Environment.UserInteractive#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserInteractive/CS/userinteractive.cs#1)]
 [!code-vb[Environment.UserInteractive#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserInteractive/VB/userinteractive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UserName">
      <MemberSignature Language="C#" Value="public static string UserName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает имя пользователя, который на данный момент выполнил вход в операционную систему Windows.</summary>
        <value>Имя пользователя, который на данный момент выполнил вход в операционную систему Windows.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать <xref:System.Environment.UserName%2A> свойство для идентификации пользователя в текущем потоке для системы и приложений в целях безопасности или доступа. Он также может использоваться для настройки данного приложения для каждого пользователя.  
  
 <xref:System.Environment.UserName%2A> Свойство создает оболочку для вызова функции Windows [GetUserName](http://msdn.microsoft.com/library/windows/desktop/ms724432.aspx) функции. Учетные данные учетной записи домена для пользователя в формате имени пользователя домена, "\\" символ, а имя пользователя. Используйте <xref:System.Environment.UserDomainName%2A> , чтобы получить имя пользователя домена и <xref:System.Environment.UserName%2A> , чтобы получить имя пользователя.  
  
 Если приложение ASP.NET выполняется в среде разработки, <xref:System.Environment.UserName%2A> свойство возвращает имя текущего пользователя. В опубликованном в приложении ASP.NET это свойство возвращает имя учетной записи пула приложений (например, пул приложений по умолчанию).  
  
   
  
## Examples  
 Следующий пример отображает имя пользователя, запустившего текущий поток.  
  
 [!code-cpp[Environment.UserName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserName/CPP/username.cpp#1)]
 [!code-csharp[Environment.UserName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserName/CS/username.cs#1)]
 [!code-vb[Environment.UserName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserName/VB/username.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">доступ для чтения к переменной среды USERNAME. Связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserDomainName" />
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public static Version Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Version" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Version As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Version ^ Version { Version ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объект <see cref="T:System.Version" />, который описывает основной и дополнительный номера, а также номер построения и редакции среды CLR.</summary>
        <value>Объект, содержащий версию среды CLR.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для платформы .NET Framework версий 4, 4.5, 4.5.1 и 4.5.2 свойство <xref:System.Environment.Version%2A?displayProperty=nameWithType> возвращает объект <xref:System.Version>, строковое представление которого имеет форму `4.0.30319.xxxxx`. .NET Framework 4.6 и более поздних версиях, имеет форму `4.0.30319.42000`.  
  
> [!WARNING]
>  Для [!INCLUDE[net_v45](~/includes/net-v45-md.md)] и более поздней версии, не рекомендуется использовать <xref:System.Environment.Version%2A> свойства для определения версии среды выполнения; вместо этого можно определить версию среды common language runtime путем отправки запроса в реестр. Дополнительные сведения см. в разделе [как: определение .NET Framework версий установленных](~/docs/framework/migration-guide/how-to-determine-which-versions-are-installed.md).  
  
 Дополнительные сведения о версии общеязыковой среды выполнения, которая устанавливается с каждой версией платформы .NET Framework см. в разделе [версии и зависимости](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 Следующий пример отображает версию среды common language runtime. (Версия указана в выходных данных примера по соображениям безопасности).  
  
 [!code-cpp[Environment.Version#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.Version/CPP/version.cpp#1)]
 [!code-csharp[Environment.Version#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.Version/CS/version.cs#1)]
 [!code-vb[Environment.Version#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.Version/VB/version.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public static long WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Environment.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property WorkingSet As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long WorkingSet { long get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает объем физической памяти, сопоставленной контексту процесса.</summary>
        <value>Целое 64-битовое число со знаком, содержащее число байтов физической памяти, сопоставленное контексту процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Следующий пример отображает размер рабочего набора компьютера, на котором выполняется пример кода.  
  
 [!code-cpp[Environment.WorkingSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.WorkingSet/CPP/workingset.cpp#1)]
 [!code-csharp[Environment.WorkingSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.WorkingSet/CS/workingset.cs#1)]
 [!code-vb[Environment.WorkingSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.WorkingSet/VB/workingset.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для полного доступа к ресурсу, защищенному этим разрешением. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>