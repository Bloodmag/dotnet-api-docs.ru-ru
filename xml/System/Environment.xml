<Type Name="Environment" FullName="System.Environment">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="ee38aecf8b92514f99bd30fc6610189253e474c8" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37729412" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Environment" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Environment extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Environment" />
  <TypeSignature Language="VB.NET" Value="Public Class Environment" />
  <TypeSignature Language="C++ CLI" Value="public ref class Environment abstract sealed" />
  <TypeSignature Language="F#" Value="type Environment = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Provides information about, and means to manipulate, the current environment and platform. This class cannot be inherited.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.Environment> класса для извлечения сведения, такие как аргументы командной строки, код выхода, параметров переменных среды, содержимое стека вызовов, времени с момента последней загрузки системы и версии среды CLR.  
  
   
  
## Examples  
 В следующем примере показано отображение списка сведений о текущей среде.  
  
 [!code-cpp[environment.class#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.class/CPP/env0.cpp#1)]
 [!code-csharp[environment.class#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.class/CS/env0.cs#1)]
 [!code-vb[environment.class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.class/VB/env0.vb#1)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="CommandLine">
      <MemberSignature Language="C#" Value="public static string CommandLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string CommandLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CommandLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CommandLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CommandLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CommandLine : string" Usage="System.Environment.CommandLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the command line for this process.</summary>
        <value>Строка, содержащая аргументы командной строки.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Это свойство предоставляет доступ к имени программы и все аргументы, указанные в командной строке, когда текущий процесс был запущен.  
  
 Имя программы может включать сведения о пути, но не требуется, чтобы сделать это. Используйте <xref:System.Environment.GetCommandLineArgs%2A> метод для извлечения сведений командной строки, синтаксический анализ и хранятся в массив строк.  
  
 Максимальный размер буфера командной строки не присваивается определенное количество символов; Это зависит от операционной системы Windows, на котором выполняется на компьютере.  
  
   
  
## Examples  
 В следующем примере отображается в отдельной командной строке.  
  
 [!code-cpp[environment.commandline#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.CommandLine/CPP/commandline.cpp#1)]
 [!code-csharp[environment.commandline#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.CommandLine/CS/commandline.cs#1)]
 [!code-vb[environment.commandline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.CommandLine/VB/commandline.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">доступ на чтение к переменной среды PATH. Связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetCommandLineArgs" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDirectory">
      <MemberSignature Language="C#" Value="public static string CurrentDirectory { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property string CurrentDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ CurrentDirectory { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDirectory : string with get, set" Usage="System.Environment.CurrentDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the fully qualified path of the current working directory.</summary>
        <value>Строка, содержащая путь к каталогу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 По определению, если этот процесс начинается в корневом каталоге локального или сетевого диска, значение этого свойства является имя диска, следуют косой чертой (например, «C:\\«). Если этот процесс запускается в подкаталоге, значение этого свойства является диска и путь без косой чертой (например, «C:\mySubDirectory»).  
  
   
  
## Examples  
 В следующем примере показано задание <xref:System.Environment.CurrentDirectory%2A> свойство.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Attempted to set to an empty string ("").</exception>
        <exception cref="T:System.ArgumentNullException">Attempted to set to <see langword="null." /></exception>
        <exception cref="T:System.IO.IOException">An I/O error occurred.</exception>
        <exception cref="T:System.IO.DirectoryNotFoundException">Attempted to set a local path that cannot be found.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the appropriate permission.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для записи к файлам или каталогам в наборе операций. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям, включенным в путь в операции get. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentManagedThreadId">
      <MemberSignature Language="C#" Value="public static int CurrentManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 CurrentManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Environment.CurrentManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int CurrentManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentManagedThreadId : int" Usage="System.Environment.CurrentManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a unique identifier for the current managed thread.</summary>
        <value>Целочисленное значение, представляющее уникальный идентификатор для этого управляемого потока.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (int exitCode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(int32 exitCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.Exit(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (exitCode As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(int exitCode);" />
      <MemberSignature Language="F#" Value="static member Exit : int -&gt; unit" Usage="System.Environment.Exit exitCode" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exitCode" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="exitCode">The exit code to return to the operating system. Use 0 (zero) to indicate that the process completed successfully.</param>
        <summary>Terminates this process and returns an exit code to the operating system.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для `exitCode` параметр, используйте ненулевое число для указания ошибки. В приложении можно определить собственные коды ошибок в перечислении и возвращают соответствующий код ошибки на основе сценария. Например возвращают значение 1, чтобы указать, что требуемый файл отсутствует и значение 2, чтобы указать, что файл находится в неверном формате. Список кодов выхода, используемый операционной системой Windows, см. в разделе [коды системных ошибок](http://msdn.microsoft.com/library/ms681381.aspx) в документации по Windows.  
  
 Вызов <xref:System.Environment.Exit%2A> метод отличается от на языке программирования `return` инструкции следующим образом:  
  
-   <xref:System.Environment.Exit%2A> всегда завершает работу приложения. С помощью `return` инструкция может завершить приложение только в том случае, если используется в точке входа приложения, такие как в `Main` метод.  
  
-   <xref:System.Environment.Exit%2A> завершает приложение немедленно, даже если работают другие потоки. Если `return` в точку входа приложения вызывается инструкция, это вызывает приложение завершить работу, только в том случае, когда завершены все основные потоки.  
  
-   <xref:System.Environment.Exit%2A> вызывающая программа должна иметь разрешение на вызов неуправляемого кода. `return` Инструкция не поддерживает.  
  
-   Если <xref:System.Environment.Exit%2A> вызывается из `try` или `catch` блока кода в любом `finally` блок не выполняется. Если `return` используется инструкция, код в `finally` блок выполнения.  
  
-   Если <xref:System.Environment.Exit%2A> вызывается, когда код в [область ограниченного выполнения](~/docs/framework/performance/constrained-execution-regions.md) запущена (CER), CER не завершится выполнение. Если `return` используется инструкция, CER завершает выполнение.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The caller does not have sufficient security permission to perform this function.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="ExitCode">
      <MemberSignature Language="C#" Value="public static int ExitCode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ExitCode" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ExitCode" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property ExitCode As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ExitCode { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ExitCode : int with get, set" Usage="System.Environment.ExitCode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets the exit code of the process.</summary>
        <value>32-битовое целое число со знаком, содержащее код выхода. Значение по умолчанию 0 (нуль), что соответствует успешно выполненному процессу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `Main` возвращает метод `void`, это свойство позволяет задать код выхода, который возвращается вызывающей среде. Если `Main` не возвращает `void`, это свойство учитывается. Начальное значение этого свойства равно нулю.  
  
> [!WARNING]
>  <xref:System.Environment.ExitCode%2A> Свойство является 32-битового знакового целого числа. Чтобы запретить свойство возвращать код выхода отрицательное, не следует использовать значения больше или равно 0x80000000.  
  
 Используйте ненулевое число для указания ошибки. В приложении можно определить собственные коды ошибок в перечислении и возвращают соответствующий код ошибки на основе сценария. Например возвращают значение 1, чтобы указать, что требуемый файл отсутствует и значение 2, чтобы указать, что файл находится в неверном формате. Список кодов выхода, используемый операционной системой Windows, см. в разделе [коды системных ошибок](http://msdn.microsoft.com/library/ms681381\(v=vs.85\)) в документации по Windows.  
  
   
  
## Examples  
 Вот простое приложение с именем Double.exe, удваивает значение типа integer, переданного в качестве аргумента командной строки. Коды ошибок для назначает значение <xref:System.Environment.ExitCode%2A> свойства для описания ошибок. Обратите внимание на то, что необходимо добавить ссылку на сборку System.Numerics.dll, чтобы успешно скомпилировать этот пример.  
  
 [!code-csharp[System.Environment.ExitCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double.cs#1)]
 [!code-vb[System.Environment.ExitCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double.vb#1)]  
  
 Пример может быть вызвана из пакетного файла, как указано ниже, в результате чего становится доступным его коды ошибок с помощью `ERRORLEVEL` команды.  
  
```  
  
echo off  
Double.exe %1  
If errorlevel 1639 goto NoArg   
if errorlevel 534 goto Overflow  
if errorlevel 160 goto BadArg  
if errorlevel 0 echo Completed Successfully   
goto :EOF  
  
:NoArg  
echo Missing argument  
goto :EOF  
  
: Overflow  
echo Arithmetic overflow  
goto :EOF  
  
:BadArg  
echo Invalid argument  
goto :EOF  
  
```  
  
 Ниже показано несколько примеров выходных данных, полученных при вызове пакетный файл.  
  
```Output  
  
>getdouble 123>echo offResult: 246Completed Successfully>getdouble 5912323109093>echo offArithmetic overflow>getdouble>echo offMissing argument>getdouble "a string">echo offInvalid argument  
  
```  
  
 Обратите внимание, что код Double.exe идентична в функции в следующем примере, за исключением того, что первое из них определяет точку входа с именем `Main` , не имеет возвращаемого значения, тогда как в этом примере определяет точку входа с именем `Main` , возвращает целое число.  
  
 [!code-csharp[System.Environment.ExitCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.exitcode/cs/double1.cs#2)]
 [!code-vb[System.Environment.ExitCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.exitcode/vb/double1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExpandEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static string ExpandEnvironmentVariables (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string ExpandEnvironmentVariables(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.ExpandEnvironmentVariables(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ExpandEnvironmentVariables (name As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ ExpandEnvironmentVariables(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member ExpandEnvironmentVariables : string -&gt; string" Usage="System.Environment.ExpandEnvironmentVariables name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">A string containing the names of zero or more environment variables. Each environment variable is quoted with the percent sign character (%).</param>
        <summary>Replaces the name of each environment variable embedded in the specified string with the string equivalent of the value of the variable, then returns the resulting string.</summary>
        <returns>A string with each environment variable replaced by its value.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 COM-взаимодействия используется для извлечения переменных среды из операционной системы. Если переменные среды не извлекаются из-за ошибки COM, HRESULT, выясните причину сбоя используется для создания одного из нескольких возможных исключений; то есть исключение зависит от значения HRESULT. Дополнительные сведения о том, как обрабатывается значение HRESULT, см. в разделе "Примечания" <xref:System.Runtime.InteropServices.Marshal.ThrowExceptionForHR%2A?displayProperty=nameWithType> метод.  
  
 Замена происходит только для переменных среды, которые заданы. Например, предположим, что `name` является «MyENV = % MyENV %». Если переменной среды MyENV имеет значение 42, этот метод возвращает «MyENV = 42». Если MyENV не задано, изменений не происходит; Этот метод возвращает «MyENV = % MyENV %».  
  
 Размер возвращаемого значения ограничен 32 КБ.  
  
   
  
## Examples  
 Приведенный ниже показано, как получить системный диск и системные переменные корневой.  
  
 [!code-cpp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CPP/expandenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/CS/expandenvironmentvariables.cs#1)]
 [!code-vb[Environment.ExpandEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.ExpandEnvironmentVariables/VB/expandenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="name" /> is <see langword="null" />.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для возможности доступа к переменным среды в <paramref name="name" />. Связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="FailFast">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Immediately terminates a process after writing a message to the Windows Application event log, and then includes the message and optional exception information in error reporting to Microsoft.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FailFast (message As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message);" />
      <MemberSignature Language="F#" Value="static member FailFast : string -&gt; unit" Usage="System.Environment.FailFast message" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="message">A message that explains why the process was terminated, or <see langword="null" /> if no explanation is provided.</param>
        <summary>Immediately terminates a process after writing a message to the Windows Application event log, and then includes the message in error reporting to Microsoft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод завершает процесс без запуска все активные `try` / `finally` блоки и методы завершения.  
  
 <xref:System.Environment.FailFast%2A> Метод записи `message` строки в журнале событий приложений Windows создает дамп приложения и затем прекращает работу текущего процесса. `message` Строка также включается в ошибках в корпорацию Майкрософт.  
  
 Используйте <xref:System.Environment.FailFast%2A> вместо метода <xref:System.Environment.Exit%2A> метод для завершения работы вашего приложения, поврежденного состояния приложения после восстановления и выполнение приложения `try` / `finally` блоки и методы завершения приведет к повреждению ресурсов программы.  
  
 Сведения передаются в корпорацию Майкрософт с помощью отчетов об ошибках Windows. Дополнительные сведения см. в разделе [отчеты об ошибках Windows: Приступая к работе](http://msdn.microsoft.com/library/windows/hardware/dn641144.aspx).  
  
   
  
## Examples  
 В следующем примере осуществляется запись в журнал событий приложений Windows и прекращает выполнение текущего процесса.  
  
 [!code-csharp[environment.FailFast#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.FailFast/cs/ff.cs#1)]
 [!code-vb[environment.FailFast#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.FailFast/vb/ff.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="FailFast">
      <MemberSignature Language="C#" Value="public static void FailFast (string message, Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FailFast(string message, class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.FailFast(System.String,System.Exception)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FailFast(System::String ^ message, Exception ^ exception);" />
      <MemberSignature Language="F#" Value="static member FailFast : string * Exception -&gt; unit" Usage="System.Environment.FailFast (message, exception)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="message" Type="System.String" />
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="message">A message that explains why the process was terminated, or <see langword="null" /> if no explanation is provided.</param>
        <param name="exception">An exception that represents the error that caused the termination. This is typically the exception in a <see langword="catch" /> block.</param>
        <summary>Immediately terminates a process after writing a message to the Windows Application event log, and then includes the message and exception information in error reporting to Microsoft.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод завершает процесс без запуска все активные `try` / `finally` блоки и методы завершения.  
  
 <xref:System.Environment.FailFast%2A> Метод записи `message` строки в журнале событий приложений Windows создает дамп приложения и затем прекращает работу текущего процесса.  
  
 Сведения передаются в корпорацию Майкрософт с помощью отчетов об ошибках Windows. Дополнительные сведения см. в разделе [отчеты об ошибках Windows: Приступая к работе](http://msdn.microsoft.com/library/windows/hardware/dn641144.aspx). Ошибка в корпорацию Майкрософт содержит `message` и `exception` сведения, возвращающие подробные сведения, используемые для классификации ошибки. Несмотря на то что `exception` является не обработано, так как процесс завершается, контекстные сведения, который вызвал исключение по-прежнему получается.  
  
 Если `exception` — `null`, или если `exception` — не исключение, этот метод работает так же, как <xref:System.Environment.FailFast%28System.String%29> перегрузки метода.  
  
 Используйте <xref:System.Environment.FailFast%2A> вместо метода <xref:System.Environment.Exit%2A> метод для завершения работы вашего приложения, поврежденного состояния приложения после восстановления и выполнение приложения `try` / `finally` блоки и методы завершения приведет к повреждению ресурсов программы.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">Требует полного доверия для непосредственного вызывающего объекта. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="GetCommandLineArgs">
      <MemberSignature Language="C#" Value="public static string[] GetCommandLineArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetCommandLineArgs() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetCommandLineArgs" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCommandLineArgs () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetCommandLineArgs();" />
      <MemberSignature Language="F#" Value="static member GetCommandLineArgs : unit -&gt; string[]" Usage="System.Environment.GetCommandLineArgs " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns a string array containing the command-line arguments for the current process.</summary>
        <returns>An array of string where each element contains a command-line argument. The first element is the executable file name, and the following zero or more elements contain the remaining command-line arguments.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Первый элемент в массиве содержит имя файла выполняемой программе. Если имя файла не доступен, первый элемент равен <xref:System.String.Empty?displayProperty=nameWithType>. Остальные элементы содержат все дополнительные лексемы, введенные в командной строке.  
  
 Имя файла программы можно, но не требуется, включают сведения о пути.  
  
 Аргументы командной строки разделяются пробелами. Чтобы добавить пробелы в аргумент можно использовать двойные кавычки (""). Тем не менее, одинарной кавычки ('), не предоставляет такой возможности.  
  
 Если двойная кавычка за два или четного числа символов обратной косой черты, каждая последующая пара заменяется одной обратной косой чертой, а двойная кавычка удаляется. Если двойная кавычка за нечетного числа символов обратной косой черты, включая одну, каждая предыдущая пара заменяется одну обратную косую черту и оставшихся косых удаляется; Однако в этом случае двойная кавычка не удаляется.  
  
 В следующей таблице показано, как аргументы командной строки могут быть с разделителями и предполагается, что `MyApp` как текущего выполняемого приложения.  
  
|Введите в командной строке|Результирующие аргументы командной строки|  
|-------------------------------|--------------------------------------|  
|`MyApp alpha beta`|`MyApp, alpha, beta`|  
|`MyApp "alpha with spaces" "beta with spaces"`|`MyApp, alpha with spaces, beta with spaces`|  
|`MyApp 'alpha with spaces' beta`|`MyApp, 'alpha, with, spaces', beta`|  
|`MyApp \\\alpha \\\\"beta`|`MyApp, \\\alpha, \\beta`|  
|`MyApp \\\\\"alpha \"beta`|`MyApp, \\"alpha, "beta`|  
  
 Для получения командной строки в виде одной строки, используйте <xref:System.Environment.CommandLine%2A> свойство.  
  
   
  
## Examples  
 Следующий пример отображает аргументы командной строки приложения.  
  
 [!code-cpp[Environment.GetCommandLineArgs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CPP/getcommandlineargs.cpp#1)]
 [!code-csharp[Environment.GetCommandLineArgs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetCommandLineArgs/CS/getcommandlineargs.cs#1)]
 [!code-vb[Environment.GetCommandLineArgs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetCommandLineArgs/VB/getcommandlineargs.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">The system does not support command-line arguments.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">доступ на чтение к переменной среды PATH. Связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.CommandLine" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retrieves the value of an environment variable.</summary>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string -&gt; string" Usage="System.Environment.GetEnvironmentVariable variable" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="variable">The name of the environment variable.</param>
        <summary>Retrieves the value of an environment variable from the current process.</summary>
        <returns>The value of the environment variable specified by <paramref name="variable" />, or <see langword="null" /> if the environment variable is not found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment.GetEnvironmentVariable%28System.String%29> Метод позволяет получить переменную среды из текущего процесса только блок среды. Он эквивалентен вызову <xref:System.Environment.GetEnvironmentVariable%28System.String%2CSystem.EnvironmentVariableTarget%29> метод с `target` значение <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>. Блок среды текущего процесса включает следующие переменные среды:  
  
-   Все на уровне компьютера переменные среды, которые определены во время создания процесса вместе со значениями.  
  
-   Все переменные среды пользователя, которые определены во время процесса создания вместе со значениями.  
  
-   Любой переменным, добавленным в блок process, пока процесс выполняется с помощью вызова <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> метод или <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> метод с `target` значение <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>.  
  
 Если переменные среды создаются после запуска процесса, этот метод можно использовать для получения только те переменные, которые были созданы путем вызова <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%29> метод или <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> метод с `target` значение.<xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>.  
  
 Чтобы получить все переменные среды, а также их значения, вызовите <xref:System.Environment.GetEnvironmentVariables%2A> метод.  
  
 Имена переменных среды не учитывается.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Environment.GetEnvironmentVariable%2A> метод для извлечения `windir` переменной среды, которая содержит путь к каталогу Windows.  
  
 [!code-cpp[System.Environment#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Environment/CPP/Vars1.cpp#4)]
 [!code-csharp[System.Environment#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Environment/CS/Vars1.cs#4)]
 [!code-vb[System.Environment#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Environment/VB/Vars1.vb#4)]  
  
 В следующем примере предпринимается для получения значения переменной среды с именем `Test1` из процесса блок среды. Если переменная не существует, в примере создается его и извлекает его значение. Выводится значение переменной. Если пример создания переменной, он вызывает <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> метод с каждым членом <xref:System.EnvironmentVariableTarget> перечисления для установления того, что переменной можно получить только из текущей среды блок process. Наконец Если в примере была создана переменная, удаляет ее.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> is <see langword="null" />.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">возможность считывать значение <paramref name="variable" />. Связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static string GetEnvironmentVariable (string variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetEnvironmentVariable(string variable, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariable (variable As String, target As EnvironmentVariableTarget) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetEnvironmentVariable(System::String ^ variable, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariable : string * EnvironmentVariableTarget -&gt; string" Usage="System.Environment.GetEnvironmentVariable (variable, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="variable">The name of an environment variable.</param>
        <param name="target">One of the <see cref="T:System.EnvironmentVariableTarget" /> values.</param>
        <summary>Retrieves the value of an environment variable from the current process or from the Windows operating system registry key for the current user or local machine.</summary>
        <returns>The value of the environment variable specified by the <paramref name="variable" /> and <paramref name="target" /> parameters, or <see langword="null" /> if the environment variable is not found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `target` Параметр указывает ли переменная среды извлекаются из текущего процесса или раздела реестра операционной системы Windows для текущего пользователя или локального компьютера. Все переменные среды на уровне пользователя и компьютера автоматически копируется в блок среды текущего процесса. Тем не менее переменные среды, добавляемый блок среды текущего процесса сохранения только в течение процесса.  
  
 Чтобы получить все переменные среды, а также их значения, вызовите <xref:System.Environment.GetEnvironmentVariables%2A> метод.  
  
 Имена переменных среды не учитывается.  
  
   
  
## Examples  
 Следующий пример создает переменные среды для целевых объектов процесса, пользователя и компьютера, проверяет ли реестра операционной системы содержит переменные среды пользователя и компьютера, а затем удаляет переменные среды.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> is not a valid <see cref="T:System.EnvironmentVariableTarget" /> value.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">возможность считывать значение <paramref name="variable" /> Если <paramref name="target" /> — <see cref="F:System.EnvironmentVariableTarget.Process" /> (связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />), или для полного доступа к переменным среды Если <paramref name="target" /> — <see cref="F:System.EnvironmentVariableTarget.User" /> или <see cref="F:System.EnvironmentVariableTarget.Machine" /> (связанные перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEnvironmentVariables">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Retrieves all environment variable names and their values.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables () As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables();" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : unit -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Retrieves all environment variable names and their values from the current process.</summary>
        <returns>A dictionary that contains all environment variable names and their values; otherwise, an empty dictionary if no environment variables are found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Имена и значения для переменных среды хранятся в виде пар ключ значение в возвращаемом <xref:System.Collections.IDictionary>.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Environment.GetEnvironmentVariables%2A> метод.  
  
 [!code-cpp[Environment.GetEnvironmentVariables#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CPP/getenvironmentvariables.cpp#1)]
 [!code-csharp[Environment.GetEnvironmentVariables#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetEnvironmentVariables/CS/getenvironmentvariables.cs#1)]
 [!code-vb[Environment.GetEnvironmentVariables#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetEnvironmentVariables/VB/getenvironmentvariables.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation.</exception>
        <exception cref="T:System.OutOfMemoryException">The buffer is out of memory.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для возможности чтения имена и значения переменных среды. Связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEnvironmentVariables">
      <MemberSignature Language="C#" Value="public static System.Collections.IDictionary GetEnvironmentVariables (EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.IDictionary GetEnvironmentVariables(valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEnvironmentVariables (target As EnvironmentVariableTarget) As IDictionary" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::IDictionary ^ GetEnvironmentVariables(EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member GetEnvironmentVariables : EnvironmentVariableTarget -&gt; System.Collections.IDictionary" Usage="System.Environment.GetEnvironmentVariables target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IDictionary</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="target">One of the <see cref="T:System.EnvironmentVariableTarget" /> values.</param>
        <summary>Retrieves all environment variable names and their values from the current process, or from the Windows operating system registry key for the current user or local machine.</summary>
        <returns>A dictionary that contains all environment variable names and their values from the source specified by the <paramref name="target" /> parameter; otherwise, an empty dictionary if no environment variables are found.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `target` Параметр указывает, является ли источник текущего процесса, раздел реестра для текущего пользователя или раздел реестра для локального компьютера.  
  
 Имена и значения переменных среды хранятся в виде пар ключ/значение в возвращаемом <xref:System.Collections.IDictionary> объекта.  
  
   
  
## Examples  
 Следующий пример создает переменные среды для целевых объектов процесса, пользователя и компьютера, проверяет ли реестра операционной системы содержит переменные среды пользователя и компьютера, а затем удаляет переменные среды.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation for the specified value of <paramref name="target" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="target" /> contains an illegal value.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для возможности чтения имена и значения переменных среды, если <paramref name="target" /> — <see cref="F:System.EnvironmentVariableTarget.Process" /> (связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" />), или для полного доступа к переменным среды Если <paramref name="target" /> — <see cref="F:System.EnvironmentVariableTarget.User" /> или <see cref="F:System.EnvironmentVariableTarget.Machine" /> () Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />).</permission>
        <altmember cref="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFolderPath">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gets the path to the system special folder that is identified by the specified enumeration.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder -&gt; string" Usage="System.Environment.GetFolderPath folder" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" />
      </Parameters>
      <Docs>
        <param name="folder">An enumerated constant that identifies a system special folder.</param>
        <summary>Gets the path to the system special folder that is identified by the specified enumeration.</summary>
        <returns>The path to the specified system special folder, if that folder physically exists on your computer; otherwise, an empty string ("").  A folder will not physically exist if the operating system did not create it, the existing folder was deleted, or the folder is a virtual directory, such as My Computer, which does not correspond to a physical path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает путь к особой системной папке, например Program Files, программы, системой или запуска, который может использоваться для доступа к общей информации. Специальные папки задаются по умолчанию системой, или явно пользователем, при установке версии платформы Windows.  
  
 `folder` Параметр указывает специальную папку, для получения и должен иметь одно из значений в <xref:System.Environment.SpecialFolder> перечисления; именем любого другого значения создает исключение.  
  
 Дополнительные сведения о специальных папках см. в разделе [CSIDL](http://go.microsoft.com/fwlink/?LinkId=116664) значения раздела.  
  
   
  
## Examples  
 Следующий пример демонстрирует, как использовать <xref:System.Environment.GetFolderPath%2A> метод для определения и отображения путь, связанный с `folder` параметра.  
  
 [!code-cpp[Environment.GetFolderPath#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetFolderPath/CPP/getfolderpath.cpp#1)]
 [!code-csharp[Environment.GetFolderPath#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetFolderPath/CS/getfolderpath.cs#1)]
 [!code-vb[Environment.GetFolderPath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetFolderPath/VB/getfolderpath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="folder" /> is not a member of <see cref="T:System.Environment.SpecialFolder" />.</exception>
        <exception cref="T:System.PlatformNotSupportedException">The current platform is not supported.</exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям, включенным в путь. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetFolderPath">
      <MemberSignature Language="C#" Value="public static string GetFolderPath (Environment.SpecialFolder folder, Environment.SpecialFolderOption option);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetFolderPath(valuetype System.Environment/SpecialFolder folder, valuetype System.Environment/SpecialFolderOption option) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetFolderPath(System.Environment.SpecialFolder,System.Environment.SpecialFolderOption)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetFolderPath (folder As Environment.SpecialFolder, option As Environment.SpecialFolderOption) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetFolderPath(Environment::SpecialFolder folder, Environment::SpecialFolderOption option);" />
      <MemberSignature Language="F#" Value="static member GetFolderPath : Environment.SpecialFolder * Environment.SpecialFolderOption -&gt; string" Usage="System.Environment.GetFolderPath (folder, option)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="folder" Type="System.Environment+SpecialFolder" />
        <Parameter Name="option" Type="System.Environment+SpecialFolderOption" />
      </Parameters>
      <Docs>
        <param name="folder">An enumerated constant that identifies a system special folder.</param>
        <param name="option">Specifies options to use for accessing a special folder.</param>
        <summary>Gets the path to the system special folder that is identified by the specified enumeration, and uses a specified option for accessing special folders.</summary>
        <returns>The path to the specified system special folder, if that folder physically exists on your computer; otherwise, an empty string ("").  A folder will not physically exist if the operating system did not create it, the existing folder was deleted, or the folder is a virtual directory, such as My Computer, which does not correspond to a physical path.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод возвращает путь к особой системной папке, например Program Files, программы, системой или запуска, который может использоваться для доступа к общей информации. Специальные папки задаются по умолчанию системой, или явно пользователем, при установке версии платформы Windows.  
  
 `folder` Параметр указывает специальную папку, для получения и должен иметь одно из значений в <xref:System.Environment.SpecialFolder> перечисления; именем любого другого значения создает исключение.  
  
 Дополнительные сведения о специальных папках см. в разделе [CSIDL](http://go.microsoft.com/fwlink/?LinkId=116664) значения раздела.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="folder" /> is not a member of <see cref="T:System.Environment.SpecialFolder" /></exception>
        <exception cref="T:System.PlatformNotSupportedException">
          <see cref="T:System.PlatformNotSupportedException" />
        </exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям, включенным в путь. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="GetLogicalDrives">
      <MemberSignature Language="C#" Value="public static string[] GetLogicalDrives ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string[] GetLogicalDrives() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.GetLogicalDrives" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetLogicalDrives () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;System::String ^&gt; ^ GetLogicalDrives();" />
      <MemberSignature Language="F#" Value="static member GetLogicalDrives : unit -&gt; string[]" Usage="System.Environment.GetLogicalDrives " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Returns an array of string containing the names of the logical drives on the current computer.</summary>
        <returns>An array of strings where each element contains the name of a logical drive. For example, if the computer's hard drive is the first logical drive, the first element returned is "C:\\".</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере показано, как для отображения логических дисков текущего компьютера с помощью <xref:System.Environment.GetLogicalDrives%2A> метод.  
  
 [!code-cpp[Environment.GetLogicalDrives#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.GetLogicalDrives/CPP/getlogicaldrives.cpp#1)]
 [!code-csharp[Environment.GetLogicalDrives#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.GetLogicalDrives/CS/getlogicaldrives.cs#1)]
 [!code-vb[Environment.GetLogicalDrives#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.GetLogicalDrives/VB/getlogicaldrives.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException">An I/O error occurs.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permissions.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для полного доступа к ресурсу, защищенному этим разрешением. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="HasShutdownStarted">
      <MemberSignature Language="C#" Value="public static bool HasShutdownStarted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool HasShutdownStarted" />
      <MemberSignature Language="DocId" Value="P:System.Environment.HasShutdownStarted" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property HasShutdownStarted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool HasShutdownStarted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasShutdownStarted : bool" Usage="System.Environment.HasShutdownStarted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether the current application domain is being unloaded or the common language runtime (CLR) is shutting down.</summary>
        <value>Значение <see langword="true" />, если текущий домен приложения выгружается или среда CLR завершает работу; в противном случае — значение <see langword="false." />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда среда CLR выгружает домен приложения, она запускает методы завершения на все объекты, имеющие в методе завершения в этом домене приложения. Если среда CLR завершает работу, он начнет поток метода завершения для всех объектов, имеющих в методе завершения. <xref:System.Environment.HasShutdownStarted%2A> Возвращает `true` только в том случае, после запуска потока финализатора. Если это свойство возвращает `true`, можно определить ли домен приложения выгружается или самой CLR завершает работу, вызвав <xref:System.AppDomain.IsFinalizingForUnload%2A?displayProperty=nameWithType> метод. Этот метод возвращает `true` Если финализаторов, так как домен приложения выгружается или `false` Если среда CLR завершает работу.  
  
 <xref:System.Environment.HasShutdownStarted%2A> Возвращает `false` Если поток метода завершения не был запущен.  
  
 С помощью этого свойства, можно определить, следует ли для доступа к статическим переменным в коде завершения. Если домен приложения или среда CLR завершает работу, может оказаться недоступным любой объект, имеющий метод финализации, и, на который ссылается статическое поле. Это потому, что эти объекты могут быть уже завершен.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomain.IsFinalizingForUnload" />
      </Docs>
    </Member>
    <Member MemberName="Is64BitOperatingSystem">
      <MemberSignature Language="C#" Value="public static bool Is64BitOperatingSystem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitOperatingSystem" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitOperatingSystem" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitOperatingSystem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitOperatingSystem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitOperatingSystem : bool" Usage="System.Environment.Is64BitOperatingSystem" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether the current operating system is a 64-bit operating system.</summary>
        <value>Значение <see langword="true" />, если операционная система является 64-разрядной; в противном случае — значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Is64BitProcess">
      <MemberSignature Language="C#" Value="public static bool Is64BitProcess { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool Is64BitProcess" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Is64BitProcess" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Is64BitProcess As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool Is64BitProcess { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Is64BitProcess : bool" Usage="System.Environment.Is64BitProcess" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Determines whether the current process is a 64-bit process.</summary>
        <value>Значение <see langword="true" />, если процесс является 64-разрядным; в противном случае —значение <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MachineName">
      <MemberSignature Language="C#" Value="public static string MachineName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string MachineName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.MachineName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MachineName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ MachineName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.MachineName : string" Usage="System.Environment.MachineName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the NetBIOS name of this local computer.</summary>
        <value>Строка, содержащая имя данного компьютера.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Имя этого компьютера устанавливается при запуске системы, при считывании из реестра. Если этот компьютер является узлом кластера, возвращается имя узла.  
  
   
  
## Examples  
 Следующий пример отображает имя компьютера, на котором выполняется в примере кода. (Имя компьютера указана в выходных данных примера по соображениям безопасности).  
  
 [!code-cpp[environment.machinename#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.MachineName/CPP/machinename.cpp#1)]
 [!code-csharp[environment.machinename#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.MachineName/CS/machinename.cs#1)]
 [!code-vb[environment.machinename#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.MachineName/VB/machinename.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The name of this computer cannot be obtained.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">доступ на чтение к переменной среды COMPUTERNAME. Связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
      </Docs>
    </Member>
    <Member MemberName="NewLine">
      <MemberSignature Language="C#" Value="public static string NewLine { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string NewLine" />
      <MemberSignature Language="DocId" Value="P:System.Environment.NewLine" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property NewLine As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ NewLine { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.NewLine : string" Usage="System.Environment.NewLine" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the newline string defined for this environment.</summary>
        <value>Строка, содержащая "\r\n" для платформ, отличных от Unix, или строка, содержащая "\n" для платформ Unix.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение свойства <xref:System.Environment.NewLine%2A> является константа, настроенная специально для текущей платформы и реализации платформы .NET Framework. Дополнительные сведения об escape-символов в значении свойства см. в разделе [escape-](~/docs/standard/base-types/character-escapes-in-regular-expressions.md).  
  
 Функциональные возможности, предоставляемые <xref:System.Environment.NewLine%2A> часто является определение условий перехода на новую строку, перевод строки, разрыв строки, возврат каретки, CRLF и конец строки.  
  
 <xref:System.Environment.NewLine%2A> можно использовать в сочетании с поддержкой новой строки для конкретного языка, такие как символы escape «\r» и «\n» в Microsoft C# и C/C++, или `vbCrLf` в Microsoft Visual Basic.  
  
 <xref:System.Environment.NewLine%2A> автоматически добавляется к тексту, обрабатываемых <xref:System.Console.WriteLine%2A?displayProperty=nameWithType> и <xref:System.Text.StringBuilder.AppendLine%2A?displayProperty=nameWithType> методы.  
  
   
  
## Examples  
 В следующем примере отображаются три строки, разделенных новыми строками.  
  
 [!code-cpp[environment.newline#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.NewLine/CPP/newline.cpp#1)]
 [!code-csharp[environment.newline#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.NewLine/CS/newline.cs#1)]
 [!code-vb[environment.newline#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.NewLine/VB/newline.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OSVersion">
      <MemberSignature Language="C#" Value="public static OperatingSystem OSVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.OperatingSystem OSVersion" />
      <MemberSignature Language="DocId" Value="P:System.Environment.OSVersion" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSVersion As OperatingSystem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property OperatingSystem ^ OSVersion { OperatingSystem ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.OSVersion : OperatingSystem" Usage="System.Environment.OSVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.OperatingSystem</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets an <see cref="T:System.OperatingSystem" /> object that contains the current platform identifier and version number.</summary>
        <value>Объект, который содержит идентификатор платформы и номер версии.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Начиная с Windows 8, <xref:System.Environment.OSVersion%2A> свойство возвращает одинаковые номера версий основных и дополнительных версий для всех платформ Windows. Таким образом что вы получаете значение этого свойства, чтобы определить версию операционной системы не рекомендуется.  
  
 Как правило <xref:System.Environment.OSVersion%2A> свойство используется, чтобы убедиться, что приложение выполняется на некоторые базовые версии операционной системы, в которой был представлен определенный компонент. Если это так, необходимо выполнить проверку версии путем проверки, является ли текущая версия операционной системы, возвращенный <xref:System.Environment.OSVersion%2A> свойство является одновременно, или больше, чем версия базовой операционной системы. Дополнительные сведения см. в разделе <xref:System.Version> разделе, посвященном классу.  
  
 По Windows 8 <xref:System.Environment.OSVersion%2A> свойство возвращает версии, указанной в Windows [GetVersionEx](http://msdn.microsoft.com/library/windows/desktop/ms724451\(v=vs.85\).aspx) функции. Список версий операционной системы Windows и их соответствующие номера версий, см. в разделе [версии операционной системы](https://msdn.microsoft.com/library/windows/desktop/ms724832.aspx) в центре разработки для Windows.  
  
> [!NOTE]
>  <xref:System.Environment.OSVersion%2A> Свойство возвращает один и тот же номер версии (6.2.0.0) для обоих [!INCLUDE[win8](~/includes/win8-md.md)] и [!INCLUDE[win81](~/includes/win81-md.md)] и один и тот же номер основной и дополнительный номер версии для Windows 10.  
  
 В некоторых случаях <xref:System.Environment.OSVersion%2A> свойство не может возвращать версию операционной системы, которая соответствует версии, указанной для функции режима совместимости программ Windows.  
  
   
  
## Examples  
 Следующий пример отображает идентификатор платформы и номер версии на компьютере под управлением в примере кода.  
  
 [!code-cpp[environment.osversion#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.OSVersion/CPP/osversion.cpp#1)]
 [!code-csharp[environment.osversion#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.OSVersion/CS/osversion.cs#1)]
 [!code-vb[environment.osversion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.OSVersion/VB/osversion.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">This property was unable to obtain the system version.  -or-  The obtained platform identifier is not a member of <see cref="T:System.PlatformID" /></exception>
      </Docs>
    </Member>
    <Member MemberName="ProcessorCount">
      <MemberSignature Language="C#" Value="public static int ProcessorCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 ProcessorCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.ProcessorCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property ProcessorCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int ProcessorCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ProcessorCount : int" Usage="System.Environment.ProcessorCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of processors on the current machine.</summary>
        <value>32-битовое целое число со знаком, которое задает количество процессоров на текущем компьютере. Значение по умолчанию отсутствует. Если текущий компьютер содержит несколько групп процессоров, данное свойство возвращает число логических процессоров, доступных для использования средой CLR.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Дополнительные сведения о группах процессоров и логических процессоров см. в разделе [групп процессоров](http://msdn.microsoft.com/library/windows/desktop/dd405503.aspx).  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Environment.ProcessorCount%2A> свойство.  
  
 [!code-cpp[environment.processorcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.processorcount/CPP/pc.cpp#1)]
 [!code-csharp[environment.processorcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.processorcount/CS/pc.cs#1)]
 [!code-vb[environment.processorcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.processorcount/VB/pc.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetEnvironmentVariable">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Creates, modifies, or deletes an environment variable.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="variable">The name of an environment variable.</param>
        <param name="value">A value to assign to <c>variable</c>.</param>
        <summary>Creates, modifies, or deletes an environment variable stored in the current process.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода эквивалентен вызову <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> перегрузки со значением <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType> для `target` аргумент.  
  
 Если `value` аргумент не является пустой (см. в обсуждении удаление переменной среды, далее в этом разделе для определения пустое значение) и переменную среды с именем, `variable` параметр не существует, среды создается и назначается содержимое переменной `value`. Если она существует, его значение изменяется. Так как переменная среды определена в блок среды только текущего процесса, он не сохраняется после завершения процесса.  
  
 Если `variable` знаков не начальный шестнадцатеричный символ нуля, прежде чем символ нуля, считаются имя переменной среды, и все последующие символы игнорируются.  
  
 Если `value` знаков не начальный шестнадцатеричный символ нуля, прежде чем символ нуля назначаются в переменную среды, и все последующие символы игнорируются.  
  
 Если `value` пуста, а также переменную среды с именем, `variable` существует, удалить переменную среды. Если `variable` не существует, ошибка не возникает несмотря на то, что невозможно выполнить операцию. `value` считается пустым выполняется любое из следующих условий:  
  
-   Это `null`.  
  
-   Это <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Он состоит из одного символа, значение которого равно U + 0000.  
  
   
  
## Examples  
 Следующий пример проверяет, является ли переменную среды с именем `APPDOMAIN` существует в текущем процессе. Если этого не произошло, он создает его и задает его значение на «True». Если значение `APPDOMAIN` переменная среды — «True», он вызывает метод `Message.Display` метод в новом домене приложения. В противном случае он выполняет `Message.Display` метод в текущем домене приложения.  
  
 [!code-csharp[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/cs/setenvironmentvariable1.cs#1)]
 [!code-vb[System.Environment.SetEnvironmentVariable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.setenvironmentvariable/vb/setenvironmentvariable1.vb#1)]  
  
 При выполнении примера в первый раз, сообщение «Выполняется в домене домен2» выводит на консоль. Если вы задали переменную среды из командной строки, с помощью команды:  
  
 `Set AppDomain=False`  
  
 в примере отображается сообщение «выполнение в домене *exeName*.exe», где *exeName* — это имя исполняемого файла.  
  
 В следующем примере предпринимается для получения значения переменной среды с именем `Test1` из процесса блок среды. Если переменная не существует, в примере создается переменная и извлекает его значение. Выводится значение переменной. Если пример создания переменной, он вызывает <xref:System.Environment.GetEnvironmentVariables%28System.EnvironmentVariableTarget%29> метод с каждым членом <xref:System.EnvironmentVariableTarget> перечисления для установления того, что переменной можно получить только из текущей среды блок process. Наконец Если в примере была создана переменная, удаляет ее.  
  
 [!code-csharp[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/cs/getenvironmentvariableex1.cs#2)]
 [!code-vb[System.Environment.GetEnvironmentVariable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.environment.getenvironmentvariable/vb/getenvironmentvariableex1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="variable" /> contains a zero-length string, an initial hexadecimal zero character (0x00), or an equal sign ("=").  -or-  The length of <paramref name="variable" /> or <paramref name="value" /> is greater than or equal to 32,767 characters.  -or-  An error occurred during the execution of this operation.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для полного доступа к переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables" />
      </Docs>
    </Member>
    <Member MemberName="SetEnvironmentVariable">
      <MemberSignature Language="C#" Value="public static void SetEnvironmentVariable (string variable, string value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetEnvironmentVariable(string variable, string value, valuetype System.EnvironmentVariableTarget target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Environment.SetEnvironmentVariable(System.String,System.String,System.EnvironmentVariableTarget)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetEnvironmentVariable (variable As String, value As String, target As EnvironmentVariableTarget)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetEnvironmentVariable(System::String ^ variable, System::String ^ value, EnvironmentVariableTarget target);" />
      <MemberSignature Language="F#" Value="static member SetEnvironmentVariable : string * string * EnvironmentVariableTarget -&gt; unit" Usage="System.Environment.SetEnvironmentVariable (variable, value, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="variable" Type="System.String" />
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="target" Type="System.EnvironmentVariableTarget" />
      </Parameters>
      <Docs>
        <param name="variable">The name of an environment variable.</param>
        <param name="value">A value to assign to <c>variable</c>.</param>
        <param name="target">One of the enumeration values that specifies the location of the environment variable.</param>
        <summary>Creates, modifies, or deletes an environment variable stored in the current process or in the Windows operating system registry key reserved for the current user or local machine.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment.SetEnvironmentVariable%28System.String%2CSystem.String%2CSystem.EnvironmentVariableTarget%29> Метод позволяет определить переменную среды, которая доступна для всех процессов, выполняющихся на компьютере ( <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType> значение), чтобы все процессы выполняются пользователем ( <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> значение), или текущий процесс ( <xref:System.EnvironmentVariableTarget.Process> значение). Переменные среды на уровне компьютера и пользователя копируется в блок среды текущего процесса. Тем не менее переменные среды, которые являются уникальными для текущей среды блок process сохраняются только до завершения данного процесса.  
  
 Если `value` аргумент не является пустой (см. в обсуждении удаление переменной среды, далее в этом разделе для определения пустое значение) и переменную среды с именем, `variable` параметр не существует, среды создается и назначается содержимое переменной `value`.  Если она существует, его значение изменяется.  
  
 Если `variable` знаков не начальный шестнадцатеричный символ нуля, прежде чем символ нуля, считаются имя переменной среды, и все последующие символы игнорируются.  
  
 Если `value` знаков не начальный шестнадцатеричный символ нуля, прежде чем символ нуля назначаются в переменную среды, и все последующие символы игнорируются.  
  
 Если `value` пуста, а также переменную среды с именем, `variable` существует, удалить переменную среды. `value` считается пустым выполняется любое из следующих условий:  
  
-   Это `null`.  
  
-   Это <xref:System.String.Empty?displayProperty=nameWithType>.  
  
-   Он состоит из одного символа, значение которого равно U + 0000.  
  
 Если `variable` не существует, ошибка не возникает несмотря на то, что невозможно выполнить операцию. Будьте внимательны при `target` является <xref:System.EnvironmentVariableTarget.Machine>, так как может случайно удалить переменную среды, которая влияет на весь локальный компьютер, а не только текущий процесс или пользователь.  
  
 Если `target` является <xref:System.EnvironmentVariableTarget.User>, переменная среды хранится в разделе hkey_current_user\environment реестра локального компьютера. Кроме того, он копируется в экземпляры проводника, работающих под управлением имени текущего пользователя. Переменная среды затем наследуется любым новым процессам, пользователь запускает в проводнике.  
  
 Аналогично Если `target` является <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, переменная среды хранится в HKEY_LOCAL_MACHINE\SYSTEM\ControlSet001\Control\Session Manager\Environment ключ реестра локального компьютера. Он также копируются все экземпляры проводника. Переменная среды затем наследуется любым новым процессам, которые запускаются в проводнике.  
  
 Если `target` — <xref:System.EnvironmentVariableTarget.User> или <xref:System.EnvironmentVariableTarget.Machine>, другие приложения получают операции задания по Windows `WM_SETTINGCHANGE` сообщения.  
  
 Если `target` — <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType> или <xref:System.EnvironmentVariableTarget.Machine?displayProperty=nameWithType>, рекомендуется, чтобы длина `value` меньше 2048 символов.  
  
   
  
## Examples  
 В следующем примере создается переменная среды для <xref:System.EnvironmentVariableTarget.Process?displayProperty=nameWithType>, <xref:System.EnvironmentVariableTarget.User?displayProperty=nameWithType>, и <xref:System.EnvironmentVariableTarget.Machine> предназначен, проверяет ли реестра операционной системы содержит переменные среды компьютера и пользователя, а затем удаляет среду переменные.  
  
 [!code-cpp[environment.getsetenvar#1](~/samples/snippets/cpp/VS_Snippets_CLR/environment.getsetenvar/CPP/source.cpp#1)]
 [!code-csharp[environment.getsetenvar#1](~/samples/snippets/csharp/VS_Snippets_CLR/environment.getsetenvar/CS/gsev.cs#1)]
 [!code-vb[environment.getsetenvar#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/environment.getsetenvar/VB/gsev.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="variable" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="variable" /> contains a zero-length string, an initial hexadecimal zero character (0x00), or an equal sign ("=").  -or-  The length of <paramref name="variable" /> is greater than or equal to 32,767 characters.  -or-  <paramref name="target" /> is not a member of the <see cref="T:System.EnvironmentVariableTarget" /> enumeration.  -or-  <paramref name="target" /> is <see cref="F:System.EnvironmentVariableTarget.Machine" /> or <see cref="F:System.EnvironmentVariableTarget.User" />, and the length of <paramref name="variable" /> is greater than or equal to 255.  -or-  <paramref name="target" /> is <see cref="F:System.EnvironmentVariableTarget.Process" /> and the length of <paramref name="value" /> is greater than or equal to 32,767 characters.  -or-  An error occurred during the execution of this operation.</exception>
        <exception cref="T:System.Security.SecurityException">The caller does not have the required permission to perform this operation.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для полного доступа к переменным среды. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
        <altmember cref="M:System.Environment.GetEnvironmentVariable(System.String,System.EnvironmentVariableTarget)" />
        <altmember cref="M:System.Environment.GetEnvironmentVariables(System.EnvironmentVariableTarget)" />
        <altmember cref="T:System.EnvironmentVariableTarget" />
      </Docs>
    </Member>
    <Member MemberName="StackTrace">
      <MemberSignature Language="C#" Value="public static string StackTrace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string StackTrace" />
      <MemberSignature Language="DocId" Value="P:System.Environment.StackTrace" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property StackTrace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ StackTrace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StackTrace : string" Usage="System.Environment.StackTrace" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets current stack trace information.</summary>
        <value>Строка, содержащая сведения о трассировке стека. Это значение может быть равно <see cref="F:System.String.Empty" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment.StackTrace%2A> Свойство перечисляет вызовы метода в обратном хронологическом порядке, то есть сначала описан самый последний вызов метода одну строку сведений о трассировке стека в списке, а для каждого вызова метода в стеке. Тем не менее <xref:System.Environment.StackTrace%2A> свойство может сообщить столько предполагаемых вызовах методов из-за преобразований кода в процессе оптимизации.  
  
> [!NOTE]
>  Иерархическое представление данные трассировки стека в классе, используйте <xref:System.Diagnostics.StackTrace> класса.  
  
 <xref:System.Environment.StackTrace%2A> Свойство форматирует сведения о трассировке стека для каждого вызова метода, следующим образом:  
  
 «в `FullClassName`.`MethodName` (`MethodParams`) в `FileName` : строки `LineNumber` "  
  
 Литерал «на» предшествует три пробела, а вся подстрока, начиная с «in» пропускается в том случае, если символы отладки недоступны. Заполнители, `FullClassName`, `MethodName`, `MethodParams`, `FileName`, и `LineNumber`, заменяются фактическими значениями и определяются следующим образом:  
  
 FullClassName  
 Полное имя класса, включая пространство имен.  
  
 `MethodName`  
 Имя метода.  
  
 `MethodParams`  
 Список пар имен и типов параметров. Каждая пара отделяется запятой («",»"). Эта информация указывается, если `MethodName` не принимает никаких параметров.  
  
 `FileName`  
 Имя источника файла where `MethodName` метод объявляется. Эта информация указывается, если символы отладки недоступны.  
  
 `LineNumber`  
 Номер строки в `FileName` , содержащий исходный код из `MethodName` для инструкции в стеке вызовов. Эта информация указывается, если символы отладки недоступны.  
  
 <xref:System.Environment.NewLine%2A?displayProperty=nameWithType> Строка завершает каждой строки трассировки стека.  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Environment.StackTrace%2A> свойство.  
  
 [!code-cpp[environment.stacktrace#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.StackTrace/CPP/stacktrace.cpp#1)]
 [!code-csharp[environment.stacktrace#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.StackTrace/CS/stacktrace.cs#1)]
 [!code-vb[environment.stacktrace#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.StackTrace/VB/stacktrace.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для полного доступа к ресурсу, защищенному с помощью разрешений. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemDirectory">
      <MemberSignature Language="C#" Value="public static string SystemDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string SystemDirectory" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemDirectory" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ SystemDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemDirectory : string" Usage="System.Environment.SystemDirectory" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the fully qualified path of the system directory.</summary>
        <value>Строка, содержащая путь к каталогу.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Пример возвращаемого значения — строка «C:\WinNT\System32».  
  
   
  
## Examples  
 Следующий пример отображает каталог системы компьютера, на котором выполняется в примере кода. (Системного каталога указана в выходных данных примера по соображениям безопасности).  
  
 [!code-cpp[environment.systemdirectory#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.SystemDirectory/CPP/systemdirectory.cpp#1)]
 [!code-csharp[environment.systemdirectory#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.SystemDirectory/CS/systemdirectory.cs#1)]
 [!code-vb[environment.systemdirectory#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.SystemDirectory/VB/systemdirectory.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission">для доступа к сведениям, включенным в путь. Связанное перечисление: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></permission>
      </Docs>
    </Member>
    <Member MemberName="SystemPageSize">
      <MemberSignature Language="C#" Value="public static int SystemPageSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 SystemPageSize" />
      <MemberSignature Language="DocId" Value="P:System.Environment.SystemPageSize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SystemPageSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int SystemPageSize { int get(); };" />
      <MemberSignature Language="F#" Value="member this.SystemPageSize : int" Usage="System.Environment.SystemPageSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of bytes in the operating system's memory page.</summary>
        <value>Количество в байтах в странице памяти системы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта информация может пригодиться при определении, следует ли использовать <xref:System.IO.MemoryMappedFiles.MemoryMappedFileOptions.DelayAllocatePages?displayProperty=nameWithType> параметр при работе с файлами, размещенный в памяти.  
  
 В Windows, это значение равно `dwPageSize` члена в `SYSTEM_INFO` структуры.  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для доступа к системным и пользовательским переменным среды. Связанное исключение:  <see cref="P:System.Security.SecurityException.PermissionState" /></permission>
      </Docs>
    </Member>
    <Member MemberName="TickCount">
      <MemberSignature Language="C#" Value="public static int TickCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 TickCount" />
      <MemberSignature Language="DocId" Value="P:System.Environment.TickCount" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property TickCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int TickCount { int get(); };" />
      <MemberSignature Language="F#" Value="member this.TickCount : int" Usage="System.Environment.TickCount" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the number of milliseconds elapsed since the system started.</summary>
        <value>32-битовое целое число со знаком, содержащее время, истекшее с момента с последней загрузки системы (в миллисекундах).</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этого свойства является производным от системного таймера и хранится в виде 32-разрядное целое число со знаком. Обратите внимание, что, поскольку он является производным от системного таймера, разрешение <xref:System.Environment.TickCount%2A> свойство ограничена разрешение системного таймера, который обычно находится в диапазоне от 10 до 16 миллисекунд.  
  
> [!IMPORTANT]
>  Так как значение <xref:System.Environment.TickCount%2A> значение свойства равно 32-разрядное знаковое целое число, если система работает непрерывно, <xref:System.Environment.TickCount%2A> будет увеличиваться от нуля до <xref:System.Int32.MaxValue?displayProperty=nameWithType> приблизительно 24,9 дней, затем перейти к <xref:System.Int32.MinValue?displayProperty=nameWithType>, который является отрицательным числом, затем увеличивается до нуля в течение следующих 24,9 дней. Эту проблему можно обойти, вызвав Windows [GetTickCount](https://msdn.microsoft.com/library/windows/desktop/ms724408.aspx) функцию, которая обнуляется приблизительно дней или вызвав [GetTickCount64](https://msdn.microsoft.com/library/windows/desktop/ms724411.aspx) функции.  
  
 <xref:System.Environment.TickCount%2A> отличается от <xref:System.DateTime.Ticks%2A?displayProperty=nameWithType> свойство, которое является количество 100-наносекундных интервалов, прошедших с 1/1/0001 12:00 am.  
  
 Используйте <xref:System.DateTime.Now%2A?displayProperty=nameWithType> свойство, чтобы получить текущую локальную дату и время данного компьютера.  
  
   
  
## Examples  
 Приведенный ниже показано, как получить диапазон положительных значений, возвращенных <xref:System.Environment.TickCount%2A> свойство. <xref:System.Environment.TickCount%2A> Свойство циклически переключается между <xref:System.Int32.MinValue?displayProperty=nameWithType>, который является отрицательным числом, и <xref:System.Int32.MaxValue?displayProperty=nameWithType> раз 49.8 дней. Этот пример кода удаляет бит знака для получения неотрицательное число, в котором с нуля и <xref:System.Int32.MaxValue> раз 24,9 дней.  
  
 [!code-cpp[environment.tickcount#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.TickCount/CPP/tickcount.cpp#1)]
 [!code-csharp[environment.tickcount#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.TickCount/CS/tickcount.cs#1)]
 [!code-vb[environment.tickcount#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.TickCount/VB/tickcount.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UserDomainName">
      <MemberSignature Language="C#" Value="public static string UserDomainName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserDomainName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserDomainName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserDomainName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserDomainName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserDomainName : string" Usage="System.Environment.UserDomainName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the network domain name associated with the current user.</summary>
        <value>Имя сетевого домена, связанное с текущим пользователем.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Учетные данные учетной записи домена для пользователя в формате имени домена пользователя, "\\" символ, а также имя пользователя. Используйте <xref:System.Environment.UserDomainName%2A> свойство для получения имени пользователя домена без указания имени пользователя и <xref:System.Environment.UserName%2A> свойство для получения имени пользователя без имени домена.  Например, если доменное имя пользователя и имя пользователя, CORPORATENETWORK\john <xref:System.Environment.UserDomainName%2A> свойство возвращает «CORPORATENETWORK».  
  
 <xref:System.Environment.UserDomainName%2A> Свойство сначала пытается получить компонент имени домена, имя учетной записи Windows для текущего пользователя. Если попытка не удалась, это свойство пытается получить имя домена, связанный с именем пользователя, предоставляемых <xref:System.Environment.UserName%2A> свойство. Если попытка не удалась, поскольку компьютер не присоединен к домену, то возвращается имя главного компьютера.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">The operating system does not support retrieving the network domain name.</exception>
        <exception cref="T:System.InvalidOperationException">The network domain name cannot be retrieved.</exception>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">доступ на чтение к переменной среды USERDOMAIN. Связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserName" />
      </Docs>
    </Member>
    <Member MemberName="UserInteractive">
      <MemberSignature Language="C#" Value="public static bool UserInteractive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool UserInteractive" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserInteractive" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserInteractive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool UserInteractive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.UserInteractive : bool" Usage="System.Environment.UserInteractive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value indicating whether the current process is running in user interactive mode.</summary>
        <value>Значение <see langword="true" />, если текущий процесс выполняется в режиме взаимодействия с пользователем; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Environment.UserInteractive%2A> Отчеты свойство `false` для процесса Windows или службы, такие как IIS, который выполняется без пользовательского интерфейса. Если это свойство имеет `false`, не отображать модальные диалоговые окна или сообщения диалоговые окна, так как нет графического пользовательского интерфейса для взаимодействия с пользователем.  
  
   
  
## Examples  
 В следующем примере отображается ли текущий процесс выполняется в режиме взаимодействия с пользователем.  
  
 [!code-cpp[Environment.UserInteractive#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserInteractive/CPP/userinteractive.cpp#1)]
 [!code-csharp[Environment.UserInteractive#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserInteractive/CS/userinteractive.cs#1)]
 [!code-vb[Environment.UserInteractive#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserInteractive/VB/userinteractive.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Windows.Forms.SystemInformation" />
      </Docs>
    </Member>
    <Member MemberName="UserName">
      <MemberSignature Language="C#" Value="public static string UserName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property string UserName" />
      <MemberSignature Language="DocId" Value="P:System.Environment.UserName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property UserName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::String ^ UserName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UserName : string" Usage="System.Environment.UserName" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the user name of the person who is currently logged on to the operating system.</summary>
        <value>Имя пользователя, пользователя, который вошел в систему для операционной системы.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Можно использовать <xref:System.Environment.UserName%2A> свойство для идентификации пользователя в текущем потоке, чтобы системы и приложений в целях безопасности или доступа. Он может также использоваться для настройки данного приложения для каждого пользователя.  
 
 В Windows <xref:System.Environment.UserName%2A> свойство создает оболочку для вызова Windows [GetUserName](http://msdn.microsoft.com/library/windows/desktop/ms724432.aspx) функции. Учетные данные учетной записи домена для пользователя в формате имени домена пользователя, "\\" символ, а также имя пользователя. Используйте <xref:System.Environment.UserDomainName%2A> свойство для получения имени пользователя домена и <xref:System.Environment.UserName%2A> свойство для получения имени пользователя.  
 
 На платформах Unix <xref:System.Environment.UserName%2A> свойство создает оболочку для вызова `getpwuid_r` функции.
 
 Если приложение ASP.NET выполняется в среде разработки, <xref:System.Environment.UserName%2A> свойство возвращает имя текущего пользователя. В опубликованном в приложении ASP.NET это свойство возвращает имя учетной записи пула приложений (например, пул приложений по умолчанию).  
  
   
  
## Examples  
 Следующий пример отображает имя пользователя, запустившего текущего потока.  
  
 [!code-cpp[Environment.UserName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.UserName/CPP/username.cpp#1)]
 [!code-csharp[Environment.UserName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.UserName/CS/username.cs#1)]
 [!code-vb[Environment.UserName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.UserName/VB/username.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">доступ на чтение к переменной среды USERNAME. Связанное перечисление: <see cref="F:System.Security.Permissions.EnvironmentPermissionAccess.Read" /></permission>
        <altmember cref="P:System.Environment.UserDomainName" />
      </Docs>
    </Member>
    <Member MemberName="Version">
      <MemberSignature Language="C#" Value="public static Version Version { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Version Version" />
      <MemberSignature Language="DocId" Value="P:System.Environment.Version" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Version As Version" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Version ^ Version { Version ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Version : Version" Usage="System.Environment.Version" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Version</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a <see cref="T:System.Version" /> object that describes the major, minor, build, and revision numbers of the common language runtime.</summary>
        <value>Объект, содержащий версию среды CLR.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для платформы .NET Framework версий 4, 4.5, 4.5.1 и 4.5.2 свойство <xref:System.Environment.Version%2A?displayProperty=nameWithType> возвращает объект <xref:System.Version>, строковое представление которого имеет форму `4.0.30319.xxxxx`. .NET Framework 4.6 и более поздних версиях, он имеет вид `4.0.30319.42000`.  
  
> [!WARNING]
>  Для [!INCLUDE[net_v45](~/includes/net-v45-md.md)] и более поздней версии, мы не рекомендуем использовать <xref:System.Environment.Version%2A> свойство для определения версии среды выполнения; вместо этого можно определить версию среда CLR путем запроса реестра. Дополнительные сведения см. в разделе [как: определение .NET Framework версий установленных](~/docs/framework/migration-guide/how-to-determine-which-versions-are-installed.md).  
  
 Дополнительные сведения о версии среды CLR, которая устанавливается вместе с каждой версии платформы .NET Framework, см. в разделе [версии и зависимости](~/docs/framework/migration-guide/versions-and-dependencies.md).  
  
   
  
## Examples  
 Следующий пример отображает версию среды CLR. (Версия указана в выходных данных примера по соображениям безопасности).  
  
 [!code-cpp[Environment.Version#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.Version/CPP/version.cpp#1)]
 [!code-csharp[Environment.Version#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.Version/CS/version.cs#1)]
 [!code-vb[Environment.Version#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.Version/VB/version.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WorkingSet">
      <MemberSignature Language="C#" Value="public static long WorkingSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 WorkingSet" />
      <MemberSignature Language="DocId" Value="P:System.Environment.WorkingSet" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property WorkingSet As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long WorkingSet { long get(); };" />
      <MemberSignature Language="F#" Value="member this.WorkingSet : int64" Usage="System.Environment.WorkingSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the amount of physical memory mapped to the process context.</summary>
        <value>Целое 64-битовое число со знаком, содержащее число байтов физической памяти, сопоставленное контексту процесса.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Следующий пример отображает размер рабочего набора компьютера, на котором выполняется в примере кода.  
  
 [!code-cpp[Environment.WorkingSet#1](~/samples/snippets/cpp/VS_Snippets_CLR/Environment.WorkingSet/CPP/workingset.cpp#1)]
 [!code-csharp[Environment.WorkingSet#1](~/samples/snippets/csharp/VS_Snippets_CLR/Environment.WorkingSet/CS/workingset.cs#1)]
 [!code-vb[Environment.WorkingSet#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Environment.WorkingSet/VB/workingset.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.EnvironmentPermission">для полного доступа к ресурсу, защищенному этим разрешением. Связанное перечисление: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" /></permission>
      </Docs>
    </Member>
  </Members>
</Type>