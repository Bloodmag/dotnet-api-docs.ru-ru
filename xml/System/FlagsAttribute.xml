<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="FlagsAttribute.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5b4a43daf94141e166fdacae6f0ba6f4be584c7b5.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b4a43daf94141e166fdacae6f0ba6f4be584c7b5</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.FlagsAttribute">
          <source>Indicates that an enumeration can be treated as a bit field; that is, a set of flags.</source>
          <target state="translated">Указывает, что перечисление может обрабатываться как битовое поле (т. е. набор флагов).</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Bit fields are generally used for lists of elements that might occur in combination, whereas enumeration constants are generally used for lists of mutually exclusive elements.</source>
          <target state="translated">Битовые поля обычно используются для списков элементов, которые могут возникнуть в сочетании, тогда как константы перечисления обычно используются для списков элементов взаимно исключают друг друга.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Therefore, bit fields are designed to be combined with a bitwise OR operation to generate unnamed values, whereas enumerated constants are not.</source>
          <target state="translated">Таким образом битовые поля предназначены для объединения с помощью побитовой операции или для создания неименованных значений, а констант перечисления.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Languages vary in their use of bit fields compared to enumeration constants.</source>
          <target state="translated">Их использование битовых полей, по сравнению с константами перечисления в разных языках.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Attributes of the FlagsAttribute</source>
          <target state="translated">Атрибуты FlagsAttribute</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source><ph id="ph1">&lt;xref:System.AttributeUsageAttribute&gt;</ph> is applied to this class, and its <ph id="ph2">&lt;xref:System.AttributeUsageAttribute.Inherited%2A&gt;</ph> property specifies <ph id="ph3">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.AttributeUsageAttribute&gt;</ph> применяется к этому классу и его <ph id="ph2">&lt;xref:System.AttributeUsageAttribute.Inherited%2A&gt;</ph> указывает свойство <ph id="ph3">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>This attribute can only be applied to enumerations.</source>
          <target state="translated">Этот атрибут может применяться только к перечислениям.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Guidelines for FlagsAttribute and Enum</source>
          <target state="translated">Рекомендации по FlagsAttribute и перечисления</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Use the <ph id="ph1">&lt;xref:System.FlagsAttribute&gt;</ph> custom attribute for an enumeration only if a bitwise operation (AND, OR, EXCLUSIVE OR) is to be performed on a numeric value.</source>
          <target state="translated">Используйте <ph id="ph1">&lt;xref:System.FlagsAttribute&gt;</ph> настраиваемый атрибут для перечисления только в том случае, если операцию побитового (AND, OR, ИСКЛЮЧАЮЩИЙ или) должно выполняться на основе числового значения.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Define enumeration constants in powers of two, that is, 1, 2, 4, 8, and so on.</source>
          <target state="translated">Объявление констант перечисления в степени двойки, то есть, 1, 2, 4, 8 и т. д.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>This means the individual flags in combined enumeration constants do not overlap.</source>
          <target state="translated">Это означает, что отдельные флаги в сочетании констант перечисления не будут перекрываться.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Consider creating an enumerated constant for commonly used flag combinations.</source>
          <target state="translated">Рассмотрите возможность создания Перечислимая константа для широко используемых сочетаний флагов.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>For example, if you have an enumeration used for file I/O operations that contains the enumerated constants <ph id="ph1">`Read = 1`</ph> and <ph id="ph2">`Write = 2`</ph>, consider creating the enumerated constant <ph id="ph3">`ReadWrite = Read OR Write`</ph>, which combines the <ph id="ph4">`Read`</ph> and <ph id="ph5">`Write`</ph> flags.</source>
          <target state="translated">Например, если у вас есть перечисление, используемое для операций файлового ввода-вывода, содержащий перечислимых констант <ph id="ph1">`Read = 1`</ph> и <ph id="ph2">`Write = 2`</ph>, рассмотрите возможность создания Перечислимая константа <ph id="ph3">`ReadWrite = Read OR Write`</ph>, который объединяет <ph id="ph4">`Read`</ph> и <ph id="ph5">`Write`</ph> флаги.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>In addition, the bitwise OR operation used to combine the flags might be considered an advanced concept in some circumstances that should not be required for simple tasks.</source>
          <target state="translated">Кроме того используются для объединения флаги побитовой операции или может считаться расширенные концепции, в некоторых ситуациях, не должно быть обязательным для простых задач.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Use caution if you define a negative number as a flag enumerated constant because many flag positions might be set to 1, which might make your code confusing and encourage coding errors.</source>
          <target state="translated">Будьте осторожны при определении отрицательное число как константа перечисления флага, так как многие позиций флаг может быть установлен в 1, что может сделать код путаницу и стимулировать ошибки в коде.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>A convenient way to test whether a flag is set in a numeric value is to perform a bitwise AND operation between the numeric value and the flag enumerated constant, which sets all bits in the numeric value to zero that do not correspond to the flag, then test whether the result of that operation is equal to the flag enumerated constant.</source>
          <target state="translated">Удобный способ проверить ли флаг в числовом значении, — для выполнения побитовую операцию и между числовым значением и флаг константа перечислимого типа, который устанавливает все биты в числовое значение к нулю, не соответствуют флаг , затем проверьте, является ли результат этой операции равно константа перечислимого типа флаг.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Use <ph id="ph1">`None`</ph> as the name of the flag enumerated constant whose value is zero.</source>
          <target state="translated">Используйте <ph id="ph1">`None`</ph> как имя флага перечисления константа, значение которого равно нулю.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>You cannot use the <ph id="ph1">`None`</ph> enumerated constant in a bitwise AND operation to test for a flag because the result is always zero.</source>
          <target state="translated">Нельзя использовать <ph id="ph1">`None`</ph> константы перечислимого типа в операцию побитового и для проверки наличия флага, поскольку результат всегда будет равно нулю.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>However, you can perform a logical, not a bitwise, comparison between the numeric value and the <ph id="ph1">`None`</ph> enumerated constant to determine whether any bits in the numeric value are set.</source>
          <target state="translated">Тем не менее, можно выполнять логические, не побитовых сравнение числовое значение и <ph id="ph1">`None`</ph> Перечислимая константа, чтобы определить, установлены ли все биты в числовое значение.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>If you create a value enumeration instead of a flags enumeration, it is still worthwhile to create a <ph id="ph1">`None`</ph> enumerated constant.</source>
          <target state="translated">При создании перечисление значений вместо перечисления flags, он по-прежнему имеет смысл создать <ph id="ph1">`None`</ph> константы перечисления.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The reason is that by default the memory used for the enumeration is initialized to zero by the common language runtime.</source>
          <target state="translated">Причина заключается в том, что по умолчанию объем памяти, используемый для перечисления инициализируется нулевым значением средой CLR.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Consequently, if you do not define a constant whose value is zero, the enumeration will contain an illegal value when it is created.</source>
          <target state="translated">Следовательно Если не определена константа, значение которого равно нулю, перечисление будет содержать недопустимое значение при его создании.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>If there is an obvious default case your application needs to represent, consider using an enumerated constant whose value is zero to represent the default.</source>
          <target state="translated">При наличии очевидного случая по умолчанию, необходимые для представления приложения рассмотрите возможность использования Перечислимая константа, значение которого равно нулю, для представления по умолчанию.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>If there is no default case, consider using an enumerated constant whose value is zero that means the case that is not represented by any of the other enumerated constants.</source>
          <target state="translated">При отсутствии случая по умолчанию, рассмотрите использование Перечислимая константа, значение которого является ноль, означает обращение, не представленного ни перечислимых констант.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Do not define an enumeration value solely to mirror the state of the enumeration itself.</source>
          <target state="translated">Не следует определять значение перечисления исключительно для отражения состояния самого перечисления.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>For example, do not define an enumerated constant that merely marks the end of the enumeration.</source>
          <target state="translated">Например не следует определять Перечислимая константа, которая лишь обозначает конец перечисления.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>If you need to determine the last value of the enumeration, check for that value explicitly.</source>
          <target state="translated">Если необходимо определить последнее значение перечисления, явным образом выполнять проверку для этого значения.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>In addition, you can perform a range check for the first and last enumerated constant if all values within the range are valid.</source>
          <target state="translated">Кроме того можно выполнить проверку диапазона для первой и последней перечислимой константы, если допустимы все значения в диапазоне.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>Do not specify enumerated constants that are reserved for future use.</source>
          <target state="translated">Указывает перечислимые константы, которые зарезервированы для будущего использования.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>When you define a method or property that takes an enumerated constant as a value, consider validating the value.</source>
          <target state="translated">При определении метода или свойства, которое принимает как значение константы перечисления, рекомендуется выполнить проверку значения.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The reason is that you can cast a numeric value to the enumeration type even if that numeric value is not defined in the enumeration.</source>
          <target state="translated">Причина в том, можно привести числовое значение в тип перечисления, даже если это числовое значение не определены в перечислении.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The following example illustrates the use of the <ph id="ph1">`FlagsAttribute`</ph> attribute and shows the effect on the <ph id="ph2">&lt;xref:System.Enum.ToString%2A&gt;</ph> method of using <ph id="ph3">`FlagsAttribute`</ph> on an <ph id="ph4">&lt;xref:System.Enum&gt;</ph> declaration.</source>
          <target state="translated">Следующий пример иллюстрирует использование <ph id="ph1">`FlagsAttribute`</ph> атрибута и показано, как влияет на <ph id="ph2">&lt;xref:System.Enum.ToString%2A&gt;</ph> метод использования <ph id="ph3">`FlagsAttribute`</ph> на <ph id="ph4">&lt;xref:System.Enum&gt;</ph> объявления.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The following example defines two color-related enumerations, <ph id="ph1">`SingleHue`</ph> and <ph id="ph2">`MultiHue`</ph>.</source>
          <target state="translated">В следующем примере определяются два перечисления цветовые <ph id="ph1">`SingleHue`</ph> и <ph id="ph2">`MultiHue`</ph>.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The latter has the <ph id="ph1">`FlagsAttribute`</ph> attribute; the former does not.</source>
          <target state="translated">Последний имеет <ph id="ph1">`FlagsAttribute`</ph> атрибут; первый интерфейс не поддерживает.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>The example shows the difference in behavior when a range of integers, including integers that do not represent underlying values of the enumeration type, are cast to the enumeration type and their string representations displayed.</source>
          <target state="translated">В примере показано различие в поведении при диапазон целых чисел, включая целые числа, которые представляют базовых значений типа перечисления, приводятся в тип перечисления и их строковые представления отображается.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.FlagsAttribute">
          <source>For example, note that 3 cannot be represented as a <ph id="ph1">`SingleHue`</ph> value because 3 is not the underlying value of any <ph id="ph2">`SingleHue`</ph> member, whereas the <ph id="ph3">`FlagsAttribute`</ph> attribute makes it possible to represent 3 as a <ph id="ph4">`MultiHue`</ph> value of <ph id="ph5">`Black, Red`</ph>.</source>
          <target state="translated">Например, обратите внимание, что 3 не может быть представлено как <ph id="ph1">`SingleHue`</ph> значение, так как 3 не базовое значение любого <ph id="ph2">`SingleHue`</ph> член, тогда как <ph id="ph3">`FlagsAttribute`</ph> атрибут делает возможным представляют 3 как <ph id="ph4">`MultiHue`</ph> значение <ph id="ph5">`Black, Red`</ph>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" uid="M:System.FlagsAttribute.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.FlagsAttribute" /&gt;</ph> class.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.FlagsAttribute" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.FlagsAttribute.#ctor">
          <source>The following example defines a <ph id="ph1">`PhoneService`</ph> enumeration that represents forms of communication provided by a telephone company.</source>
          <target state="translated">В следующем примере определяется <ph id="ph1">`PhoneService`</ph> перечисление, представляющее форм, предоставленный компанией телефонной связи.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.FlagsAttribute.#ctor">
          <source>It initializes three variables representing the service provided to three different households, and then indicates which households have no service, which households have only cell phone service, and which households have both cell phone and land line service.</source>
          <target state="translated">Инициализирует три переменные, представляющие службы, предоставленной для трех различных домов и затем указывает, какие семей служба не какие семей имеют только сотовой связи, а какие семей сотовых телефонов и Земли строку службы.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.FlagsAttribute.#ctor">
          <source>Finally, it implicitly calls the <ph id="ph1">&lt;xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> method to display the types of service provided to each household.</source>
          <target state="translated">Наконец, неявно вызывает <ph id="ph1">&lt;xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType&gt;</ph> метод для отображения типов службы, предоставленной для любой владелец.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.FlagsAttribute.#ctor">
          <source>The following example illustrates the use of the <ph id="ph1">`FlagsAttribute`</ph> attribute and shows the effect on the <ph id="ph2">&lt;xref:System.Enum.ToString%2A&gt;</ph> method of using <ph id="ph3">`FlagsAttribute`</ph> on an <ph id="ph4">&lt;xref:System.Enum&gt;</ph> declaration.</source>
          <target state="translated">Следующий пример иллюстрирует использование <ph id="ph1">`FlagsAttribute`</ph> атрибута и показано, как влияет на <ph id="ph2">&lt;xref:System.Enum.ToString%2A&gt;</ph> метод использования <ph id="ph3">`FlagsAttribute`</ph> на <ph id="ph4">&lt;xref:System.Enum&gt;</ph> объявления.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>