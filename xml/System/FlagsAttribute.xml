<Type Name="FlagsAttribute" FullName="System.FlagsAttribute">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4b2417901d3ec970c72a2c6cc0524b2108855ce0" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36431668" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class FlagsAttribute : Attribute" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit FlagsAttribute extends System.Attribute" />
  <TypeSignature Language="DocId" Value="T:System.FlagsAttribute" />
  <TypeSignature Language="VB.NET" Value="Public Class FlagsAttribute&#xA;Inherits Attribute" />
  <TypeSignature Language="C++ CLI" Value="public ref class FlagsAttribute : Attribute" />
  <TypeSignature Language="F#" Value="type FlagsAttribute = class&#xA;    inherit Attribute" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Attribute</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.AttributeUsage(System.AttributeTargets.Enum, Inherited=false)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Указывает, что перечисление может обрабатываться как битовое поле (т. е. набор флагов).</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Битовые поля обычно используются для списков элементов, которые могут возникнуть в сочетании, тогда как константы перечисления обычно используются для списков элементов взаимно исключают друг друга. Таким образом битовые поля предназначены для объединения с помощью побитовой операции или для создания неименованных значений, а констант перечисления. Их использование битовых полей, по сравнению с константами перечисления в разных языках.  
  
## <a name="attributes-of-the-flagsattribute"></a>Атрибуты FlagsAttribute  
 <xref:System.AttributeUsageAttribute> применяется к этому классу и его <xref:System.AttributeUsageAttribute.Inherited%2A> указывает свойство `false`. Этот атрибут может применяться только к перечислениям.  
  
## <a name="guidelines-for-flagsattribute-and-enum"></a>Рекомендации по FlagsAttribute и перечисления  
  
-   Используйте <xref:System.FlagsAttribute> настраиваемый атрибут для перечисления только в том случае, если операцию побитового (AND, OR, ИСКЛЮЧАЮЩИЙ или) должно выполняться на основе числового значения.  
  
-   Объявление констант перечисления в степени двойки, то есть, 1, 2, 4, 8 и т. д. Это означает, что отдельные флаги в сочетании констант перечисления не будут перекрываться.  
  
-   Рассмотрите возможность создания Перечислимая константа для широко используемых сочетаний флагов. Например, если у вас есть перечисление, используемое для операций файлового ввода-вывода, содержащий перечислимых констант `Read = 1` и `Write = 2`, рассмотрите возможность создания Перечислимая константа `ReadWrite = Read OR Write`, который объединяет `Read` и `Write` флаги. Кроме того используются для объединения флаги побитовой операции или может считаться расширенные концепции, в некоторых ситуациях, не должно быть обязательным для простых задач.  
  
-   Будьте осторожны при определении отрицательное число как константа перечисления флага, так как многие позиций флаг может быть установлен в 1, что может сделать код путаницу и стимулировать ошибки в коде.  
  
-   Удобный способ проверить ли флаг в числовом значении, — для выполнения побитовую операцию и между числовым значением и флаг константа перечислимого типа, который устанавливает все биты в числовое значение к нулю, не соответствуют флаг , затем проверьте, является ли результат этой операции равно константа перечислимого типа флаг.  
  
-   Используйте `None` как имя флага перечисления константа, значение которого равно нулю. Нельзя использовать `None` константы перечислимого типа в операцию побитового и для проверки наличия флага, поскольку результат всегда будет равно нулю. Тем не менее, можно выполнять логические, не побитовых сравнение числовое значение и `None` Перечислимая константа, чтобы определить, установлены ли все биты в числовое значение.  
  
     При создании перечисление значений вместо перечисления flags, он по-прежнему имеет смысл создать `None` константы перечисления. Причина заключается в том, что по умолчанию объем памяти, используемый для перечисления инициализируется нулевым значением средой CLR. Следовательно Если не определена константа, значение которого равно нулю, перечисление будет содержать недопустимое значение при его создании.  
  
     При наличии очевидного случая по умолчанию, необходимые для представления приложения рассмотрите возможность использования Перечислимая константа, значение которого равно нулю, для представления по умолчанию. При отсутствии случая по умолчанию, рассмотрите использование Перечислимая константа, значение которого является ноль, означает обращение, не представленного ни перечислимых констант.  
  
-   Не следует определять значение перечисления исключительно для отражения состояния самого перечисления. Например не следует определять Перечислимая константа, которая лишь обозначает конец перечисления. Если необходимо определить последнее значение перечисления, явным образом выполнять проверку для этого значения. Кроме того можно выполнить проверку диапазона для первой и последней перечислимой константы, если допустимы все значения в диапазоне.  
  
-   Указывает перечислимые константы, которые зарезервированы для будущего использования.  
  
-   При определении метода или свойства, которое принимает как значение константы перечисления, рекомендуется выполнить проверку значения. Причина в том, можно привести числовое значение в тип перечисления, даже если это числовое значение не определены в перечислении.  
  
   
  
## Examples  
 Следующий пример иллюстрирует использование `FlagsAttribute` атрибута и показано, как влияет на <xref:System.Enum.ToString%2A> метод использования `FlagsAttribute` на <xref:System.Enum> объявления.  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 В следующем примере определяются два перечисления цветовые `SingleHue` и `MultiHue`. Последний имеет `FlagsAttribute` атрибут; первый интерфейс не поддерживает. В примере показано различие в поведении при диапазон целых чисел, включая целые числа, которые представляют базовых значений типа перечисления, приводятся в тип перечисления и их строковые представления отображается.   Например, обратите внимание, что 3 не может быть представлено как `SingleHue` значение, так как 3 не базовое значение любого `SingleHue` член, тогда как `FlagsAttribute` атрибут делает возможным представляют 3 как `MultiHue` значение `Black, Red`.  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public FlagsAttribute ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.FlagsAttribute.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; FlagsAttribute();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.FlagsAttribute" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере определяется `PhoneService` перечисление, представляющее форм, предоставленный компанией телефонной связи. Инициализирует три переменные, представляющие службы, предоставленной для трех различных домов и затем указывает, какие семей служба не какие семей имеют только сотовой связи, а какие семей сотовых телефонов и Земли строку службы. Наконец, неявно вызывает <xref:System.Enum.ToString%28System.String%29?displayProperty=nameWithType> метод для отображения типов службы, предоставленной для любой владелец.  
  
 [!code-cpp[System.FlagsAttribute#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags1.cpp#2)]
 [!code-csharp[System.FlagsAttribute#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags1.cs#2)]
 [!code-vb[System.FlagsAttribute#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags1.vb#2)]  
  
 Следующий пример иллюстрирует использование `FlagsAttribute` атрибута и показано, как влияет на <xref:System.Enum.ToString%2A> метод использования `FlagsAttribute` на <xref:System.Enum> объявления.  
  
 [!code-cpp[System.FlagsAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.FlagsAttribute/CPP/flags.cpp#1)]
 [!code-csharp[System.FlagsAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.FlagsAttribute/CS/flags.cs#1)]
 [!code-vb[System.FlagsAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.FlagsAttribute/VB/flags.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>