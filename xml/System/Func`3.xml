<Type Name="Func&lt;T1,T2,TResult&gt;" FullName="System.Func&lt;T1,T2,TResult&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7d81a800a1274d7a6e8f8da7fb40438e85b38d11" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36431701" />
  </Metadata>
  <TypeSignature Language="C#" Value="public delegate TResult Func&lt;in T1,in T2,out TResult&gt;(T1 arg1, T2 arg2);" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed Func`3&lt;- T1, - T2, + TResult&gt; extends System.MulticastDelegate" />
  <TypeSignature Language="DocId" Value="T:System.Func`3" />
  <TypeSignature Language="VB.NET" Value="Public Delegate Function Func(Of In T1, In T2, Out TResult)(arg1 As T1, arg2 As T2) As TResult " />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T1, typename T2, typename TResult&gt;&#xA;public delegate TResult Func(T1 arg1, T2 arg2);" />
  <TypeSignature Language="F#" Value="type Func&lt;'T1, 'T2, 'Result&gt; = delegate of 'T1 * 'T2 -&gt; 'Result" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T1">
      <Constraints>
        <ParameterAttribute>Contravariant</ParameterAttribute>
      </Constraints>
    </TypeParameter>
    <TypeParameter Name="T2">
      <Constraints>
        <ParameterAttribute>Contravariant</ParameterAttribute>
      </Constraints>
    </TypeParameter>
    <TypeParameter Name="TResult">
      <Constraints>
        <ParameterAttribute>Covariant</ParameterAttribute>
      </Constraints>
    </TypeParameter>
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Delegate</BaseTypeName>
  </Base>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.TypeForwardedFrom("System.Core, Version=3.5.0.0, Culture=Neutral, PublicKeyToken=b77a5c561934e089")</AttributeName>
    </Attribute>
  </Attributes>
  <Parameters>
    <Parameter Name="arg1" Type="T1" />
    <Parameter Name="arg2" Type="T2" />
  </Parameters>
  <ReturnValue>
    <ReturnType>TResult</ReturnType>
  </ReturnValue>
  <Docs>
    <typeparam name="T1">Тип первого параметра метода, инкапсулируемого этим делегатом.</typeparam>
    <typeparam name="T2">Тип второго параметра метода, инкапсулируемого данным делегатом.</typeparam>
    <typeparam name="TResult">Тип возвращаемого значения метода, инкапсулируемого данным делегатом.</typeparam>
    <param name="arg1">Первый параметр метода, инкапсулируемого этим делегатом.</param>
    <param name="arg2">Второй параметр метода, инкапсулируемого этим делегатом.</param>
    <summary>Инкапсулирует метод с двумя параметрами и возвращает значение типа, указанного в параметре <typeparamref name="TResult" />.</summary>
    <returns>Возвращаемое значение метода, инкапсулируемого данным делегатом.</returns>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот делегат можно использовать для представления метода, который может быть передан в качестве параметра без явного объявления пользовательского делегата. Инкапсулированный метод должен соответствовать сигнатуре метода, определенные этим делегатом. Это означает, что инкапсулированный метод должен иметь два параметра, каждый из которых передается по значению, и что он должен возвращать значение.  
  
> [!NOTE]
>  Для ссылки на метод, который имеет два параметра и возвращает `void` (или в Visual Basic, объявленный как `Sub` , а не как `Function`), использовать универсальный <xref:System.Action%602> вместо этого делегата.  
  
 При использовании <xref:System.Func%603> делегата, вам не нужно явным образом определять делегат, инкапсулирующий метод с двумя параметрами. Например, в следующем коде явно объявляется делегат с именем `ExtractMethod` и ссылка на `ExtractWords` способ его экземпляр делегата.  
  
 [!code-csharp[System.Func~3#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Func~3/cs/Delegate.cs#1)]
 [!code-vb[System.Func~3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Func~3/vb/Delegate.vb#1)]  
  
 В следующем примере этот код упрощается путем создания экземпляра <xref:System.Func%603> делегат вместо явного объявления нового делегата и присвоения именованного метода.  
  
 [!code-csharp[System.Func~3#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Func~3/cs/Func3.cs#2)]
 [!code-vb[System.Func~3#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Func~3/vb/Func3.vb#2)]  
  
 Можно использовать <xref:System.Func%603> делегировать с анонимных методов в C#, как показано в следующем примере. (Введение анонимных методов см. в разделе [анонимные методы](~/docs/csharp/programming-guide/statements-expressions-operators/anonymous-methods.md).)  
  
 [!code-csharp[System.Func~3#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Func~3/cs/Anon.cs#3)]  
  
 Можно также назначить лямбда-выражение, <xref:System.Func%603> делегат, как показано в следующем примере. (Введение лямбда-выражений см. в разделе [лямбда-выражения](~/docs/visual-basic/programming-guide/language-features/procedures/lambda-expressions.md) и [лямбда-выражения](~/docs/csharp/programming-guide/statements-expressions-operators/lambda-expressions.md).)  
  
 [!code-csharp[System.Func~3#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Func~3/cs/Lambda.cs#4)]
 [!code-vb[System.Func~3#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Func~3/vb/lambda.vb#4)]  
  
 Базовый тип лямбда-выражения является одним из универсальных `Func` делегатов. Это дает возможность передать лямбда-выражение в качестве параметра без явного присвоения его делегату. В частности так как многие методы типов в <xref:System.Linq> пространство имен имеет <xref:System.Func%603> параметры, можно передать эти методы лямбда-выражение без явного создания <xref:System.Func%603> делегата.  
  
   
  
## Examples  
 Следующий пример демонстрирует объявление и использование <xref:System.Func%603> делегата. В этом примере объявляется <xref:System.Func%603> переменной и присваивает его лямбда-выражения, принимающего <xref:System.String> значение и <xref:System.Int32> значение в качестве параметров. Лямбда-выражение возвращает `true` Если длина <xref:System.String> равен значению <xref:System.Int32> параметра. Делегат, инкапсулирующий этот метод впоследствии используется в запросе для фильтрации строк в массиве строк.  
  
 [!code-csharp[System.Func~3#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Func~3/cs/Example.cs#5)]
 [!code-vb[System.Func~3#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Func~3/vb/Example.vb#5)]  
  
 ]]></format>
    </remarks>
  </Docs>
</Type>