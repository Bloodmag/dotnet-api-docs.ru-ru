<Type Name="GC" FullName="System.GC">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="11996d97bef6121bce982a8368bef5e8197c8a44" />
    <Meta Name="ms.sourcegitcommit" Value="1465f1a9bce3970cd9e95769eaa641b92a0a22d5" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/18/2018" />
    <Meta Name="ms.locfileid" Value="31469403" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class GC" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GC extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.GC" />
  <TypeSignature Language="VB.NET" Value="Public Class GC" />
  <TypeSignature Language="C++ CLI" Value="public ref class GC abstract sealed" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Управляет системным сборщиком мусора — службой, которая автоматически высвобождает неиспользуемую память.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сборщик мусора — это компонент времени выполнения, который управляет выделением и освобождением памяти для управляемых. Методы в этом классе влияют при выполнении сборки мусора для объекта и освобождение ресурсов, выделенных с помощью объекта. Свойства этого класса предоставляют сведения о общий объем доступной памяти в системе и возрастную категорию или создание память, выделенная для объекта.  
  
 Сборщик мусора отслеживает и уничтожает объекты, находящиеся в управляемой памяти. Периодически сборщик мусора выполняет сборку мусора освободить память, выделенную для объектов, для которых не существует допустимых ссылок. Сборка мусора происходит автоматически, если запрос на выделение памяти не может быть удовлетворено доступного объема свободной памяти. Кроме того, приложение может принудительно запустить с помощью сбора мусора <xref:System.GC.Collect%2A> метод.  
  
 Сборка мусора состоит из следующих шагов:  
  
1.  Сборщик мусора выполняет поиск управляемых объектов, на которые имеются ссылки в управляемом коде.  
  
2.  Сборщик мусора пытается завершить объекты, на которые нет ссылок.  
  
3.  Сборщик мусора освобождает объекты, на которые нет ссылок и освобождает память.  
  
 Этот раздел включает следующие подразделы:  
  
 [Сборщик мусора и неуправляемые ресурсы](#unmanaged)   
 [Время существования объектов и версий](#generations)   
 [Отключение сбора мусора](#NoGCRegion)  
  
<a name="unmanaged"></a>   
## <a name="the-garbage-collector-and-unmanaged-resources"></a>Сборщик мусора и неуправляемые ресурсы  
 Во время сбора сборщик мусора не освобождает объект, при обнаружении одну или несколько ссылок на объект в управляемом коде. Тем не менее сборщик мусора не распознает ссылки на объект из неуправляемого кода и может уничтожать объекты, которые используются исключительно в неуправляемом коде, если явно запрещено сделать это. <xref:System.GC.KeepAlive%2A> Метод предоставляет механизм, который не позволяет сборщику мусора уничтожать объекты, которые по-прежнему используются в неуправляемом коде.  
  
 Помимо распределения управляемой памяти реализации сборщика мусора не работают со сведениями о ресурсах, принадлежащих объекту, таких как дескрипторы файлов или подключения к базе данных. Если тип использует неуправляемые ресурсы, которые должны быть освобождены до освобождения экземпляров типа, этот тип может реализовать метод завершения.  
  
 В большинстве случаев финализаторы реализуются путем переопределения <xref:System.Object.Finalize%2A?displayProperty=nameWithType> метод; Однако типы, написанные на C# или C++ реализуют деструкторы, которые компилятор преобразует в переопределения <xref:System.Object.Finalize%2A?displayProperty=nameWithType>. В большинстве случаев Если у объекта есть метод завершения, сборщик мусора вызывает его до освобождения объекта. Тем не менее сборщик мусора не требуется вызывать методы завершения во всех случаях; например <xref:System.GC.SuppressFinalize%2A> метод явным образом запрещает метода завершения объекта вызова. Кроме того сборщик мусора не требуется для использования определенного потока для завершения объектов или гарантировал порядок вызова методов завершения для объектов, которые ссылаются друг на друга, но в остальном доступных для сборки мусора.  
  
 В сценариях, где ресурсы должны быть освобождены в определенное время, классы могут реализовывать <xref:System.IDisposable> интерфейс, содержащий <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> метод, который выполняет задачи управления и очистку ресурсов. Классы, реализующие <xref:System.IDisposable.Dispose%2A> , необходимо указать как часть своего контракта класса, и время вызова метода очистки объекта потребителями класса. Сборщик мусора не, по умолчанию вызывает <xref:System.IDisposable.Dispose%2A> метод, однако реализации <xref:System.IDisposable.Dispose%2A> метод можно вызывать методы в <xref:System.GC> класса для настройки поведения сборщика мусора.  
  
 Дополнительные сведения о завершении объекта и шаблон dispose см. в разделе [очистки неуправляемых ресурсов](~/docs/standard/garbage-collection/unmanaged.md).  
  
<a name="generations"></a>   
## <a name="object-aging-and-generations"></a>Время существования объектов и версий  
 В среде CLR сборщик мусора поддерживает концепцию возраста объектов поколений. Поколение — это единица измерения относительного времени хранения объектов в памяти. Номер поколения, или возраст объекта указывает поколения, к которой принадлежит объект. Объекты, создаваемые дополнительные недавно входят новые поколения и имеют меньший номер поколения, чем объекты, созданные ранее в приложение жизненного цикла. Объекты в поколении самые последние находятся в поколении 0. Данная реализация сборщика мусора поддерживает три поколения объектов поколения 0, 1 и 2. Можно извлечь значение <xref:System.GC.MaxGeneration%2A> свойства, чтобы определить максимальный номер поколения поддерживается системой.  
  
 Время существования объекта позволяет приложениям целевой сборка мусора на определенное число поколений, вместо сборщику мусора обрабатывать все поколения. Перегруженные версии <xref:System.GC.Collect%2A> метод, который включает `generation` позволяют указать мусора старших поколений.  
  
<a name="NoGCRegion"></a>   
## <a name="disallowing-garbage-collection"></a>Отключение сбора мусора  
 Начиная с [!INCLUDE[net_v46](~/includes/net-v46-md.md)], сборщик мусора поддерживает GC режим задержки без области, можно использовать во время выполнения критического пути, в какой сборке мусора коллекции может отрицательно сказаться на производительности приложения. Сборка Мусора режим задержки без области необходимо указать объем памяти, который может быть выделен без помех сборщиком мусора. Если среда выполнения может выделить память, среда выполнения не выполнит сбор мусора во время выполнения кода на критическом пути.  
  
 Определение начала критический путь без области сборки Мусора путем вызова одной из перегрузок <xref:System.GC.TryStartNoGCRegion%2A>. Укажите окончание его критическим путем вызова <xref:System.GC.EndNoGCRegion%2A> метод.  
  
 Не удается вложить вызовы <xref:System.GC.TryStartNoGCRegion%2A> метод и вы должны вызывать только <xref:System.GC.EndNoGCRegion%2A> метод, если среда выполнения в данный момент в режим задержки без области сборки Мусора. Другими словами, не следует вызывать <xref:System.GC.TryStartNoGCRegion%2A> несколько раз (после первого вызова метода, последующие вызовы не будет выполнено), и не должен ожидать вызовы <xref:System.GC.EndNoGCRegion%2A> для успешного выполнения только потому, что первый вызов <xref:System.GC.TryStartNoGCRegion%2A> успешно выполнен.  
  
   
  
## Examples  
 В следующем примере несколько методов сборки Мусора поколения памяти данные о блоке неиспользуемых объектов и печати на консоль. Неиспользуемые объекты затем собираются и отображаются результирующие итоги памяти.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.GCSettings" />
  </Docs>
  <Members>
    <Member MemberName="AddMemoryPressure">
      <MemberSignature Language="C#" Value="public static void AddMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.AddMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMemoryPressure(long bytesAllocated);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">Дополнительный объем выделенной неуправляемой памяти.</param>
        <summary>Информирует среду выполнения о выделении большого объема неуправляемой памяти, которую необходимо учесть при планировании сборки мусора.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При определении времени запланировать сбор мусора, среда выполнения учитывает выделенный объем управляемой памяти. Если маленький управляемый объект выделяет большой объем неуправляемой памяти, среда выполнения учитывает только управляемую память и поэтому недооценивает срочность планирования сборки мусора. <xref:System.GC.AddMemoryPressure%2A> Метод информирует среду выполнения о этот дополнительную нагрузку на системную память.  
  
 В простейшей схеме использования управляемый объект выделяет неуправляемую память в конструкторе и освобождает его в `Dispose` или `Finalize` метод. Вызовите <xref:System.GC.AddMemoryPressure%2A> метод после выделения неуправляемой памяти и вызывать <xref:System.GC.RemoveMemoryPressure%2A> метод после ее освобождения.  
  
 В более сложных сценариях, где выделения неуправляемой памяти существенно изменяется за время жизни управляемого объекта, можно вызвать <xref:System.GC.AddMemoryPressure%2A> и <xref:System.GC.RemoveMemoryPressure%2A> методов для взаимодействия эти добавочных изменений в среду выполнения.  
  
> [!CAUTION]
>  Необходимо гарантировать, что удаляется точно степень давления, можно добавить. Невыполнение этого может отрицательно сказаться на производительности системы в приложениях, выполняемых в течение длительного времени.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bytesAllocated" /> меньше или равно 0.  
  
 - или -  
  
 На 32-разрядном компьютере <paramref name="bytesAllocated" /> больше <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода, при обработке приоритетом сборки мусора. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="CancelFullGCNotification">
      <MemberSignature Language="C#" Value="public static void CancelFullGCNotification ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelFullGCNotification() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CancelFullGCNotification" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelFullGCNotification ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelFullGCNotification();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Отменяет регистрацию уведомления о сборке мусора.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод отменяет уведомление о сборке мусора, зарегистрированный с помощью <xref:System.GC.RegisterForFullGCNotification%2A> метод. Нет необходимости вызывать этот метод перед настройкой пороговые значения параметра в последующих вызовах <xref:System.GC.RegisterForFullGCNotification%2A> метод.  
  
   
  
## Examples  
 В следующем примере отменяется регистрация сборки мусора. Данный пример является частью большего примера, приведенного для [сборке мусора](~/docs/standard/garbage-collection/notifications.md) раздела.  
  
 [!code-cpp[GCNotification#7](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#7)]
 [!code-csharp[GCNotification#7](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#7)]
 [!code-vb[GCNotification#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Этот член недоступен, если включена параллельная сборка мусора. Сведения об отключении параллельной сборки мусора см. в статье, посвященной параметру среды выполнения [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md).</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="Collect">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Принудительно начинает сборку мусора.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Принудительно запускает немедленную сборку мусора для всех поколений.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, чтобы попытаться освободить всю память, который недоступен. Он выполняет блокирующей сборки мусора для всех поколений.  
  
 Все объекты, независимо от того, как долго они находятся в памяти, считаются для коллекции. Тем не менее объекты, на которые имеются ссылки в управляемом коде, не собираются. Используйте этот метод, чтобы принудительно предпринять попытку высвободить максимальный объем доступной памяти.  
  
 Начиная с [!INCLUDE[net_v451](~/includes/net-v451-md.md)], можно сжать кучи больших объектов (LOH), задав <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> свойства <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> перед вызовом <xref:System.GC.Collect%2A> метода, как приведенный ниже пример иллюстрирует.  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
   
  
## Examples  
 В следующем примере демонстрируется использование <xref:System.GC.Collect%2A> метод, чтобы выполнить сборку мусора для всех поколений памяти. Код создает число неиспользуемых объектов, а затем вызывает <xref:System.GC.Collect%2A> метод для их удаления из памяти.  
  
 [!code-cpp[System.GC.Collect Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.Collect Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.Collect Example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.Collect Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">Количество старших поколений, для которых следует выполнить сборку мусора.</param>
        <summary>Принудительно начинает немедленную сборку мусора, начиная с нулевого поколения и вплоть до указанного поколения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для освобождения памяти, который недоступен. Тем не менее с помощью этого метода не гарантирует что всей недоступной памяти в указанном поколении.  
  
 Если реализована время существования объекта, сборщик мусора не собирать объекты с номер поколения, превышающего заданного поколения. Если не используется время существования объекта, сборщик мусора считает, что все объекты во время сборки мусора.  
  
 Используйте <xref:System.GC.MaxGeneration%2A> свойства, чтобы определить максимальное допустимое значение параметра `generation` параметр.  
  
 Чтобы сборщик мусора учитывать все объекты, независимо от их поколения, используйте версию этого метода, который не имеет параметров. Чтобы сборщик мусора освобождает объекты, на основе <xref:System.GCCollectionMode> установка, использование <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> перегрузки метода.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование <xref:System.GC.Collect%2A> метод, чтобы выполнить сборку мусора для отдельных уровней памяти. Код создает число неиспользуемых объектов, а затем вызывает <xref:System.GC.Collect%2A> метод для их удаления из памяти.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Недопустимый параметр <paramref name="generation" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
      </Parameters>
      <Docs>
        <param name="generation">Количество старших поколений, для которых следует выполнить сборку мусора.</param>
        <param name="mode">Значение перечисления, указывающее, является ли сборка мусора принудительной (<see cref="F:System.GCCollectionMode.Default" /> или <see cref="F:System.GCCollectionMode.Forced" />) или оптимизированной (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <summary>Принудительно запускает немедленную сборку мусора начиная с нулевого поколения и вплоть до указанного поколения в момент времени, заданный значением <see cref="T:System.GCCollectionMode" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте `mode` для указания, является ли сборка мусора должно выполняться немедленно или только если время является оптимальным для освобождения объектов. С помощью этого метода не гарантирует что всей недоступной памяти в указанном поколении.  
  
 Чтобы настроить степень вмешательства сборщика мусора в приложении в критические периоды, установите <xref:System.Runtime.GCSettings.LatencyMode%2A> свойство.  
  
 Сборщик мусора не пытается освободить объекты номер поколения, выше, чем указано в `generation` параметра. Используйте <xref:System.GC.MaxGeneration%2A> свойства, чтобы определить максимальное допустимое значение параметра `generation`.  
  
 Чтобы сборщик мусора учитывать все объекты, независимо от их поколения, используйте версию этого метода, который не имеет параметров.  
  
 Чтобы сборщик мусора освобождает объекты, вплоть до указанного поколения объектов, используйте <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> перегрузки метода. При указании максимальное поколение, освобождаются все объекты.  
  
   
  
## Examples  
 Следующий пример вызывает сборку мусора для объектов поколения 2 с <xref:System.GCCollectionMode.Optimized> параметр.  
  
 [!code-csharp[System.GC.GCCollectionMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GCCollectionMode/cs/Program.cs#1)]
 [!code-vb[System.GC.GCCollectionMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GCCollectionMode/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Недопустимый параметр <paramref name="generation" />.  
  
 - или -  
  
 <paramref name="mode" /> не является одним из значений <see cref="T:System.GCCollectionMode" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">Количество старших поколений, для которых следует выполнить сборку мусора.</param>
        <param name="mode">Значение перечисления, указывающее, является ли сборка мусора принудительной (<see cref="F:System.GCCollectionMode.Default" /> или <see cref="F:System.GCCollectionMode.Forced" />) или оптимизированной (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <param name="blocking">
          Значение <see langword="true" /> для выполнения блокирующей сборки мусора; значение <see langword="false" /> для выполнения фоновой сборки мусора, где это возможно.</param>
        <summary>Принудительная сборка мусора с поколения 0 до указанного поколения во время, указанное значением <see cref="T:System.GCCollectionMode" />, со значением, указывающим, должна ли сборка быть блокирующей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 В следующей таблице перечислены взаимодействия `mode` и `blocking` параметры:  
  
|`mode`|`blocking` равно `true`|`blocking` равно `false`|  
|-|-|-|  
|<xref:System.GCCollectionMode.Forced> или <xref:System.GCCollectionMode.Default>|Блокирующий сбор выполнится, как только это станет возможным. Если выполняется фоновая сборка мусора и `generation` равен 0 или 1, <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> метод немедленно запускает заблокированной коллекции и возвращает при завершении коллекции. Если выполняется фоновая сборка мусора и `generation` 2, метод ожидает, пока фоновая сборка мусора завершения работы вызывает блокирующие сборки поколения 2 и возвращает.|Сборка выполнится, как только это станет возможным. Метод <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> запрашивает фоновую сборку, но не гарантирует этот режим. В зависимости от обстоятельств может выполняться блокирующая сборка. Если фоновая сборка уже выполняется, метод возвращает управление немедленно.|  
|<xref:System.GCCollectionMode.Optimized>|В зависимости от текущего состояния сборщика мусора и значения параметра `generation` может выполняться блокирующая сборка. Сборщик мусора пытается обеспечить оптимальную производительность.|Сборка может быть выполнена в зависимости от состояния сборщика мусора. Метод <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> запрашивает фоновую сборку, но не гарантирует этот режим. В зависимости от обстоятельств может выполняться блокирующая сборка. Сборщик мусора пытается обеспечить оптимальную производительность. Если фоновая сборка уже выполняется, метод возвращает управление немедленно.|  
  
 Если вызов <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> метод выполняет полной блокирующей сборки мусора, можно также сжать кучи больших объектов, задав <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> свойства <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> перед вызовом <xref:System.GC.Collect%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Недопустимый параметр <paramref name="generation" />.  
  
 - или -  
  
 <paramref name="mode" /> не является одним из значений <see cref="T:System.GCCollectionMode" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking, bool compacting) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean, compacting As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
        <Parameter Name="compacting" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">Количество старших поколений, для которых следует выполнить сборку мусора.</param>
        <param name="mode">Значение перечисления, указывающее, является ли сборка мусора принудительной (<see cref="F:System.GCCollectionMode.Default" /> или <see cref="F:System.GCCollectionMode.Forced" />) или оптимизированной (<see cref="F:System.GCCollectionMode.Optimized" />).</param>
        <param name="blocking">
          Значение <see langword="true" /> для выполнения блокирующей сборки мусора; значение <see langword="false" /> для выполнения фоновой сборки мусора, где это возможно.</param>
        <param name="compacting">
          Значение <see langword="true" />, чтобы сжимать кучу маленьких объектов; значение <see langword="false" />, чтобы только очищать.</param>
        <summary>Принудительная сборка мусора с поколения 0 до указанного поколения во время, указанное значением <see cref="T:System.GCCollectionMode" />, со значениями, указывающими, должна ли сборка быть блокирующей и сжимающей.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `blocking` — `false`, сборщик Мусора решает, следует ли выполнять фоновый рисунок или блокирующей сборки мусора. Если `compacting` — `true`, он выполняет блокирующей сборки мусора.  
  
 Если `compacting` — `true`, среда выполнения сжимает кучу небольших объектов (SOH). Для кучи больших объектов (LOH) не сжимается, если не <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> свойству <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>. Обратите внимание, что в нем все блокировка сборки мусора, не только полностью блокирующие сборки мусора.  
  
 Можно вызвать <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> способ уменьшить до наименьшего возможного размера, в управляемой куче, как показано в следующем фрагменте кода.  
  
 [!code-csharp[System.GC.Collect#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)]
 [!code-vb[System.GC.Collect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)]  
  
 Указание `true` для `compacting` аргумент гарантирует со сжатием, полной блокирующей сборки мусора. Установка <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> свойства <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> гарантирует сжимаются LOH и состояние работоспособности.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionCount">
      <MemberSignature Language="C#" Value="public static int CollectionCount (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CollectionCount(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CollectionCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CollectionCount (generation As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CollectionCount(int generation);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">Поколение объектов, для которого будет определено количество операций сборки мусора.</param>
        <summary>Возвращает количество операций сборки мусора, выполненных для заданного поколения объектов.</summary>
        <returns>Количество операций сборки мусора, выполненных для заданного поколения объектов с начала процесса.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если вы реализуете собственное управление ресурсами, может потребоваться принудительно запустить сборку мусора периодически путем вызова <xref:System.GC.Collect%2A> метод. Поскольку это ресурсоемкая операция, пропустив вызов после сборки мусора недавно может повысить производительность. Сохранить значение, возвращаемое <xref:System.GC.CollectionCount%2A> сразу после вызова <xref:System.GC.Collect%2A>. В следующий раз, необходимо вызвать <xref:System.GC.Collect%2A>, сравнения текущего значения, возвращенного <xref:System.GC.CollectionCount%2A> сохраненному значению. Если два значения равны, ни одна из коллекций произошла за этот промежуток времени, и имеет смысл для вызова <xref:System.GC.Collect%2A> еще раз.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="generation" /> меньше 0.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndNoGCRegion">
      <MemberSignature Language="C#" Value="public static void EndNoGCRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndNoGCRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.EndNoGCRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndNoGCRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndNoGCRegion();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Завершает режим задержки без области сборки мусора.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.EndNoGCRegion%2A> Вызывает исключение <xref:System.InvalidOperationException> если сборщик мусора не входит в режим задержки без области сборки Мусора. Это происходит при выполнении любого из следующих условий:  
  
-   <xref:System.GC.TryStartNoGCRegion%2A> Метод не был вызван ранее.  
  
-   Вызов <xref:System.GC.TryStartNoGCRegion%2A> возвращаемое значение метода `false`.  
  
-   Вызов <xref:System.GC.TryStartNoGCRegion%2A> метод исключение.  
  
 С помощью следующего кода можно предотвратить возникновение исключений для любой из следующих причин:  
  
 [!code-csharp[System.GC.EndNoGCRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)]
 [!code-vb[System.GC.EndNoGCRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Сборщик мусора не находится в режиме задержки без области сборки мусора.  
  
 - или -  
  
 Режим задержки без области сборки мусора был завершен заранее, поскольку была вызвана сборка мусора.  
  
 - или -  
  
 Выделение памяти превышает объем, указанный в вызове метода <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />.</exception>
        <altmember cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />
        <altmember cref="P:System.Runtime.GCSettings.LatencyMode" />
      </Docs>
    </Member>
    <Member MemberName="GetAllocatedBytesForCurrentThread">
      <MemberSignature Language="C#" Value="public static long GetAllocatedBytesForCurrentThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetAllocatedBytesForCurrentThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetAllocatedBytesForCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllocatedBytesForCurrentThread () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetAllocatedBytesForCurrentThread();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGeneration">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает текущий номер поколения объекта.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, информация о поколении которого извлекается.</param>
        <summary>Возвращает номер текущего поколения указанного объекта.</summary>
        <returns>Текущий номер поколения <paramref name="obj" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод, чтобы определить возраст объекта, а затем использовать эти сведения с <xref:System.GC.Collect%2A> метод, чтобы сборщик мусора для сбора объектов этого поколения. Например используйте этот метод, если у вас есть набор объектов, которые были созданы группы и стали недоступными одновременно.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование <xref:System.GC.GetGeneration%2A> метод, чтобы определить возраст объекта. Затем в примере выполняется сборки мусора для очистки памяти и сравнения pre и post итоги памяти коллекцию в консоли.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (WeakReference wo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(class System.WeakReference wo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.WeakReference)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (wo As WeakReference) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(WeakReference ^ wo);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="wo" Type="System.WeakReference" />
      </Parameters>
      <Docs>
        <param name="wo">Объект <see cref="T:System.WeakReference" />, указывающий на целевой объект, номер поколения которого требуется определить.</param>
        <summary>Возвращает текущий номер поколения для целевого объекта указанной слабой ссылки.</summary>
        <returns>Текущий номер поколения для целевого объекта <paramref name="wo" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 В следующем примере показано использование <xref:System.GC.GetGeneration%2A> метод, чтобы определить возраст объект слабой ссылки.  
  
 [!code-cpp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CPP/systemgcgetgenerationweak.cpp#1)]
 [!code-csharp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CS/systemgcgetgenerationweak.cs#1)]
 [!code-vb[System.GC.GetGenerationWeak Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/VB/systemgcgetgenerationweak.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Сборка мусора уже выполнена для <paramref name="wo" />.</exception>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetTotalMemory">
      <MemberSignature Language="C#" Value="public static long GetTotalMemory (bool forceFullCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalMemory(bool forceFullCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalMemory(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalMemory (forceFullCollection As Boolean) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetTotalMemory(bool forceFullCollection);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceFullCollection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forceFullCollection">
          Значение <see langword="true" />, указывающий, что перед возвратом этот метод может дождаться выполнения сборки мусора; в противном случае — <see langword="false" />.</param>
        <summary>Извлекает предполагаемое количество выделенных в данный момент байтов. Параметр указывает, может ли этот метод выдержать короткий интервал времени ожидания перед возвратом, пока система выполняет сборку мусора и завершает объекты.</summary>
        <returns>Наилучшая доступная аппроксимация числа байтов, распределенных в данный момент в управляемой памяти.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если `forceFullCollection` параметр `true`, этот метод ожидает короткий интервал времени перед возвратом, пока система выполняет сборку мусора и завершает объекты. Длительность интервала — внутренне определяемый предел зависит от числа завершенных циклов сборки мусора и изменения восстановленного объема памяти между циклами. Сборщик мусора не гарантирует, что собираются все недоступной памяти.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование <xref:System.GC.GetTotalMemory%2A> метода для возврата и отображения число байтов, выделенных в данный момент в управляемой памяти.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public static void KeepAlive (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KeepAlive(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.KeepAlive(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KeepAlive (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KeepAlive(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект для ссылки.</param>
        <summary>Ссылается на указанный объект, делая его недоступным для сборщика мусора с момента начала текущей процедуры до вызова этого метода.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Назначение <xref:System.GC.KeepAlive%2A> проще гарантировать наличие ссылки на объект, который может быть преждевременно освобожден сборщиком мусора. Является распространенным сценарием, где это может произойти при отсутствии ссылок на объект в управляемом коде или в данных, но он по-прежнему используется в неуправляемый код, например API-интерфейсов Win32, неуправляемые библиотеки DLL или методы, с помощью COM.  
  
 Этот метод ссылается `obj` параметр в результате этого объекта недоступным для сборщика мусора начала процедуры к точке, в порядке выполнения, где вызывается этот метод. Код этого метода в конце, а не в начале диапазона инструкций, где `obj` должны быть доступны.  
  
 <xref:System.GC.KeepAlive%2A> Метод не выполняет никаких действий и не производит побочных эффектов Кроме увеличения времени существования объекта, переданного в качестве параметра.  
  
   
  
## Examples  
 В следующем примере кода создается объект в начале его `Main` метода и не ссылается на объект до самого конца при <xref:System.GC.KeepAlive%2A> вызывается метод. Объект сохраняется в течение 30 секунд `Main` метода, несмотря на вызовы <xref:System.GC.Collect%2A> и <xref:System.GC.WaitForPendingFinalizers%2A> методы.  
  
 [!code-cpp[System.GC.KeepAlive Example2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CPP/gckeepalive.cpp#1)]
 [!code-csharp[System.GC.KeepAlive Example2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CS/gckeepalive.cs#1)]
 [!code-vb[System.GC.KeepAlive Example2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/VB/gckeepalive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxGeneration">
      <MemberSignature Language="C#" Value="public static int MaxGeneration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxGeneration" />
      <MemberSignature Language="DocId" Value="P:System.GC.MaxGeneration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxGeneration As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxGeneration { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает наибольшее число поколений, поддерживаемое системой в настоящее время.</summary>
        <value>Значение от нуля до максимального числа поддерживаемых поколений.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Номер поколения, или возраст объекта является определяемым относительная мера времени существования объекта зависящая от. Недавно созданные объекты в поколении 0 и старые объекты находящиеся в поколение меньше или равно поколение возвращенных <xref:System.GC.MaxGeneration%2A> свойство.  
  
 Сборщик мусора предполагает, что память, выделенная является наиболее вероятные мусора более старые памяти. Таким образом, сборщик мусора повышает эффективность своей работы, настраивая номера поколений при каждом высвобождении памяти, и <xref:System.GC.MaxGeneration%2A> значение свойства может увеличиваться с течением времени.  
  
 Если реализована концепция возраста объектов, <xref:System.GC.MaxGeneration%2A> свойство возвращает максимальный номер поколения используется системой; в противном случае это свойство возвращает ноль.  
  
   
  
## Examples  
 Следующий пример демонстрирует использование свойства MaxGeneration для отображения наибольший номер поколения в настоящее время используется.  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Для этой реализации значение, возвращаемое <see cref="P:System.GC.MaxGeneration" /> свойство гарантированно остаются постоянными в течение всего времени выполнения приложения.  
  
 Используйте <see cref="P:System.GC.MaxGeneration" /> свойства, чтобы определить максимальное значение, можно указать при вызове <see cref="M:System.GC.Collect(System.Int32)" /> метода, принимающего поколения в качестве параметра.</para>
        </block>
        <altmember cref="M:System.GC.GetGeneration(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForFullGCNotification">
      <MemberSignature Language="C#" Value="public static void RegisterForFullGCNotification (int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterForFullGCNotification(int32 maxGenerationThreshold, int32 largeObjectHeapThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterForFullGCNotification (maxGenerationThreshold As Integer, largeObjectHeapThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxGenerationThreshold" Type="System.Int32" />
        <Parameter Name="largeObjectHeapThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxGenerationThreshold">Число от 1 до 99, указывающее условия создания уведомления в зависимости от объектов, выделенных в поколение 2.</param>
        <param name="largeObjectHeapThreshold">Число от 1 до 99, указывающее условия создания уведомления в зависимости от объектов, помещенных в кучу больших объектов.</param>
        <summary>Указывает, что необходимо отправлять уведомления о сборке мусора, когда соблюдены условия для полной сборки мусора и когда завершена сборка.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для каждого поколения сборщик мусора Задает пороговое значение для распределения в этом поколении. Когда размер выделений превышает этот порог, сбора мусора запускается для этого поколения. Для например, если пороговое значение поколения 2 составляет 20 МБ (то есть, остается после первого поколения 20 МБ, перешедшие в поколение 2) и более 20 МБ уцелел поколения 1 и предлагается в поколение 2, будет предпринята попытка следующей сборки мусора как сборки поколения 2. Аналогично Если куча больших объектов (LOH) пороговое значение — 20 МБ и приложения выделил более 20 МБ больших объектов, следующая сборка мусора также применяется как сборки поколения 2 (поскольку LOH собираются только в gen2 сборки мусора).  
  
 `maxGenerationThreshold` И `largeObjectHeapThreshold` пороговые значения управления заранее объем уведомляются прежде, чем полная сборка мусора происходит. Чем больше порогового значения, дополнительные выделения, которые могут возникать между уведомления и следующей сборке мусора.  
  
 Если у вас есть ситуации, в которых полная сборка мусора средой CLR может неблагоприятно повлиять на производительность приложения, вы можете запросить уведомления, когда среда выполнения собирается выполнить полную сборку мусора и обходить эту сборку вызывая сборку самостоятельно (с помощью <xref:System.GC.Collect%2A> метод) Если предпочтительна, по-прежнему выполняются условия. Помимо изменения расписание сбора мусора самостоятельно, полной сборки Мусора уведомлений можно использовать в следующих сценариях:  
  
-   За метод полной сборкой мусора, и при появлении одного приближается, уменьшите размер динамических данных (например, освободив некоторых записей кэша). В результате Если производится сбор мусора, является возможность освободить больше памяти.  
  
-   Мониторинг для выполнения полной сборкой мусора, чтобы вы можете собирать статистику.  Например может потребоваться измерения размера кучи по завершении сборки Мусора, чтобы знать размер данных в режиме реального времени. (После полной сборки Мусора кучи — минимальный размер).  
  
 Дополнительные сведения о том, что представляет полную сборку мусора см. в разделе [сборке мусора](~/docs/standard/garbage-collection/notifications.md).  
  
 При регистрации уведомления о сборке мусора, чтобы настроить уведомления при приближении к полной сборкой мусора, и при ее завершении. Этот шаблон напоминает как операционная система отслеживает уведомления о нехватке памяти.  
  
 Следуйте приведенным ниже рекомендациям для указания `maxGenerationThreshold` и `largeObjectHeapThreshold` параметры:  
  
-   Чем больше порогового значения, дополнительные выделения произойдет между уведомления и полная сборка мусора.  
  
     Большее значение порога обеспечивает дополнительные возможности для выполнения, чтобы проверить приближение сборки. Это повышает вероятность того, что вы получите уведомление. Однако не следует задавать слишком большое пороговое значение, так как дополнительные выделения прежде, чем среда выполнения вызывает следующую сборку.  
  
     Если коллекция самостоятельно после уведомления с использованием высокого порогового значения, меньше объектов уничтожаются не будет удален при следующей коллекции среды выполнения.  
  
-   Чем меньше пороговое значение, меньшее число распределения между уведомлением и полная сборка мусора.  
  
   
  
## Examples  
 В следующем примере показано, как зарегистрировать уведомление о сборке мусора и запустить поток, чтобы отслеживать состояние уведомления о сборке мусора. Данный пример кода является частью большего примера, приведенного для [сборке мусора](~/docs/standard/garbage-collection/notifications.md) раздела.  
  
 [!code-cpp[GCNotification#2](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#2)]
 [!code-csharp[GCNotification#2](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#2)]
 [!code-vb[GCNotification#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Значение параметра <paramref name="maxGenerationThreshold" /> или <paramref name="largeObjectHeapThreshold" /> не входит в диапазон от 1 до 99.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="RemoveMemoryPressure">
      <MemberSignature Language="C#" Value="public static void RemoveMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RemoveMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMemoryPressure(long bytesAllocated);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">Объем освобожденной неуправляемой памяти.</param>
        <summary>Информирует среду выполнения о том, что неуправляемая память освобождена и ее более не требуется учитывать при планировании сборки мусора.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 При определении времени запланировать сбор мусора, среда выполнения учитывает выделенный объем управляемой памяти. Если маленький управляемый объект выделяет большой объем неуправляемой памяти, среда выполнения учитывает только управляемую память и поэтому недооценивает срочность планирования сборки мусора. <xref:System.GC.AddMemoryPressure%2A> Метод информирует среду выполнения о этот дополнительную нагрузку на системной памяти и <xref:System.GC.RemoveMemoryPressure%2A> метод информирует среду выполнения, что была снята дополнительную нагрузку.  
  
 В простейшей схеме использования управляемый объект выделяет неуправляемую память в конструкторе и освобождает его в `Dispose` или `Finalize` метод. Вызовите <xref:System.GC.AddMemoryPressure%2A> метод после выделения неуправляемой памяти и вызывать <xref:System.GC.RemoveMemoryPressure%2A> метод после ее освобождения.  
  
 В более сложных сценариях, где выделения неуправляемой памяти существенно изменяется за время жизни управляемого объекта, можно вызвать <xref:System.GC.AddMemoryPressure%2A> и <xref:System.GC.RemoveMemoryPressure%2A> методов для взаимодействия эти добавочных изменений в среду выполнения.  
  
> [!CAUTION]
>  Необходимо гарантировать, что удаляется точно степень давления, можно добавить. Невыполнение этого может отрицательно сказаться на производительности системы в приложениях, выполняемых в течение длительного времени.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="bytesAllocated" /> меньше или равно 0.  
  
 - или -  
  
 На 32-разрядном компьютере <paramref name="bytesAllocated" /> больше <see cref="F:System.Int32.MaxValue" />.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">для возможности вызова неуправляемого кода, при обработке приоритетом сборки мусора. Связанное перечисление: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="ReRegisterForFinalize">
      <MemberSignature Language="C#" Value="public static void ReRegisterForFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReRegisterForFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.ReRegisterForFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReRegisterForFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReRegisterForFinalize(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, для которого должен быть вызван метод завершения.</param>
        <summary>Требует, чтобы система вызвала метод завершения для указанного объекта, для которого ранее был вызван метод <see cref="M:System.GC.SuppressFinalize(System.Object)" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.ReRegisterForFinalize%2A> Добавляет метод `obj` параметра к списку объектов, запрашивающих завершения, прежде чем сборщик мусора освобождает объект. `obj` Параметр должен иметь код, вызывающий этот метод.  
  
 Вызов <xref:System.GC.ReRegisterForFinalize%2A> метод не гарантирует, что сборщик мусора вызовет метод завершения объекта.  
  
 По умолчанию все объекты, которые реализуют финализаторы добавляются в список объектов, которые требуют завершения; Тем не менее, может быть уже завершен или может отключен путем вызова объекта <xref:System.GC.SuppressFinalize%2A> метод.  
  
 Метод завершения может использовать этот метод, чтобы восстановить себя или объект, который он ссылается.  
  
   
  
## Examples  
 В следующем примере показано, как с помощью метода ReRegisterForFinalize завершить объект второй после сборки мусора.  
  
 [!code-cpp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CS/class1.cs#1)]
 [!code-vb[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SuppressFinalize">
      <MemberSignature Language="C#" Value="public static void SuppressFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SuppressFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.SuppressFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SuppressFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SuppressFinalize(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект, метод завершения для которого не должен выполняться.</param>
        <summary>Сообщает среде CLR, что она на не должна вызывать метод завершения для указанного объекта.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод устанавливает бит в заголовке объекта `obj`, который среда выполнения проверяет при вызове метода завершения. Метод завершения, которое представляется <xref:System.Object.Finalize%2A?displayProperty=nameWithType> метод, используется для освобождения неуправляемых ресурсов, перед объект сбора мусора. Если `obj` не метод завершения, вызов <xref:System.GC.SuppressFinalize%2A> метод не оказывает влияния.  
  
 Объекты, реализующие <xref:System.IDisposable> интерфейс этот метод можно вызывать из объекта <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> реализацию, чтобы помешать сборщику мусора вызвать <xref:System.Object.Finalize%2A?displayProperty=nameWithType> на объекте, который не требует его. Как правило, это делается во избежание метода завершения освободить неуправляемые ресурсы, которые уже был освобожден <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> реализации.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование <xref:System.GC.SuppressFinalize%2A> метода в классе ресурса во избежание избыточной сборки мусора от их вызова. В этом примере [шаблон удаления](~/docs/standard/design-guidelines/dispose-pattern.md) освободить как управляемые ресурсы (то есть объекты, реализующие <xref:System.IDisposable>) и неуправляемые ресурсы.  
  
 [!code-csharp[System.GC.SuppressFinalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.suppressfinalize/cs/suppressfinalize1.cs#1)]
 [!code-vb[System.GC.SuppressFinalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.suppressfinalize/vb/suppressfinalize1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          Свойство <paramref name="obj" /> имеет значение <see langword="null" />.</exception>
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.Object.Finalize" />
      </Docs>
    </Member>
    <MemberGroup MemberName="TryStartNoGCRegion">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Пытается запретить сборку мусора во время выполнения критического пути.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  Не удается вложить вызовы <xref:System.GC.TryStartNoGCRegion%2A> метод и вы должны вызывать только <xref:System.GC.EndNoGCRegion%2A> метод, если среда выполнения в данный момент в режим задержки без области сборки Мусора. Другими словами, не следует вызывать <xref:System.GC.TryStartNoGCRegion%2A> несколько раз (после первого вызова метода, последующие вызовы не будет выполнено), и не должен ожидать вызовы <xref:System.GC.EndNoGCRegion%2A> для успешного выполнения только потому, что первый вызов <xref:System.GC.TryStartNoGCRegion%2A> успешно выполнен.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">Объем памяти в байтах для выделения без запуска сборки мусора. Он должен быть меньше или равен размеру временного сегмента. Сведения о размере эфемерных сегментов см. в разделе "Эфемерные поколения и сегменты" статьи [Основы сборки мусора](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <summary>Пытается запретить сборку мусора во время выполнения критического пути, если доступен указанный достаточный объем памяти.</summary>
        <returns>
          Значение <see langword="true" />, если среде выполнения удалось зафиксировать необходимый объем памяти и сборщик мусора может перейти в режим задержки без области сборки мусора; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> Метод предпринимает попытку сборщика мусора в GC режим задержки без области, запрещающая сбора мусора, пока приложение выполняет критической области кода.  Если среда выполнения не сможет изначально назначить запрошенный объем памяти, сборщик мусора выполняет полной блокирующей сборки мусора, при попытке освободить память. Сборщик мусора переходит в режим задержки без области сборки Мусора он может выделить необходимый объем памяти, что в данном случае является фактически 2 * `totalSize` байт (он пытается выделить `totalSize` байт для кучи маленьких объектов и `totalSize` байт для кучи больших объектов).  
  
 `totalSize` должно быть достаточно большим для обработки всех операций выделения памяти, которые происходят в критический путь. Сюда входят выделения, приложения, а также параметры распределения, среда выполнения предоставляет от имени приложения.  
  
> [!IMPORTANT]
>  Не удается вложить вызовы <xref:System.GC.TryStartNoGCRegion%2A> метод и вы должны вызывать только <xref:System.GC.EndNoGCRegion%2A> метод, если среда выполнения в данный момент в режим задержки без области сборки Мусора. Другими словами, не следует вызывать <xref:System.GC.TryStartNoGCRegion%2A> несколько раз (после первого вызова метода, последующие вызовы не будет выполнено), и не должен ожидать вызовы <xref:System.GC.EndNoGCRegion%2A> для успешного выполнения только потому, что первый вызов <xref:System.GC.TryStartNoGCRegion%2A> успешно выполнен.  
  
 Выход из глобального Каталога режим задержки без области путем вызова <xref:System.GC.EndNoGCRegion%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> превышает размер эфемерного сегмента.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс уже находится в режиме задержки без области сборки мусора.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">Объем памяти в байтах для выделения без запуска сборки мусора. Он должен быть меньше или равен размеру временного сегмента. Сведения о размере эфемерных сегментов см. в разделе "Эфемерные поколения и сегменты" статьи [Основы сборки мусора](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <param name="disallowFullBlockingGC">
          Значение <see langword="true" />, чтобы пропустить полную блокирующую сборку мусора, если сборщику мусора изначально не удалось выделить <c>totalSize</c> байтов; в противном случае значение <see langword="false" />.</param>
        <summary>Пытается запретить сборку мусора во время выполнения критического пути, если доступен указанный объем памяти, и устанавливает, будет ли выполняться полная блокирующая сборка мусора, если изначально не хватает памяти.</summary>
        <returns>
          Значение <see langword="true" />, если среде выполнения удалось зафиксировать необходимый объем памяти и сборщик мусора может перейти в режим задержки без области сборки мусора; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> Метод предпринимает попытку сборщика мусора в GC режим задержки без области, запрещающая сбора мусора, пока приложение выполняет критической области кода.  Если среда выполнения не может изначально выделить запрошенного объема памяти и `disallowFullBlockingGC` аргумент `false`, сборщик мусора выполняет полной блокирующей сборки мусора, пытаясь освободить память; в противном случае происходит сбой выделения, и метод возвращает `false`. Сборщик мусора переходит в режим задержки без области сборки Мусора он может выделить необходимый объем памяти, что в данном случае является фактически 2 * `totalSize` (он пытается выделить `totalSize` для кучи маленьких объектов и `totalSize` для кучи больших объектов).  
  
 `totalSize` должно быть достаточно большим для обработки всех операций выделения памяти, которые происходят в критический путь. Сюда входят выделения, приложения, а также параметры распределения, среда выполнения предоставляет от имени приложения.  
  
 Установка `disallowFullBlockingGC` для `true` для предотвращения блокировки полной сборки мусора коллекции, если изначально не хватает памяти наиболее полезна в сценариях балансировки нагрузки: одну систему можно вызвать этот метод и сообщает о себе как Готово к приему запросов, если он возвращает `true`, и иметь подсистемы балансировки нагрузки, которые перенаправляют запросы с другими системами, если он возвращает `false`. Затем его можно сделать полной блокирующей сборки мусора, если он не обрабатывает запросы путем вызова <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> метод.  
  
> [!IMPORTANT]
>  Не удается вложить вызовы <xref:System.GC.TryStartNoGCRegion%2A> метод и вы должны вызывать только <xref:System.GC.EndNoGCRegion%2A> метод, если среда выполнения в данный момент в режим задержки без области сборки Мусора. Другими словами, не следует вызывать <xref:System.GC.TryStartNoGCRegion%2A> несколько раз (после первого вызова метода, последующие вызовы не будет выполнено), и не должен ожидать вызовы <xref:System.GC.EndNoGCRegion%2A> для успешного выполнения только потому, что первый вызов <xref:System.GC.TryStartNoGCRegion%2A> успешно выполнен.  
  
 Выход из глобального Каталога режим задержки без области путем вызова <xref:System.GC.EndNoGCRegion%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> превышает размер эфемерного сегмента.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс уже находится в режиме задержки без области сборки мусора.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">Объем памяти в байтах для выделения без запуска сборки мусора. Значение <c>totalSize</c> –<c>lohSize</c> должно быть меньше или равно размеру временного сегмента. Сведения о размере эфемерных сегментов см. в разделе "Эфемерные поколения и сегменты" статьи [Основы сборки мусора](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <param name="lohSize">Число байтов в <c>totalSize</c> для назначения кучи больших объектов.</param>
        <summary>Пытается запретить сборку мусора во время выполнения критического пути, если указанный объем памяти доступен для кучи больших объектов и для кучи маленьких объектов.</summary>
        <returns>
          Значение <see langword="true" />, если среде выполнения удалось зафиксировать необходимый объем памяти и сборщик мусора может перейти в режим задержки без области сборки мусора; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> Метод предпринимает попытку сборщика мусора в GC режим задержки без области, запрещающая сбора мусора, пока приложение выполняет критической области кода.  Если среда выполнения не сможет изначально назначить запрошенный объем памяти, сборщик мусора выполняет полной блокирующей сборки мусора, при попытке освободить память. Сборщик мусора переходит в режим задержки без области сборки Мусора он может выделить `lohSize` для LOH и `totalSize` — `lohSize` для кучи маленьких объектов (SOH).  
  
 `lohSize` должно быть достаточно большим для обработки всех операций выделения памяти, происходящие на критическом пути для LOH и `totalSize` — `lohSize` должно быть достаточно большим для обработки всех операций выделения памяти, происходящие на критическом пути для состояние работоспособности. Сюда входят выделения, приложения, а также параметры распределения, среда выполнения предоставляет от имени приложения.  
  
> [!IMPORTANT]
>  Не удается вложить вызовы <xref:System.GC.TryStartNoGCRegion%2A> метод и вы должны вызывать только <xref:System.GC.EndNoGCRegion%2A> метод, если среда выполнения в данный момент в режим задержки без области сборки Мусора. Другими словами, не следует вызывать <xref:System.GC.TryStartNoGCRegion%2A> несколько раз (после первого вызова метода, последующие вызовы не будет выполнено), и не должен ожидать вызовы <xref:System.GC.EndNoGCRegion%2A> для успешного выполнения только потому, что первый вызов <xref:System.GC.TryStartNoGCRegion%2A> успешно выполнен.  
  
 Выход из глобального Каталога режим задержки без области путем вызова <xref:System.GC.EndNoGCRegion%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> — <paramref name="lohSize" /> превышает размер эфемерного сегмента.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс уже находится в режиме задержки без области сборки мусора.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">Объем памяти в байтах для выделения без запуска сборки мусора. Значение <c>totalSize</c> –<c>lohSize</c> должно быть меньше или равно размеру временного сегмента. Сведения о размере эфемерных сегментов см. в разделе "Эфемерные поколения и сегменты" статьи [Основы сборки мусора](~/docs/standard/garbage-collection/fundamentals.md).</param>
        <param name="lohSize">Число байтов в <c>totalSize</c> для назначения кучи больших объектов.</param>
        <param name="disallowFullBlockingGC">
          Значение <see langword="true" />, чтобы пропустить полную блокирующую сборку мусора, если сборщику мусора изначально не удалось выделить указанную память в куче малых и в куче больших объектов; в противном случае — значение <see langword="false" />.</param>
        <summary>Пытается запретить сборку мусора во время выполнения критического пути, если доступен указанный объем памяти для кучи больших объектов и для кучи маленьких объектов, и устанавливает, будет ли выполняться полная блокирующая сборка мусора, если изначально не хватает памяти.</summary>
        <returns>
          Значение <see langword="true" />, если среде выполнения удалось зафиксировать необходимый объем памяти и сборщик мусора может перейти в режим задержки без области сборки мусора; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> Метод предпринимает попытку сборщика мусора в GC режим задержки без области, запрещающая сбора мусора, пока приложение выполняет критической области кода.  Если среда выполнения не может изначально выделить запрошенного объема памяти и `disallowFullBlockingGC` аргумент `false`, сборщик мусора выполняет полной блокирующей сборки мусора, пытаясь освободить память; в противном случае происходит сбой выделения, и метод возвращает `false`. Сборщик мусора переходит в режим задержки без области сборки Мусора он может выделить `lohSize` для LOH и `totalSize` — `lohSize` для кучи маленьких объектов (SOH).  
  
 `lohSize` должно быть достаточно большим для обработки всех операций выделения памяти, происходящие на критическом пути для LOH и `totalSize` — `lohSize` должно быть достаточно большим для обработки всех операций выделения памяти, происходящие на критическом пути для состояние работоспособности. Сюда входят выделения, приложения, а также параметры распределения, среда выполнения предоставляет от имени приложения.  
  
 Установка `disallowFullBlockingGC` для `true` для предотвращения блокировки полной сборки мусора коллекции, если изначально не хватает памяти наиболее полезна в сценариях балансировки нагрузки: одну систему можно вызвать этот метод и сообщает о себе как Готово к приему запросов, если он возвращает `true`, и иметь подсистемы балансировки нагрузки, которые перенаправляют запросы с другими системами, если он возвращает `false`. Затем его можно сделать полной блокирующей сборки мусора, если он не обрабатывает запросы путем вызова <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> метод.  
  
> [!IMPORTANT]
>  Не удается вложить вызовы <xref:System.GC.TryStartNoGCRegion%2A> метод и вы должны вызывать только <xref:System.GC.EndNoGCRegion%2A> метод, если среда выполнения в данный момент в режим задержки без области сборки Мусора. Другими словами, не следует вызывать <xref:System.GC.TryStartNoGCRegion%2A> несколько раз (после первого вызова метода, последующие вызовы не будет выполнено), и не должен ожидать вызовы <xref:System.GC.EndNoGCRegion%2A> для успешного выполнения только потому, что первый вызов <xref:System.GC.TryStartNoGCRegion%2A> успешно выполнен.  
  
 Выход из глобального Каталога режим задержки без области путем вызова <xref:System.GC.EndNoGCRegion%2A> метод.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="totalSize" /> — <paramref name="lohSize" /> превышает размер эфемерного сегмента.</exception>
        <exception cref="T:System.InvalidOperationException">Процесс уже находится в режиме задержки без области сборки мусора.</exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCApproach">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает состояние зарегистрированного уведомления, чтобы определить, является ли неизбежной полная, блокирующая сборка мусора средой CLR.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает состояние зарегистрированного уведомления, чтобы определить, является ли неизбежной полная, блокирующая сборка мусора средой CLR.</summary>
        <returns>Состояние зарегистрированного уведомления о сборке мусора.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.GCNotificationStatus> перечисления, возвращаемый этим методом, чтобы определить состояние текущего уведомления о сборке мусора, зарегистрированный с помощью <xref:System.GC.RegisterForFullGCNotification%2A> метод. Можно также использовать <xref:System.GC.WaitForFullGCComplete%2A> метод, чтобы определить, завершена ли полная сборка мусора.  
  
 При перечислении возвращает <xref:System.GCNotificationStatus.Succeeded>, можно выполнять задачи, такие как дополнительные объекты, предотвращая выделяется и вызывая сборку самостоятельно с <xref:System.GC.Collect%2A> метод. Обратите внимание, что уведомление не гарантирует, что полная сборка мусора происходит, только то, что условия Достигнуто пороговое значение, подходящей для полная сборка мусора возникает.  
  
 Этот метод бесконечно ожидает уведомления о сборке мусора может быть получена. Если вы хотите указать время ожидания для метода, возвращающего не удается получить уведомления, используйте <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> перегрузки метода. Если этот метод вызывается без указания времени ожидания, можно вызвать <xref:System.GC.CancelFullGCNotification%2A> метод, если ожидается больше, чем основной.  
  
 С помощью вызова этого метода необходимо следовать <xref:System.GC.WaitForFullGCComplete%2A> метод, чтобы убедиться в том, что у вас уже есть полная сборка мусора. Вызов этого метода только дает неопределенные результаты.  
  
   
  
## Examples  
 В следующем примере показано, как этот метод используется для определения того, достигает ли полная блокировка сборки мусора. Каждый раз, когда находится в состоянии уведомление <xref:System.GCNotificationStatus.Succeeded>, пользовательский метод `OnFullGCApproachNotify` вызывается для выполнения действий в ответ на приближение сборки. Данный пример кода является частью большего примера, приведенного для [сборке мусора](~/docs/standard/garbage-collection/notifications.md) раздела.  
  
 [!code-cpp[GCNotification#3](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#3)]
 [!code-csharp[GCNotification#3](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#3)]
 [!code-vb[GCNotification#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Продолжительность времени ожидания, прежде чем можно извлечь состояние уведомления. Укажите значение -1, если период ожидания неограниченный.</param>
        <summary>Возвращает состояние зарегистрированного уведомления в пределах указанного времени ожидания, чтобы определить, является ли неизбежной полная блокировка сборки мусора средой CLR.</summary>
        <returns>Состояние зарегистрированного уведомления о сборке мусора.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.GCNotificationStatus> перечисления, возвращаемый этим методом, чтобы определить состояние текущего уведомления о сборке мусора, зарегистрированный с помощью <xref:System.GC.RegisterForFullGCNotification%2A> метод. Можно также использовать <xref:System.GC.WaitForFullGCComplete%2A> метод, чтобы определить, завершена ли полная сборка мусора.  
  
 Обратите внимание, что этот метод возвращает немедленно каждый раз, когда извлечь состояние уведомления сбора мусора, независимо от значения, указанного в `millisecondsTimeout`. Если состояние уведомления сбора мусора не может быть получен до `millisecondsTimeout` время ожидания, этот метод возвращает <xref:System.GCNotificationStatus.NotApplicable>.  
  
 При перечислении возвращает <xref:System.GCNotificationStatus.Succeeded>, можно выполнять задачи, такие как дополнительные объекты, предотвращая выделяется и вызывая сборку самостоятельно с <xref:System.GC.Collect%2A> метод. Обратите внимание, что уведомление не гарантирует, что полная сборка мусора происходит, только то, что условия Достигнуто пороговое значение, подходящей для полная сборка мусора возникает.  
  
 Можно вызвать <xref:System.GC.CancelFullGCNotification%2A> метод, если не может ожидать интервал времени ожидания, которое должно пройти.  
  
 С помощью вызова этого метода необходимо следовать <xref:System.GC.WaitForFullGCComplete%2A> метод, чтобы убедиться в том, что у вас уже есть полная сборка мусора. Вызов этого метода только дает неопределенные результаты.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          Параметр <paramref name="millisecondsTimeout" /> должен быть неотрицательным или не больше <see cref="F:System.Int32.MaxValue" /> или -1.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCComplete">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает состояние зарегистрированного уведомления, чтобы определить, завершена ли полная блокировка сборки мусора средой CLR.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает состояние зарегистрированного уведомления, чтобы определить, завершена ли полная блокировка сборки мусора средой CLR.</summary>
        <returns>Состояние зарегистрированного уведомления о сборке мусора.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.GCNotificationStatus> перечисления, возвращаемый этим методом, чтобы определить состояние текущего уведомления о сборке мусора, зарегистрированный с помощью <xref:System.GC.RegisterForFullGCNotification%2A> метод. Можно также использовать <xref:System.GC.WaitForFullGCApproach%2A> метод, чтобы определить, является ли неизбежной полная сборка мусора.  
  
 При перечислении возвращает <xref:System.GCNotificationStatus.Succeeded>, можно выполнять задачи, такие как возобновление работы и получить число коллекций с <xref:System.GC.CollectionCount%2A> свойство.  
  
 Этот метод бесконечно ожидает уведомления о сборке мусора может быть получена. Если вы хотите указать время ожидания для метода, возвращающего не удается получить уведомления, используйте <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> перегрузки метода. Если этот метод вызывается без указания времени ожидания, можно вызвать <xref:System.GC.CancelFullGCNotification%2A> метод, если ожидается больше, чем основной.  
  
 Вызов этого метода должен стоять вызов <xref:System.GC.WaitForFullGCApproach%2A> метод, чтобы убедиться в том, что у вас уже есть полная сборка мусора. Сам по себе вызов этого метода может привести к непредсказуемым результатам.  
  
   
  
## Examples  
 В следующем примере показано, как использовать этот метод, чтобы определить, завершена ли полная сборка мусора. Каждый раз, когда находится в состоянии уведомление <xref:System.GCNotificationStatus.Succeeded>, пользовательский метод `OnFullGCCompletedNotify` вызывается для выполнения действий в ответ на выполненной сборки мусора. Данный пример кода является частью большего примера, приведенного для [сборке мусора](~/docs/standard/garbage-collection/notifications.md) раздела.  
  
 [!code-cpp[GCNotification#4](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#4)]
 [!code-csharp[GCNotification#4](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#4)]
 [!code-vb[GCNotification#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">Продолжительность времени ожидания, прежде чем можно извлечь состояние уведомления. Укажите значение -1, если период ожидания неограниченный.</param>
        <summary>Возвращает состояние зарегистрированного уведомления в пределах указанного времени ожидания, чтобы определить, завершена ли полная блокировка сборки мусора средой CLR.</summary>
        <returns>Состояние зарегистрированного уведомления о сборке мусора.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте <xref:System.GCNotificationStatus> перечисления, возвращаемый этим методом, чтобы определить состояние текущего уведомления о сборке мусора, зарегистрированный с помощью <xref:System.GC.RegisterForFullGCNotification%2A> метод. Можно также использовать <xref:System.GC.WaitForFullGCApproach%2A> метод, чтобы определить, является ли неизбежной полная сборка мусора.  
  
 Обратите внимание, что этот метод возвращает немедленно каждый раз, когда извлечь состояние уведомления сбора мусора, независимо от значения, указанного в `millisecondsTimeout`. Если состояние уведомления сбора мусора не может быть получен до `millisecondsTimeout` время ожидания, этот метод возвращает <xref:System.GCNotificationStatus.NotApplicable>.  
  
 При перечислении возвращает <xref:System.GCNotificationStatus.Succeeded>, можно выполнять задачи, такие как возобновление работы и получить число коллекций с <xref:System.GC.CollectionCount%2A> свойство.  
  
 Можно вызвать <xref:System.GC.CancelFullGCNotification%2A> метод, если не может ожидать интервал времени ожидания, которое должно пройти.  
  
 Вызов этого метода должен стоять вызов <xref:System.GC.WaitForFullGCApproach%2A> метод, чтобы убедиться в том, что у вас уже есть полная сборка мусора. Сам по себе вызов этого метода может привести к непредсказуемым результатам.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          Параметр <paramref name="millisecondsTimeout" /> должен быть неотрицательным или не больше <see cref="F:System.Int32.MaxValue" /> или -1.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">Для полного доверия для непосредственного вызывающего. Этот член не может быть использован частично доверенным кодом.</permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">требуется полное доверие для непосредственно вызывающего метода. Этот член не может использоваться частично доверенным или прозрачным кодом.</permission>
      </Docs>
    </Member>
    <Member MemberName="WaitForPendingFinalizers">
      <MemberSignature Language="C#" Value="public static void WaitForPendingFinalizers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitForPendingFinalizers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForPendingFinalizers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitForPendingFinalizers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitForPendingFinalizers();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Приостанавливает текущий поток до тех пор, пока поток, обрабатывающий очередь методов завершения, не обработает всю очередь.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда сборщик мусора находит объекты, которые могут быть освобождены, он проверяет каждый объект, чтобы определить его требования к завершению. Если объект реализует метод завершения и завершения не отключен, вызвав <xref:System.GC.SuppressFinalize%2A>, то объект помещается в список объектов, которые помечены как готовые к завершению. Сборщик мусора вызывает <xref:System.Object.Finalize%2A> методы для объектов в этом списке и удаляет элементы из списка. Этот метод блокируется, пока все методы завершения выполнено до завершения.  
  
 Поток, на котором выполняются методы завершения не определен, поэтому нет никакой гарантии, что этот метод будет завершена. Тем не менее, этот поток может быть прерван другим потоком <xref:System.GC.WaitForPendingFinalizers%2A> метод идет. Например может запустить другой поток, который ожидает в течение заданного времени и прервет этот поток, если он все еще находится в приостановленном состоянии.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование <xref:System.GC.WaitForPendingFinalizers%2A> методе для приостановки текущего потока до завершения всех объектов.  
  
 [!code-cpp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CS/class1.cs#1)]
 [!code-vb[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>