<Type Name="IDisposable" FullName="System.IDisposable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1e6b408b88af2e3e5027106be9c33751cc9e19c3" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34452204" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.IDisposable" />
  <TypeSignature Language="VB.NET" Value="Public Interface IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public interface class IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет механизм для освобождения неуправляемых ресурсов.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Главным образом используется этот интерфейс является освобождение неуправляемых ресурсов. Сборщик мусора автоматически освобождает память, выделенную для управляемого объекта, если этот объект больше не используется. Тем не менее не может предсказать, когда будет выполнена сборка мусора. Кроме того сборщик мусора не имеет сведений о неуправляемых ресурсов, таких как дескрипторы окон или открытия файлов и потоков.  
  
 Используйте <xref:System.IDisposable.Dispose%2A> метод этого интерфейса, чтобы явно освобождать неуправляемые ресурсы вместе со сборщиком мусора. Пользователь объекта может вызвать этот метод, когда объект больше не нужен.  
  
> [!WARNING]
>  Это критическое изменение для добавления <xref:System.IDisposable> интерфейса в существующий класс. Так как не удается вызвать существующие объекты-получатели типа <xref:System.IDisposable.Dispose%2A>, невозможно точно определить, освобождение неуправляемых ресурсов, содержащихся в типе.  
  
 Поскольку <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> реализация вызывается объектом-получателем типа, когда ресурсы, принадлежащие экземпляру больше не нужны, либо обтекания управляемого объекта в <xref:System.Runtime.InteropServices.SafeHandle> (рекомендуется), или необходимо перезаписать <xref:System.Object.Finalize%2A?displayProperty=nameWithType>для освобождения неуправляемых ресурсов, в том случае, если потребитель не будет вызван <xref:System.IDisposable.Dispose%2A>.  
  
> [!IMPORTANT]
>  В .NET Framework, компилятор C++ поддерживает детерминированную утилизацию ресурсов и позволяет непосредственно реализовать <xref:System.IDisposable.Dispose%2A> метод.  
  
 Подробный рассказ о том, как этот интерфейс и <xref:System.Object.Finalize%2A?displayProperty=nameWithType> используются метод см. в разделе [мусора](~/docs/standard/garbage-collection/index.md) и [метода](~/docs/standard/garbage-collection/implementing-dispose.md) разделы.  
  
## <a name="using-an-object-that-implements-idisposable"></a>С помощью объекта, реализующего IDisposable  
 Если ваше приложение просто использует объект, реализующий интерфейс <xref:System.IDisposable> интерфейса, необходимо вызвать объекта <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> реализацию после его использования. В зависимости от того, на языке программирования это можно сделать одним из двух способов:  
  
-   Например, используя язык создания `using` оператор в C# и Visual Basic.  
  
-   Путем заключения вызова <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> реализацию в `try` / `finally` блока.  
  
> [!NOTE]
>  Документация по типам, реализующим <xref:System.IDisposable> запишите этот факт и включите напоминание о необходимости вызывать ее <xref:System.IDisposable.Dispose%2A> реализации.  
  
<a name="Using"></a>   
### <a name="the-c-and-visual-basic-using-statement"></a>C# и Visual Basic с помощью инструкции  
 Если ваш язык поддерживает конструкцию, например [с помощью](~/docs/csharp/language-reference/keywords/using.md) инструкции на языке C# и [использование](~/docs/visual-basic/language-reference/statements/using-statement.md) инструкции на языке Visual Basic можно использовать его вместо явного вызова <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> самостоятельно. В следующем примере используется этот подход при определении `WordCount` класс, который сохраняет сведения о файле и количество слов в нем.  
  
 [!code-csharp[System.IDisposable#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/calling1.cs#1)]
 [!code-vb[System.IDisposable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/calling1.vb#1)]  
  
 `using` Инструкция является фактически синтаксического удобства. Во время компиляции компилятор языка реализует промежуточный язык (IL) для `try` / `finally` блока.  
  
 Дополнительные сведения о `using` инструкции в разделе [инструкции Using](~/docs/visual-basic/language-reference/statements/using-statement.md) или [с помощью инструкции](~/docs/csharp/language-reference/keywords/using-statement.md) разделы.  
  
### <a name="the-tryfinally-block"></a>Блок Try/Finally  
 Если язык программирования не поддерживает конструкцию как `using` оператор в C# или Visual Basic, или если вы предпочитаете не использовать его, можно вызвать <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> реализацию от `finally` блока `try` / `finally` инструкции. В следующем примере заменяется `using` блока в предыдущем примере с `try` / `finally` блока.  
  
 [!code-csharp[System.IDisposable#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/calling2.cs#2)]
 [!code-vb[System.IDisposable#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/calling2.vb#2)]  
  
 Дополнительные сведения о `try` / `finally` шаблонов см. в разделе [Try... CATCH... Оператор Finally](~/docs/visual-basic/language-reference/statements/try-catch-finally-statement.md), [try-finally](~/docs/csharp/language-reference/keywords/try-finally.md), или [оператор try-finally](http://msdn.microsoft.com/library/514400c1-c322-4bf3-9e48-3047240b8a82).  
  
## <a name="implementing-idisposable"></a>Использование IDisposable  
 Вам следует реализовать <xref:System.IDisposable> только в том случае, если тип использует неуправляемые ресурсы, непосредственно. Объекты-получатели типа может вызвать ваш <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> реализацию, чтобы освободить ресурсы, когда экземпляр больше не нужен. Для обработки случаев, в которых они не удалось вызвать <xref:System.IDisposable.Dispose%2A>, следует использовать класс, производный от <xref:System.Runtime.InteropServices.SafeHandle> программы-оболочки для неуправляемых ресурсов, или должны переопределять <xref:System.Object.Finalize%2A?displayProperty=nameWithType> метод для типа ссылки. В любом случае используйте <xref:System.IDisposable.Dispose%2A> метод для выполнения любой очистки необходим после использования неуправляемых ресурсов, например, удалением, высвобождением или сбросом неуправляемых ресурсов.  
  
> [!IMPORTANT]
>  При определении базового класса, использующего неуправляемые ресурсы и, имеет либо скорее всего имеет подклассов, которые должны быть освобождены, необходимо реализовать <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> метод и предоставляют вторая перегрузка `Dispose`, как описано в следующем раздел.  
  
<a name="BaseClasses"></a>   
## <a name="idisposable-and-the-inheritance-hierarchy"></a>Интерфейс IDisposable и иерархию наследования  
 Базовый класс с подклассов, которые должны быть высвобождаемыми должен реализовывать <xref:System.IDisposable> следующим образом. При реализации следует использовать этот шаблон <xref:System.IDisposable> на любой тип, который не `sealed` (`NotInheritable` в Visual Basic).  
  
-   Он должен предоставлять один открытый невиртуальный <xref:System.IDisposable.Dispose> метод и защищенный виртуальный `Dispose(Boolean disposing)` метод.  
  
-   <xref:System.IDisposable.Dispose> Необходимо вызвать метод `Dispose(true)` и следует подавления финализации для повышения производительности.  
  
-   базовый тип не должен включать никакие методы завершения.  
  
 В следующем фрагменте кода отражает шаблон удаления для базовых классов. Предполагается, что тип не переопределяет <xref:System.Object.Finalize%2A?displayProperty=nameWithType> метод.  
  
 [!code-csharp[System.IDisposable#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base1.cs#3)]
 [!code-vb[System.IDisposable#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base1.vb#3)]  
  
 При переопределении <xref:System.Object.Finalize%2A?displayProperty=nameWithType> метода, класс должен реализовывать следующий шаблон.  
  
 [!code-csharp[System.IDisposable#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/base2.cs#5)]
 [!code-vb[System.IDisposable#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/base2.vb#5)]  
  
 Подклассы должны реализовывать удаляемость следующим образом:  
  
-   они должны переопределять `Dispose(Boolean)` и вызвать реализацию `Dispose(Boolean)` базового класса;  
  
-   при необходимости они могут предоставлять метод завершения. Метод завершения должен вызвать `Dispose(false)`.  
  
 Обратите внимание, что производные классы не сами реализуют <xref:System.IDisposable> интерфейс, который не должен содержать конструктор без параметров <xref:System.IDisposable.Dispose%2A> метод. Они только переопределения базового класса `Dispose(Boolean)` метод.  
  
 В следующем фрагменте кода отражает шаблон удаления для производных классов. Предполагается, что тип не переопределяет <xref:System.Object.Finalize%2A?displayProperty=nameWithType> метод.  
  
 [!code-csharp[System.IDisposable#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.idisposable/cs/derived1.cs#4)]
 [!code-vb[System.IDisposable#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.idisposable/vb/derived1.vb#4)]  
  
   
  
## Examples  
 Ниже приведен пример, как создать класс ресурса, который реализует <xref:System.IDisposable> интерфейса.  
  
 [!code-cpp[System.IDisposable.Dispose Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CPP/idisposabledispose.cpp#1)]
 [!code-csharp[System.IDisposable.Dispose Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CS/idisposabledispose.cs#1)]
 [!code-vb[System.IDisposable.Dispose Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/VB/idisposabledispose.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:Microsoft.Win32.SafeHandles.SafeFileHandle" />
  </Docs>
  <Members>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IDisposable.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Dispose();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Выполняет определяемые приложением задачи, связанные с удалением, высвобождением или сбросом неуправляемых ресурсов.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Используйте этот метод для закрытия или высвобождения неуправляемых ресурсов, таких как файлы, потоки и обработчики, занятые экземплярами класса, который реализует этот интерфейс. По соглашению этот метод используется для всех задач, связанных с высвобождением занятых объектом ресурсов или подготовкой объекта к повторному использованию.  
  
> [!WARNING]
>  Если вы используете класс, реализующий <xref:System.IDisposable> интерфейса, необходимо вызвать его <xref:System.IDisposable.Dispose%2A> реализации, когда вы закончите, с помощью класса. Дополнительные сведения см. в подразделе «Использование объекта, реализующего IDisposable» <xref:System.IDisposable> раздела.  
  
 При реализации этого метода убедитесь, что все занятые ресурсы высвобождены путем передачи вызова по иерархии вложений. Например, если объект A размещает объект B, а объект B размещает объекта C, А затем <xref:System.IDisposable.Dispose%2A> реализация должна вызывать <xref:System.IDisposable.Dispose%2A> на B, который в свою очередь вызывают <xref:System.IDisposable.Dispose%2A> в C.  
  
> [!IMPORTANT]
>  Компилятор C++ поддерживает детерминированную утилизацию ресурсов и позволяет непосредственно реализовать <xref:System.IDisposable.Dispose%2A> метод.  
  
 Объект должен также вызвать метод <xref:System.IDisposable.Dispose%2A> метод базового класса, если базовый класс реализует <xref:System.IDisposable>. Дополнительные сведения о реализации <xref:System.IDisposable> на базовый класс и его подклассов, в разделе «IDisposable и иерархию наследования» в <xref:System.IDisposable> разделе.  
  
 Если объект <xref:System.IDisposable.Dispose%2A> метод вызывается несколько раз, то объект должен игнорировать все вызовы после первого. Объект не должен создавать исключения, если его <xref:System.IDisposable.Dispose%2A> метод вызывается несколько раз. Методы экземпляров отличных от <xref:System.IDisposable.Dispose%2A> может вызывать <xref:System.ObjectDisposedException> при ресурсы уже удален.  
  
 Тип ресурса для использования определенного соглашение для обозначения состоянии выделенных и освобожденных состояния могут рассчитывать пользователи. Примером этого является классы потоков, которые обычно считаются открытыми или закрытыми. Реализации класса, который имеет такой соглашение может потребоваться реализовать открытый метод с заданным именем, например `Close`, которая вызывает <xref:System.IDisposable.Dispose%2A> метод.  
  
 Поскольку <xref:System.IDisposable.Dispose%2A> метод должен вызываться явным образом, всегда есть опасность, что неуправляемые ресурсы, не будет освобожден, так как объект-получатель не может вызывать его <xref:System.IDisposable.Dispose%2A> метод. Чтобы этого избежать двумя способами.  
  
-   Перенос управляемого ресурса в объект, производный от <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>. Ваш <xref:System.IDisposable.Dispose%2A> затем реализация вызывает <xref:System.IDisposable.Dispose%2A> метод <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> экземпляров. Дополнительные сведения см. в разделе «Вместо SafeHandle» раздела <xref:System.Object.Finalize%2A?displayProperty=nameWithType> раздела.  
  
-   Реализуйте метод завершения, чтобы освободить ресурсы при <xref:System.IDisposable.Dispose%2A> не вызывается. По умолчанию сборщик мусора автоматически вызывает метод завершения объекта прежде чем высвободить память. Однако если <xref:System.IDisposable.Dispose%2A> метод был вызван, это правило, нет сборщику мусора вызывать метод завершения удаленного объекта. Для предотвращения автоматического завершения <xref:System.IDisposable.Dispose%2A> реализации может вызывать <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> метод.  
  
 При использовании объекта, который обращается к неуправляемым ресурсам, таких как <xref:System.IO.StreamWriter>, хорошей практикой является создание экземпляра с `using` инструкции. `using` Инструкция автоматически закрывает поток и вызывает <xref:System.IDisposable.Dispose%2A> для объекта после завершения код, который использует его. Пример см. в разделе <xref:System.IO.StreamWriter> класса.  
  
   
  
## Examples  
 В следующем примере показано, как можно реализовать <xref:System.IDisposable.Dispose%2A> метод.  
  
 [!code-cpp[System.IDisposable.Dispose Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CPP/idisposabledispose.cpp#1)]
 [!code-csharp[System.IDisposable.Dispose Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/CS/idisposabledispose.cs#1)]
 [!code-vb[System.IDisposable.Dispose Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.IDisposable.Dispose Example/VB/idisposabledispose.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>