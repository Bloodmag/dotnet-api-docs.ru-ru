<Type Name="IntPtr" FullName="System.IntPtr">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="560c7563290bc2d4237f4521628265386b3920ad" />
    <Meta Name="ms.sourcegitcommit" Value="f9e3295b6cc303a611a73a84c4b27f9da792ad0d" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="04/26/2018" />
    <Meta Name="ms.locfileid" Value="31911094" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct IntPtr : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit native int extends System.ValueType implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.IntPtr" />
  <TypeSignature Language="VB.NET" Value="Public Structure IntPtr&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public value class IntPtr : System::Runtime::Serialization::ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="7ff17-101">Определяемый платформой тип, который используется для представления указателя или дескриптора.</span>
      <span class="sxs-lookup">
        <span data-stu-id="7ff17-101">A platform-specific type that is used to represent a pointer or a handle.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7ff17-102"><xref:System.IntPtr> Тип должен быть целое число, размер которого зависит от платформы.</span><span class="sxs-lookup"><span data-stu-id="7ff17-102">The <xref:System.IntPtr> type is designed to be an integer whose size is platform-specific.</span></span> <span data-ttu-id="7ff17-103">То есть экземпляр этого типа предполагается 32 бита в 32-разрядном оборудовании и операционных системах и 64-разрядной на 64-разрядном оборудовании и операционных систем.</span><span class="sxs-lookup"><span data-stu-id="7ff17-103">That is, an instance of this type is expected to be 32-bits on 32-bit hardware and operating systems, and 64-bits on 64-bit hardware and operating systems.</span></span>  
  
 <span data-ttu-id="7ff17-104"><xref:System.IntPtr> Тип может использоваться языками, поддерживающими указатели, а также для перенаправления данных между языками, не поддерживающими указатели.</span><span class="sxs-lookup"><span data-stu-id="7ff17-104">The <xref:System.IntPtr> type can be used by languages that support pointers, and as a common means of referring to data between languages that do and do not support pointers.</span></span>  
  
 <span data-ttu-id="7ff17-105"><xref:System.IntPtr> объекты могут также использоваться для хранения дескрипторов.</span><span class="sxs-lookup"><span data-stu-id="7ff17-105"><xref:System.IntPtr> objects can also be used to hold handles.</span></span> <span data-ttu-id="7ff17-106">Например, экземпляры <xref:System.IntPtr> широко используются в <xref:System.IO.FileStream?displayProperty=nameWithType> класс, содержащий дескрипторы файлов.</span><span class="sxs-lookup"><span data-stu-id="7ff17-106">For example, instances of <xref:System.IntPtr> are used extensively in the <xref:System.IO.FileStream?displayProperty=nameWithType> class to hold file handles.</span></span>  
  
 <span data-ttu-id="7ff17-107"><xref:System.IntPtr> Тип является CLS-совместимым, пока <xref:System.UIntPtr> тип не является.</span><span class="sxs-lookup"><span data-stu-id="7ff17-107">The <xref:System.IntPtr> type is CLS-compliant, while the <xref:System.UIntPtr> type is not.</span></span> <span data-ttu-id="7ff17-108">Только <xref:System.IntPtr> тип используется в среде CLR.</span><span class="sxs-lookup"><span data-stu-id="7ff17-108">Only the <xref:System.IntPtr> type is used in the common language runtime.</span></span> <span data-ttu-id="7ff17-109"><xref:System.UIntPtr> Типа обеспечивает в основном обслуживание архитектурной симметрии с <xref:System.IntPtr> типа.</span><span class="sxs-lookup"><span data-stu-id="7ff17-109">The <xref:System.UIntPtr> type is provided mostly to maintain architectural symmetry with the <xref:System.IntPtr> type.</span></span>  
  
 <span data-ttu-id="7ff17-110">Этот тип реализует <xref:System.Runtime.Serialization.ISerializable> интерфейса.</span><span class="sxs-lookup"><span data-stu-id="7ff17-110">This type implements the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7ff17-111">В следующем примере управляемые указатели обратного символов в массиве.</span><span class="sxs-lookup"><span data-stu-id="7ff17-111">The following example uses managed pointers to reverse the characters in an array.</span></span> <span data-ttu-id="7ff17-112">После инициализации <xref:System.String> объекта и возвращает его длиной, он делает следующее:</span><span class="sxs-lookup"><span data-stu-id="7ff17-112">After it initializes a <xref:System.String> object and gets its length, it does the following:</span></span>  
  
1.  <span data-ttu-id="7ff17-113">Вызовы <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> метод, чтобы скопировать строку в кодировке Юникод в неуправляемой памяти в кодировке ANSI (однобайтовых).</span><span class="sxs-lookup"><span data-stu-id="7ff17-113">Calls the <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> method to copy the Unicode string to unmanaged memory as an ANSI (one-byte) character.</span></span> <span data-ttu-id="7ff17-114">Метод возвращает <xref:System.IntPtr> объект, который указывает на начало в неуправляемой строке.</span><span class="sxs-lookup"><span data-stu-id="7ff17-114">The method returns an <xref:System.IntPtr> object that points to the beginning of the unmanaged string.</span></span> <span data-ttu-id="7ff17-115">В примере Visual Basic использует этот указатель напрямую. Примеры C++ и C# оно приводится к указателю на байт.</span><span class="sxs-lookup"><span data-stu-id="7ff17-115">The Visual Basic example uses this pointer directly; in the C++ and C# examples, it is cast to a pointer to a byte.</span></span>  
  
2.  <span data-ttu-id="7ff17-116">Вызовы <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> метод, чтобы выделить одинаковое количество байтов, занимаемых неуправляемой строки.</span><span class="sxs-lookup"><span data-stu-id="7ff17-116">Calls the <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> method to allocate the same number of bytes as the unmanaged string occupies.</span></span> <span data-ttu-id="7ff17-117">Метод возвращает <xref:System.IntPtr> объект, который указывает на начало неуправляемого блока памяти.</span><span class="sxs-lookup"><span data-stu-id="7ff17-117">The method returns an <xref:System.IntPtr> object that points to the beginning of the unmanaged block of memory.</span></span> <span data-ttu-id="7ff17-118">В примере Visual Basic использует этот указатель напрямую. Примеры C++ и C# оно приводится к указателю на байт.</span><span class="sxs-lookup"><span data-stu-id="7ff17-118">The Visual Basic example uses this pointer directly; in the C++ and C# examples, it is cast to a pointer to a byte.</span></span>  
  
3.  <span data-ttu-id="7ff17-119">В примере Visual Basic определяет переменную с именем `offset` , равным длине строки ANSI.</span><span class="sxs-lookup"><span data-stu-id="7ff17-119">The Visual Basic example defines a variable named `offset` that is equal to the length of the ANSI string.</span></span> <span data-ttu-id="7ff17-120">Он используется, чтобы определить смещение в неуправляемую память, в которую копируются Далее ценными в строку ANSI.</span><span class="sxs-lookup"><span data-stu-id="7ff17-120">It is used to determine the offset into unmanaged memory to which the next charter in the ANSI string is copied.</span></span> <span data-ttu-id="7ff17-121">Поскольку начальное значение длины строки, операция копирования будет копировать символ от начала строки до конца блока памяти.</span><span class="sxs-lookup"><span data-stu-id="7ff17-121">Because its starting value is the length of the string, the copy operation will copy a character from the start of the string to the end of the memory block.</span></span>  
  
     <span data-ttu-id="7ff17-122">Вызов примеры C# и C++ <xref:System.IntPtr.ToPointer%2A> метод для получения неуправляемый указатель на начальный адрес строки и неуправляемый блок памяти, а также добавить один меньше, чем длина строки на начальный адрес строки ANSI.</span><span class="sxs-lookup"><span data-stu-id="7ff17-122">The C# and C++ examples call the <xref:System.IntPtr.ToPointer%2A> method to get an unmanaged pointer to the starting address of the string and the unmanaged block of memory, and they add one less than the length of the string to the starting address of the ANSI string.</span></span> <span data-ttu-id="7ff17-123">Так как указатель неуправляемой строки теперь указывает на конец строки, операция копирования будет копировать символ из конца строки на начало блока памяти.</span><span class="sxs-lookup"><span data-stu-id="7ff17-123">Because the unmanaged string pointer now points to the end of the string, the copy operation will copy a character from the end of the string to the start of the memory block.</span></span>  
  
4.  <span data-ttu-id="7ff17-124">Использует цикл для копирования каждого символа в строке в неуправляемый блок памяти.</span><span class="sxs-lookup"><span data-stu-id="7ff17-124">Uses a loop to copy each character from the string to the unmanaged block of memory.</span></span>  
  
     <span data-ttu-id="7ff17-125">В примере вызывается метод Visual Basic <xref:System.Runtime.InteropServices.Marshal.ReadByte%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType> метод для чтения байтов (или символ однобайтовый) с указанным смещением управляемый указатель строки ANSI.</span><span class="sxs-lookup"><span data-stu-id="7ff17-125">The Visual Basic example calls the <xref:System.Runtime.InteropServices.Marshal.ReadByte%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType> method to read the byte (or one-byte character) at a specified offset from the managed pointer to the ANSI string.</span></span> <span data-ttu-id="7ff17-126">Смещение увеличивается при каждой итерации цикла.</span><span class="sxs-lookup"><span data-stu-id="7ff17-126">The offset is incremented with each iteration of the loop.</span></span> <span data-ttu-id="7ff17-127">Затем он вызывает <xref:System.Runtime.InteropServices.Marshal.WriteByte%28System.IntPtr%2CSystem.Int32%2CSystem.Byte%29?displayProperty=nameWithType> метод для записи байтов на адрес в памяти, определяемый начальный адрес неуправляемый блок памяти, а также `offset`.</span><span class="sxs-lookup"><span data-stu-id="7ff17-127">It then calls the <xref:System.Runtime.InteropServices.Marshal.WriteByte%28System.IntPtr%2CSystem.Int32%2CSystem.Byte%29?displayProperty=nameWithType> method to write the byte to the memory address defined by the starting address of the unmanaged block of memory plus `offset`.</span></span> <span data-ttu-id="7ff17-128">Затем этот параметр уменьшает `offset`.</span><span class="sxs-lookup"><span data-stu-id="7ff17-128">It then decrements `offset`.</span></span>  
  
     <span data-ttu-id="7ff17-129">C# и C++ примеры выполнить операцию копирования, а затем уменьшения указатель на адрес объекта со следующего расположения в неуправляемой строки ANSI и увеличить указатель до следующего адреса в неуправляемый блок.</span><span class="sxs-lookup"><span data-stu-id="7ff17-129">The C# and C++ examples perform the copy operation, then decrement the pointer to the address of the next location in the unmanaged ANSI string and increment the pointer to the next address in the unmanaged block.</span></span>  
  
5.  <span data-ttu-id="7ff17-130">Все примеры вызова <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType> для преобразования блок неуправляемой памяти, содержащий скопированной строки ANSI в управляемый Юникод <xref:System.String> объекта.</span><span class="sxs-lookup"><span data-stu-id="7ff17-130">All examples call the <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType> to convert the unmanaged memory block containing the copied ANSI string to a managed Unicode <xref:System.String> object.</span></span>  
  
6.  <span data-ttu-id="7ff17-131">После отображения строки исходного и обратном, вызовите все примеры <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> метод для освобождения памяти, выделенной для неуправляемой строки ANSI и неуправляемый блок памяти.</span><span class="sxs-lookup"><span data-stu-id="7ff17-131">After displaying the original and reversed strings, all examples call the <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> method to free the memory allocated for the unmanaged ANSI string and the unmanaged block of memory.</span></span>  
  
 [!code-cpp[System.IntPtr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.intptr/cpp/topointer.cpp#1)]
 [!code-csharp[System.IntPtr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr/cs/topointer.cs#1)]
 [!code-vb[System.IntPtr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr/vb/topointer.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="7ff17-132">Данный тип потокобезопасен.</span>
      <span class="sxs-lookup">
        <span data-stu-id="7ff17-132">This type is thread safe.</span>
      </span>
    </threadsafe>
    <altmember cref="T:System.UIntPtr" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="7ff17-133">Инициализирует новый экземпляр <see cref="T:System.IntPtr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-133">Initializes a new instance of <see cref="T:System.IntPtr" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IntPtr (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr(int value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="7ff17-134">Указатель или дескриптор состоит из 32-разрядного целого числа со знаком.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-134">A pointer or handle contained in a 32-bit signed integer.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7ff17-135">Инициализирует новый экземпляр структуры <see cref="T:System.IntPtr" /> с помощью заданного 32-битового указателя или дескриптора.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-135">Initializes a new instance of <see cref="T:System.IntPtr" /> using the specified 32-bit pointer or handle.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IntPtr (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr(long value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="7ff17-136">Указатель или дескриптор состоит из 64-разрядного целого числа со знаком.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-136">A pointer or handle contained in a 64-bit signed integer.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7ff17-137">Инициализирует новый экземпляр <see cref="T:System.IntPtr" /> с использованием заданного 64-разрядного указателя.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-137">Initializes a new instance of <see cref="T:System.IntPtr" /> using the specified 64-bit pointer.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7ff17-138">Исключение возникает только в том случае, если значение `value` требуется больше разрядов, чем поддерживает данная платформа.</span><span class="sxs-lookup"><span data-stu-id="7ff17-138">An exception is only thrown if the value of `value` requires more bits than the current platform supports.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="7ff17-139">На 32-разрядной платформе значение <paramref name="value" /> слишком велико, или слишком мало для представления структуры <see cref="T:System.IntPtr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-139">On a 32-bit platform, <paramref name="value" /> is too large or too small to represent as an <see cref="T:System.IntPtr" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IntPtr (void* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(void* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.#ctor(System.Void*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr(void* value);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Void*" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="7ff17-140">Указатель незаданного типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-140">A pointer to an unspecified type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7ff17-141">Инициализирует новый экземпляр структуры <see cref="T:System.IntPtr" /> с использованием заданного указателя на незаданный тип.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-141">Initializes a new instance of <see cref="T:System.IntPtr" /> using the specified pointer to an unspecified type.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="7ff17-142">требуется полное доверие для непосредственно вызывающего метода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-142">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="7ff17-143">Этот член не может использоваться частично доверенным или прозрачным кодом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-143">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Void" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static IntPtr Add (IntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Add(native int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.Add(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (pointer As IntPtr, offset As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Add(IntPtr pointer, int offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer">
          <span data-ttu-id="7ff17-144">Указатель, к которому требуется добавить смещение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-144">The pointer to add the offset to.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="7ff17-145">Добавляемое смещение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-145">The offset to add.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7ff17-146">Добавляет смещение к значению указателя.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-146">Adds an offset to the value of a pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7ff17-147">Новый указатель, получающийся при добавлении смещения <paramref name="offset" /> к указателю <paramref name="pointer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-147">A new pointer that reflects the addition of <paramref name="offset" /> to <paramref name="pointer" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7ff17-148"><xref:System.IntPtr.Add%2A> Метод не вызывает исключение, если результат слишком велик для представления указателя на указанной платформы.</span><span class="sxs-lookup"><span data-stu-id="7ff17-148">The <xref:System.IntPtr.Add%2A> method does not throw an exception if the result is too large to represent as a pointer on the specified platform.</span></span> <span data-ttu-id="7ff17-149">Вместо этого в непроверяемом контексте выполняется операция сложения.</span><span class="sxs-lookup"><span data-stu-id="7ff17-149">Instead, the addition operation is performed in an unchecked context.</span></span>  
  
 <span data-ttu-id="7ff17-150">Языки, не поддерживающих перегрузку операторов или пользовательские операторы можно использовать этот метод для добавления смещения к значению указателя.</span><span class="sxs-lookup"><span data-stu-id="7ff17-150">Languages that do not support operator overloading or custom operators can use this method to add an offset to the value of a pointer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7ff17-151">В следующем примере создается <xref:System.IntPtr> объект, который указывает на начало массив из 10 элементов, а затем вызывает <xref:System.IntPtr.Add%2A> метода для перечисления элементов в массиве.</span><span class="sxs-lookup"><span data-stu-id="7ff17-151">The following example instantiates an <xref:System.IntPtr> object that points to the beginning of a ten-element array, and then calls the <xref:System.IntPtr.Add%2A> method to iterate the elements in the array.</span></span>  
  
 [!code-csharp[System.IntPtr.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.add/cs/add1.cs#1)]
 [!code-vb[System.IntPtr.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.add/vb/add1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="7ff17-152">Объект, сравниваемый с этим экземпляром или <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-152">An object to compare with this instance or <see langword="null" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7ff17-153">Возвращает значение, показывающее, равен ли данный экземпляр заданному объекту.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-153">Returns a value indicating whether this instance is equal to a specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7ff17-154">Значение <see langword="true" />, если параметр <paramref name="obj" /> является экземпляром типа <see cref="T:System.IntPtr" /> и равен значению данного экземпляра; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-154">
              <see langword="true" /> if <paramref name="obj" /> is an instance of <see cref="T:System.IntPtr" /> and equals the value of this instance; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="7ff17-155">Возвращает хэш-код данного экземпляра.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-155">Returns the hash code for this instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7ff17-156">Хэш-код в виде 32-разрядного целого числа со знаком.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-156">A 32-bit signed integer hash code.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static IntPtr operator + (IntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Addition(native int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (pointer As IntPtr, offset As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr operator +(IntPtr pointer, int offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer">
          <span data-ttu-id="7ff17-157">Указатель, к которому требуется добавить смещение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-157">The pointer to add the offset to.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="7ff17-158">Добавляемое смещение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-158">The offset to add.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7ff17-159">Добавляет смещение к значению указателя.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-159">Adds an offset to the value of a pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7ff17-160">Новый указатель, получающийся при добавлении смещения <paramref name="offset" /> к указателю <paramref name="pointer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-160">A new pointer that reflects the addition of <paramref name="offset" /> to <paramref name="pointer" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7ff17-161"><xref:System.IntPtr.op_Addition%2A> Метод определяет операцию сложения для <xref:System.IntPtr> объектов.</span><span class="sxs-lookup"><span data-stu-id="7ff17-161">The <xref:System.IntPtr.op_Addition%2A> method defines the addition operation for <xref:System.IntPtr> objects.</span></span> <span data-ttu-id="7ff17-162">Он включает следующий код.</span><span class="sxs-lookup"><span data-stu-id="7ff17-162">It enables code such as the following.</span></span>  
  
 [!code-csharp[System.IntPtr.op_Addition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.op_addition/cs/addition1.cs#1)]
 [!code-vb[System.IntPtr.op_Addition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.op_addition/vb/addition1.vb#1)]  
  
 <span data-ttu-id="7ff17-163">Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.IntPtr.Add%2A> метод вместо него.</span><span class="sxs-lookup"><span data-stu-id="7ff17-163">Languages that do not support custom operators can call the <xref:System.IntPtr.Add%2A> method instead.</span></span>  
  
 <span data-ttu-id="7ff17-164">Операция сложения не вызывает исключение, если результат слишком велик для представления указателя на указанной платформы.</span><span class="sxs-lookup"><span data-stu-id="7ff17-164">The addition operation does not throw an exception if the result is too large to represent as a pointer on the specified platform.</span></span> <span data-ttu-id="7ff17-165">Вместо этого он выполняется в непроверенном контексте.</span><span class="sxs-lookup"><span data-stu-id="7ff17-165">Instead, it is performed in an unchecked context.</span></span>  
  
 <span data-ttu-id="7ff17-166">Эквивалентный метод для этого оператора <xref:System.IntPtr.Add%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="7ff17-166">The equivalent method for this operator is <xref:System.IntPtr.Add%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.IntPtr.Add(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (IntPtr value1, IntPtr value2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(native int value1, native int value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Equality(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (value1 As IntPtr, value2 As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(IntPtr value1, IntPtr value2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value1" Type="System.IntPtr" />
        <Parameter Name="value2" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value1">
          <span data-ttu-id="7ff17-167">Первый из сравниваемых указателей или дескрипторов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-167">The first pointer or handle to compare.</span>
          </span>
        </param>
        <param name="value2">
          <span data-ttu-id="7ff17-168">Второй из сравниваемых указателей или дескрипторов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-168">The second pointer or handle to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7ff17-169">Определяет, равны ли два заданных экземпляра класса <see cref="T:System.IntPtr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-169">Determines whether two specified instances of <see cref="T:System.IntPtr" /> are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7ff17-170">Если значение <paramref name="value1" /> равно <paramref name="value2" />, значение <see langword="true" />; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-170">
              <see langword="true" /> if <paramref name="value1" /> equals <paramref name="value2" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[<span data-ttu-id="7ff17-171">Эквивалентный метод для этого оператора <xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="7ff17-171">The equivalent method for this operator is <xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="7ff17-172">Преобразует заданный тип данных в значение <see cref="T:System.IntPtr" /> или значение <see cref="T:System.IntPtr" /> в заданный тип данных.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-172">Converts a specified data type to an <see cref="T:System.IntPtr" /> value, or an <see cref="T:System.IntPtr" /> value to a specified data type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator IntPtr (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Explicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.Int32)~System.IntPtr" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator IntPtr(int value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="7ff17-173">32-разрядное знаковое целое число.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-173">A 32-bit signed integer.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7ff17-174">Преобразует 32-разрядное целочисленное значение со знаком в <see cref="T:System.IntPtr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-174">Converts the value of a 32-bit signed integer to an <see cref="T:System.IntPtr" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7ff17-175">Новый экземпляр <see cref="T:System.IntPtr" />, инициализированный значением <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-175">A new instance of <see cref="T:System.IntPtr" /> initialized to <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks></remarks>
        <altmember cref="Overload:System.IntPtr.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator IntPtr (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Explicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.Int64)~System.IntPtr" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Long) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator IntPtr(long value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="7ff17-176">64-разрядное целое число со знаком.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-176">A 64-bit signed integer.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7ff17-177">Преобразует 64-разрядное целочисленное значение со знаком в <see cref="T:System.IntPtr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-177">Converts the value of a 64-bit signed integer to an <see cref="T:System.IntPtr" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7ff17-178">Новый экземпляр <see cref="T:System.IntPtr" />, инициализированный значением <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-178">A new instance of <see cref="T:System.IntPtr" /> initialized to <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks></remarks>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="7ff17-179">На 32-разрядной платформе значение параметра <paramref name="value" /> слишком велико для представления параметра <see cref="T:System.IntPtr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-179">On a 32-bit platform, <paramref name="value" /> is too large to represent as an <see cref="T:System.IntPtr" />.</span>
          </span>
        </exception>
        <altmember cref="Overload:System.IntPtr.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(IntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="7ff17-180">Указатель или дескриптор, подлежащий преобразованию.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-180">The pointer or handle to convert.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7ff17-181">Преобразует значение заданной структуры <see cref="T:System.IntPtr" /> в формат 32-разрядного целого числа со знаком.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-181">Converts the value of the specified <see cref="T:System.IntPtr" /> to a 32-bit signed integer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7ff17-182">Содержимое <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-182">The contents of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7ff17-183">Исключение возникает только в том случае, если значение `value` требуется больше разрядов, чем поддерживает данная платформа.</span><span class="sxs-lookup"><span data-stu-id="7ff17-183">An exception is only thrown if the value of `value` requires more bits than the current platform supports.</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="7ff17-184">На 64-разрядной платформе значение <paramref name="value" /> слишком велико для представления в качестве 32-разрядного целого числа со знаком.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-184">On a 64-bit platform, the value of <paramref name="value" /> is too large to represent as a 32-bit signed integer.</span>
          </span>
        </exception>
        <altmember cref="M:System.IntPtr.ToInt32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As IntPtr) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(IntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="7ff17-185">Указатель или дескриптор, подлежащий преобразованию.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-185">The pointer or handle to convert.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7ff17-186">Преобразует значение заданной структуры <see cref="T:System.IntPtr" /> в формат 64-разрядного целого числа со знаком.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-186">Converts the value of the specified <see cref="T:System.IntPtr" /> to a 64-bit signed integer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7ff17-187">Содержимое <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-187">The contents of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks></remarks>
        <altmember cref="M:System.IntPtr.ToInt64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator void* (IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname void* op_Explicit(native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Void*" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator void*(IntPtr value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void*</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="7ff17-188">Указатель или дескриптор, подлежащий преобразованию.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-188">The pointer or handle to convert.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7ff17-189">Преобразует значение заданной структуры <see cref="T:System.IntPtr" /> в указатель на незаданный тип.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-189">Converts the value of the specified <see cref="T:System.IntPtr" /> to a pointer to an unspecified type.</span>
          </span>
          <span data-ttu-id="7ff17-190">Этот интерфейс API CLS-несовместим.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-190">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7ff17-191">Содержимое <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-191">The contents of <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks></remarks>
        <altmember cref="M:System.IntPtr.ToPointer" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator IntPtr (void* value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Explicit(void* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.Void*)~System.IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator IntPtr(void* value);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Void*" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="7ff17-192">Указатель незаданного типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-192">A pointer to an unspecified type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7ff17-193">Преобразует заданный указатель на незаданный тип в <see cref="T:System.IntPtr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-193">Converts the specified pointer to an unspecified type to an <see cref="T:System.IntPtr" />.</span>
          </span>
          <span data-ttu-id="7ff17-194">Этот интерфейс API CLS-несовместим.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-194">This API is not CLS-compliant.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7ff17-195">Новый экземпляр <see cref="T:System.IntPtr" />, инициализированный значением <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-195">A new instance of <see cref="T:System.IntPtr" /> initialized to <paramref name="value" />.</span>
          </span>
        </returns>
        <remarks></remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="7ff17-196">требуется полное доверие для непосредственно вызывающего метода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-196">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="7ff17-197">Этот член не может использоваться частично доверенным или прозрачным кодом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-197">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="Overload:System.IntPtr.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (IntPtr value1, IntPtr value2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(native int value1, native int value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Inequality(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (value1 As IntPtr, value2 As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(IntPtr value1, IntPtr value2);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value1" Type="System.IntPtr" />
        <Parameter Name="value2" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value1">
          <span data-ttu-id="7ff17-198">Первый из сравниваемых указателей или дескрипторов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-198">The first pointer or handle to compare.</span>
          </span>
        </param>
        <param name="value2">
          <span data-ttu-id="7ff17-199">Второй из сравниваемых указателей или дескрипторов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-199">The second pointer or handle to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7ff17-200">Определяет, являются ли два заданных экземпляра класса <see cref="T:System.IntPtr" /> неравными.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-200">Determines whether two specified instances of <see cref="T:System.IntPtr" /> are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7ff17-201">Значение <see langword="true" />, если значения параметров <paramref name="value1" /> и <paramref name="value2" /> не равны; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-201">
              <see langword="true" /> if <paramref name="value1" /> does not equal <paramref name="value2" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[<span data-ttu-id="7ff17-202">Эквивалентный метод для этого оператора <xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="7ff17-202">The equivalent method for this operator is <xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static IntPtr operator - (IntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Subtraction(native int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (pointer As IntPtr, offset As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr operator -(IntPtr pointer, int offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer">
          <span data-ttu-id="7ff17-203">Указатель, из которого требуется вычесть смещение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-203">The pointer to subtract the offset from.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="7ff17-204">Вычитаемое смещение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-204">The offset to subtract.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7ff17-205">Вычитает смещение из значения указателя.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-205">Subtracts an offset from the value of a pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7ff17-206">Новый указатель, получающийся при вычитании смещения <paramref name="offset" /> из указателя <paramref name="pointer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-206">A new pointer that reflects the subtraction of <paramref name="offset" /> from <paramref name="pointer" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7ff17-207"><xref:System.IntPtr.op_Subtraction%2A> Метод определяет операцию вычитания для <xref:System.IntPtr> объектов.</span><span class="sxs-lookup"><span data-stu-id="7ff17-207">The <xref:System.IntPtr.op_Subtraction%2A> method defines the subtraction operation for <xref:System.IntPtr> objects.</span></span> <span data-ttu-id="7ff17-208">Он включает следующий код.</span><span class="sxs-lookup"><span data-stu-id="7ff17-208">It enables code such as the following.</span></span>  
  
 [!code-csharp[System.IntPtr.op_Addition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.op_addition/cs/op_subtraction1.cs#2)]
 [!code-vb[System.IntPtr.op_Addition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.op_addition/vb/op_subtraction1.vb#2)]  
  
 <span data-ttu-id="7ff17-209">Языки, которые не поддерживают пользовательские операторы можно вызвать <xref:System.IntPtr.Subtract%2A> метод вместо него.</span><span class="sxs-lookup"><span data-stu-id="7ff17-209">Languages that do not support custom operators can call the <xref:System.IntPtr.Subtract%2A> method instead.</span></span>  
  
 <span data-ttu-id="7ff17-210">Операция вычитания не вызывает исключение, если результат слишком мал для представления указателя на указанной платформы.</span><span class="sxs-lookup"><span data-stu-id="7ff17-210">The subtraction operation does not throw an exception if the result is too small to represent as a pointer on the specified platform.</span></span> <span data-ttu-id="7ff17-211">Вместо этого он выполняется в непроверенном контексте.</span><span class="sxs-lookup"><span data-stu-id="7ff17-211">Instead, it is performed in an unchecked context.</span></span>  
  
 <span data-ttu-id="7ff17-212">Эквивалентный метод для этого оператора <xref:System.IntPtr.Subtract%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="7ff17-212">The equivalent method for this operator is <xref:System.IntPtr.Subtract%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public static int Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 Size" />
      <MemberSignature Language="DocId" Value="P:System.IntPtr.Size" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Size As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int Size { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7ff17-213">Получает размер этого экземпляра.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-213">Gets the size of this instance.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="7ff17-214">Размер указателя или дескриптора в данном процессе в байтах.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-214">The size of a pointer or handle in this process, measured in bytes.</span>
          </span>
          <span data-ttu-id="7ff17-215">Значение этого свойства равно 4 в 32-разрядном процессе и 8 в 64-разрядном процессе.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-215">The value of this property is 4 in a 32-bit process, and 8 in a 64-bit process.</span>
          </span>
          <span data-ttu-id="7ff17-216">Можно указать тип процесса, задав параметр <see langword="/platform" /> при компилировании кода с помощью компиляторов C# и Visual Basic.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-216">You can define the process type by setting the <see langword="/platform" /> switch when you compile your code with the C# and Visual Basic compilers.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static IntPtr Subtract (IntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Subtract(native int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (pointer As IntPtr, offset As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Subtract(IntPtr pointer, int offset);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.IntPtr" />
        <Parameter Name="offset" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer">
          <span data-ttu-id="7ff17-217">Указатель, из которого требуется вычесть смещение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-217">The pointer to subtract the offset from.</span>
          </span>
        </param>
        <param name="offset">
          <span data-ttu-id="7ff17-218">Вычитаемое смещение.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-218">The offset to subtract.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7ff17-219">Вычитает смещение из значения указателя.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-219">Subtracts an offset from the value of a pointer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7ff17-220">Новый указатель, получающийся при вычитании смещения <paramref name="offset" /> из указателя <paramref name="pointer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-220">A new pointer that reflects the subtraction of <paramref name="offset" /> from <paramref name="pointer" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7ff17-221"><xref:System.IntPtr.Subtract%2A> Метод не вызывает исключение, если результат слишком мал для представления указателя на указанной платформы.</span><span class="sxs-lookup"><span data-stu-id="7ff17-221">The <xref:System.IntPtr.Subtract%2A> method does not throw an exception if the result is too small to represent as a pointer on the specified platform.</span></span> <span data-ttu-id="7ff17-222">Вместо этого в непроверяемом контексте выполняется операция вычитания.</span><span class="sxs-lookup"><span data-stu-id="7ff17-222">Instead, the subtraction operation is performed in an unchecked context.</span></span>  
  
 <span data-ttu-id="7ff17-223">Языки, не поддерживающих перегрузку операторов или пользовательские операторы могут использовать этот метод Вычитаемое смещение из значения указателя.</span><span class="sxs-lookup"><span data-stu-id="7ff17-223">Languages that do not support operator overloading or custom operators can use this method to subtract an offset from the value of a pointer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="7ff17-224">В следующем примере создается <xref:System.IntPtr> объект, который указывает конец массив из 10 элементов, а затем вызывает <xref:System.IntPtr.Subtract%2A> метода для перечисления элементов в массиве в обратном порядке.</span><span class="sxs-lookup"><span data-stu-id="7ff17-224">The following example instantiates an <xref:System.IntPtr> object that points to the end of a ten-element array, and then calls the <xref:System.IntPtr.Subtract%2A> method to iterate the elements in the array in reverse order.</span></span>  
  
 [!code-csharp[System.IntPtr.Subtract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.subtract/cs/subtract1.cs#1)]
 [!code-vb[System.IntPtr.Subtract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.subtract/vb/subtract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.IEquatable&lt;System.IntPtr&gt;.Equals">
      <MemberSignature Language="C#" Value="bool IEquatable&lt;IntPtr&gt;.Equals (IntPtr other);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IEquatable&lt;System.IntPtr&gt;.Equals(native int other) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.System#IEquatable&lt;System#IntPtr&gt;#Equals(System.IntPtr)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.1;netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As IntPtr) As Boolean Implements IEquatable(Of IntPtr).Equals" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IEquatable&lt;System.IntPtr&gt;.Equals(IntPtr other) = IEquatable&lt;IntPtr&gt;::Equals;" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1" />
      </Parameters>
      <Docs>
        <param name="other">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <span data-ttu-id="7ff17-225">Объект <see cref="T:System.Runtime.Serialization.SerializationInfo" />, который требуется заполнить данными.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-225">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object to populate with data.</span>
          </span>
        </param>
        <param name="context">
          <span data-ttu-id="7ff17-226">Целевой объект этой сериализации.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-226">The destination for this serialization.</span>
          </span>
          <span data-ttu-id="7ff17-227">(Этот параметр не используется; задайте значение <see langword="null" />.)</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-227">(This parameter is not used; specify <see langword="null" />.)</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7ff17-228">Заполняет объект <see cref="T:System.Runtime.Serialization.SerializationInfo" /> данными, необходимыми для сериализации текущего объекта <see cref="T:System.IntPtr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-228">Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object with the data needed to serialize the current <see cref="T:System.IntPtr" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7ff17-229">Этот метод заполняет `info` параметр со значением текущего <xref:System.IntPtr> объекта.</span><span class="sxs-lookup"><span data-stu-id="7ff17-229">This method populates the `info` parameter with the value of the current <xref:System.IntPtr> object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="7ff17-230">Свойство <paramref name="info" /> имеет значение <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-230">
              <paramref name="info" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="7ff17-231">требуется полное доверие для непосредственно вызывающего метода.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-231">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="7ff17-232">Этот член не может использоваться частично доверенным или прозрачным кодом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-232">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public int ToInt32 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ToInt32() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToInt32" />
      <MemberSignature Language="VB.NET" Value="Public Function ToInt32 () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ToInt32();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="7ff17-233">Преобразует значение этого экземпляра в формат 32-разрядного целого числа со знаком.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-233">Converts the value of this instance to a 32-bit signed integer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7ff17-234">32-разрядное целое число со знаком, равное значению данного экземпляра.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-234">A 32-bit signed integer equal to the value of this instance.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OverflowException">
          <span data-ttu-id="7ff17-235">На 64-разрядной платформе значение этого экземпляра слишком велико, или слишком мало для представления его в качестве 32-разрядного целого числа со знаком.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-235">On a 64-bit platform, the value of this instance is too large or too small to represent as a 32-bit signed integer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public long ToInt64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 ToInt64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToInt64" />
      <MemberSignature Language="VB.NET" Value="Public Function ToInt64 () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long ToInt64();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="7ff17-236">Преобразует значение этого экземпляра в формат 64-разрядного целого числа со знаком.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-236">Converts the value of this instance to a 64-bit signed integer.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7ff17-237">64-и разрядное целое число со знаком равно значению данного экземпляра.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-237">A 64-bit signed integer equal to the value of this instance.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToPointer">
      <MemberSignature Language="C#" Value="public void* ToPointer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void* ToPointer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void* ToPointer();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void*</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="7ff17-238">Преобразует значение этого экземпляра в указатель незаданного типа.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-238">Converts the value of this instance to a pointer to an unspecified type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7ff17-239">Указатель на <see cref="T:System.Void" /> (указатель на ячейку памяти, содержащую данные незаданного типа).</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-239">A pointer to <see cref="T:System.Void" />; that is, a pointer to memory containing data of an unspecified type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="7ff17-240">В следующем примере управляемые указатели обратного символов в массиве.</span><span class="sxs-lookup"><span data-stu-id="7ff17-240">The following example uses managed pointers to reverse the characters in an array.</span></span> <span data-ttu-id="7ff17-241">После инициализации <xref:System.String> объекта и возвращает его длиной, он делает следующее:</span><span class="sxs-lookup"><span data-stu-id="7ff17-241">After it initializes a <xref:System.String> object and gets its length, it does the following:</span></span>  
  
-   <span data-ttu-id="7ff17-242">Вызовы <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> метод, чтобы скопировать строку в кодировке Юникод в неуправляемой памяти в виде ANSI (однобайтовых) символов.</span><span class="sxs-lookup"><span data-stu-id="7ff17-242">Calls the <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> method to copy the Unicode string to unmanaged memory as ANSI (one-byte) characters.</span></span> <span data-ttu-id="7ff17-243">Метод возвращает <xref:System.IntPtr> объект, который указывает на начало в неуправляемой строке.</span><span class="sxs-lookup"><span data-stu-id="7ff17-243">The method returns an <xref:System.IntPtr> object that points to the beginning of the unmanaged string.</span></span>  
  
-   <span data-ttu-id="7ff17-244">Вызовы <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> метод, чтобы выделить одинаковое количество байтов, занимаемых неуправляемой строки.</span><span class="sxs-lookup"><span data-stu-id="7ff17-244">Calls the <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> method to allocate the same number of bytes as the unmanaged string occupies.</span></span> <span data-ttu-id="7ff17-245">Метод возвращает <xref:System.IntPtr> объект, который указывает на начало неуправляемого блока памяти.</span><span class="sxs-lookup"><span data-stu-id="7ff17-245">The method returns an <xref:System.IntPtr> object that points to the beginning of the unmanaged block of memory.</span></span>  
  
-   <span data-ttu-id="7ff17-246">Вызовы <xref:System.IntPtr.ToPointer%2A> метод для получения неуправляемый указатель на начальный адрес строки и неуправляемый блок памяти и добавляет единицу меньше, чем длина строки на начальный адрес строки ANSI.</span><span class="sxs-lookup"><span data-stu-id="7ff17-246">Calls the <xref:System.IntPtr.ToPointer%2A> method to get an unmanaged pointer to the starting address of the string and the unmanaged block of memory, and adds one less than the length of the string to the starting address of the ANSI string.</span></span> <span data-ttu-id="7ff17-247">Так как указатель неуправляемой строки теперь указывает на конец строки, операция копирования будет копировать символ из конца строки на начало блока памяти.</span><span class="sxs-lookup"><span data-stu-id="7ff17-247">Because the unmanaged string pointer now points to the end of the string, the copy operation will copy a character from the end of the string to the start of the memory block.</span></span>  
  
-   <span data-ttu-id="7ff17-248">Использует цикл для копирования каждого символа в строке в неуправляемый блок памяти.</span><span class="sxs-lookup"><span data-stu-id="7ff17-248">Uses a loop to copy each character from the string to the unmanaged block of memory.</span></span> <span data-ttu-id="7ff17-249">После каждой операции копирования он уменьшает указатель на адрес объекта со следующего расположения в неуправляемой строки ANSI и увеличивает значение указателя до следующего адреса в неуправляемый блок.</span><span class="sxs-lookup"><span data-stu-id="7ff17-249">After each copy operation, it decrements the pointer to the address of the next location in the unmanaged ANSI string and increments the pointer to the next address in the unmanaged block.</span></span>  
  
-   <span data-ttu-id="7ff17-250">Вызовы <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType> для преобразования блок неуправляемой памяти, содержащий скопированной строки ANSI в управляемый Юникод <xref:System.String> объекта.</span><span class="sxs-lookup"><span data-stu-id="7ff17-250">Calls the <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType> to convert the unmanaged memory block containing the copied ANSI string to a managed Unicode <xref:System.String> object.</span></span>  
  
-   <span data-ttu-id="7ff17-251">После отображения строки исходного и обратном, вызывает <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType> метод для освобождения памяти, выделенной для неуправляемой строки ANSI и неуправляемый блок памяти.</span><span class="sxs-lookup"><span data-stu-id="7ff17-251">After displaying the original and reversed strings, calls the <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType> method to free the memory allocated for the unmanaged ANSI string and the unmanaged block of memory.</span></span>  
  
 [!code-cpp[System.IntPtr.ToPointer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.IntPtr.ToPointer/cpp/topointer.cpp#1)]
 [!code-csharp[System.IntPtr.ToPointer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.IntPtr.ToPointer/cs/topointer.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="7ff17-252">Преобразует числовое значение текущего объекта <see cref="T:System.IntPtr" /> в эквивалентное ему строковое представление.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-252">Converts the numeric value of the current <see cref="T:System.IntPtr" /> object to its equivalent string representation.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="7ff17-253">Преобразует числовое значение текущего объекта <see cref="T:System.IntPtr" /> в эквивалентное ему строковое представление.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-253">Converts the numeric value of the current <see cref="T:System.IntPtr" /> object to its equivalent string representation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7ff17-254">Строковое представление значения этого экземпляра.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-254">The string representation of the value of this instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7ff17-255">Если значение <xref:System.IntPtr.Size%2A> свойства для этого экземпляра равно 4, то этот метод эквивалентен методу <xref:System.Int32.ToString%2A?displayProperty=nameWithType>; в противном случае этот метод эквивалентен методу <xref:System.Int64.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7ff17-255">If the value of the <xref:System.IntPtr.Size%2A> property for this instance is 4, then this method is equivalent to <xref:System.Int32.ToString%2A?displayProperty=nameWithType>; otherwise, this method is equivalent to <xref:System.Int64.ToString%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">
          <span data-ttu-id="7ff17-256">Спецификация формата, в которой определен порядок преобразования текущего объекта <see cref="T:System.IntPtr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-256">A format specification that governs how the current <see cref="T:System.IntPtr" /> object is converted.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="7ff17-257">Преобразует числовое значение текущего объекта <see cref="T:System.IntPtr" /> в эквивалентное ему строковое представление.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-257">Converts the numeric value of the current <see cref="T:System.IntPtr" /> object to its equivalent string representation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="7ff17-258">Строковое представление значения текущего объекта <see cref="T:System.IntPtr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-258">The string representation of the value of the current <see cref="T:System.IntPtr" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7ff17-259">Если `format` параметр `null` или пустая строка ("»), возвращаемое значение форматируется с помощью спецификатора общего формата («G»).</span><span class="sxs-lookup"><span data-stu-id="7ff17-259">If the `format` parameter is `null` or an empty string (""), the return value is formatted with the general format specifier ("G").</span></span> <span data-ttu-id="7ff17-260">Дополнительные сведения об описателях числового формата см. в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) раздела.</span><span class="sxs-lookup"><span data-stu-id="7ff17-260">For more information about numeric format specifiers, see the [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) topic.</span></span>  
  
 <span data-ttu-id="7ff17-261">Возвращаемое значение форматируется с использованием инвариантных региональных параметров.</span><span class="sxs-lookup"><span data-stu-id="7ff17-261">The return value is formatted using the invariant culture.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly IntPtr Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly native int Zero" />
      <MemberSignature Language="DocId" Value="F:System.IntPtr.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly IntPtr Zero;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="7ff17-262">Доступное только для чтения поле, которое предоставляет указатель или дескриптор, инициализированный с нулевым значением.</span>
          <span class="sxs-lookup">
            <span data-stu-id="7ff17-262">A read-only field that represents a pointer or handle that has been initialized to zero.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="7ff17-263">Значение этого поля не эквивалентно `null`.</span><span class="sxs-lookup"><span data-stu-id="7ff17-263">The value of this field is not equivalent to `null`.</span></span> <span data-ttu-id="7ff17-264">Используйте это поле позволяет определить, является ли экземпляр <xref:System.IntPtr> ему было присвоено значение, отличное от нуля.</span><span class="sxs-lookup"><span data-stu-id="7ff17-264">Use this field to efficiently determine whether an instance of <xref:System.IntPtr> has been set to a value other than zero.</span></span>  
  
 <span data-ttu-id="7ff17-265">Предположим, например, переменная ip является экземпляром класса <xref:System.IntPtr>.</span><span class="sxs-lookup"><span data-stu-id="7ff17-265">For example, assume the variable, ip, is an instance of <xref:System.IntPtr>.</span></span> <span data-ttu-id="7ff17-266">Можно определить, если оно было задано, сравнивая его значение, возвращаемое в конструкторе, например: « `if ip != new IntPtr(0)...` ».</span><span class="sxs-lookup"><span data-stu-id="7ff17-266">You can determine if it has been set by comparing it to the value returned by a constructor, for example: " `if ip != new IntPtr(0)...` ".</span></span> <span data-ttu-id="7ff17-267">Тем не менее вызов конструктора для получения неинициализированного указателя неэффективен.</span><span class="sxs-lookup"><span data-stu-id="7ff17-267">However, invoking a constructor to get an unintialized pointer is inefficient.</span></span> <span data-ttu-id="7ff17-268">Лучше всего кода, либо " `if ip != IntPtr.Zero...` », или « `if !IntPtr.Zero.Equals(ip)...` ».</span><span class="sxs-lookup"><span data-stu-id="7ff17-268">It is better to code either " `if ip != IntPtr.Zero...` ", or " `if !IntPtr.Zero.Equals(ip)...` ".</span></span>  
  
 <span data-ttu-id="7ff17-269">При вызове Windows API из управляемого кода, можно передать <xref:System.IntPtr.Zero?displayProperty=nameWithType> вместо `null` Если аргумент должен быть либо указателем или `null`.</span><span class="sxs-lookup"><span data-stu-id="7ff17-269">When calling the Windows API from managed code, you can pass <xref:System.IntPtr.Zero?displayProperty=nameWithType> instead of `null` if an argument is expected to be either a pointer or a `null`.</span></span> <span data-ttu-id="7ff17-270">Например, в следующем вызове Windows `CreateFile` функции предоставляет <xref:System.IntPtr.Zero?displayProperty=nameWithType> для `pSecurityAttributes` и `hTemplateFile` значения аргументов.</span><span class="sxs-lookup"><span data-stu-id="7ff17-270">For example, the following call to the Windows `CreateFile` function supplies <xref:System.IntPtr.Zero?displayProperty=nameWithType> for the `pSecurityAttributes` and `hTemplateFile` argument values.</span></span>  
  
 [!code-csharp[System.IntPtr.Zero#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.zero/cs/zero4.cs#2)]
 [!code-vb[System.IntPtr.Zero#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.zero/vb/zero4.vb#2)]  
  
> [!NOTE]
>  <span data-ttu-id="7ff17-271">Несмотря на то что <xref:System.IntPtr.Zero> эквивалентно `null` для функции Windows API с помощью параметров или возвращаемых значений, которые могут быть либо указателей или `null`, <xref:System.IntPtr.Zero> не эквивалентен `null`.</span><span class="sxs-lookup"><span data-stu-id="7ff17-271">Although <xref:System.IntPtr.Zero> is equivalent to `null` for Windows API functions with parameters or return values that can be either pointers or `null`, <xref:System.IntPtr.Zero> is not equivalent to `null`.</span></span> <span data-ttu-id="7ff17-272">Передача `null` для `IntPtr.Zero.Equals` метод всегда возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="7ff17-272">Passing `null` to the `IntPtr.Zero.Equals` method always returns `false`.</span></span>  
  
 <span data-ttu-id="7ff17-273">Можно также проверить `null` возвращаемое значение из вызовов функций Windows API, которые возвращают либо указателем или `null` путем сравнения возвращаемого значения с <xref:System.IntPtr.Zero?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7ff17-273">You can also test for a `null` return value from Windows API function calls that return either a pointer or a `null` by comparing the returned value with <xref:System.IntPtr.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="7ff17-274">Например, вызов `GetWindow` функции в следующем примере предпринимается попытка извлечь дескриптор окна не существует.</span><span class="sxs-lookup"><span data-stu-id="7ff17-274">For example, the call to the `GetWindow` function in the following example tries to retrieve the handle of a non-existent window.</span></span> <span data-ttu-id="7ff17-275">Если его вызов из неуправляемого кода, функция вернет `null`, но при вызове из управляемого кода, она возвращает <xref:System.IntPtr.Zero?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="7ff17-275">If it were called from unmanaged code, the function would return `null`, but when it is called from managed code, it returns <xref:System.IntPtr.Zero?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.IntPtr.Zero#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.zero/cs/zero2.cs#1)]
 [!code-vb[System.IntPtr.Zero#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.zero/vb/zero2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>