<Type Name="Lazy&lt;T&gt;" FullName="System.Lazy&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="18f7acfe9be295d345b133ff0702748156b3ca30" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36429900" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Lazy&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Lazy`1&lt;T&gt; extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Lazy`1" />
  <TypeSignature Language="VB.NET" Value="Public Class Lazy(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class Lazy" />
  <TypeSignature Language="F#" Value="type Lazy&lt;'T&gt; = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("ThreadSafetyMode={Mode}, IsValueCreated={IsValueCreated}, IsValueFaulted={IsValueFaulted}, Value={ValueForDebugDisplay}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.System_LazyDebugView`1))</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">Тип объекта с отложенной инициализацией.</typeparam>
    <summary>Обеспечивает поддержку отложенной инициализации.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Использование отложенной инициализации, чтобы отложить создание большого или ресурсоемкого объекта или выполнения задачи много ресурсов, особенно в том случае, если такие создания или выполнения могут не выполняться в течение срока жизни программы.  
  
 Чтобы подготовить отложенной инициализации, создать экземпляр <xref:System.Lazy%601>. Аргумент типа <xref:System.Lazy%601> , созданный тип объекта, который требуется инициализировать неактивно. Конструктор, который используется для создания <xref:System.Lazy%601> объекта определяет характеристики инициализации. Отложенная инициализация производится при первом обращении к свойству <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType>.  
  
 В большинстве случаев выбор конструктор зависит ответы на два вопроса:  
  
-   Объект с отложенной инициализацией будут доступны из нескольких потоков? В этом случае <xref:System.Lazy%601> объект может создать в любом потоке. Можно использовать один из конструкторов простых, поведение по умолчанию является создание поточно ориентированного <xref:System.Lazy%601> объекта, так что только один экземпляр неактивно экземпляр объекта создается независимо от того, сколько потоков пытаются получить доступ к его. Для создания <xref:System.Lazy%601> объекта, который не является потокобезопасным, необходимо использовать конструктор, который позволяет указать без потокобезопасности.  
  
    > [!CAUTION]
    >  Делая <xref:System.Lazy%601> объекта потокобезопасным не защищает неактивно инициализированный объект. Если несколько потоков могут получить доступ к объект с отложенной инициализацией, необходимо его свойства и методы безопасными для многопоточного доступа.  
  
-   Отложенная инициализация требует большого объема кода или отложенной инициализацией объект имеет конструктор по умолчанию, который выполняет все, что требуется и не создают исключения? Если необходимо написать код инициализации или если необходимо обрабатывать исключения, используйте один из конструкторов, принимающих фабричный метод. Напишите код инициализации в метод фабрики.  
  
 В следующей таблице приведены, чтобы выбрать, какой конструктор на основе этих двух факторов:  
  
|Объект, которые будут доступны для|Если не требуется никакого кода инициализации (конструктор по умолчанию), используйте|Если код инициализации не требуется, используйте|  
|--------------------------------|------------------------------------------------------------------------|---------------------------------------------|  
|Несколько потоков|<xref:System.Lazy%601.%23ctor>|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>|  
|Один поток|<xref:System.Lazy%601.%23ctor%28System.Boolean%29> с `isThreadSafe` значение `false`.|<xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> с `isThreadSafe` значение `false`.|  
  
 Лямбда-выражения можно использовать для указания метода фабрики. В этом случае всех кодов инициализации в одном месте. Лямбда-выражение перехватывает контекст, включая все аргументы, передаваемые конструктору неактивно инициализированный объект.  
  
 **Кэширование исключений** кэшируются при использовании фабричные методы исключения. То есть если фабричный метод создает исключение времени исключения первый поток пытается получить доступ к <xref:System.Lazy%601.Value%2A> свойство <xref:System.Lazy%601> объекта же исключение создается для каждой последующей попытки. Это гарантирует, что каждый вызов <xref:System.Lazy%601.Value%2A> свойство дает тот же результат и позволяет избежать незначительные ошибки, которые могут возникнуть при различных потоках получить разные результаты. <xref:System.Lazy%601> Заменяет фактический `T` , в противном случае будут инициализированы на более раннем этапе, обычно во время запуска. Сбой на этом раннем этапе обычно неустранимой. Если существует вероятность возникновения сбоя невозможным, рекомендуется построить логику повторных попыток в программу инициализации (в данном случае фабричный метод), так же, как если не использовали отложенной инициализации.  
  
 **Вместо блокировки** в некоторых случаях может потребоваться избежать дополнительной нагрузки <xref:System.Lazy%601> объекта по умолчанию режим блокировки. В редких случаях может быть потенциальный риск взаимоблокировки. В таких случаях можно использовать <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> или <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> конструктор и укажите <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>. Это позволяет <xref:System.Lazy%601> объект для создания копии объекта отложенной инициализацией на каждом из нескольких потоков, если потоки вызова <xref:System.Lazy%601.Value%2A> свойство одновременно. <xref:System.Lazy%601> Объект гарантирует, что все потоки использовать тот же экземпляр объекта с отложенной инициализацией и удаляет экземпляры, которые не используются. Таким образом сокращение расходов на блокировку обходится программа может иногда создать и удалить лишние копии ресурсоемкий объект. В большинстве случаев это маловероятно. В примерах для <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> и <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> конструкторы демонстрируют это поведение.  
  
> [!IMPORTANT]
>  При указании <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, исключения не кэшируются, даже если указан метод фабрики.  
  
 **Эквивалент конструкторы** помимо включения использование <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> и <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> конструкторы могут дублировать функции других конструкторов. В следующей таблице показаны значения параметров, возвращающих эквивалентное поведение.  
  
|Для создания <xref:System.Lazy%601> объект, который отсутствует|Для конструкторов, которые имеют `LazyThreadSafetyMode` `mode` задайте `mode` для|Для конструкторов, имеющих значение типа Boolean `isThreadSafe` задайте `isThreadSafe` для|Для конструкторов без параметров безопасности потока|  
|-------------------------------------------------------------------------------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------|-------------------------------------------------------|  
|Полностью потокобезопасным; использует блокировку, чтобы убедиться, что только один поток инициализирует значение.|<xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication>|`true`|Все конструкторы полностью являются потокобезопасными.|  
|Не потокобезопасным.|<xref:System.Threading.LazyThreadSafetyMode.None>|`false`|Неприменимо.|  
|Полностью потокобезопасным; состояние гонки потоков для инициализации значения.|<xref:System.Threading.LazyThreadSafetyMode.PublicationOnly>|Неприменимо.|Неприменимо.|  
  
 **Другие возможности** сведения об использовании <xref:System.Lazy%601> с поля статического потока, а также резервным хранилищем для свойства, в разделе [отложенной инициализации](~/docs/framework/performance/lazy-initialization.md).  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Lazy%601> класса для выполнения отложенной инициализации доступ из нескольких потоков.  
  
> [!NOTE]
>  В этом примере <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> конструктор. Он также демонстрирует использование <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> конструктор (указание `true` для `isThreadSafe`) и <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> конструктор (указание <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> для `mode`). Чтобы переключиться в другой конструктор, замените закомментированы конструкторов.  
>   
>  Пример, демонстрирующий исключение кэширования с помощью того же конструкторов. в разделе <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> конструктор.  
  
 В этом примере определяется класс `LargeObject`, для которого будет выполняться отложенная инициализация одним из нескольких потоков. Четыре ключевых раздела кода показано создание инициализатор, метод фабрики, фактическую инициализацию и конструктор `LargeObject` класс, который выводит сообщение при создании объекта. В начале метода `Main` в этом примере создается потокобезопасный отложенный инициализатор для класса `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#newlazy)]  
  
 Фабричный метод показано создание объекта, с заполнителем для дальнейшей инициализации:  
  
 [!code-csharp[System.Lazy\`1#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#factoryfunc)]  
  
 Обратите внимание, что разделов первые два кода может комбинироваться с помощью лямбда-функции, как показано ниже:  
  
 [!code-csharp[System.Lazy\`1#InitWithLambda](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/lambda.cs#initwithlambda)]
 [!code-vb[System.Lazy\`1#InitWithLambda](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/lambda.vb#initwithlambda)]  
  
 В примере приостанавливается, чтобы указать, что неопределенное может пройти, прежде чем отложенной инициализации. При нажатии клавиши **ввод** ключа, в примере создается и запускается три потока. `ThreadProc` Метод, используемый на всех трех потоков вызовы <xref:System.Lazy%601.Value%2A> свойство. Это происходит при первом `LargeObject` создается экземпляр:  
  
 [!code-csharp[System.Lazy\`1#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#valueprop)]  
  
 Конструктор `LargeObject` класса, содержащего последний ключа раздела кода, отображается сообщение, а также записывает идентификации инициализации потока. Выходные данные программы отображается в конце полный листинг кода.  
  
 [!code-csharp[System.Lazy\`1#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#largector)]  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1/vb/example.vb#all)]  
  
 ]]></format>
    </remarks>
    <threadsafe>По умолчанию все открытые и защищенные члены <see cref="T:System.Lazy`1" /> класса являются потокобезопасными и могут быть использованы одновременно из нескольких потоков. Эти потокобезопасности могут быть удалены, при необходимости и экземпляра, используя параметры для конструкторов типа.</threadsafe>
    <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Lazy`1" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Lazy`1" />. При отложенной инициализации используется конструктор по умолчанию для целевого типа.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Экземпляр, который создается с помощью этого конструктора может использоваться одновременно несколькими потоками.  
  
 Потокобезопасный режим из <xref:System.Lazy%601> экземпляр, который инициализируется этим конструктором <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>. Режим потокобезопасности описывает поведение, когда несколько потоков пытаются инициализировать <xref:System.Lazy%601> экземпляра.  
  
 Объект <xref:System.Lazy%601> , созданного с помощью этого конструктора не кэширует исключения. Дополнительные сведения см. в описании класса <xref:System.Lazy%601> или перечисления <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере показано использование этого конструктора. Он также демонстрирует использование <xref:System.Lazy%601.%23ctor%28System.Boolean%29> конструктор (указание `true` для `isThreadSafe`) и <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> конструктор (указание <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> для `mode`). Чтобы переключиться в другой конструктор, замените закомментированы конструкторов.  
  
 В этом примере определяется класс `LargeObject`, для которого будет выполняться отложенная инициализация одним из нескольких потоков. Два ключа строки кода в этом примере — это создание инициализатор и фактическую инициализацию. В начале метода `Main` в этом примере создается потокобезопасный отложенный инициализатор для класса `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctor#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#newlazy)]  
  
 В примере создается и запускается три потока, блокирующие на <xref:System.Threading.ManualResetEvent> объекта, чтобы пример можно освободить потоков за один раз. `ThreadProc` Метод, используемый на всех трех потоков вызовы <xref:System.Lazy%601.Value%2A> свойства `LargeObject` экземпляр:  
  
 [!code-csharp[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctor#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#valueprop)]  
  
 <xref:System.Lazy%601> Класс предоставляет блокировку, так что только один поток может создать `LargeObject` экземпляра. В примере показано, что все другие потоки получить тот же экземпляр.  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1.ctor#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctor/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctor#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctor/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; isThreadSafe" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isThreadSafe">Значение <see langword="true" />, если необходимо разрешить параллельное использование этого экземпляра несколькими потоками; значение <see langword="false" />, если необходимо разрешить одновременное использование этого экземпляра только одним потоком.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Lazy`1" />. При отложенной инициализации используется конструктор по умолчанию целевого типа и указанный режим инициализации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Потокобезопасный режим из <xref:System.Lazy%601> экземпляр, который инициализируется этим конструктором <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> Если `isThreadSafe` — `true`; в противном случае используется режим <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. Режим потокобезопасности описывает поведение, когда несколько потоков пытаются инициализировать <xref:System.Lazy%601> экземпляра. Чтобы указать <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> режиме, используйте <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> или <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> конструктор.  
  
 Объект <xref:System.Lazy%601> , созданного с помощью этого конструктора не кэширует исключения. Дополнительные сведения см. в описании класса <xref:System.Lazy%601> или перечисления <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере показано использование этого конструктора для создания отложенный инициализатор, который не является потокобезопасным, для сценариев, где весь доступ к объекту с отложенной инициализацией происходит в том же потоке. Он также демонстрирует использование <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> конструктор (указание <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> для `mode`. Чтобы переключиться в другой конструктор, замените закомментирован какой конструктор.  
  
> [!NOTE]
>  Для кода, в котором показано, как использовать этот конструктор в сценариях с несколькими потоками (указание `true` для `isThreadSafe`), см. пример для <xref:System.Lazy%601.%23ctor> конструктор.  
  
 В примере определяется `LargeObject` класс, который будет выполняться отложенная инициализация. В `Main` метода, в примере создается <xref:System.Lazy%601> экземпляра, а затем приостанавливает свою работу. При нажатии клавиши **ввод** ключа, пример обращается к <xref:System.Lazy%601.Value%2A> свойство <xref:System.Lazy%601> экземпляра, который приводит к инициализации возникновения. Конструктор `LargeObject` класс отображает сообщения консоли.  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1.ctorBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; valueFactory" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Делегат, вызываемый для создания значения с отложенной инициализацией при необходимости.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Lazy`1" />. Когда происходит отложенная инициализация, используется заданная функция инициализации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Экземпляр, который создается с помощью этого конструктора может использоваться одновременно несколькими потоками.  
  
 Потокобезопасный режим из <xref:System.Lazy%601> экземпляр, который инициализируется этим конструктором <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType>. Режим потокобезопасности описывает поведение, когда несколько потоков пытаются инициализировать <xref:System.Lazy%601> экземпляра.  
  
 Исключения, вызываемые `valueFactory` кэшируются. Дополнительные сведения см. в описании класса <xref:System.Lazy%601> или перечисления <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере показано использование этого конструктора для предоставления отложенной инициализации с кэшированием исключений. Он также демонстрирует использование <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> конструктор (указание `true` для `isThreadSafe`) и <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> конструктор (указание <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> для `mode`). Чтобы переключиться в другой конструктор, замените закомментированы конструкторов.  
  
 В этом примере определяется класс `LargeObject`, для которого будет выполняться отложенная инициализация одним из нескольких потоков. Три ключевых фрагменты кода показывают Создание инициализатор, фактическую инициализацию и конструктор `LargeObject` класса, в котором показано кэширование исключений. В начале метода `Main` в этом примере создается потокобезопасный отложенный инициализатор для класса `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFunc#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#newlazy)]  
  
 В примере создает и запускает три потока. `ThreadProc` Метод, используемый на всех трех потоков вызовы <xref:System.Lazy%601.Value%2A> свойства `LargeObject` экземпляр:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFunc#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#valueprop)]  
  
 В конструкторе `LargeObject` класса, третий ключевой части кода приводит к возникновению исключения первый раз `LargeObject` экземпляр создается, но впоследствии разрешает создание экземпляра возникает:  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFunc#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#largector)]  
  
 При запуске данного примера первый поток, который пытается создать экземпляр `LargeObject` завершается с ошибкой и исключение перехватывается. Можно предположить, что следующий поток успешно создать экземпляр, но <xref:System.Lazy%601> объекта кэшировал исключение. По этой причине все три потока исключение.  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1.ctorFunc#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFunc#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfunc/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="valueFactory" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; mode" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="mode">Одно из значений перечисления, задающее потокобезопасный режим.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Lazy`1" />, который использует конструктор <paramref name="T" /> по умолчанию и заданный потокобезопасный режим.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Потокобезопасный режим из <xref:System.Lazy%601> экземпляр описывает поведение, когда несколько потоков пытаются инициализировать <xref:System.Lazy%601> экземпляра.  
  
 Объект <xref:System.Lazy%601> , созданного с помощью этого конструктора не кэширует исключения. Дополнительные сведения см. в описании класса <xref:System.Lazy%601> или перечисления <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере показано использование этого конструктора для создания отложенный инициализатор, который позволяет нескольким потокам симуляторы для создания объекта неактивно. Несколько потоков могут в успешном создании экземпляров, но все потоки использовать экземпляр, который сначала был создан.  
  
> [!NOTE]
>  Пример, демонстрирующий, как использовать этот конструктор в однопоточных сценариях (указание <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> для `mode`), в разделе <xref:System.Lazy%601.%23ctor%28System.Boolean%29> конструктор. Пример, демонстрирующий, как использовать этот конструктор, чтобы обеспечить блокировку вместо состояния гонки в сценариях с несколькими потоками (указание <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> для `mode`), в разделе <xref:System.Lazy%601.%23ctor> конструктор.  
  
 В примере определяется `LargeObject` класс, который будет выполняться отложенная инициализация с помощью любого из нескольких потоков. Три ключевых части кода, иллюстрируют Создание инициализатор, фактическую инициализацию и конструктор и метод завершения из `LargeObject` класса. В начале `Main` метода, в примере создается <xref:System.Lazy%601> объект, который выполняет отложенную инициализацию `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#newlazy)]  
  
 В примере создается и запускается три потока, блокирующие на <xref:System.Threading.ManualResetEvent> объекта, чтобы пример можно освободить потоков за один раз. В `ThreadProc` , используемый для всех трех потоков, вызвав метод <xref:System.Lazy%601.Value%2A> свойство создает `LargeObject` экземпляр:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#valueprop)]  
  
 Так как конструктор для <xref:System.Lazy%601> указанный экземпляр <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, все три потока разрешено создавать `LargeObject` экземпляров. Это демонстрируется в примере путем отображения сообщения консоли в конструкторе и в методе завершения `LargeObject` класса:  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#ctorfinalizer)]  
  
 Тем не менее <xref:System.Lazy%601> объект гарантирует, что только один экземпляр, использованное всеми потоками. Выходные данные примера показано, что все три потока использовать того же экземпляра, а также показано, что два экземпляра можно сборщиком мусора.  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="mode" /> содержит недопустимое значение.</exception>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(T value);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : 'T -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, bool isThreadSafe) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), isThreadSafe As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, bool isThreadSafe);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * bool -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, isThreadSafe)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="isThreadSafe" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Делегат, вызываемый для создания значения с отложенной инициализацией при необходимости.</param>
        <param name="isThreadSafe">Значение <see langword="true" />, если необходимо разрешить параллельное использование этого экземпляра несколькими потоками; значение <see langword="false" />, если необходимо разрешить одновременное использование этого экземпляра только одним потоком.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Lazy`1" />. Когда происходит отложенная инициализация, используются заданные функция инициализации и режим инициализации.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Потокобезопасный режим из <xref:System.Lazy%601> экземпляр, который инициализируется этим конструктором <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> Если `isThreadSafe` — `true`; в противном случае используется режим <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>. Режим потокобезопасности описывает поведение, когда несколько потоков пытаются инициализировать <xref:System.Lazy%601> экземпляра.  
  
 Чтобы указать <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> режиме, используйте <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29> или <xref:System.Lazy%601.%23ctor%28System.Threading.LazyThreadSafetyMode%29> конструктор.  
  
 Исключения, вызываемые `valueFactory` кэшируются. Дополнительные сведения см. в описании класса <xref:System.Lazy%601> или перечисления <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере показано использование этого конструктора для предоставления отложенной инициализации с исключением, кэширование, в сценарии с одним потоком. Он также демонстрирует использование <xref:System.Lazy%601.%23ctor%2A> конструктор (указание <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> для `mode`). Чтобы переключиться в конструктор, замените закомментирован какой конструктор.  
  
> [!NOTE]
>  Для кода, в котором показано, как использовать этот конструктор в сценариях с несколькими потоками (указание `true` для `isThreadSafe`), см. пример для <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29> конструктор.  
  
 В этом примере определяется класс `LargeObject`, для которого будет выполняться отложенная инициализация одним из нескольких потоков. Три ключевых фрагменты кода показывают Создание инициализатор, фактическую инициализацию и конструктор `LargeObject` класса, в котором показано кэширование исключений. В начале метода `Main` в этом примере создается потокобезопасный отложенный инициализатор для класса `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#newlazy)]  
  
 В вызове в конструктор `isThreadSafe` параметр `false`, поэтому <xref:System.Lazy%601> не является потокобезопасным. Так как он не является потокобезопасным, в примере вызывается <xref:System.Lazy%601.Value%2A> свойство три раза в одном потоке:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#valueprop)]  
  
 В конструкторе `LargeObject` класса, третий ключевой части кода приводит к возникновению исключения первый раз `LargeObject` экземпляр создается, но впоследствии разрешает создание экземпляра возникает:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#largector)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#LargeCtor](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#largector)]  
  
 При запуске данного примера первая попытка создать экземпляр `LargeObject` завершается с ошибкой и исключение перехватывается. Можно предположить, что попытка Далее будет выполнено успешно, но <xref:System.Lazy%601> объекта кэшировал исключение. По этой причине все три попытки исключение.  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncBool#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncbool/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="valueFactory" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Lazy (Func&lt;T&gt; valueFactory, System.Threading.LazyThreadSafetyMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Func`1&lt;!T&gt; valueFactory, valuetype System.Threading.LazyThreadSafetyMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.#ctor(System.Func{`0},System.Threading.LazyThreadSafetyMode)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (valueFactory As Func(Of T), mode As LazyThreadSafetyMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Lazy(Func&lt;T&gt; ^ valueFactory, System::Threading::LazyThreadSafetyMode mode);" />
      <MemberSignature Language="F#" Value="new Lazy&lt;'T&gt; : Func&lt;'T&gt; * System.Threading.LazyThreadSafetyMode -&gt; Lazy&lt;'T&gt;" Usage="new System.Lazy&lt;'T&gt; (valueFactory, mode)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
        <Parameter Name="mode" Type="System.Threading.LazyThreadSafetyMode" />
      </Parameters>
      <Docs>
        <param name="valueFactory">Делегат, вызываемый для создания значения с отложенной инициализацией при необходимости.</param>
        <param name="mode">Одно из значений перечисления, задающее потокобезопасный режим.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Lazy`1" />, который использует заданную функцию инициализации и потокобезопасный режим.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Потокобезопасный режим из <xref:System.Lazy%601> экземпляр описывает поведение, когда несколько потоков пытаются инициализировать <xref:System.Lazy%601> экземпляра.  
  
 Исключения, вызываемые `valueFactory` кэшируются, если не `mode` — <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>. Дополнительные сведения см. в описании класса <xref:System.Lazy%601> или перечисления <xref:System.Threading.LazyThreadSafetyMode?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере показано использование этого конструктора для создания отложенный инициализатор, который позволяет нескольким потокам симуляторы для создания объекта неактивно. Несколько потоков могут в успешном создании экземпляров, но все потоки использовать экземпляр, который сначала был создан. Кроме того, в примере показано, что исключения не кэшируются при указании <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, даже если инициализация выполняется функцией, а не конструктором по умолчанию неактивно созданного типа.  
  
> [!NOTE]
>  Пример, демонстрирующий, как использовать этот конструктор в однопоточных сценариях (указание <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType> для `mode`), в разделе <xref:System.Lazy%601.%23ctor%28System.Boolean%29> конструктор. Пример, демонстрирующий, как использовать этот конструктор, чтобы обеспечить блокировку вместо состояния гонки в сценариях с несколькими потоками (указание <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> для `mode`), в разделе <xref:System.Lazy%601.%23ctor> конструктор.  
  
 В примере определяется `LargeObject` класс, который будет выполняться отложенная инициализация с помощью любого из нескольких потоков. Четыре ключевых раздела кода иллюстрируют Создание инициализатор, фактическую инициализацию, функцию инициализации и конструктор и метод завершения из `LargeObject` класса. В начале `Main` метода, в примере создается <xref:System.Lazy%601> объект, который выполняет отложенную инициализацию `LargeObject`:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#newlazy)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#NewLazy](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#newlazy)]  
  
 Функция отложенный инициализатор для выполнения инициализации. В этом случае функция является обязательным, поскольку нет конструктора по умолчанию для `LargeObject` класса.  
  
 В примере создается и запускается три потока, блокирующие на <xref:System.Threading.ManualResetEvent> объекта, чтобы пример можно освободить потоков за один раз. В `ThreadProc` , используемый для всех трех потоков, вызвав метод <xref:System.Lazy%601.Value%2A> свойство создает `LargeObject` экземпляр:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#valueprop)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#ValueProp](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#valueprop)]  
  
 В третьем ключа раздела кода, вызывается функция отложенной инициализации для создания `LargeObject` экземпляра. Эта функция создает исключение первого времени при вызове:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#factoryfunc)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#FactoryFunc](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#factoryfunc)]  
  
 Для любого другого <xref:System.Threading.LazyThreadSafetyMode> параметр необработанного исключения в функции инициализации будут кэшироваться. Однако <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType> отключает кэширование исключений. Выходные данные примера показано повторная попытка инициализации объекта выполняется успешно.  
  
> [!NOTE]
>  После сообщения о том, другие потоки успешно инициализированы объект обычно отображается сообщение об исключении. Причина-задержка, вызванная путем создания и перехвата исключения.  
  
 Так как конструктор для <xref:System.Lazy%601> указанный экземпляр <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, все три потока разрешено создавать `LargeObject` экземпляров. Это демонстрируется в примере путем отображения сообщения консоли в конструкторе и в методе завершения `LargeObject` класса:  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#ctorfinalizer)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#CtorFinalizer](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#ctorfinalizer)]  
  
 <xref:System.Lazy%601> Объект гарантирует, что только один экземпляр используется всеми потоками (за исключением потока, где функция инициализации вызывает исключение). Это показано в выходные данные примера.  
  
> [!NOTE]
>  Для простоты в этом примере используется глобальный экземпляр класса <xref:System.Lazy%601>, а все методы объявлены как `static` (`Shared` в Visual Basic). Это не является обязательными требованиями для использования отложенной инициализации.  
  
 [!code-csharp[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/cs/example.cs#all)]
 [!code-vb[System.Lazy\`1.ctorFuncLTSM#All](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.lazy`1.ctorfuncltsm/vb/example.vb#all)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Параметр <paramref name="mode" /> содержит недопустимое значение.</exception>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="valueFactory" /> имеет значение <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="IsValueCreated">
      <MemberSignature Language="C#" Value="public bool IsValueCreated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueCreated" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.IsValueCreated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueCreated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueCreated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueCreated : bool" Usage="System.Lazy&lt;'T&gt;.IsValueCreated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает значение, указывающее, было ли создано значение для данного экземпляра <see cref="T:System.Lazy`1" />.</summary>
        <value>Значение <see langword="true" />, если для данного экземпляра <see cref="T:System.Lazy`1" /> было создано значение; в противном случае — значение <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Когда происходит отложенная инициализация для <xref:System.Lazy%601> экземпляр, он может повлечь создается значение или исключение. Если исключение создается, последующего поведение <xref:System.Lazy%601> экземпляр, зависит ли кэширование исключений действует. Если <xref:System.Lazy%601> был создан экземпляр, используя конструктор, который не соответствует функции инициализации, то кэширование исключений не действует. Повторная попытка инициализировать <xref:System.Lazy%601> может завершиться успешно и после успешной инициализации <xref:System.Lazy%601.IsValueCreated%2A> возвращает `true`. Если <xref:System.Lazy%601> экземпляр был создан с помощью функции инициализации (заданные `valueFactory` параметр <xref:System.Lazy%601> конструктора), а затем кэширование исключений управляется потокобезопасный режим.  
  
-   Если используется режим <xref:System.Threading.LazyThreadSafetyMode.ExecutionAndPublication?displayProperty=nameWithType> или <xref:System.Threading.LazyThreadSafetyMode.None?displayProperty=nameWithType>, нет возможности для инициализации второго <xref:System.Lazy%601> экземпляра. Если исключение возникает и не было обработано в функции инициализации, исключение кэшируется и повторно вызывается на последующие обращения к <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> свойство. Значение не создается, если создается исключение, поэтому в таких случаях <xref:System.Lazy%601.IsValueCreated%2A> возвращает `false`.  
  
-   Если используется режим <xref:System.Threading.LazyThreadSafetyMode.PublicationOnly?displayProperty=nameWithType>, первый поток, успешно запущена функция инициализации (или конструктор по умолчанию) создает значение для <xref:System.Lazy%601> экземпляра. Если функция инициализации вызывает исключение в одном потоке, другие потоки все еще могут попытаться инициализировать <xref:System.Lazy%601> экземпляра. До создания значение <xref:System.Lazy%601.IsValueCreated%2A> возвращает `false`.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.LazyThreadSafetyMode" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Lazy`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="lazy.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Создает и возвращает строковое представление свойства <see cref="P:System.Lazy`1.Value" /> данного экземпляра.</summary>
        <returns>Результат вызова метода <see cref="M:System.Object.ToString" /> для свойства <see cref="P:System.Lazy`1.Value" /> данного экземпляра, если это значение было создано (то есть если свойство <see cref="P:System.Lazy`1.IsValueCreated" /> возвращает значение <see langword="true" />). В противном случае строка, указывающая, что значение не создано.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Вызов этого метода не вызывает инициализацию.  
  
 <xref:System.Lazy%601.Value%2A?displayProperty=nameWithType> Свойство может быть `null` после отложенной инициализации, если метод фабрики, который был указан для `valueFactory` параметр <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>, или <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> конструктор возвращает `null`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">Значение свойства <see cref="P:System.Lazy`1.Value" /> — <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Value">
      <MemberSignature Language="C#" Value="public T Value { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Value" />
      <MemberSignature Language="DocId" Value="P:System.Lazy`1.Value" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Value As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T Value { T get(); };" />
      <MemberSignature Language="F#" Value="member this.Value : 'T" Usage="System.Lazy&lt;'T&gt;.Value" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Diagnostics.DebuggerBrowsable(System.Diagnostics.DebuggerBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает неактивно инициализированное значение текущего экземпляра <see cref="T:System.Lazy`1" />.</summary>
        <value>Неактивно инициализированное значение текущего экземпляра <see cref="T:System.Lazy`1" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если <xref:System.Lazy%601.IsValueCreated%2A?displayProperty=nameWithType> свойство `false`, доступ к свойству <xref:System.Lazy%601.Value%2A> свойство вызывает инициализацию.  
  
 Кроме исключений, которые перечислены <xref:System.Lazy%601.Value%2A> свойства можно вызывать любые необработанное исключение, вызванное фабричный метод, который был передан в `valueFactory` параметр <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%29>, <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Threading.LazyThreadSafetyMode%29>, или <xref:System.Lazy%601.%23ctor%28System.Func%7B%600%7D%2CSystem.Boolean%29> конструктор.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException">Экземпляр <see cref="T:System.Lazy`1" /> инициализируется для использования конструктора по умолчанию, имеющего тип с отложенной инициализацией, а разрешения для доступа к конструктору отсутствуют.</exception>
        <exception cref="T:System.MissingMemberException">Экземпляр <see cref="T:System.Lazy`1" /> инициализируется для использования конструктора по умолчанию, имеющего тип с отложенной инициализацией, и данный тип не имеет открытого конструктора, не принимающего параметров.</exception>
        <exception cref="T:System.InvalidOperationException">Функция инициализации в данном экземпляре пытается получить доступ к <see cref="P:System.Lazy`1.Value" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>