<Type Name="Object" FullName="System.Object">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="0499b9ab8b5160fa80acdb83902087541206252e" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36429237" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Object" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit object" />
  <TypeSignature Language="DocId" Value="T:System.Object" />
  <TypeSignature Language="VB.NET" Value="Public Class Object" />
  <TypeSignature Language="C++ CLI" Value="public ref class Object" />
  <TypeSignature Language="F#" Value="type obj = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="63c59-101">Поддерживает все классы в иерархии классов .NET Framework и предоставляет низкоуровневые службы для производных классов.</span>
      <span class="sxs-lookup">
        <span data-stu-id="63c59-101">Supports all classes in the .NET Framework class hierarchy and provides low-level services to derived classes.</span>
      </span>
      <span data-ttu-id="63c59-102">Он является исходным базовым классом для всех классов платформы .NET Framework и корнем иерархии типов.</span>
      <span class="sxs-lookup">
        <span data-stu-id="63c59-102">This is the ultimate base class of all classes in the .NET Framework; it is the root of the type hierarchy.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63c59-103">Языки обычно не требуется объявлять наследование от класс <xref:System.Object> так, как наследование происходит неявно.</span><span class="sxs-lookup"><span data-stu-id="63c59-103">Languages typically do not require a class to declare inheritance from <xref:System.Object> because the inheritance is implicit.</span></span>  
  
 <span data-ttu-id="63c59-104">Поскольку все классы в .NET Framework являются производными от <xref:System.Object>, каждый метод, определенный в <xref:System.Object> класс доступен во всех объектах в системе.</span><span class="sxs-lookup"><span data-stu-id="63c59-104">Because all classes in the .NET Framework are derived from <xref:System.Object>, every method defined in the <xref:System.Object> class is available in all objects in the system.</span></span> <span data-ttu-id="63c59-105">Производные классы могут и переопределить некоторые из этих методов, включая:</span><span class="sxs-lookup"><span data-stu-id="63c59-105">Derived classes can and do override some of these methods, including:</span></span>  
  
-   <span data-ttu-id="63c59-106"><xref:System.Object.Equals%2A> — Поддерживает сравнение объектов.</span><span class="sxs-lookup"><span data-stu-id="63c59-106"><xref:System.Object.Equals%2A> - Supports comparisons between objects.</span></span>  
  
-   <span data-ttu-id="63c59-107"><xref:System.Object.Finalize%2A> -Выполняет операции очистки, прежде чем будет автоматически удален объект.</span><span class="sxs-lookup"><span data-stu-id="63c59-107"><xref:System.Object.Finalize%2A> - Performs cleanup operations before an object is automatically reclaimed.</span></span>  
  
-   <span data-ttu-id="63c59-108"><xref:System.Object.GetHashCode%2A> — Создает число, соответствующее значению объекта, для поддержки использования хэш-таблицы.</span><span class="sxs-lookup"><span data-stu-id="63c59-108"><xref:System.Object.GetHashCode%2A> - Generates a number corresponding to the value of the object to support the use of a hash table.</span></span>  
  
-   <span data-ttu-id="63c59-109"><xref:System.Object.ToString%2A> — Создает удобочитаемого текста строку, описывающую экземпляр класса.</span><span class="sxs-lookup"><span data-stu-id="63c59-109"><xref:System.Object.ToString%2A> - Manufactures a human-readable text string that describes an instance of the class.</span></span>  
  
## <a name="performance-considerations"></a><span data-ttu-id="63c59-110">Особенности производительности</span><span class="sxs-lookup"><span data-stu-id="63c59-110">Performance Considerations</span></span>  
 <span data-ttu-id="63c59-111">При создании класса, такие как коллекции, который должен обрабатывать любой тип объекта, можно создать члены класса, принимающие экземпляры <xref:System.Object> класса.</span><span class="sxs-lookup"><span data-stu-id="63c59-111">If you are designing a class, such as a collection, that must handle any type of object, you can create class members that accept instances of the <xref:System.Object> class.</span></span> <span data-ttu-id="63c59-112">Тем не менее процесс упаковка-преобразование и распаковка-преобразование типа приводит к снижению производительности.</span><span class="sxs-lookup"><span data-stu-id="63c59-112">However, the process of boxing and unboxing a type carries a performance cost.</span></span> <span data-ttu-id="63c59-113">Если известно, что новый класс будет часто обрабатывать определенные типы значений можно использовать один из двух методик для минимизации затрат на упаковки-преобразования.</span><span class="sxs-lookup"><span data-stu-id="63c59-113">If you know your new class will frequently handle certain value types you can use one of two tactics to minimize the cost of boxing.</span></span>  
  
-   <span data-ttu-id="63c59-114">Создание общего метода, принимающую <xref:System.Object> тип и набор из перегрузок метода, принимающих значения всех типов, предполагается, что класс обрабатываться.</span><span class="sxs-lookup"><span data-stu-id="63c59-114">Create a general method that accepts an <xref:System.Object> type, and a set of type-specific method overloads that accept each value type you expect your class to frequently handle.</span></span> <span data-ttu-id="63c59-115">Если существует определенный метод, который принимает тип параметра вызова, вызывается метод определенного типа и упаковка-преобразование не происходит.</span><span class="sxs-lookup"><span data-stu-id="63c59-115">If a type-specific method exists that accepts the calling parameter type, no boxing occurs and the type-specific method is invoked.</span></span> <span data-ttu-id="63c59-116">Если аргумент не метод, который соответствует типу параметра вызова, вызывается метод общие и выполняется упаковка.</span><span class="sxs-lookup"><span data-stu-id="63c59-116">If there is no method argument that matches the calling parameter type, the parameter is boxed and the general method is invoked.</span></span>  
  
-   <span data-ttu-id="63c59-117">Разработка данного типа и его члены для использования универсальных шаблонов.</span><span class="sxs-lookup"><span data-stu-id="63c59-117">Design your type and its members to use generics.</span></span> <span data-ttu-id="63c59-118">Общеязыковая среда выполнения создает закрытого универсального типа, при создании экземпляра этого класса и указывать аргумент универсального типа.</span><span class="sxs-lookup"><span data-stu-id="63c59-118">The common language runtime creates a closed generic type when you create an instance of your class and specify a generic type argument.</span></span> <span data-ttu-id="63c59-119">Универсальный метод определенного типа и его можно вызывать без упаковки-преобразования параметра вызова.</span><span class="sxs-lookup"><span data-stu-id="63c59-119">The generic method is type-specific and can be invoked without boxing the calling parameter.</span></span>  
  
 <span data-ttu-id="63c59-120">Несмотря на то, что иногда бывает необходимо создавать классы общего назначения, которые принимают и возвращают <xref:System.Object> типов, можно повысить производительность, можно также создать класс конкретного типа для реализации часто используемых типов.</span><span class="sxs-lookup"><span data-stu-id="63c59-120">Although it is sometimes necessary to develop general purpose classes that accept and return <xref:System.Object> types, you can improve performance by also providing a type-specific class to handle a frequently used type.</span></span> <span data-ttu-id="63c59-121">Например предоставления класса, относящиеся к установке и получении логические значения, можно избежать затрат упаковка-преобразование и распаковка-преобразование логических значений.</span><span class="sxs-lookup"><span data-stu-id="63c59-121">For example, providing a class that is specific to setting and getting Boolean values eliminates the cost of boxing and unboxing Boolean values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="63c59-122">В следующем примере определяется точка типа, производного от <xref:System.Object> класса и переопределение множества виртуальных методов <xref:System.Object> класса.</span><span class="sxs-lookup"><span data-stu-id="63c59-122">The following example defines a Point type derived from the <xref:System.Object> class and overrides many of the virtual methods of the <xref:System.Object> class.</span></span> <span data-ttu-id="63c59-123">Кроме того, в примере показано вызывать многие статических и методы экземпляра <xref:System.Object> класса.</span><span class="sxs-lookup"><span data-stu-id="63c59-123">In addition, the example shows how to call many of the static and instance methods of the <xref:System.Object> class.</span></span>  
  
 [!code-cpp[ObjectX#1](~/samples/snippets/cpp/VS_Snippets_CLR/ObjectX/cpp/ObjectX.cpp#1)]
 [!code-csharp[ObjectX#1](~/samples/snippets/csharp/VS_Snippets_CLR/ObjectX/CS/ObjectX.cs#1)]
 [!code-vb[ObjectX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ObjectX/vb/objectX.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="63c59-124">Открытые статические (<see langword="Shared" /> в Visual Basic) члены этого типа являются потокобезопасными.</span>
      <span class="sxs-lookup">
        <span data-stu-id="63c59-124">Public static (<see langword="Shared" /> in Visual Basic) members of this type are thread safe.</span>
      </span>
      <span data-ttu-id="63c59-125">Члены экземпляров не гарантируется потокобезопасность.</span>
      <span class="sxs-lookup">
        <span data-stu-id="63c59-125">Instance members are not guaranteed to be thread-safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Object ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Object();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="63c59-126">Инициализирует новый экземпляр класса <see cref="T:System.Object" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63c59-126">Initializes a new instance of the <see cref="T:System.Object" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63c59-127">Этот конструктор вызывается конструкторами в производных классах, но он также может использоваться для непосредственного создания экземпляра <xref:System.Object> класса.</span><span class="sxs-lookup"><span data-stu-id="63c59-127">This constructor is called by constructors in derived classes, but it can also be used to directly create an instance of the <xref:System.Object> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="63c59-128">Определяет, равны ли два экземпляра объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63c59-128">Determines whether two object instances are equal.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member Equals : obj -&gt; bool&#xA;override this.Equals : obj -&gt; bool" Usage="obj.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="63c59-129">Объект, который требуется сравнить с текущим объектом.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63c59-129">The object to compare with the current object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="63c59-130">Определяет, равен ли заданный объект текущему объекту.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63c59-130">Determines whether the specified object is equal to the current object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="63c59-131">Значение <see langword="true" />, если указанный объект равен текущему объекту; в противном случае — значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63c59-131">
              <see langword="true" /> if the specified object  is equal to the current object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63c59-132">Тип сравнения между текущим экземпляром и `obj` параметр зависит от того, является ли текущий экземпляр является ссылочным типом или типом значения.</span><span class="sxs-lookup"><span data-stu-id="63c59-132">The type of comparison between the current instance and the `obj` parameter depends on whether the current instance is a reference type or a value type.</span></span>  
  
-   <span data-ttu-id="63c59-133">Если текущий экземпляр является ссылочным типом, <xref:System.Object.Equals%28System.Object%29> метод тесты на равенство ссылок и вызов <xref:System.Object.Equals%28System.Object%29> метод эквивалентен вызов <xref:System.Object.ReferenceEquals%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="63c59-133">If the current instance is a reference type, the <xref:System.Object.Equals%28System.Object%29> method tests for reference equality, and a call to the <xref:System.Object.Equals%28System.Object%29> method is equivalent to a call to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="63c59-134">Равенство ссылок означает, что объектные переменные, которые сравниваются ссылаются на один объект.</span><span class="sxs-lookup"><span data-stu-id="63c59-134">Reference equality means that the object variables that are compared refer to the same object.</span></span> <span data-ttu-id="63c59-135">В следующем примере показано, в результате такого сопоставления.</span><span class="sxs-lookup"><span data-stu-id="63c59-135">The following example illustrates the result of such a comparison.</span></span> <span data-ttu-id="63c59-136">Он определяет `Person` класс, который является ссылочным типом, и вызывает метод `Person` класс конструктора для создания двух новых `Person` объектов, `person1a` и `person2`, который имеет то же значение.</span><span class="sxs-lookup"><span data-stu-id="63c59-136">It defines a `Person` class, which is a reference type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1a` and `person2`, which have the same value.</span></span> <span data-ttu-id="63c59-137">Также назначает `person1a` другой переменной объекта `person1b`.</span><span class="sxs-lookup"><span data-stu-id="63c59-137">It also assigns `person1a` to another object variable, `person1b`.</span></span> <span data-ttu-id="63c59-138">Как видно в результатах показано в примере `person1a` и `person1b` равны, поскольку они ссылаются на один объект.</span><span class="sxs-lookup"><span data-stu-id="63c59-138">As the output from the example shows, `person1a` and `person1b` are equal because they reference the same object.</span></span> <span data-ttu-id="63c59-139">Тем не менее `person1a` и `person2` не равны, несмотря на то, что они имеют одинаковое значение.</span><span class="sxs-lookup"><span data-stu-id="63c59-139">However, `person1a` and `person2` are not equal, although they have the same value.</span></span>  
  
     [!code-csharp[System.Object.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_ref.cs#2)]
     [!code-vb[System.Object.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_ref.vb#2)]  
  
-   <span data-ttu-id="63c59-140">Если текущий экземпляр является типом значения, <xref:System.Object.Equals%28System.Object%29> метод проверка на равенство значений.</span><span class="sxs-lookup"><span data-stu-id="63c59-140">If the current instance is a value type, the <xref:System.Object.Equals%28System.Object%29> method tests for value equality.</span></span> <span data-ttu-id="63c59-141">Равенство значений означает следующее.</span><span class="sxs-lookup"><span data-stu-id="63c59-141">Value equality means the following:</span></span>  
  
    -   <span data-ttu-id="63c59-142">Два объекта имеют тот же тип.</span><span class="sxs-lookup"><span data-stu-id="63c59-142">The two objects are of the same type.</span></span> <span data-ttu-id="63c59-143">Как показано в следующем примере, <xref:System.Byte> объект, имеющий значение 12 не равно <xref:System.Int32> объект, имеющий значение 12, поскольку оба объекта имеют разные типы во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="63c59-143">As the following example shows, a <xref:System.Byte> object that has a value of 12 does not equal an <xref:System.Int32> object that has a value of 12, because the two objects have different run-time types.</span></span>  
  
         [!code-csharp[System.Object.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val1.cs#3)]
         [!code-vb[System.Object.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val1.vb#3)]  
  
    -   <span data-ttu-id="63c59-144">Значения открытых и закрытых полей из двух объектов равны.</span><span class="sxs-lookup"><span data-stu-id="63c59-144">The values of the public and private fields of the two objects are equal.</span></span> <span data-ttu-id="63c59-145">В следующем примере проверка на равенство значений.</span><span class="sxs-lookup"><span data-stu-id="63c59-145">The following example tests for value equality.</span></span> <span data-ttu-id="63c59-146">Он определяет `Person` структуру, которая является типом значения, и вызывает метод `Person` класс конструктора для создания двух новых `Person` объектов, `person1` и `person2`, который имеет то же значение.</span><span class="sxs-lookup"><span data-stu-id="63c59-146">It defines a `Person` structure, which is a value type, and calls the `Person` class constructor to instantiate two new `Person` objects, `person1` and `person2`, which have the same value.</span></span> <span data-ttu-id="63c59-147">Как показывают выходные данные примера, несмотря на то, что две переменные объекта ссылаются на разные объекты, `person1` и `person2` равны, поскольку они имеют одинаковое значение для частного `personName` поля.</span><span class="sxs-lookup"><span data-stu-id="63c59-147">As the output from the example shows, although the two object variables refer to different objects, `person1` and `person2` are equal because they have the same value for the private `personName` field.</span></span>  
  
         [!code-csharp[System.Object.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_val2.cs#4)]
         [!code-vb[System.Object.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_val2.vb#4)]  
  
 <span data-ttu-id="63c59-148">Поскольку <xref:System.Object> класс является базовым классом для всех типов в .NET Framework, <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> метод обеспечивает сравнение на равенство по умолчанию для всех других типов.</span><span class="sxs-lookup"><span data-stu-id="63c59-148">Because the <xref:System.Object> class is the base class for all types in the .NET Framework, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method provides the default equality comparison for all other types.</span></span> <span data-ttu-id="63c59-149">Тем не менее, часто переопределить типы <xref:System.Object.Equals%2A> метод, чтобы реализовать равенство значений.</span><span class="sxs-lookup"><span data-stu-id="63c59-149">However, types often override the <xref:System.Object.Equals%2A> method to implement value equality.</span></span> <span data-ttu-id="63c59-150">Дополнительные сведения см. примечания вызывающим объектам и примечания для наследующих объектов разделов.</span><span class="sxs-lookup"><span data-stu-id="63c59-150">For more information, see the Notes for Callers and Notes for Inheritors sections.</span></span>  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="63c59-151">Заметки о [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="63c59-151">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="63c59-152">При вызове <xref:System.Object.Equals%28System.Object%29> перегрузка метода класса в [!INCLUDE[wrt](~/includes/wrt-md.md)], он предоставляет поведение по умолчанию для классов, которые не переопределяют <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="63c59-152">When you call the <xref:System.Object.Equals%28System.Object%29> method overload on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don’t override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="63c59-153">Это является частью возможностей .NET Framework для [!INCLUDE[wrt](~/includes/wrt-md.md)] (см. [.NET Framework поддерживает для приложений магазина Windows и среды выполнения Windows](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="63c59-153">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="63c59-154">Классы в [!INCLUDE[wrt](~/includes/wrt-md.md)] не наследуют <xref:System.Object>и в настоящее время не использовать <xref:System.Object.Equals%28System.Object%29> метода.</span><span class="sxs-lookup"><span data-stu-id="63c59-154">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don’t inherit <xref:System.Object>, and currently don’t implement an <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="63c59-155">При этом они будут иметь <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, и <xref:System.Object.GetHashCode%2A> методов при их использовании в коде C# или Visual Basic и .NET Framework предоставляет поведение по умолчанию для этих методов.</span><span class="sxs-lookup"><span data-stu-id="63c59-155">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)]<span data-ttu-id="63c59-156"> классы, написанные на C# или Visual Basic можно переопределить <xref:System.Object.Equals%28System.Object%29> перегрузки метода.</span><span class="sxs-lookup"><span data-stu-id="63c59-156"> classes that are written in C# or Visual Basic can override the <xref:System.Object.Equals%28System.Object%29> method overload.</span></span>  
  
## <a name="notes-for-callers"></a><span data-ttu-id="63c59-157">Примечания для вызывающих объектов</span><span class="sxs-lookup"><span data-stu-id="63c59-157">Notes for Callers</span></span>  
 <span data-ttu-id="63c59-158">Производные классы переопределяют часто <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> метод, чтобы реализовать равенство значений.</span><span class="sxs-lookup"><span data-stu-id="63c59-158">Derived classes frequently override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to implement value equality.</span></span> <span data-ttu-id="63c59-159">Кроме того, типы также часто предоставляют дополнительные перегрузка строго типизированные для `Equals` метод, как правило, реализовав <xref:System.IEquatable%601> интерфейса.</span><span class="sxs-lookup"><span data-stu-id="63c59-159">In addition, types also frequently provide an additional strongly typed overload to the `Equals` method, typically by implementing the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="63c59-160">При вызове `Equals` метод для проверки на равенство, следует знать, является ли текущий экземпляр переопределяет <xref:System.Object.Equals%2A?displayProperty=nameWithType> и понять, каким образом определенного вызова `Equals` метод разрешается.</span><span class="sxs-lookup"><span data-stu-id="63c59-160">When you call the `Equals` method to test for equality, you should know whether the current instance overrides <xref:System.Object.Equals%2A?displayProperty=nameWithType> and understand how a particular call to an `Equals` method is resolved.</span></span> <span data-ttu-id="63c59-161">В противном случае может выполнять проверку на равенство, которое отличается от требуемого, и метод может возвратить непредвиденное значение.</span><span class="sxs-lookup"><span data-stu-id="63c59-161">Otherwise, you may be performing a test for equality that is different from what you intended, and the method may return an unexpected value.</span></span>  
  
 <span data-ttu-id="63c59-162">Ниже приведен пример.</span><span class="sxs-lookup"><span data-stu-id="63c59-162">The following example provides an illustration.</span></span> <span data-ttu-id="63c59-163">Он создает три <xref:System.Text.StringBuilder> объекты с одинаковых строк, а затем вызывает четыре `Equals` методы.</span><span class="sxs-lookup"><span data-stu-id="63c59-163">It instantiates three <xref:System.Text.StringBuilder> objects with identical strings, and then makes four calls to `Equals` methods.</span></span> <span data-ttu-id="63c59-164">Первый метод вызова возвращает `true`и для остальных трех возвращаемого `false`.</span><span class="sxs-lookup"><span data-stu-id="63c59-164">The first method call returns `true`, and the remaining three return `false`.</span></span>  
  
 [!code-csharp[System.Object.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalssb1.cs#5)]
 [!code-vb[System.Object.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalssb1.vb#5)]  
  
 <span data-ttu-id="63c59-165">В первом случае строго типизированный <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> вызове перегруженного метода, который проверяет равенство значений.</span><span class="sxs-lookup"><span data-stu-id="63c59-165">In the first case, the strongly typed <xref:System.Text.StringBuilder.Equals%28System.Text.StringBuilder%29?displayProperty=nameWithType> method overload, which tests for value equality, is called.</span></span> <span data-ttu-id="63c59-166">Поскольку строки назначены два <xref:System.Text.StringBuilder> объекты равны, метод возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="63c59-166">Because the strings assigned to the two <xref:System.Text.StringBuilder> objects are equal, the method returns `true`.</span></span> <span data-ttu-id="63c59-167">Тем не менее <xref:System.Text.StringBuilder> не переопределяет <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="63c59-167">However, <xref:System.Text.StringBuilder> does not override <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="63c59-168">По этой причине при <xref:System.Text.StringBuilder> объект приведен <xref:System.Object>, когда <xref:System.Text.StringBuilder> экземпляра присваивается переменной типа <xref:System.Object>и когда <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> методу передается два <xref:System.Text.StringBuilder> объекты, значение по умолчанию <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>вызывается метод.</span><span class="sxs-lookup"><span data-stu-id="63c59-168">Because of this, when the <xref:System.Text.StringBuilder> object is cast to an <xref:System.Object>, when a <xref:System.Text.StringBuilder> instance is assigned to a variable of type <xref:System.Object>, and when the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29?displayProperty=nameWithType> method is passed two <xref:System.Text.StringBuilder> objects, the default <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="63c59-169">Поскольку <xref:System.Text.StringBuilder> является ссылочным типом, это эквивалентно передаче два <xref:System.Text.StringBuilder> объектов <xref:System.Object.ReferenceEquals%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="63c59-169">Because <xref:System.Text.StringBuilder> is a reference type, this is equivalent to passing the two <xref:System.Text.StringBuilder> objects to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="63c59-170">Хотя все три <xref:System.Text.StringBuilder> объекты содержат идентичные строки, они ссылаются на трех различных объектов.</span><span class="sxs-lookup"><span data-stu-id="63c59-170">Although all three <xref:System.Text.StringBuilder> objects contain identical strings, they refer to three distinct objects.</span></span> <span data-ttu-id="63c59-171">В результате эти три метода вызывает возвращаемого `false`.</span><span class="sxs-lookup"><span data-stu-id="63c59-171">As a result, these three method calls return `false`.</span></span>  
  
 <span data-ttu-id="63c59-172">Вы можете сравнить текущий объект в другой объект на равенство ссылок путем вызова <xref:System.Object.ReferenceEquals%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="63c59-172">You can compare the current object to another object for reference equality by calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="63c59-173">В Visual Basic можно использовать `is` ключевое слово (например, `If Me Is otherObject Then ...`).</span><span class="sxs-lookup"><span data-stu-id="63c59-173">In Visual Basic, you can also use the `is` keyword (for example, `If Me Is otherObject Then ...`).</span></span>  
  
## <a name="notes-for-inheritors"></a><span data-ttu-id="63c59-174">Примечания для наследующих объектов</span><span class="sxs-lookup"><span data-stu-id="63c59-174">Notes for Inheritors</span></span>  
 <span data-ttu-id="63c59-175">При определении собственного типа, этот тип наследует функциональные возможности, определенные `Equals` метод базового типа.</span><span class="sxs-lookup"><span data-stu-id="63c59-175">When you define your own type, that type inherits the functionality defined by the `Equals` method of its base type.</span></span> <span data-ttu-id="63c59-176">В следующей таблице перечислены реализации по умолчанию `Equals` метод для основных категорий типов в .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="63c59-176">The following table lists the default implementation of the `Equals` method for the major categories of types in the .NET Framework.</span></span>  
  
|<span data-ttu-id="63c59-177">Категория типа</span><span class="sxs-lookup"><span data-stu-id="63c59-177">Type category</span></span>|<span data-ttu-id="63c59-178">Равенство определяется</span><span class="sxs-lookup"><span data-stu-id="63c59-178">Equality defined by</span></span>|<span data-ttu-id="63c59-179">Комментарии</span><span class="sxs-lookup"><span data-stu-id="63c59-179">Comments</span></span>|  
|-------------------|-------------------------|--------------|  
|<span data-ttu-id="63c59-180">Класс, производный прямо из <xref:System.Object></span><span class="sxs-lookup"><span data-stu-id="63c59-180">Class derived directly from <xref:System.Object></span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="63c59-181">Равенство ссылок; аналогичен вызову <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="63c59-181">Reference equality; equivalent to calling <xref:System.Object.ReferenceEquals%2A?displayProperty=nameWithType>.</span></span>|  
|<span data-ttu-id="63c59-182">Структура</span><span class="sxs-lookup"><span data-stu-id="63c59-182">Structure</span></span>|<xref:System.ValueType.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="63c59-183">Равные значения; прямой байт за байтом сравнения или сравнения, поля с помощью отражения.</span><span class="sxs-lookup"><span data-stu-id="63c59-183">Value equality; either direct byte-by-byte comparison or field-by-field comparison using reflection.</span></span>|  
|<span data-ttu-id="63c59-184">Перечисление</span><span class="sxs-lookup"><span data-stu-id="63c59-184">Enumeration</span></span>|<xref:System.Enum.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="63c59-185">Значения должны иметь одинаковый тип перечисления и тем же базовым значением.</span><span class="sxs-lookup"><span data-stu-id="63c59-185">Values must have the same enumeration type and the same underlying value.</span></span>|  
|<span data-ttu-id="63c59-186">делегат</span><span class="sxs-lookup"><span data-stu-id="63c59-186">Delegate</span></span>|<xref:System.MulticastDelegate.Equals%2A?displayProperty=nameWithType>|<span data-ttu-id="63c59-187">Делегаты должен иметь тот же тип с списки вызовов идентичными.</span><span class="sxs-lookup"><span data-stu-id="63c59-187">Delegates must have the same type with identical invocation lists.</span></span>|  
|<span data-ttu-id="63c59-188">Интерфейс</span><span class="sxs-lookup"><span data-stu-id="63c59-188">Interface</span></span>|<xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>|<span data-ttu-id="63c59-189">Равенство ссылок.</span><span class="sxs-lookup"><span data-stu-id="63c59-189">Reference equality.</span></span>|  
  
 <span data-ttu-id="63c59-190">Для типа значения всегда должны переопределять <xref:System.Object.Equals%2A>, так как тесты на равенство, основанные на отражении являются причиной низкой производительности.</span><span class="sxs-lookup"><span data-stu-id="63c59-190">For a value type, you should always override <xref:System.Object.Equals%2A>, because tests for equality that rely on reflection offer poor performance.</span></span> <span data-ttu-id="63c59-191">Можно также переопределить реализацию по умолчанию <xref:System.Object.Equals%2A> для ссылочных типов для проверки на равенство значений, а не равенство ссылок и для определения равенства значений точное значение.</span><span class="sxs-lookup"><span data-stu-id="63c59-191">You can also override the default implementation of <xref:System.Object.Equals%2A> for reference types to test for value equality instead of reference equality and to define the precise meaning of value equality.</span></span> <span data-ttu-id="63c59-192">Такая реализация <xref:System.Object.Equals%2A> возврата `true` Если два объекта имеют одно и то же значение, даже если они не тот же экземпляр.</span><span class="sxs-lookup"><span data-stu-id="63c59-192">Such implementations of <xref:System.Object.Equals%2A> return `true` if the two objects have the same value, even if they are not the same instance.</span></span> <span data-ttu-id="63c59-193">Разработчик типа решает, что такое значение объекта, но обычно некоторые или все данные, хранящиеся в переменных экземпляра объекта.</span><span class="sxs-lookup"><span data-stu-id="63c59-193">The type's implementer decides what constitutes an object's value, but it is typically some or all the data stored in the instance variables of the object.</span></span> <span data-ttu-id="63c59-194">Например, значение <xref:System.String> объект основан на символы строки; <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> переопределения методов <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> метод для возврата `true` для любых двух экземпляров строк, которые содержат те же символы в том же порядке.</span><span class="sxs-lookup"><span data-stu-id="63c59-194">For example, the value of a <xref:System.String> object is based on the characters of the string; the <xref:System.String.Equals%28System.Object%29?displayProperty=nameWithType> method overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to return `true` for any two string instances that contain the same characters in the same order.</span></span>  
  
 <span data-ttu-id="63c59-195">В следующем примере показан способ переопределения <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> метод для проверки на равенство значений.</span><span class="sxs-lookup"><span data-stu-id="63c59-195">The following example shows how to override the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method to test for value equality.</span></span> <span data-ttu-id="63c59-196">Он переопределяет <xref:System.Object.Equals%2A> метод `Person` класса.</span><span class="sxs-lookup"><span data-stu-id="63c59-196">It overrides the <xref:System.Object.Equals%2A> method for the `Person` class.</span></span> <span data-ttu-id="63c59-197">Если `Person` принят реализацию его базового класса равенства, два `Person` объекта будут равны, только в том случае, если они ссылка на один объект.</span><span class="sxs-lookup"><span data-stu-id="63c59-197">If `Person` accepted its base class implementation of equality, two `Person` objects would be equal only if they referenced a single object.</span></span> <span data-ttu-id="63c59-198">Однако в этом случае два `Person` объекты равны, если они имеют одинаковое значение для `Person.Id` свойства.</span><span class="sxs-lookup"><span data-stu-id="63c59-198">However, in this case, two `Person` objects are equal if they have the same value for the `Person.Id` property.</span></span>  
  
 [!code-csharp[System.Object.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equalsoverride.cs#6)]
 [!code-vb[System.Object.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equalsoverride.vb#6)]  
  
 <span data-ttu-id="63c59-199">Помимо переопределения <xref:System.Object.Equals%2A>, можно реализовать <xref:System.IEquatable%601> интерфейс для предоставления строго типизированных проверка на равенство.</span><span class="sxs-lookup"><span data-stu-id="63c59-199">In addition to overriding <xref:System.Object.Equals%2A>, you can implement the <xref:System.IEquatable%601> interface to provide a strongly typed test for equality.</span></span>  
  
 <span data-ttu-id="63c59-200">Следующие инструкции должен иметь значение true для всех реализаций <xref:System.Object.Equals%28System.Object%29> метод.</span><span class="sxs-lookup"><span data-stu-id="63c59-200">The following statements must be true for all implementations of the <xref:System.Object.Equals%28System.Object%29> method.</span></span> <span data-ttu-id="63c59-201">В списке `x`, `y`, и `z` обозначают ссылки на объекты, которые не являются **null**.</span><span class="sxs-lookup"><span data-stu-id="63c59-201">In the list, `x`, `y`, and `z` represent object references that are not **null**.</span></span>  
  
-   <span data-ttu-id="63c59-202">`x.Equals(x)` Возвращает `true`, за исключением случаев, с плавающей запятой.</span><span class="sxs-lookup"><span data-stu-id="63c59-202">`x.Equals(x)` returns `true`, except in cases that involve floating-point types.</span></span> <span data-ttu-id="63c59-203">В разделе 60559:2011 ISO/IEC и IEEE, информационных технологий--микропроцессора систем--арифметических операций с плавающей запятой.</span><span class="sxs-lookup"><span data-stu-id="63c59-203">See ISO/IEC/IEEE 60559:2011, Information technology -- Microprocessor Systems -- Floating-Point arithmetic.</span></span>  
  
-   <span data-ttu-id="63c59-204">`x.Equals(y)` Возвращает то же значение, что `y.Equals(x)`.</span><span class="sxs-lookup"><span data-stu-id="63c59-204">`x.Equals(y)` returns the same value as `y.Equals(x)`.</span></span>  
  
-   <span data-ttu-id="63c59-205">`x.Equals(y)` Возвращает `true` Если оба `x` и `y` являются `NaN`.</span><span class="sxs-lookup"><span data-stu-id="63c59-205">`x.Equals(y)` returns `true` if both `x` and `y` are `NaN`.</span></span>  
  
-   <span data-ttu-id="63c59-206">Если `(x.Equals(y) && y.Equals(z))` возвращает `true`, затем `x.Equals(z)` возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="63c59-206">If `(x.Equals(y) && y.Equals(z))` returns `true`, then `x.Equals(z)` returns `true`.</span></span>  
  
-   <span data-ttu-id="63c59-207">Последующие вызовы `x.Equals(y)` возвращает то же значение, при условии, что объект, который ссылается `x` и `y` не изменяются.</span><span class="sxs-lookup"><span data-stu-id="63c59-207">Successive calls to `x.Equals(y)` return the same value as long as the objects referenced by `x` and `y` are not modified.</span></span>  
  
-   <span data-ttu-id="63c59-208">`x.Equals(null)` возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="63c59-208">`x.Equals(null)` returns `false`.</span></span>  
  
 <span data-ttu-id="63c59-209">Реализации <xref:System.Object.Equals%2A> не должны выдавать исключения; они должны всегда возвращать значение.</span><span class="sxs-lookup"><span data-stu-id="63c59-209">Implementations of <xref:System.Object.Equals%2A> must not throw exceptions; they should always return a value.</span></span> <span data-ttu-id="63c59-210">Например если `obj` — `null`, <xref:System.Object.Equals%2A> метод должен возвращать `false` вместо создания <xref:System.ArgumentNullException>.</span><span class="sxs-lookup"><span data-stu-id="63c59-210">For example, if `obj` is `null`, the <xref:System.Object.Equals%2A> method should return `false` instead of throwing an <xref:System.ArgumentNullException>.</span></span>  
  
 <span data-ttu-id="63c59-211">Придерживайтесь следующих правил при переопределении метода <xref:System.Object.Equals%28System.Object%29>:</span><span class="sxs-lookup"><span data-stu-id="63c59-211">Follow these guidelines when overriding <xref:System.Object.Equals%28System.Object%29>:</span></span>  
  
-   <span data-ttu-id="63c59-212">Типы, реализующие <xref:System.IComparable> необходимо переопределить <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="63c59-212">Types that implement <xref:System.IComparable> must override <xref:System.Object.Equals%28System.Object%29>.</span></span>  
  
-   <span data-ttu-id="63c59-213">Типы, переопределяющие <xref:System.Object.Equals%28System.Object%29> необходимо также переопределить <xref:System.Object.GetHashCode%2A>; в противном случае хэш-таблицы могут работать неправильно.</span><span class="sxs-lookup"><span data-stu-id="63c59-213">Types that override <xref:System.Object.Equals%28System.Object%29> must also override <xref:System.Object.GetHashCode%2A>; otherwise, hash tables  might not work correctly.</span></span>  
  
-   <span data-ttu-id="63c59-214">Следует рассмотреть возможность реализации <xref:System.IEquatable%601> интерфейс для поддержки строго типизированных тесты на равенство.</span><span class="sxs-lookup"><span data-stu-id="63c59-214">You should consider implementing the <xref:System.IEquatable%601> interface to support strongly typed tests for equality.</span></span> <span data-ttu-id="63c59-215">Ваш <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> реализации должен возвращать результаты, которые соответствуют <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="63c59-215">Your <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> implementation should return results that are consistent with <xref:System.Object.Equals%2A>.</span></span>  
  
-   <span data-ttu-id="63c59-216">Если язык программирования поддерживает перегрузку операторов и перегрузка оператора равенства для данного типа, необходимо также переопределить <xref:System.Object.Equals%28System.Object%29> метод для возврата тот же результат, что и оператор равенства.</span><span class="sxs-lookup"><span data-stu-id="63c59-216">If your programming language supports operator overloading and you overload the equality operator for a given type, you must also override the <xref:System.Object.Equals%28System.Object%29> method to return the same result as the equality operator.</span></span> <span data-ttu-id="63c59-217">Это позволяет гарантировать, что код библиотеки классов, использующий <xref:System.Object.Equals%2A> (такие как <xref:System.Collections.ArrayList> и <xref:System.Collections.Hashtable>) ведет себя таким способом, который согласуется с тем, как оператор равенства, используемый кодом приложения.</span><span class="sxs-lookup"><span data-stu-id="63c59-217">This  helps ensure that class library code that uses <xref:System.Object.Equals%2A> (such as <xref:System.Collections.ArrayList> and <xref:System.Collections.Hashtable>) behaves in a manner that is consistent with the way the equality operator is used by application code.</span></span>  
  
### <a name="guidelines-for-reference-types"></a><span data-ttu-id="63c59-218">Рекомендации для ссылочных типов</span><span class="sxs-lookup"><span data-stu-id="63c59-218">Guidelines for Reference Types</span></span>  
 <span data-ttu-id="63c59-219">Следующие правила применяются к переопределенным <xref:System.Object.Equals%28System.Object%29> для ссылочного типа:</span><span class="sxs-lookup"><span data-stu-id="63c59-219">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a reference type:</span></span>  
  
-   <span data-ttu-id="63c59-220">Переопределение <xref:System.Object.Equals%2A> Если семантика типа основана на том, что этот тип представляет некоторые значения.</span><span class="sxs-lookup"><span data-stu-id="63c59-220">Consider overriding <xref:System.Object.Equals%2A> if the semantics of the type are based on the fact that the type represents some value(s).</span></span>  
  
-   <span data-ttu-id="63c59-221">Большинство ссылочных типов не следует перегружать оператор равенства, даже если они переопределяют <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="63c59-221">Most reference types must not overload the equality operator, even if they override <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="63c59-222">Однако при реализации ссылочного типа, который предназначен для семантического значения, такие как тип комплексного числа, необходимо переопределить оператор равенства.</span><span class="sxs-lookup"><span data-stu-id="63c59-222">However, if you are implementing a reference type that is intended to have value semantics, such as a complex number type, you must override the equality operator.</span></span>  
  
-   <span data-ttu-id="63c59-223">Не следует переопределять <xref:System.Object.Equals%2A> на изменяемым ссылочным типом.</span><span class="sxs-lookup"><span data-stu-id="63c59-223">You should not override <xref:System.Object.Equals%2A> on a mutable reference type.</span></span> <span data-ttu-id="63c59-224">Это происходит потому переопределяет <xref:System.Object.Equals%2A> необходимо также переопределить <xref:System.Object.GetHashCode%2A> метода, как описано в предыдущем разделе.</span><span class="sxs-lookup"><span data-stu-id="63c59-224">This is because overriding <xref:System.Object.Equals%2A> requires that you also override the <xref:System.Object.GetHashCode%2A> method, as discussed in the previous section.</span></span> <span data-ttu-id="63c59-225">Это означает, что хэш-код экземпляра изменяемым ссылочным типом можно изменить во время существования, что может привести объект к потере в хэш-таблице.</span><span class="sxs-lookup"><span data-stu-id="63c59-225">This means that the hash code of an instance of a mutable reference type can change during its lifetime, which can cause the object to be lost in a hash table.</span></span>  
  
### <a name="guidelines-for-value-types"></a><span data-ttu-id="63c59-226">Правила для типов значений</span><span class="sxs-lookup"><span data-stu-id="63c59-226">Guidelines for Value Types</span></span>  
 <span data-ttu-id="63c59-227">Следующие правила применяются к переопределенным <xref:System.Object.Equals%28System.Object%29> для типа значения:</span><span class="sxs-lookup"><span data-stu-id="63c59-227">The following guidelines apply to overriding <xref:System.Object.Equals%28System.Object%29> for a value type:</span></span>  
  
-   <span data-ttu-id="63c59-228">Вы определяете тип значения, который включает одно или несколько полей, значения которого являются ссылочными типами, должны переопределять <xref:System.Object.Equals%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="63c59-228">If you are defining a value type that includes one or more fields whose values are reference types, you should override <xref:System.Object.Equals%28System.Object%29>.</span></span> <span data-ttu-id="63c59-229"><xref:System.Object.Equals%28System.Object%29> Реализации <xref:System.ValueType> выполняет сравнение байт за байтом, для которых типы значений поля являются все типы значений, но он использует отражение для выполнения сравнения с поля типов значений, поля которых включают ссылочных типов.</span><span class="sxs-lookup"><span data-stu-id="63c59-229">The <xref:System.Object.Equals%28System.Object%29> implementation provided by <xref:System.ValueType> performs a byte-by-byte comparison for value types whose fields are all value types, but it uses reflection to perform a field-by-field comparison of value types whose fields include reference types.</span></span>  
  
-   <span data-ttu-id="63c59-230">При переопределении <xref:System.Object.Equals%2A> и выбранного языка программирования поддерживает перегрузку операторов, необходимо перегрузить оператор равенства.</span><span class="sxs-lookup"><span data-stu-id="63c59-230">If you override <xref:System.Object.Equals%2A> and your development language supports operator overloading, you must overload the equality operator.</span></span>  
  
-   <span data-ttu-id="63c59-231">Вам следует реализовать <xref:System.IEquatable%601> интерфейса.</span><span class="sxs-lookup"><span data-stu-id="63c59-231">You should implement the <xref:System.IEquatable%601> interface.</span></span> <span data-ttu-id="63c59-232">Строго типизированный вызов <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> метод позволят избежать упаковка-преобразование `obj` аргумент.</span><span class="sxs-lookup"><span data-stu-id="63c59-232">Calling the strongly typed <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> method avoids boxing the `obj` argument.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="63c59-233">В следующем примере показан `Point` класс, который переопределяет <xref:System.Object.Equals%2A> метод для предоставления равенства значений и `Point3D` класс, производный от `Point`.</span><span class="sxs-lookup"><span data-stu-id="63c59-233">The following example shows a `Point` class that overrides the <xref:System.Object.Equals%2A> method to provide value equality, and a `Point3D` class that is derived from `Point`.</span></span> <span data-ttu-id="63c59-234">Поскольку `Point` переопределяет <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> для проверки на равенство значений <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> метод не вызывается.</span><span class="sxs-lookup"><span data-stu-id="63c59-234">Because `Point` overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to test for value equality, the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is not called.</span></span> <span data-ttu-id="63c59-235">Тем не менее `Point3D.Equals` вызовы `Point.Equals` из-за `Point` реализует <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> таким способом, который обеспечивает равенство значений.</span><span class="sxs-lookup"><span data-stu-id="63c59-235">However, `Point3D.Equals` calls `Point.Equals` because `Point` implements <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> in a manner that provides value equality.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals2#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals2/CS/equals2.cs#1)]
 [!code-vb[ECMA-System.Object.Equals2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals2/VB/equals2.vb#1)]  
  
 <span data-ttu-id="63c59-236">`Point.Equals` Метод проверяет, чтобы убедиться в том, что `obj` аргумент не **null** и что он ссылается на экземпляр того же типа, что и данный объект.</span><span class="sxs-lookup"><span data-stu-id="63c59-236">The `Point.Equals` method checks to make sure that the `obj` argument is not **null** and that it references an instance of the same type as this object.</span></span> <span data-ttu-id="63c59-237">Если проверка завершается с ошибкой, метод возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="63c59-237">If either check fails, the method returns `false`.</span></span>  
  
 <span data-ttu-id="63c59-238">`Point.Equals` Вызовы метода <xref:System.Object.GetType%2A> метод для определения идентичности типов времени выполнения двух объектов.</span><span class="sxs-lookup"><span data-stu-id="63c59-238">The `Point.Equals` method calls the <xref:System.Object.GetType%2A> method to determine whether the run-time types of the two objects are identical.</span></span> <span data-ttu-id="63c59-239">Если используется метод проверки формы `obj is Point` в C# или `TryCast(obj, Point)` в Visual Basic, она будет возвращать `true` в случаях, где `obj` является экземпляром класса, производного от `Point`, даже если `obj` и текущий экземпляр не того же типа во время выполнения.</span><span class="sxs-lookup"><span data-stu-id="63c59-239">If the method used a check of the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic, the check would return `true` in cases where `obj` is an instance of a derived class of `Point`, even though `obj` and the current instance are not of the same run-time type.</span></span> <span data-ttu-id="63c59-240">Убедившись, что оба объекта имеют тот же тип, метод приводит `obj` ввода `Point` и возвращает результат сравнения двух объектов полей экземпляра.</span><span class="sxs-lookup"><span data-stu-id="63c59-240">Having verified that both objects are of the same type, the method casts `obj` to type `Point` and returns the result of comparing the instance fields of the two objects.</span></span>  
  
 <span data-ttu-id="63c59-241">В `Point3D.Equals`, наследуемого `Point.Equals` метода, который переопределяет <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, вызывается перед выполнением других действий.</span><span class="sxs-lookup"><span data-stu-id="63c59-241">In `Point3D.Equals`, the inherited `Point.Equals` method, which overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType>, is invoked before anything else is done.</span></span> <span data-ttu-id="63c59-242">Поскольку `Point3D` является запечатанным (`NotInheritable` в Visual Basic), проверку в форме `obj is Point` в C# или `TryCast(obj, Point)` в Visual Basic является достаточным, чтобы убедиться, что `obj` — `Point3D` объекта.</span><span class="sxs-lookup"><span data-stu-id="63c59-242">Because `Point3D` is a sealed class (`NotInheritable` in Visual Basic), a check in the form `obj is Point` in C# or `TryCast(obj, Point)` in Visual Basic is adequate to ensure that `obj` is a `Point3D` object.</span></span> <span data-ttu-id="63c59-243">Если это `Point3D` объекта, оно приводится к `Point` объекта и передается реализации базового класса <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="63c59-243">If it is a `Point3D` object, it is cast to a `Point` object and passed to the base class implementation of <xref:System.Object.Equals%2A>.</span></span> <span data-ttu-id="63c59-244">Только если наследуемого `Point.Equals` возвращает `true` метод compare `z` экземпляр поля, введенные в производном классе.</span><span class="sxs-lookup"><span data-stu-id="63c59-244">Only when the inherited `Point.Equals` method returns `true` does the method compare the `z` instance fields introduced in the derived class.</span></span>  
  
 <span data-ttu-id="63c59-245">В следующем примере определяется `Rectangle` класс, реализующий прямоугольник как два внутренних целей `Point` объектов.</span><span class="sxs-lookup"><span data-stu-id="63c59-245">The following example defines a `Rectangle` class that internally implements a rectangle as two `Point` objects.</span></span> <span data-ttu-id="63c59-246">`Rectangle` Класса также переопределения <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> для предоставления равенство значений.</span><span class="sxs-lookup"><span data-stu-id="63c59-246">The `Rectangle` class also overrides <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> to provide for value equality.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals3#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals3/CS/equals3.cs#1)]
 [!code-vb[ECMA-System.Object.Equals3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals3/VB/equals3.vb#1)]  
  
 <span data-ttu-id="63c59-247">В некоторых языках, таких как C# и Visual Basic поддерживает перегрузку операторов.</span><span class="sxs-lookup"><span data-stu-id="63c59-247">Some languages such as C# and Visual Basic support operator overloading.</span></span> <span data-ttu-id="63c59-248">Если тип перегружает оператор равенства, необходимо также переопределить <xref:System.Object.Equals%28System.Object%29> метод, чтобы обеспечить те же функциональные возможности.</span><span class="sxs-lookup"><span data-stu-id="63c59-248">When a type overloads the equality operator, it must also override the <xref:System.Object.Equals%28System.Object%29> method to provide the same functionality.</span></span> <span data-ttu-id="63c59-249">Обычно это выполняется путем написания <xref:System.Object.Equals%28System.Object%29> метод с точки зрения перегруженный оператор равенства, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="63c59-249">This is typically accomplished by writing the <xref:System.Object.Equals%28System.Object%29> method in terms of the overloaded equality operator, as in the following example.</span></span>  
  
 [!code-csharp[ECMA-System.Object.Equals4#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.Equals4/CS/equals4.cs#1)]
 [!code-vb[ECMA-System.Object.Equals4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.Equals4/vb/equals4.vb#1)]  
  
 <span data-ttu-id="63c59-250">Поскольку `Complex` — это тип значения не может быть производным от.</span><span class="sxs-lookup"><span data-stu-id="63c59-250">Because `Complex` is a value type, it cannot be derived from.</span></span>  <span data-ttu-id="63c59-251">Таким образом, переопределение <xref:System.Object.Equals%28System.Object%29> метод не требуется вызывать <xref:System.Object.GetType%2A> определить точный тип времени выполнения каждого объекта, но ее можно вместо этого используйте `is` оператором в C# или `TypeOf` оператор на языке Visual Basic для проверки типа `obj` параметра.</span><span class="sxs-lookup"><span data-stu-id="63c59-251">Therefore, the override to <xref:System.Object.Equals%28System.Object%29> method need not call <xref:System.Object.GetType%2A> to determine the precise run-time type of each object, but can instead use the `is` operator in C# or the `TypeOf` operator in Visual Basic to check the type of the `obj` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
        <altmember cref="M:System.Object.GetHashCode" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="T:System.IComparable" />
        <altmember cref="T:System.Collections.ArrayList" />
        <altmember cref="T:System.Collections.Hashtable" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public static bool Equals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Equals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Equals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Equals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Equals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member Equals : obj * obj -&gt; bool" Usage="System.obj.Equals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">
          <span data-ttu-id="63c59-252">Первый из сравниваемых объектов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63c59-252">The first object to compare.</span>
          </span>
        </param>
        <param name="objB">
          <span data-ttu-id="63c59-253">Второй из сравниваемых объектов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63c59-253">The second object to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="63c59-254">Определяет, считаются ли равными указанные экземпляры объектов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63c59-254">Determines whether the specified object instances are considered equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="63c59-255">
            <see langword="true" />, если указанные объекты равны; в противном случае — <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63c59-255">
              <see langword="true" /> if the objects are considered equal; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="63c59-256">Если оба параметра <paramref name="objA" /> и <paramref name="objB" /> имеют значение **NULL**, метод возвращает значение <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63c59-256">If both <paramref name="objA" /> and <paramref name="objB" /> are **null**, the method returns <see langword="true" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63c59-257">Статический <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> метод указывает, является ли два объекта, `objA` и `objB`, равны.</span><span class="sxs-lookup"><span data-stu-id="63c59-257">The static <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method indicates whether two objects, `objA` and  `objB`, are equal.</span></span> <span data-ttu-id="63c59-258">Это также дает возможность проверки объектов, значение которого является **null** на равенство.</span><span class="sxs-lookup"><span data-stu-id="63c59-258">It also enables you to test objects whose value is **null** for equality.</span></span> <span data-ttu-id="63c59-259">Он сравнивает `objA` и `objB` на равенство, как показано ниже:</span><span class="sxs-lookup"><span data-stu-id="63c59-259">It compares `objA` and `objB` for equality as follows:</span></span>  
  
-   <span data-ttu-id="63c59-260">Он определяет, представляют ли два объекта одной ссылки на объект.</span><span class="sxs-lookup"><span data-stu-id="63c59-260">It determines whether the two objects represent the same object reference.</span></span> <span data-ttu-id="63c59-261">Если это так, метод возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="63c59-261">If they do, the method returns `true`.</span></span> <span data-ttu-id="63c59-262">Этот тест, аналогичен вызову <xref:System.Object.ReferenceEquals%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="63c59-262">This test is equivalent to calling the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="63c59-263">Кроме того, если оба `objA` и `objB` , **null**, метод возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="63c59-263">In addition, if both `objA` and `objB` are **null**, the method returns `true`.</span></span>  
  
-   <span data-ttu-id="63c59-264">Он определяет, является ли либо `objA` или `objB` — **null**.</span><span class="sxs-lookup"><span data-stu-id="63c59-264">It determines whether either `objA` or `objB` is **null**.</span></span> <span data-ttu-id="63c59-265">Если Да, он возвращает `false`.</span><span class="sxs-lookup"><span data-stu-id="63c59-265">If so, it returns `false`.</span></span>  
  
-   <span data-ttu-id="63c59-266">Если оба объекта представляют одной ссылки на объект, и ни один не **null**, он вызывает `objA`.`Equals` (`objB`) и возвращает результат.</span><span class="sxs-lookup"><span data-stu-id="63c59-266">If the two objects do not represent the same object reference and neither is **null**, it calls `objA`.`Equals`(`objB`) and returns the result.</span></span> <span data-ttu-id="63c59-267">Это означает, что если `objA` переопределяет <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> вызывается метод, это переопределение.</span><span class="sxs-lookup"><span data-stu-id="63c59-267">This means that if `objA` overrides the <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method, this override is called.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="63c59-268">В следующем примере демонстрируется <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> метод и сравнивает его с <xref:System.Object.ReferenceEquals%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="63c59-268">The following example illustrates the <xref:System.Object.Equals%28System.Object%2CSystem.Object%29> method and compares it with the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 [!code-csharp[System.Object.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.equals/cs/equals_static2.cs#1)]
 [!code-vb[System.Object.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.equals/vb/equals_static2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Object ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Object ()" />
      <MemberSignature Language="F#" Value="abstract member Finalize : unit -&gt; unit&#xA;override this.Finalize : unit -&gt; unit" Usage="obj.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="63c59-269">Позволяет объекту попытаться освободить ресурсы и выполнить другие операции очистки, перед тем как он будет уничтожен во время сборки мусора.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63c59-269">Allows an object to try to free resources and perform other cleanup operations before it is reclaimed by garbage collection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63c59-270"><xref:System.Object.Finalize%2A> Метод используется для выполнения операций очистки неуправляемых ресурсов, удерживаемых текущим объектом до уничтожения объекта.</span><span class="sxs-lookup"><span data-stu-id="63c59-270">The <xref:System.Object.Finalize%2A> method is used to perform cleanup operations on unmanaged resources held by the current object before the object is destroyed.</span></span> <span data-ttu-id="63c59-271">Метод является защищенным и таким образом, доступный только с помощью этого класса или производного класса.</span><span class="sxs-lookup"><span data-stu-id="63c59-271">The method is protected and therefore is accessible only through this class or through a derived class.</span></span>  
  
 <span data-ttu-id="63c59-272">Содержание</span><span class="sxs-lookup"><span data-stu-id="63c59-272">In this section:</span></span>  
  
-   [<span data-ttu-id="63c59-273">Как работает завершения</span><span class="sxs-lookup"><span data-stu-id="63c59-273">How finalization works</span></span>](#How)  
  
-   [<span data-ttu-id="63c59-274">Примечания для разработчиков</span><span class="sxs-lookup"><span data-stu-id="63c59-274">Notes for implementers</span></span>](#Notes)  
  
-   [<span data-ttu-id="63c59-275">В качестве альтернативы SafeHandle</span><span class="sxs-lookup"><span data-stu-id="63c59-275">The SafeHandle alternative</span></span>](#SafeHandle)  
  
<a name="How"></a>   
## <a name="how-finalization-works"></a><span data-ttu-id="63c59-276">Как работает завершения</span><span class="sxs-lookup"><span data-stu-id="63c59-276">How finalization works</span></span>  
 <span data-ttu-id="63c59-277"><xref:System.Object> Класс не предоставляет реализацию для <xref:System.Object.Finalize%2A> метода и сборщик мусора не помечает типов, производных от <xref:System.Object> для заключительной обработки, если только они переопределяют <xref:System.Object.Finalize%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="63c59-277">The <xref:System.Object> class provides no implementation for the <xref:System.Object.Finalize%2A> method, and the garbage collector does not mark types derived from <xref:System.Object> for finalization unless they override the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 <span data-ttu-id="63c59-278">Если тип переопределять <xref:System.Object.Finalize%2A> метод, сборщик мусора будет добавлена запись для каждого экземпляра типа внутренней структуры, которая называется очередью завершения.</span><span class="sxs-lookup"><span data-stu-id="63c59-278">If a type does override the <xref:System.Object.Finalize%2A> method, the garbage collector adds an entry for each instance of the type to an internal structure called the finalization queue.</span></span> <span data-ttu-id="63c59-279">Очереди завершения содержит записи для всех объектов в управляемой куче, код завершения, необходимо выполнить сборщик мусора мог освободить память.</span><span class="sxs-lookup"><span data-stu-id="63c59-279">The finalization queue contains entries for all the objects in the managed heap whose finalization code must run before the garbage collector can reclaim their memory.</span></span> <span data-ttu-id="63c59-280">Затем сборщик мусора вызывает <xref:System.Object.Finalize%2A> метод автоматически при следующих условиях:</span><span class="sxs-lookup"><span data-stu-id="63c59-280">The garbage collector then calls the <xref:System.Object.Finalize%2A> method automatically under the following conditions:</span></span>  
  
-   <span data-ttu-id="63c59-281">После сборщик мусора был обнаружен объект недоступен, если объект завершение было отключено путем вызова <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="63c59-281">After the garbage collector has discovered that an object is inaccessible, unless the object has been exempted from finalization by a call to the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="63c59-282">Во время завершения работы домена приложения Если объект не было отключено.</span><span class="sxs-lookup"><span data-stu-id="63c59-282">During shutdown of an application domain, unless the object is exempt from finalization.</span></span> <span data-ttu-id="63c59-283">Во время завершения работы были закрыты даже объекты, которые по-прежнему доступны.</span><span class="sxs-lookup"><span data-stu-id="63c59-283">During shutdown, even objects that are still accessible are finalized.</span></span>  
  
 <span data-ttu-id="63c59-284"><xref:System.Object.Finalize%2A> автоматически вызывается только один раз в данном экземпляре, если объект был заново зарегистрирован с использованием механизма, таких как <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> и <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> впоследствии не был вызван метод.</span><span class="sxs-lookup"><span data-stu-id="63c59-284"><xref:System.Object.Finalize%2A> is automatically called only once on a given instance, unless the object is re-registered by using a mechanism such as <xref:System.GC.ReRegisterForFinalize%2A?displayProperty=nameWithType> and the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method has not been subsequently called.</span></span>  
  
 <span data-ttu-id="63c59-285"><xref:System.Object.Finalize%2A> операции имеют следующие ограничения:</span><span class="sxs-lookup"><span data-stu-id="63c59-285"><xref:System.Object.Finalize%2A> operations have the following limitations:</span></span>  
  
-   <span data-ttu-id="63c59-286">Точное время выполнения метода завершения не определен.</span><span class="sxs-lookup"><span data-stu-id="63c59-286">The exact time when the finalizer executes is undefined.</span></span> <span data-ttu-id="63c59-287">Чтобы обеспечить детерминированного освобождения ресурсов для экземпляров класса, реализовывать `Close` метод или предоставить <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> реализации.</span><span class="sxs-lookup"><span data-stu-id="63c59-287">To ensure deterministic release of resources for instances of your class, implement a `Close` method or provide a <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>  
  
-   <span data-ttu-id="63c59-288">Методы завершения двух объектов не гарантируется выполнение определенный порядок размещения, даже если один объект ссылается на другой.</span><span class="sxs-lookup"><span data-stu-id="63c59-288">The finalizers of two objects are not guaranteed to run in any specific order, even if one object refers to the other.</span></span> <span data-ttu-id="63c59-289">То есть если объекте A имеется ссылка на объект B и имеют финализаторы, объект B может быть уже был завершен при запуске метода завершения объекта A.</span><span class="sxs-lookup"><span data-stu-id="63c59-289">That is, if Object A has a reference to Object B and both have finalizers, Object B might have already been finalized when the finalizer of Object A starts.</span></span>  
  
-   <span data-ttu-id="63c59-290">Поток, в которой выполняется метод завершения не определен.</span><span class="sxs-lookup"><span data-stu-id="63c59-290">The thread on which the finalizer runs is unspecified.</span></span>  
  
 <span data-ttu-id="63c59-291"><xref:System.Object.Finalize%2A> Метод не может выполняться до завершения или могут не выполняться в исключительных обстоятельствах:</span><span class="sxs-lookup"><span data-stu-id="63c59-291">The <xref:System.Object.Finalize%2A> method might not run to completion or might not run at all under the following exceptional circumstances:</span></span>  
  
-   <span data-ttu-id="63c59-292">Если другой метод завершения неограниченно блокируется (переход в бесконечный цикл, пытается получить блокировку, он никогда не получает и так далее).</span><span class="sxs-lookup"><span data-stu-id="63c59-292">If another finalizer blocks indefinitely (goes into an infinite loop, tries to obtain a lock it can never obtain, and so on).</span></span> <span data-ttu-id="63c59-293">Так как среда выполнения пытается выполнять финализаторы до завершения, другие методы завершения вызвать нельзя при блокировке бесконечно.</span><span class="sxs-lookup"><span data-stu-id="63c59-293">Because the runtime tries to run finalizers to completion, other finalizers might not be called if a finalizer blocks indefinitely.</span></span>  
  
-   <span data-ttu-id="63c59-294">Если процесс завершается без предоставления среде выполнения возможность очистки.</span><span class="sxs-lookup"><span data-stu-id="63c59-294">If the process terminates without giving the runtime a chance to clean up.</span></span> <span data-ttu-id="63c59-295">В этом случае первый уведомлением среды выполнения о завершении процесса будет уведомление DLL_PROCESS_DETACH.</span><span class="sxs-lookup"><span data-stu-id="63c59-295">In this case, the runtime's first notification of process termination is a DLL_PROCESS_DETACH notification.</span></span>  
  
 <span data-ttu-id="63c59-296">Среда выполнения продолжает завершения объектов во время завершения работы только в том случае, пока число объектов, подлежащих завершению, продолжает уменьшаться.</span><span class="sxs-lookup"><span data-stu-id="63c59-296">The runtime continues to finalize objects during shutdown only while the number of finalizable objects continues to decrease.</span></span>  
  
 <span data-ttu-id="63c59-297">Если <xref:System.Object.Finalize%2A> или переопределение <xref:System.Object.Finalize%2A> создает исключение и среда выполнения не будет размещено в приложение, которое переопределяет политику по умолчанию, среда выполнения завершает процесс и ни один активный `try` / `finally` блоков или метод завершения выполняются.</span><span class="sxs-lookup"><span data-stu-id="63c59-297">If <xref:System.Object.Finalize%2A> or an override of <xref:System.Object.Finalize%2A> throws an exception, and the runtime is not hosted by an application that overrides the default policy, the runtime terminates the process and no active `try`/`finally` blocks or finalizers are executed.</span></span> <span data-ttu-id="63c59-298">Такое поведение гарантирует целостность процесса, если метод завершения не может освободить или уничтожение ресурсов.</span><span class="sxs-lookup"><span data-stu-id="63c59-298">This behavior ensures process integrity if the finalizer cannot free or destroy resources.</span></span>  
  
<a name="Notes"></a>   
## <a name="overriding-the-finalize-method"></a><span data-ttu-id="63c59-299">Переопределение метода Finalize</span><span class="sxs-lookup"><span data-stu-id="63c59-299">Overriding the Finalize method</span></span> 
 <span data-ttu-id="63c59-300">Необходимо переопределить <xref:System.Object.Finalize%2A> для класса, который использует неуправляемые ресурсы, такие как дескрипторы файлов или подключения базы данных, которые должны быть освобождены при отказе управляемый объект, который использует их во время сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="63c59-300">You should override <xref:System.Object.Finalize%2A> for a class that uses unmanaged resources, such as file handles or database connections that must be released when the managed object that uses them is discarded during garbage collection.</span></span> <span data-ttu-id="63c59-301">Не должен реализовывать <xref:System.Object.Finalize%2A> метод для управляемых объектов, так как сборщик мусора автоматически освобождает управляемые ресурсы.</span><span class="sxs-lookup"><span data-stu-id="63c59-301">You shouldn't implement a <xref:System.Object.Finalize%2A> method for managed objects because the garbage collector releases managed resources automatically.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="63c59-302">Если <xref:System.Runtime.InteropServices.SafeHandle> объект доступен, создает оболочку для неуправляемого ресурса, взамен рекомендуется использовать для реализации шаблона удаления с безопасным дескриптором и переопределения <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="63c59-302">If a <xref:System.Runtime.InteropServices.SafeHandle> object is available that wraps your unmanaged resource, the recommended alternative is to implement the dispose pattern with a safe handle and not override <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="63c59-303">Дополнительные сведения см. в разделе [альтернативой SafeHandle](#SafeHandle) раздела.</span><span class="sxs-lookup"><span data-stu-id="63c59-303">For more information, see [The SafeHandle alternative](#SafeHandle) section.</span></span>  
  
 <span data-ttu-id="63c59-304"><xref:System.Object.Finalize%2A?displayProperty=nameWithType> Метод не выполняет никаких действий по умолчанию, но необходимо переопределить <xref:System.Object.Finalize%2A> только в том случае, если необходимо и только для освобождения неуправляемых ресурсов.</span><span class="sxs-lookup"><span data-stu-id="63c59-304">The <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method does nothing by default, but you should override <xref:System.Object.Finalize%2A> only if necessary, and only to release unmanaged resources.</span></span> <span data-ttu-id="63c59-305">Освобождение памяти обычно занимает больше времени при выполнении операции завершения, поскольку требуется по крайней мере два сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="63c59-305">Reclaiming memory tends to take much longer if a finalization operation runs, because it requires at least two garbage collections.</span></span> <span data-ttu-id="63c59-306">Кроме того, необходимо переопределить <xref:System.Object.Finalize%2A> только для типов метод для ссылки.</span><span class="sxs-lookup"><span data-stu-id="63c59-306">In addition, you should override the <xref:System.Object.Finalize%2A> method for reference types only.</span></span> <span data-ttu-id="63c59-307">Общеязыковая среда выполнения завершает только ссылочные типы.</span><span class="sxs-lookup"><span data-stu-id="63c59-307">The common language runtime only finalizes reference types.</span></span> <span data-ttu-id="63c59-308">Пропускает методы завершения для типов значений.</span><span class="sxs-lookup"><span data-stu-id="63c59-308">It ignores finalizers on value types.</span></span>  

<span data-ttu-id="63c59-309">Область <xref:System.Object.Finalize%2A?displayProperty=nameWithType> метод `protected`.</span><span class="sxs-lookup"><span data-stu-id="63c59-309">The scope of the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method is `protected`.</span></span> <span data-ttu-id="63c59-310">При переопределении метода в классе необходимо поддерживать эта ограниченная область действия.</span><span class="sxs-lookup"><span data-stu-id="63c59-310">You should maintain this limited scope when you override the method in your class.</span></span> <span data-ttu-id="63c59-311">За счет <xref:System.Object.Finalize%2A> метод, защищенный, это не позволит пользователям приложения при вызове объекта <xref:System.Object.Finalize%2A> метод непосредственно.</span><span class="sxs-lookup"><span data-stu-id="63c59-311">By keeping a <xref:System.Object.Finalize%2A> method protected, you prevent users of your application from calling an object's <xref:System.Object.Finalize%2A> method directly.</span></span>
  
 <span data-ttu-id="63c59-312">Каждая реализация <xref:System.Object.Finalize%2A> в производном типе, необходимо вызвать реализацию базового типа <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="63c59-312">Every implementation of <xref:System.Object.Finalize%2A> in a derived type must call its base type's implementation of <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="63c59-313">Это единственный случай, в какие приложения могут вызывать код <xref:System.Object.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="63c59-313">This is the only case in which application code is allowed to call <xref:System.Object.Finalize%2A>.</span></span> <span data-ttu-id="63c59-314">Объект <xref:System.Object.Finalize%2A> метод не должен вызывать метод каких-либо объектов, отличным от своего базового класса.</span><span class="sxs-lookup"><span data-stu-id="63c59-314">An object's <xref:System.Object.Finalize%2A> method shouldn't call a method on any objects other than that of its base class.</span></span> <span data-ttu-id="63c59-315">Это так, как при вызове других объектов собирается одновременно вызывающего объекта, например, в случае закрытия среды CLR.</span><span class="sxs-lookup"><span data-stu-id="63c59-315">This is because the other objects being called could be collected at the same time as the calling object, such as in the case of a common language runtime shutdown.</span></span> 
  
> [!NOTE]
>  <span data-ttu-id="63c59-316">Компилятор C# не позволяет переопределить <xref:System.Object.Finalize%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="63c59-316">The C# compiler does not allow you to override the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="63c59-317">Вместо этого предоставлять метод завершения, реализовав [деструктор](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) для своего класса.</span><span class="sxs-lookup"><span data-stu-id="63c59-317">Instead, you provide a finalizer by implementing a [destructor](~/docs/csharp/programming-guide/classes-and-structs/destructors.md) for your class.</span></span> <span data-ttu-id="63c59-318">Деструктор C# автоматически вызывает деструктор базового класса.</span><span class="sxs-lookup"><span data-stu-id="63c59-318">A C# destructor automatically calls the destructor of its base class.</span></span>  
>   
>  <span data-ttu-id="63c59-319">Visual C++ также предоставляет свой собственный синтаксис для реализации <xref:System.Object.Finalize%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="63c59-319">Visual C++ also provides its own syntax for implementing the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="63c59-320">Дополнительные сведения см в разделе «Деструкторы и методы завершения» [как: определение и использование классов и структур (C + +/ CLI)](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).</span><span class="sxs-lookup"><span data-stu-id="63c59-320">For more information, see the "Destructors and finalizers" section of [How to: Define and Consume Classes and Structs (C++/CLI)](http://msdn.microsoft.com/library/1c03cb0d-1459-4b5e-af65-97d6b3094fd7).</span></span>  
  
 <span data-ttu-id="63c59-321">Так как сборщик мусора является недетерминированным, вы не знаете точно в том случае, когда сборщик мусора выполняет финализации.</span><span class="sxs-lookup"><span data-stu-id="63c59-321">Because garbage collection is non-deterministic, you do not know precisely when the garbage collector performs finalization.</span></span> <span data-ttu-id="63c59-322">Чтобы освободить ресурсы немедленно, также можно реализовать [шаблон удаления](~/docs/standard/design-guidelines/dispose-pattern.md) и <xref:System.IDisposable> интерфейса.</span><span class="sxs-lookup"><span data-stu-id="63c59-322">To release resources immediately, you can also choose to implement the [dispose pattern](~/docs/standard/design-guidelines/dispose-pattern.md) and the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="63c59-323"><xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> Реализация может быть вызван потребители этого класса, чтобы освободить неуправляемые ресурсы, а также можно использовать <xref:System.Object.Finalize%2A> метод для освобождения неуправляемых ресурсов в случае, если <xref:System.IDisposable.Dispose%2A> метод не вызывается.</span><span class="sxs-lookup"><span data-stu-id="63c59-323">The <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation can be called by consumers of your class to free unmanaged resources, and you can use the <xref:System.Object.Finalize%2A> method to free unmanaged resources in the event that the <xref:System.IDisposable.Dispose%2A> method is not called.</span></span>  
  
 <span data-ttu-id="63c59-324"><xref:System.Object.Finalize%2A> можно предпринять практически любые действия, включая восстановление объекта (который доступности еще раз), после его были очищены во время сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="63c59-324"><xref:System.Object.Finalize%2A> can take almost any action, including resurrecting an object (that is, making the object accessible again) after it has been cleaned up during garbage collection.</span></span> <span data-ttu-id="63c59-325">Тем не менее объект может быть восстановлен только один раз; <xref:System.Object.Finalize%2A> не может вызываться для восстановленных объектов во время сборки мусора.</span><span class="sxs-lookup"><span data-stu-id="63c59-325">However, the object can only be resurrected once; <xref:System.Object.Finalize%2A> cannot be called on resurrected objects during garbage collection.</span></span> <span data-ttu-id="63c59-326">Имеется одно действие, реализация <xref:System.Object.Finalize%2A> никогда не должен принимать: он никогда не должно создавать исключения.</span><span class="sxs-lookup"><span data-stu-id="63c59-326">There is one action that your implementation of <xref:System.Object.Finalize%2A> should never take: it should never throw an exception.</span></span> <span data-ttu-id="63c59-327">При вызове исключения, вызываемые методы из <xref:System.Object.Finalize%2A> обрабатывается метод <xref:System.Object.Finalize%2A> метод, среда выполнения предполагает, что <xref:System.Object.Finalize%2A> метод возвращается и продолжает вызывать <xref:System.Object.Finalize%2A> методов других объектов.</span><span class="sxs-lookup"><span data-stu-id="63c59-327">If any exceptions thrown by methods called from the <xref:System.Object.Finalize%2A> method are unhandled by the <xref:System.Object.Finalize%2A> method, the runtime assumes that the <xref:System.Object.Finalize%2A> method returned and continues to call the <xref:System.Object.Finalize%2A> methods of other objects.</span></span> 
  
<a name="SafeHandle"></a>   
## <a name="the-safehandle-alternative"></a><span data-ttu-id="63c59-328">Альтернативный вариант с использованием SafeHandle</span><span class="sxs-lookup"><span data-stu-id="63c59-328">The SafeHandle alternative</span></span>  
 <span data-ttu-id="63c59-329">Создание надежных методов завершения часто сложно, поскольку не может делать предположения о состоянии приложения и необработанные исключения системы, такие как <xref:System.OutOfMemoryException> и <xref:System.StackOverflowException> завершение метода завершения.</span><span class="sxs-lookup"><span data-stu-id="63c59-329">Creating reliable finalizers is often difficult, because you cannot make assumptions about the state of your application, and because unhandled system exceptions such as <xref:System.OutOfMemoryException> and <xref:System.StackOverflowException> terminate the finalizer.</span></span> <span data-ttu-id="63c59-330">Вместо реализации метода завершения для класса, чтобы освободить неуправляемые ресурсы, можно использовать объект, который является производным от <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> класса программы-оболочки для неуправляемых ресурсов, а затем реализовать шаблон удаления без метода завершения.</span><span class="sxs-lookup"><span data-stu-id="63c59-330">Instead of implementing a finalizer for your class to release unmanaged resources, you can use an object that is derived from the <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType> class to wrap your unmanaged resources, and then implement the dispose pattern without a finalizer.</span></span> <span data-ttu-id="63c59-331">Платформа .NET Framework предоставляет следующие классы в <xref:Microsoft.Win32?displayProperty=nameWithType> пространства имен, которые являются производными от <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="63c59-331">The .NET Framework provides the following classes in the <xref:Microsoft.Win32?displayProperty=nameWithType> namespace that are derived from <xref:System.Runtime.InteropServices.SafeHandle?displayProperty=nameWithType>:</span></span>  
  
-   <span data-ttu-id="63c59-332"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> Представляет класс-оболочку для дескриптора файла.</span><span class="sxs-lookup"><span data-stu-id="63c59-332"><xref:Microsoft.Win32.SafeHandles.SafeFileHandle> is a wrapper class for a file handle.</span></span>  
  
-   <span data-ttu-id="63c59-333"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> Представляет класс-оболочку для дескрипторов файлов, размещенный в памяти.</span><span class="sxs-lookup"><span data-stu-id="63c59-333"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> is a wrapper class for memory-mapped file handles.</span></span>  
  
-   <span data-ttu-id="63c59-334"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> Представляет класс-оболочку для указателя на блок неуправляемой памяти.</span><span class="sxs-lookup"><span data-stu-id="63c59-334"><xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> is a wrapper class for a pointer to a block of unmanaged memory.</span></span>  
  
-   <span data-ttu-id="63c59-335"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, и <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> являются классы-оболочки для шифрования маркеров.</span><span class="sxs-lookup"><span data-stu-id="63c59-335"><xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> are wrapper classes for cryptographic handles.</span></span>  
  
-   <span data-ttu-id="63c59-336"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> Представляет класс-оболочку для дескрипторов канала.</span><span class="sxs-lookup"><span data-stu-id="63c59-336"><xref:Microsoft.Win32.SafeHandles.SafePipeHandle> is a wrapper class for pipe handles.</span></span>  
  
-   <span data-ttu-id="63c59-337"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> Представляет класс-оболочку для дескриптора в раздел реестра.</span><span class="sxs-lookup"><span data-stu-id="63c59-337"><xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> is a wrapper class for a handle to a registry key.</span></span>  
  
-   <span data-ttu-id="63c59-338"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> Представляет класс-оболочку для дескриптора ожидания.</span><span class="sxs-lookup"><span data-stu-id="63c59-338"><xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> is a wrapper class for a wait handle.</span></span>  
  
 <span data-ttu-id="63c59-339">В следующем примере используется [шаблон удаления](~/docs/standard/design-guidelines/dispose-pattern.md) с безопасных дескрипторов вместо переопределения <xref:System.Object.Finalize%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="63c59-339">The following example uses the [dispose pattern](~/docs/standard/design-guidelines/dispose-pattern.md) with safe handles instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="63c59-340">Он определяет `FileAssociation` класс-оболочку реестра сведения о приложении, которое работает с файлами с расширением определенного файла.</span><span class="sxs-lookup"><span data-stu-id="63c59-340">It defines a `FileAssociation` class that wraps registry information about the application that handles files with a particular file extension.</span></span> <span data-ttu-id="63c59-341">Обрабатывает два реестра, возвращаются в виде `out` параметров с Windows [RegOpenKeyEx](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) вызовы функций передаются <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> конструктор.</span><span class="sxs-lookup"><span data-stu-id="63c59-341">The two registry handles returned as `out` parameters by Windows [RegOpenKeyEx](http://msdn.microsoft.com/library/windows/desktop/ms724897.aspx) function calls are passed to the <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> constructor.</span></span> <span data-ttu-id="63c59-342">Тип защищенные `Dispose` затем вызывает метод `SafeRegistryHandle.Dispose` метод для освобождения эти два маркера.</span><span class="sxs-lookup"><span data-stu-id="63c59-342">The type's protected `Dispose` method then calls the `SafeRegistryHandle.Dispose` method  to free these two handles.</span></span>  
  
 [!code-csharp[System.Object.Finalize#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize_safe.cs#2)]
 [!code-vb[System.Object.Finalize#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize_safe.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="63c59-343">В следующем примере проверяется, <xref:System.Object.Finalize%2A> метод вызывается, когда объект, который переопределяет <xref:System.Object.Finalize%2A> уничтожается.</span><span class="sxs-lookup"><span data-stu-id="63c59-343">The following example verifies that the <xref:System.Object.Finalize%2A> method is called when an object that overrides <xref:System.Object.Finalize%2A> is destroyed.</span></span> <span data-ttu-id="63c59-344">Обратите внимание, что в реальном приложении <xref:System.Object.Finalize%2A> метод был бы переопределен, чтобы освободить неуправляемые ресурсы, удерживаемые объектом.</span><span class="sxs-lookup"><span data-stu-id="63c59-344">Note that, in a production application, the <xref:System.Object.Finalize%2A> method would be overridden to release unmanaged resources held by the object.</span></span> <span data-ttu-id="63c59-345">Также Обратите внимание, что в примере на C# предоставляет деструктор вместо переопределения <xref:System.Object.Finalize%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="63c59-345">Also note that the C# example provides a destructor instead of overriding the <xref:System.Object.Finalize%2A> method.</span></span>  
  
 [!code-csharp[System.Object.Finalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.finalize/cs/finalize1.cs#1)]
 [!code-vb[System.Object.Finalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.finalize/vb/finalize1.vb#1)]  
  
 <span data-ttu-id="63c59-346">Дополнительный пример, который переопределяет <xref:System.Object.Finalize%2A> метода, в разделе <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="63c59-346">For an additional example that overrides the <xref:System.Object.Finalize%2A> method, see the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.GC.WaitForPendingFinalizers" />
        <altmember cref="T:System.WeakReference" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public virtual int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetHashCode();" />
      <MemberSignature Language="F#" Value="abstract member GetHashCode : unit -&gt; int&#xA;override this.GetHashCode : unit -&gt; int" Usage="obj.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="63c59-347">Служит хэш-функцией по умолчанию.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63c59-347">Serves as the default hash function.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="63c59-348">Хэш-код для текущего объекта.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63c59-348">A hash code for the current object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63c59-349">Хэш-код является числовым значением, используемый для вставки и идентификации объекта в коллекции на основе хэша, таких как <xref:System.Collections.Generic.Dictionary%602> класса <xref:System.Collections.Hashtable> класса или типа, производного от <xref:System.Collections.DictionaryBase> класса.</span><span class="sxs-lookup"><span data-stu-id="63c59-349">A hash code is a numeric value that is used to insert and identify an object in a hash-based collection such as the <xref:System.Collections.Generic.Dictionary%602> class, the <xref:System.Collections.Hashtable> class, or a type derived from the <xref:System.Collections.DictionaryBase> class.</span></span> <span data-ttu-id="63c59-350"><xref:System.Object.GetHashCode%2A> Метод предоставляет этот хэш-код для алгоритмов, требующих быстрой проверки равенства объекта.</span><span class="sxs-lookup"><span data-stu-id="63c59-350">The <xref:System.Object.GetHashCode%2A> method provides this hash code for algorithms that need quick checks of object equality.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="63c59-351">См. сведения об использовании хэш-кодов в хэш-таблицы, а также некоторые дополнительные хэш-код алгоритмы [хэш-функции](https://en.wikipedia.org/wiki/Hash_function) запись в Википедии.</span><span class="sxs-lookup"><span data-stu-id="63c59-351">For information about how hash codes are used in hash tables and for some additional hash code algorithms, see the [Hash Function](https://en.wikipedia.org/wiki/Hash_function) entry in Wikipedia.</span></span>  
  
 <span data-ttu-id="63c59-352">Два объекта, равно возвращаемого хэш-кодов, которые равны.</span><span class="sxs-lookup"><span data-stu-id="63c59-352">Two objects that are equal return hash codes that are equal.</span></span> <span data-ttu-id="63c59-353">Однако обратное неверно: равно хэш-кодов не влекут за собой равенство объектов, так как другой (равны) объекты могут иметь одинаковые хэш-коды.</span><span class="sxs-lookup"><span data-stu-id="63c59-353">However, the reverse is not true: equal hash codes do not imply object equality, because different (unequal) objects can have identical hash codes.</span></span> <span data-ttu-id="63c59-354">Кроме того, платформа .NET Framework не гарантирует реализацию по умолчанию <xref:System.Object.GetHashCode%2A> метод и значения, этот метод возвращает могут различаться между версиями .NET Framework и платформ, таких как 32-разрядных и 64-разрядных платформах.</span><span class="sxs-lookup"><span data-stu-id="63c59-354">Furthermore, the .NET Framework does not guarantee the default implementation of the <xref:System.Object.GetHashCode%2A> method, and the value this method returns may differ between .NET Framework versions and platforms, such as 32-bit and 64-bit platforms.</span></span> <span data-ttu-id="63c59-355">По этим причинам не используйте реализация этого метода по умолчанию в качестве уникального идентификатора объекта для хэширования целей.</span><span class="sxs-lookup"><span data-stu-id="63c59-355">For these reasons, do not use the default implementation of this method as a unique object identifier for hashing purposes.</span></span> <span data-ttu-id="63c59-356">От этого, выполните два последствия.</span><span class="sxs-lookup"><span data-stu-id="63c59-356">Two consequences follow from this:</span></span>  
  
-   <span data-ttu-id="63c59-357">Не следует предполагать, что равно хэш-кодов определяют равенство объектов.</span><span class="sxs-lookup"><span data-stu-id="63c59-357">You should not assume that equal hash codes imply object equality.</span></span>  
  
-   <span data-ttu-id="63c59-358">Никогда не следует хранить или использовать хэш-код вне домена приложения, в котором он был создан, поскольку тот же объект может хэша между доменами приложений, процессами и платформы.</span><span class="sxs-lookup"><span data-stu-id="63c59-358">You should never persist or use a hash code outside the application domain in which it was created, because the same object may hash across application domains, processes, and platforms.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="63c59-359">Хэш-код предназначен для эффективную вставку и поиск в коллекции, основанные на хэш-таблицу.</span><span class="sxs-lookup"><span data-stu-id="63c59-359">A hash code is intended for efficient insertion and lookup in collections that are based on a hash table.</span></span> <span data-ttu-id="63c59-360">Хэш-код не постоянное значение.</span><span class="sxs-lookup"><span data-stu-id="63c59-360">A hash code is not a permanent value.</span></span> <span data-ttu-id="63c59-361">По этой причине:</span><span class="sxs-lookup"><span data-stu-id="63c59-361">For this reason:</span></span>  
>   
>  -   <span data-ttu-id="63c59-362">Не сериализации значения хэш-кода и хранить их в базах данных.</span><span class="sxs-lookup"><span data-stu-id="63c59-362">Do not serialize hash code values or store them in databases.</span></span>  
> -   <span data-ttu-id="63c59-363">Не используйте хэш-код в качестве ключа для извлечения объекта из коллекции с ключом.</span><span class="sxs-lookup"><span data-stu-id="63c59-363">Do not use the hash code as the key to retrieve an object from a keyed collection.</span></span>  
> -   <span data-ttu-id="63c59-364">Не отправляйте хэш-кодов в доменах приложений или процессах.</span><span class="sxs-lookup"><span data-stu-id="63c59-364">Do not send hash codes across application domains or processes.</span></span> <span data-ttu-id="63c59-365">В некоторых случаях хэш-коды могут вычисляться на основе домена каждого процесса или на уровне приложений.</span><span class="sxs-lookup"><span data-stu-id="63c59-365">In some cases, hash codes may be computed on a per-process or per-application domain basis.</span></span>  
> -   <span data-ttu-id="63c59-366">Не используйте хэш-код вместо значения, возвращенные шифрования функции хэширования, если вам требуется криптостойкой хэш.</span><span class="sxs-lookup"><span data-stu-id="63c59-366">Do not use the hash code instead of a value returned by a cryptographic hashing function if you need a cryptographically strong hash.</span></span> <span data-ttu-id="63c59-367">Для криптографическое хэширование, используйте класс, производный от <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> или <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> класса.</span><span class="sxs-lookup"><span data-stu-id="63c59-367">For cryptographic hashes, use a class derived from the <xref:System.Security.Cryptography.HashAlgorithm?displayProperty=nameWithType> or <xref:System.Security.Cryptography.KeyedHashAlgorithm?displayProperty=nameWithType> class.</span></span>  
> -   <span data-ttu-id="63c59-368">Не выполняйте проверку на равенство хэш-кодов, чтобы определить, равны ли два объекта.</span><span class="sxs-lookup"><span data-stu-id="63c59-368">Do not test for equality of hash codes to determine whether two objects are equal.</span></span> <span data-ttu-id="63c59-369">(Равны объекты могут иметь одинаковые хэш-коды.) Для проверки на равенство, вызовите <xref:System.Object.ReferenceEquals%2A> или <xref:System.Object.Equals%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="63c59-369">(Unequal objects can have identical hash codes.) To test for equality, call the <xref:System.Object.ReferenceEquals%2A> or <xref:System.Object.Equals%2A> method.</span></span>  
  
 <span data-ttu-id="63c59-370"><xref:System.Object.GetHashCode%2A> Метод может быть переопределен в производном типе.</span><span class="sxs-lookup"><span data-stu-id="63c59-370">The <xref:System.Object.GetHashCode%2A> method can be overridden by a derived type.</span></span> <span data-ttu-id="63c59-371">Если <xref:System.Object.GetHashCode%2A> — не переопределен, хэш-кодов для ссылочных типов вычисляются путем вызова <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> метод базового класса, который вычисляет хэш-код на основе объекта ссылки; Дополнительные сведения см. в разделе <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="63c59-371">If <xref:System.Object.GetHashCode%2A> is not overridden, hash codes for reference types are computed by calling the <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType> method of the base class, which computes a hash code based on an object's reference; for more information, see <xref:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="63c59-372">Другими словами, два объекта, для которого <xref:System.Object.ReferenceEquals%2A> возвращает `true` имеют одинаковые хэш-коды.</span><span class="sxs-lookup"><span data-stu-id="63c59-372">In other words, two objects for which the <xref:System.Object.ReferenceEquals%2A> method returns `true` have identical hash codes.</span></span> <span data-ttu-id="63c59-373">Если типы значений не переопределяйте <xref:System.Object.GetHashCode%2A>, <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> метод базового класса использует отражение для вычисления хэш-код на основе значений поля типа.</span><span class="sxs-lookup"><span data-stu-id="63c59-373">If value types do not override <xref:System.Object.GetHashCode%2A>, the <xref:System.ValueType.GetHashCode%2A?displayProperty=nameWithType> method of the base class uses reflection to compute the hash code based on the values of the type's fields.</span></span> <span data-ttu-id="63c59-374">Другими словами типы значений, поля которого имеют одинаковые значения имеют равно хэш-кодов.</span><span class="sxs-lookup"><span data-stu-id="63c59-374">In other words, value types whose fields have equal values have equal hash codes.</span></span> <span data-ttu-id="63c59-375">Дополнительные сведения о переопределении <xref:System.Object.GetHashCode%2A>, см. в разделе «Примечания для наследующих объектов».</span><span class="sxs-lookup"><span data-stu-id="63c59-375">For more information about overriding <xref:System.Object.GetHashCode%2A>, see the "Notes to Inheritors" section.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="63c59-376">При переопределении <xref:System.Object.GetHashCode%2A> метод, необходимо также переопределить <xref:System.Object.Equals%2A>и наоборот.</span><span class="sxs-lookup"><span data-stu-id="63c59-376">If you override the <xref:System.Object.GetHashCode%2A> method, you should also override <xref:System.Object.Equals%2A>, and vice versa.</span></span> <span data-ttu-id="63c59-377">Если переопределенном <xref:System.Object.Equals%2A> возвращает `true` при двух объектов для проверки на равенство, переопределенном <xref:System.Object.GetHashCode%2A> метод должен возвращать одинаковое значение для двух объектов.</span><span class="sxs-lookup"><span data-stu-id="63c59-377">If your overridden <xref:System.Object.Equals%2A> method returns `true` when two objects are tested for equality, your overridden <xref:System.Object.GetHashCode%2A> method must return the same value for the two objects.</span></span>  
  
 <span data-ttu-id="63c59-378">Если объект, который используется в качестве ключа в хэш-таблице не предоставляет полезную реализацию <xref:System.Object.GetHashCode%2A>, можно указать поставщика хэш-кода, указав <xref:System.Collections.IEqualityComparer> реализации к одной из перегрузок <xref:System.Collections.Hashtable> конструктора класса.</span><span class="sxs-lookup"><span data-stu-id="63c59-378">If an object that is used as a key in a hash table does not provide a useful implementation of <xref:System.Object.GetHashCode%2A>, you can specify a hash code provider by supplying an <xref:System.Collections.IEqualityComparer> implementation to one of the overloads of the <xref:System.Collections.Hashtable> class constructor.</span></span>  
  
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="63c59-379">Заметки о [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="63c59-379">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="63c59-380">При вызове <xref:System.Object.GetHashCode%2A> метод класса в [!INCLUDE[wrt](~/includes/wrt-md.md)], он предоставляет поведение по умолчанию для классов, которые не переопределяют <xref:System.Object.GetHashCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="63c59-380">When you call the <xref:System.Object.GetHashCode%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don’t override <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="63c59-381">Это является частью возможностей .NET Framework для [!INCLUDE[wrt](~/includes/wrt-md.md)] (см. [.NET Framework поддерживает для приложений магазина Windows и среды выполнения Windows](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="63c59-381">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="63c59-382">Классы в [!INCLUDE[wrt](~/includes/wrt-md.md)] не наследуют <xref:System.Object>и в настоящее время не использовать <xref:System.Object.GetHashCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="63c59-382">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don’t inherit <xref:System.Object>, and currently don’t implement a <xref:System.Object.GetHashCode%2A>.</span></span> <span data-ttu-id="63c59-383">При этом они будут иметь <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, и <xref:System.Object.GetHashCode%2A> методов при их использовании в коде C# или Visual Basic и .NET Framework предоставляет поведение по умолчанию для этих методов.</span><span class="sxs-lookup"><span data-stu-id="63c59-383">However, they appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides the default behavior for these methods.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)]<span data-ttu-id="63c59-384"> классы, написанные на C# или Visual Basic можно переопределить <xref:System.Object.GetHashCode%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="63c59-384"> classes that are written in C# or Visual Basic can override the <xref:System.Object.GetHashCode%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="63c59-385">Один из самых простых способов вычисления хэш-код для числовое значение, которое имеет тот же или меньший диапазон, чем <xref:System.Int32> типа является просто возвращать это значение.</span><span class="sxs-lookup"><span data-stu-id="63c59-385">One of the simplest ways to compute a hash code for a numeric value that has the same or a smaller range than the <xref:System.Int32> type is to simply return that value.</span></span> <span data-ttu-id="63c59-386">В примере показан такой реализации для `Number` структуры.</span><span class="sxs-lookup"><span data-stu-id="63c59-386">The following example shows such an implementation for a `Number` structure.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/direct1.cs#1)]
 [!code-vb[System.Object.GetHashCode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/direct1.vb#1)]  
  
 <span data-ttu-id="63c59-387">Как правило тип имеет несколько полей данных, которые могут участвовать в создании хэш-код.</span><span class="sxs-lookup"><span data-stu-id="63c59-387">Frequently, a type has multiple data fields that can participate in generating the hash code.</span></span> <span data-ttu-id="63c59-388">Является одним из способов создания хэш-код для объединения этих полей с помощью `XOR (eXclusive OR)` операции, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="63c59-388">One way to generate a hash code is to combine these fields using an `XOR (eXclusive OR)` operation, as shown in the following example.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor1.cs#2)]
 [!code-vb[System.Object.GetHashCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor1.vb#2)]  
  
 <span data-ttu-id="63c59-389">Предыдущий пример возвращает тот же хэш-код для (n1, n2) и (n2 n1) и поэтому может создавать дополнительные конфликтов, чем нежелательно.</span><span class="sxs-lookup"><span data-stu-id="63c59-389">The previous example returns the same hash code for (n1, n2) and (n2, n1), and so may generate more collisions than are desirable.</span></span> <span data-ttu-id="63c59-390">Доступно несколько решений, чтобы хэш-кодов в таких случаях не совпадают.</span><span class="sxs-lookup"><span data-stu-id="63c59-390">A number of solutions are available so that hash codes in these cases are not identical.</span></span> <span data-ttu-id="63c59-391">Он возвращает хэш-код `Tuple` объекта, который соответствует порядку каждого поля.</span><span class="sxs-lookup"><span data-stu-id="63c59-391">One is to return the hash code of a `Tuple` object that reflects the order of each field.</span></span> <span data-ttu-id="63c59-392">В следующем примере показана возможная реализация, использующий <xref:System.Tuple%602> класса.</span><span class="sxs-lookup"><span data-stu-id="63c59-392">The following example shows a possible implementation that uses the <xref:System.Tuple%602> class.</span></span> <span data-ttu-id="63c59-393">Обратите внимание на то, что производительность создания экземпляра `Tuple` объекта может существенно сказаться на общую производительность приложения, которое сохраняет большое число объектов в хэш-таблицах.</span><span class="sxs-lookup"><span data-stu-id="63c59-393">Note, though, that the performance overhead of instantiating a `Tuple` object may significantly impact the overall performance of an application that stores large numbers of objects in hash tables.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/xor2.cs#3)]
 [!code-vb[System.Object.GetHashCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/xor2.vb#3)]  
  
 <span data-ttu-id="63c59-394">Второй альтернативное решение включает в себя взвешивание отдельных хэш-кодов, сдвиг влево хэш-кодов последующих полей двух или более разрядами.</span><span class="sxs-lookup"><span data-stu-id="63c59-394">A second alternative solution involves weighting the individual hash codes by left-shifting the hash codes of successive fields by two or more bits.</span></span> <span data-ttu-id="63c59-395">Оптимально вместо удаления, биты, сдвигаемые дальше 31 разряд обтекания вокруг, а не сбрасываются.</span><span class="sxs-lookup"><span data-stu-id="63c59-395">Optimally, instead of being discarded, bits shifted beyond bit 31 should wrap around rather than be discarded.</span></span> <span data-ttu-id="63c59-396">Так как bits удаляются с помощью операторов сдвига влево на C# и Visual Basic, для этого требуется создание левой метода shift и перенос следующим образом:</span><span class="sxs-lookup"><span data-stu-id="63c59-396">Since bits are discarded by the left-shift operators in both C# and Visual Basic, this requires creating a left shift-and-wrap method like the following:</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#4)]
 [!code-vb[System.Object.GetHashCode#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#4)]  
  
 <span data-ttu-id="63c59-397">В следующем примере затем используется этот метод shift и перенос для вычисления хэш-код `Point` структура, используемая в предыдущих примерах.</span><span class="sxs-lookup"><span data-stu-id="63c59-397">The following example then uses this shift-and-wrap method to compute the hash code of the `Point` structure used in the previous examples.</span></span>  
  
 [!code-csharp[System.Object.GetHashCode#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gethashcode/cs/shift1.cs#5)]
 [!code-vb[System.Object.GetHashCode#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gethashcode/vb/shift1.vb#5)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="63c59-398">
            <para>Хэш-функция используется для быстрого создания числа (хэш-код), соответствующее значению объекта. Хэш-функции обычно специфичны для каждого типа и уникальности, необходимо использовать по крайней мере одно поле экземпляра в качестве входного. Хэш-коды не должно быть вычислено с помощью значения статических полей.  Для классов, производных от <see cref="T:System.Object" />, <see langword="GetHashCode" /> метод базового класса можно делегировать <see cref="M:System.Object.GetHashCode" /> реализации только в том случае, если производный класс определяет равенство ссылок. Реализация по умолчанию <see cref="M:System.Object.GetHashCode" /> для ссылки на типы Возвращает хэш-код, которое эквивалентно значению, возвращенных <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> метод. Можно переопределить <see cref="M:System.Object.GetHashCode" /> для неизменяемого ссылочных типов. В общем случае для изменяемые ссылочные типы, должны переопределять <see cref="M:System.Object.GetHashCode" /> только если: - можно вычислить хэш-код из полей, которые не являются изменяемыми; или - убедитесь, что хэш-код для изменяемого объекта не изменить объект содержится в collecti от этого зависит от его хэш-код.  В противном случае вы можете подумать, теряется, изменяемого объекта в хэш-таблице. Если вы решите переопределить <see cref="M:System.Object.GetHashCode" /> для изменяемым ссылочным типом, документации следует сделать снимите флажок, чтобы пользователи этого типа не могут изменять значения объекта во время хранения объекта в хэш-таблице.  Для типов значений <see cref="M:System.ValueType.GetHashCode" /> предоставляет стандартную реализацию кода хэш, который использует отражение. Рассмотрите возможность его переопределения для повышения производительности.  <block subset="none" type="note"><para> Дополнительные сведения и примеры, которые вычисляют хэш-кодов в различными способами см. подраздел «примеры».  </para></block>  Хэш-функции должны иметь следующие свойства: - если два объекта при сравнении считаются равными, <see cref="M:System.Object.GetHashCode" /> метод для каждого объекта должен возвращать одинаковое значение. Тем не менее, если два объекта не при сравнении считаются равными, <see cref="M:System.Object.GetHashCode" /> методы для двух объектов не обязательно должны возвращать разные значения.  - <see cref="M:System.Object.GetHashCode" /> Метод для объекта, постоянно должен возвращать такой же хэш-код при условии, что есть какие-либо изменения состояния объекта, определяющее возвращаемое значение объекта [System.Object.Equals](xref:System.Object.Equals*) метод. Обратите внимание, что это справедливо только для текущего выполнения приложения при повторном запуске приложения может возвращаться другой хэш-код.  -Для повышения производительности хэш-функция должна создавать равномерное распределение для всех входных данных, включая входных данных, который сильно кластер. Суть в том, что небольшие изменения состояния объекта должны появиться больших изменений в результирующее хэш-код для достижения оптимальной производительности хэш-таблицы.  -Хэш функции должно быть недорогих для вычисления.  - <see cref="M:System.Object.GetHashCode" /> Метод не должен выдавать исключения.  Например, реализация <see cref="M:System.String.GetHashCode" /> метод <see cref="T:System.String" /> класса возвращает одинаковые хэш-коды для идентичные строковые значения. Таким образом, два <see cref="T:System.String" /> объекты возвращают одинаковые хэш-код, если они представляют одно и то же значение строки. Кроме того, этот метод использует все символы в строке для создания случайно распределенного результата, даже в том случае, если является кластеризованным экземпляром входные данные в определенные диапазоны (например, многие пользователи применяют строки, содержащие только первые 128 ASCII, даже если Строка может содержать любые из 65535 символов Юникода).  Предоставление хорошей хэш-функции для каждого класса может значительно повлиять на производительность Добавление соответствующих объектов в хэш-таблицу. В хэш-таблицу с ключами, которые обеспечивают реализацию хорошей хэш-функции поиск элементов требуется постоянное время (например, операцией o(1)). В хэш-таблице при плохой реализации хэш-функции, скорость поиска зависит от числа элементов в хэш-таблице (например, операцией O('n'), где 'n' — количество элементов в хэш-таблице). Пользователь-злоумышленник может входные данные, что увеличивает количество конфликтов, в которых может значительно ухудшить производительность приложений, зависящих от хэш-таблицы в следующих случаях: - Если хэш-функции выдают часто конфликтов.  -Если большую часть объектов в хэш-таблице создания хэш-кодов, которые равны или приблизительно друг с другом.  -Если пользователи входных данных, из которого вычисляется хэш-код.  Производные классы, переопределяющие <see cref="M:System.Object.GetHashCode" /> необходимо также переопределить <see cref="M:System.Object.Equals(System.Object)" /> гарантировать, что два объекта, считаются равными, имеют тот же хэш-код; в противном случае <see cref="T:System.Collections.Hashtable" /> типа могут работать неправильно.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="63c59-398">
              <para>A hash function is used to quickly generate a number (hash code) that corresponds to the value of an object. Hash functions are usually specific to each type and, for uniqueness, must use at least one of the instance fields as input. Hash codes should not be computed by using the values of static fields.  For classes derived from <see cref="T:System.Object" />, the <see langword="GetHashCode" /> method can delegate to the base class <see cref="M:System.Object.GetHashCode" /> implementation only if the derived class defines equality to be reference equality. The default implementation of <see cref="M:System.Object.GetHashCode" /> for reference types returns a hash code that is equivalent to the one returned by the <see cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" /> method. You can override <see cref="M:System.Object.GetHashCode" /> for immutable reference types. In general, for mutable reference types, you should override <see cref="M:System.Object.GetHashCode" /> only if:  -   You can compute the hash code from fields that are not mutable; or  -   You can ensure that the hash code of a mutable object does not change while the object is contained in a collection that relies on its hash code.  Otherwise, you might think that the mutable object is lost in the hash table. If you do choose to override <see cref="M:System.Object.GetHashCode" /> for a mutable reference type, your documentation should make it clear that users of your type should not modify object values while the object is stored in a hash table.  For value types, <see cref="M:System.ValueType.GetHashCode" /> provides a default hash code implementation that uses reflection. You should consider overriding it for better performance.  <block subset="none" type="note"><para> For more information and examples that compute hash codes in a variety of ways, see the Examples section.  </para></block>  A hash function must have the following properties:  -   If two objects compare as equal, the <see cref="M:System.Object.GetHashCode" /> method for each object must return the same value. However, if two objects do not compare as equal, the <see cref="M:System.Object.GetHashCode" /> methods for the two objects do not have to return different values.  -   The <see cref="M:System.Object.GetHashCode" /> method for an object must consistently return the same hash code as long as there is no modification to the object state that determines the return value of the object's [System.Object.Equals](xref:System.Object.Equals*) method. Note that this is true only for the current execution of an application, and that a different hash code can be returned if the application is run again.  -   For the best performance, a hash function should generate an even distribution for all input, including input that is heavily clustered. An implication is that small modifications to object state should result in large modifications to the resulting hash code for best hash table performance.  -   Hash functions should be inexpensive to compute.  -   The <see cref="M:System.Object.GetHashCode" /> method should not throw exceptions.  For example, the implementation of the <see cref="M:System.String.GetHashCode" /> method provided by the <see cref="T:System.String" /> class returns identical hash codes for identical string values. Therefore, two <see cref="T:System.String" /> objects return the same hash code if they represent the same string value. Also, the method uses all the characters in the string to generate reasonably randomly distributed output, even when the input is clustered in certain ranges (for example, many users might have strings that contain only the lower 128 ASCII characters, even though a string can contain any of the 65,535 Unicode characters).  Providing a good hash function on a class can significantly affect the performance of adding those objects to a hash table. In a hash table with keys that provide a good implementation of a hash function, searching for an element takes constant time (for example, an O(1) operation). In a hash table with a poor implementation of a hash function, the performance of a search depends on the number of items in the hash table (for example, an O(`n`) operation, where `n` is the number of items in the hash table). A malicious user can input data that increases the number of collisions, which can significantly degrade the performance of applications that depend on hash tables, under the following conditions:  -   When hash functions produce frequent collisions.  -   When a large proportion of objects in a hash table produce hash codes that are equal or approximately equal to one another.  -   When users input the data from which the hash code is computed.  Derived classes that override <see cref="M:System.Object.GetHashCode" /> must also override <see cref="M:System.Object.Equals(System.Object)" /> to guarantee that two objects considered equal have the same hash code; otherwise, the <see cref="T:System.Collections.Hashtable" /> type might not work correctly.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Collections.Hashtable" />
        <altmember cref="M:System.Object.Equals(System.Object)" />
        <altmember cref="M:System.Runtime.CompilerServices.RuntimeHelpers.GetHashCode(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Type ^ GetType();" />
      <MemberSignature Language="F#" Value="member this.GetType : unit -&gt; Type" Usage="obj.GetType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="63c59-399">Возвращает объект <see cref="T:System.Type" /> для текущего экземпляра.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63c59-399">Gets the <see cref="T:System.Type" /> of the current instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="63c59-400">Точный тип текущего экземпляра в среде выполнения.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63c59-400">The exact runtime type of the current instance.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63c59-401">Поскольку <xref:System.Object?displayProperty=nameWithType> является базовым классом для всех типов в системе типов .NET Framework, <xref:System.Object.GetType%2A> метод может использоваться для возврата <xref:System.Type> объекты, представляющие все типы .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="63c59-401">Because <xref:System.Object?displayProperty=nameWithType> is the base class for all types in the .NET Framework type system, the <xref:System.Object.GetType%2A> method can be used to return <xref:System.Type> objects that represent all .NET Framework types.</span></span> <span data-ttu-id="63c59-402">Платформа .NET Framework распознает следующие пять категорий типов:</span><span class="sxs-lookup"><span data-stu-id="63c59-402">The .NET Framework recognizes the following five categories of types:</span></span>  
  
-   <span data-ttu-id="63c59-403">Классы, которые являются производными от <xref:System.Object?displayProperty=nameWithType>,</span><span class="sxs-lookup"><span data-stu-id="63c59-403">Classes, which are derived from <xref:System.Object?displayProperty=nameWithType>,</span></span>  
  
-   <span data-ttu-id="63c59-404">Типы, которые являются производными от значений <xref:System.ValueType?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="63c59-404">Value types, which are derived from <xref:System.ValueType?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="63c59-405">Интерфейсы, которые являются производными от <xref:System.Object?displayProperty=nameWithType> начиная с .NET Framework 2.0.</span><span class="sxs-lookup"><span data-stu-id="63c59-405">Interfaces, which are derived from <xref:System.Object?displayProperty=nameWithType> starting with the .NET Framework 2.0.</span></span>  
  
-   <span data-ttu-id="63c59-406">Перечислений, которые являются производными от <xref:System.Enum?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="63c59-406">Enumerations, which are derived from <xref:System.Enum?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="63c59-407">Делегаты, которые являются производными от <xref:System.MulticastDelegate?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="63c59-407">Delegates, which are derived from <xref:System.MulticastDelegate?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="63c59-408">Для двух объектов `x` и `y` , имеющий типы среды выполнения идентичных `Object.ReferenceEquals(x.GetType(),y.GetType())` возвращает `true`.</span><span class="sxs-lookup"><span data-stu-id="63c59-408">For two objects `x` and `y` that have identical runtime types, `Object.ReferenceEquals(x.GetType(),y.GetType())` returns `true`.</span></span> <span data-ttu-id="63c59-409">В следующем примере используется <xref:System.Object.GetType%2A> метод с <xref:System.Object.ReferenceEquals%2A> метод, чтобы определить, является ли одно числовое значение совпадает с типом двух числовых значений.</span><span class="sxs-lookup"><span data-stu-id="63c59-409">The following example uses the <xref:System.Object.GetType%2A> method with the <xref:System.Object.ReferenceEquals%2A> method to determine whether one numeric value is the same type as two other numeric values.</span></span>  
  
 [!code-csharp[System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/gettype1.vb#1)]  
  
> [!NOTE]
>  <span data-ttu-id="63c59-410">Чтобы определить, является ли объект заданного типа, можно использовать ключевое слово языка для типа сравнения или создания.</span><span class="sxs-lookup"><span data-stu-id="63c59-410">To determine whether an object is a specific type, you can use your language's type comparison keyword or construct.</span></span> <span data-ttu-id="63c59-411">Например, можно использовать `TypeOf…Is` построения в Visual Basic или `is` ключевого слова C#.</span><span class="sxs-lookup"><span data-stu-id="63c59-411">For example, you can use the `TypeOf…Is` construct in Visual Basic or the `is` keyword in C#.</span></span>  
  
 <span data-ttu-id="63c59-412"><xref:System.Object.GetType%2A> Метод наследуется всеми типами, которые являются производными от <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="63c59-412">The <xref:System.Object.GetType%2A> method is inherited by all types that derive from <xref:System.Object>.</span></span> <span data-ttu-id="63c59-413">Это означает, что, помимо использования собственных ключевым словом, для сравнения, можно использовать <xref:System.Object.GetType%2A> метод для определения типа, определенного объекта, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="63c59-413">This means that, in addition to using your own language's comparison keyword, you can use the <xref:System.Object.GetType%2A> method to determine the type of a particular object, as the following example shows.</span></span>  
  
 [!code-csharp[System.Object.GetType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.gettype/cs/GetTypeEx2.cs#2)]
 [!code-vb[System.Object.GetType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.gettype/vb/GetTypeEx2.vb#2)]  
  
 <span data-ttu-id="63c59-414"><xref:System.Type> Объект предоставляет метаданные, связанные с классом текущего <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="63c59-414">The <xref:System.Type> object exposes the metadata associated with the class of the current <xref:System.Object>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="63c59-415">В следующем примере кода показано, что <xref:System.Object.GetType%2A> возвращает тип среды выполнения текущего экземпляра.</span><span class="sxs-lookup"><span data-stu-id="63c59-415">The following code example demonstrates that <xref:System.Object.GetType%2A> returns the runtime type of the current instance.</span></span>  
  
 [!code-cpp[ECMA-System.Object.GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.GetType/CPP/gettype.cpp#1)]
 [!code-csharp[ECMA-System.Object.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.GetType/CS/gettype.cs#1)]
 [!code-vb[ECMA-System.Object.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.GetType/VB/gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Type" />
      </Docs>
    </Member>
    <Member MemberName="MemberwiseClone">
      <MemberSignature Language="C#" Value="protected object MemberwiseClone ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance object MemberwiseClone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.MemberwiseClone" />
      <MemberSignature Language="VB.NET" Value="Protected Function MemberwiseClone () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; System::Object ^ MemberwiseClone();" />
      <MemberSignature Language="F#" Value="member this.MemberwiseClone : unit -&gt; obj" Usage="obj.MemberwiseClone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="63c59-416">Создает неполную копию текущего объекта <see cref="T:System.Object" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63c59-416">Creates a shallow copy of the current <see cref="T:System.Object" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="63c59-417">Неполная копия объекта <see cref="T:System.Object" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63c59-417">A shallow copy of the current <see cref="T:System.Object" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63c59-418"><xref:System.Object.MemberwiseClone%2A> Метод создает неполную копию путем создания объекта, а затем скопировать нестатические поля текущего объекта в новый объект.</span><span class="sxs-lookup"><span data-stu-id="63c59-418">The <xref:System.Object.MemberwiseClone%2A> method creates a shallow copy by creating a new object, and then copying the nonstatic fields of the current object to the new object.</span></span> <span data-ttu-id="63c59-419">Если поле имеет тип значения, выполняется копирование разрядной поля.</span><span class="sxs-lookup"><span data-stu-id="63c59-419">If a field is a value type, a bit-by-bit copy of the field is performed.</span></span> <span data-ttu-id="63c59-420">Если поле имеет ссылочный тип, ссылка копируется, но не объекты; Поэтому исходный объект и его копия относятся к одному объекту.</span><span class="sxs-lookup"><span data-stu-id="63c59-420">If a field is a reference type, the reference is copied but the referred object is not; therefore, the original object and its clone refer to the same object.</span></span>  
  
 <span data-ttu-id="63c59-421">Например рассмотрим объект, называемый X, который ссылается на объекты A и B. объекта B, в свою очередь, ссылается на объект C. Неполная копия X создает новый объект X2, который также ссылается на объекты A и B. Напротив глубокая копия X создает новый объект X2, который ссылается на новые объекты A2 и В2, которые являются копиями A и B. В2, в свою очередь, ссылается на новый объект C2, который является копией C. В примере показано различие между поверхностная и операции глубокой копией.</span><span class="sxs-lookup"><span data-stu-id="63c59-421">For example, consider an object called X that references objects A and B. Object B, in turn, references object C. A shallow copy of X creates new object X2 that also references objects A and B. In contrast, a deep copy of X creates a new object X2 that references the new objects A2 and B2, which are copies of A and B. B2, in turn, references the new object C2, which is a copy of C. The example illustrates the difference between a shallow and a deep copy operation.</span></span>  
  
 <span data-ttu-id="63c59-422">Существуют различные сценарии для реализации операции глубокую копию, если выполнить операцию неполную копию по <xref:System.Object.MemberwiseClone%2A> метод не соответствует вашим потребностям.</span><span class="sxs-lookup"><span data-stu-id="63c59-422">There are numerous ways to implement a deep copy operation if the shallow copy operation performed by the <xref:System.Object.MemberwiseClone%2A> method does not meet your needs.</span></span> <span data-ttu-id="63c59-423">В число этих требований входят следующие:</span><span class="sxs-lookup"><span data-stu-id="63c59-423">These include the following:</span></span>  
  
-   <span data-ttu-id="63c59-424">Вызовите конструктор класса объекта для копирования создать со значениями свойств, которые берутся из первого объекта второму объекту.</span><span class="sxs-lookup"><span data-stu-id="63c59-424">Call a class constructor of the object to be copied to create a second object with property values taken from the first object.</span></span> <span data-ttu-id="63c59-425">Это предполагает, что значения объекта полностью определяется конструктора класса.</span><span class="sxs-lookup"><span data-stu-id="63c59-425">This assumes that the values of an object are entirely defined by its class constructor.</span></span>  
  
-   <span data-ttu-id="63c59-426">Вызовите <xref:System.Object.MemberwiseClone%2A> метод для создания неполную копию объекта и затем назначить новые объекты, значения которого являются таким же, как исходный объект для любого свойства или поля, значения которого являются ссылочными типами.</span><span class="sxs-lookup"><span data-stu-id="63c59-426">Call the <xref:System.Object.MemberwiseClone%2A> method to create a shallow copy of an object, and then assign new objects whose values are the same as the original object to any properties or fields whose values are reference types.</span></span> <span data-ttu-id="63c59-427">`DeepCopy` Метод в этом примере демонстрируется этот подход.</span><span class="sxs-lookup"><span data-stu-id="63c59-427">The `DeepCopy` method in the example illustrates this approach.</span></span>  
  
-   <span data-ttu-id="63c59-428">Сериализовать объект быть глубокого копирования, а затем восстановите сериализованные данные переменной другого объекта.</span><span class="sxs-lookup"><span data-stu-id="63c59-428">Serialize the object to be deep copied, and then restore the serialized data to a different object variable.</span></span>  
  
-   <span data-ttu-id="63c59-429">Отражение можно используйте с рекурсией для выполнения операции глубокой копией.</span><span class="sxs-lookup"><span data-stu-id="63c59-429">Use reflection with recursion to perform the deep copy operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="63c59-430">В следующем примере демонстрируется <xref:System.Object.MemberwiseClone%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="63c59-430">The following example illustrates the <xref:System.Object.MemberwiseClone%2A> method.</span></span> <span data-ttu-id="63c59-431">Он определяет `ShallowCopy` метод, который вызывает <xref:System.Object.MemberwiseClone%2A> метод для выполнения операции неполную копию на `Person` объекта.</span><span class="sxs-lookup"><span data-stu-id="63c59-431">It defines a `ShallowCopy` method that calls the <xref:System.Object.MemberwiseClone%2A> method to perform a shallow copy operation on a `Person` object.</span></span> <span data-ttu-id="63c59-432">Он также определяет `DeepCopy` метод, выполняющий операцию глубокой копией `Person` объекта.</span><span class="sxs-lookup"><span data-stu-id="63c59-432">It also defines a `DeepCopy` method that performs a deep copy operation on a `Person` object.</span></span>  
  
 [!code-csharp[System.Object.MemberwiseClone#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.memberwiseclone/cs/memberwiseclone1.cs#1)]
 [!code-vb[System.Object.MemberwiseClone#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.memberwiseclone/vb/memberwiseclone1.vb#1)]  
  
 <span data-ttu-id="63c59-433">В этом примере `Person.IdInfo` возвращает свойство `IdInfo` объекта.</span><span class="sxs-lookup"><span data-stu-id="63c59-433">In this example, the `Person.IdInfo` property returns an `IdInfo` object.</span></span> <span data-ttu-id="63c59-434">Как видно в результатах показано в примере при `Person` клонировании объекта путем вызова <xref:System.Object.MemberwiseClone%2A> метод, клонированный `Person` объект является независимая копия исходного объекта, за исключением того, что они имеют одинаковое `Person.IdInfo` ссылку на объект.</span><span class="sxs-lookup"><span data-stu-id="63c59-434">As the output from the example shows, when a `Person` object is cloned by calling the <xref:System.Object.MemberwiseClone%2A> method, the cloned `Person` object is an independent copy of the original object, except that they share the same `Person.IdInfo` object reference.</span></span> <span data-ttu-id="63c59-435">В результате изменения клона `Person.IdInfo` изменении свойства исходного объекта `Person.IdInfo` свойство.</span><span class="sxs-lookup"><span data-stu-id="63c59-435">As a result, modifying the clone's `Person.IdInfo` property changes the original object's `Person.IdInfo` property.</span></span> <span data-ttu-id="63c59-436">С другой стороны, когда выполняется операция глубокой копией, клонированный `Person` объекта, включая его `Person.IdInfo` свойство, можно изменять без изменения исходного объекта.</span><span class="sxs-lookup"><span data-stu-id="63c59-436">On the other hand, when a deep copy operation is performed, the cloned `Person` object, including its `Person.IdInfo` property, can be modified without affecting the original object.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReferenceEquals">
      <MemberSignature Language="C#" Value="public static bool ReferenceEquals (object objA, object objB);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ReferenceEquals(object objA, object objB) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ReferenceEquals(System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReferenceEquals (objA As Object, objB As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ReferenceEquals(System::Object ^ objA, System::Object ^ objB);" />
      <MemberSignature Language="F#" Value="static member ReferenceEquals : obj * obj -&gt; bool" Usage="System.obj.ReferenceEquals (objA, objB)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objA" Type="System.Object" />
        <Parameter Name="objB" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="objA">
          <span data-ttu-id="63c59-437">Первый из сравниваемых объектов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63c59-437">The first object to compare.</span>
          </span>
        </param>
        <param name="objB">
          <span data-ttu-id="63c59-438">Второй из сравниваемых объектов.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63c59-438">The second object  to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="63c59-439">Определяет, совпадают ли указанные экземпляры <see cref="T:System.Object" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63c59-439">Determines whether the specified <see cref="T:System.Object" /> instances are the same instance.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="63c59-440">Значение <see langword="true" />, если параметр <paramref name="objA" /> соответствует тому же экземпляру, что и параметр <paramref name="objB" />, или же оба они имеют значение **NULL**; в противном случае значение <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63c59-440">
              <see langword="true" /> if <paramref name="objA" /> is the same instance as <paramref name="objB" /> or if both are **null**; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63c59-441">В отличие от <xref:System.Object.Equals%2A> метода и оператор равенства, <xref:System.Object.ReferenceEquals%2A> метод не может быть переопределен.</span><span class="sxs-lookup"><span data-stu-id="63c59-441">Unlike the <xref:System.Object.Equals%2A> method and the equality operator, the <xref:System.Object.ReferenceEquals%2A> method cannot be overridden.</span></span> <span data-ttu-id="63c59-442">По этой причине, если требуется протестировать две объектные ссылки на равенство и неизвестно о реализации `Equals` метод, можно вызвать <xref:System.Object.ReferenceEquals%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="63c59-442">Because of this, if you want to test two object references for equality and you are unsure about the implementation of the `Equals` method, you can call the <xref:System.Object.ReferenceEquals%2A> method.</span></span>  
  
 <span data-ttu-id="63c59-443">Тем не менее возвращаемое значение <xref:System.Object.ReferenceEquals%2A> метод может быть ошибочно аномальных в этих двух случаях:</span><span class="sxs-lookup"><span data-stu-id="63c59-443">However, the return value of the <xref:System.Object.ReferenceEquals%2A> method may appear to be anomalous in these two scenarios:</span></span>  
  
-   <span data-ttu-id="63c59-444">При сравнении типов значений.</span><span class="sxs-lookup"><span data-stu-id="63c59-444">When comparing value types.</span></span> <span data-ttu-id="63c59-445">Если `objA` и `objB` являются типами значений, упакованы перед передачей в <xref:System.Object.ReferenceEquals%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="63c59-445">If `objA` and `objB` are value types, they are boxed before they are passed to the <xref:System.Object.ReferenceEquals%2A> method.</span></span> <span data-ttu-id="63c59-446">Это означает, что если оба `objA` и `objB` же экземпляр типа значения, представляющие <xref:System.Object.ReferenceEquals%2A> тем не менее, метод возвращает `false`, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="63c59-446">This means that if both `objA` and `objB` represent the same instance of a value type, the <xref:System.Object.ReferenceEquals%2A> method nevertheless returns `false`, as the following example shows.</span></span>  
  
     [!code-csharp[System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequals4.cs#1)]
     [!code-vb[System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequals4.vb#1)]  
  
     <span data-ttu-id="63c59-447">Сведения для упаковки типов значений см. в разделе [упаковка-преобразование и распаковка-преобразование](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).</span><span class="sxs-lookup"><span data-stu-id="63c59-447">For information on boxing value types, see [Boxing and Unboxing](~/docs/csharp/programming-guide/types/boxing-and-unboxing.md).</span></span>  
  
-   <span data-ttu-id="63c59-448">При сравнении строк.</span><span class="sxs-lookup"><span data-stu-id="63c59-448">When comparing strings.</span></span> <span data-ttu-id="63c59-449">Если `objA` и `objB` являются строками, <xref:System.Object.ReferenceEquals%2A> возвращает `true` Если интернировано строки.</span><span class="sxs-lookup"><span data-stu-id="63c59-449">If `objA` and `objB` are strings, the <xref:System.Object.ReferenceEquals%2A> method returns `true` if the string is interned.</span></span> <span data-ttu-id="63c59-450">Он не выполняет проверку на равенство значений.</span><span class="sxs-lookup"><span data-stu-id="63c59-450">It does not perform a test for value equality.</span></span>  <span data-ttu-id="63c59-451">В следующем примере `s1` и `s2` равны, поскольку они являются два экземпляра одной интернированные строки.</span><span class="sxs-lookup"><span data-stu-id="63c59-451">In the following example, `s1` and `s2` are equal because they are two instances of a single interned string.</span></span> <span data-ttu-id="63c59-452">Тем не менее `s3` и `s4` не равны, поскольку несмотря на то, что они являются имеют идентичные строковые значения, эта строка не интернировано.</span><span class="sxs-lookup"><span data-stu-id="63c59-452">However, `s3` and `s4` are not equal, because although they are have identical string values, that string is not interned.</span></span>  
  
     [!code-csharp[System.Object.ReferenceEquals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.referenceequals/cs/referenceequalsa.cs#2)]
     [!code-vb[System.Object.ReferenceEquals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.referenceequals/vb/referenceequalsa.vb#2)]  
  
     <span data-ttu-id="63c59-453">Дополнительные сведения об изоляции строк см. в разделе <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="63c59-453">For more information about string interning, see <xref:System.String.IsInterned%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="63c59-454">В следующем примере используется <xref:System.Object.ReferenceEquals%2A> для определения, если два объекта и тот же экземпляр.</span><span class="sxs-lookup"><span data-stu-id="63c59-454">The following example uses <xref:System.Object.ReferenceEquals%2A> to determine if two objects are the same instance.</span></span>  
  
 [!code-cpp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/cpp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CPP/referenceequals.cpp#1)]
 [!code-csharp[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/csharp/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/CS/referenceequals.cs#1)]
 [!code-vb[ECMA-System.Object.ReferenceEquals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ECMA-System.Object.ReferenceEquals/vb/referenceequals.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Object.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public virtual string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Object.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="abstract member ToString : unit -&gt; string&#xA;override this.ToString : unit -&gt; string" Usage="obj.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="63c59-455">Возвращает строку, представляющую текущий объект.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63c59-455">Returns a string that represents the current object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="63c59-456">Строка, представляющая текущий объект.</span>
          <span class="sxs-lookup">
            <span data-stu-id="63c59-456">A string that represents the current object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="63c59-457"><xref:System.Object.ToString%2A?displayProperty=nameWithType> форматирование основной метод в .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="63c59-457"><xref:System.Object.ToString%2A?displayProperty=nameWithType> is the major formatting method in the .NET Framework.</span></span> <span data-ttu-id="63c59-458">Он преобразует объект в строковое представление, чтобы он подходит для отображения.</span><span class="sxs-lookup"><span data-stu-id="63c59-458">It converts an object to its string representation so that it is suitable for display.</span></span> <span data-ttu-id="63c59-459">(Сведения о форматировании поддержки платформы .NET Framework см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).) Используемые по умолчанию реализации <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод возвращает полное имя типа объекта.</span><span class="sxs-lookup"><span data-stu-id="63c59-459">(For information about formatting support in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).) Default implementations of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method return the fully qualified name of the object's type.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="63c59-460">Возможно, достигнуто эту страницу, щелкнув ссылку из списка членов другого типа.</span><span class="sxs-lookup"><span data-stu-id="63c59-460">You may have reached this page by following the link from the member list of another type.</span></span> <span data-ttu-id="63c59-461">Это потому, что этот тип не переопределяет <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="63c59-461">That is because that type does not override <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="63c59-462">Вместо этого он наследует функциональные возможности <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="63c59-462">Instead, it inherits the functionality of the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="63c59-463">Типы часто переопределить <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод, чтобы обеспечить более подходящими строковое представление определенного типа.</span><span class="sxs-lookup"><span data-stu-id="63c59-463">Types frequently override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide a more suitable string representation of a particular type.</span></span> <span data-ttu-id="63c59-464">Типы также могут вызвать перегрузку <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод, чтобы обеспечить поддержку для строки формата или форматирование с учетом языка и региональных параметров.</span><span class="sxs-lookup"><span data-stu-id="63c59-464">Types also frequently overload the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to provide support for format strings or culture-sensitive formatting.</span></span>  
  
 <span data-ttu-id="63c59-465">Содержание</span><span class="sxs-lookup"><span data-stu-id="63c59-465">In this section:</span></span>  
  
 <span data-ttu-id="63c59-466">[Метод Object.ToString() по умолчанию](#Default) </span><span class="sxs-lookup"><span data-stu-id="63c59-466">[The default Object.ToString() method](#Default) </span></span>  
 <span data-ttu-id="63c59-467">[Переопределение метода Object.ToString()](#Overriding) </span><span class="sxs-lookup"><span data-stu-id="63c59-467">[Overriding the Object.ToString() method](#Overriding) </span></span>  
 <span data-ttu-id="63c59-468">[Перегрузка метода ToString](#Overloading) </span><span class="sxs-lookup"><span data-stu-id="63c59-468">[Overloading the ToString method](#Overloading) </span></span>  
 <span data-ttu-id="63c59-469">[Расширение Object.ToString-метод](#Extending) </span><span class="sxs-lookup"><span data-stu-id="63c59-469">[Extending the Object.ToString method](#Extending) </span></span>  
 [<span data-ttu-id="63c59-470">Примечания для среды выполнения Windows</span><span class="sxs-lookup"><span data-stu-id="63c59-470">Notes for the Windows Runtime</span></span>](#WinRT)  
  
<a name="Default"></a>   
## <a name="the-default-objecttostring-method"></a><span data-ttu-id="63c59-471">Метод Object.ToString() по умолчанию</span><span class="sxs-lookup"><span data-stu-id="63c59-471">The default Object.ToString() method</span></span>  
 <span data-ttu-id="63c59-472">Реализация по умолчанию <xref:System.Object.ToString%2A> метод возвращает полное имя типа <xref:System.Object>, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="63c59-472">The default implementation of the <xref:System.Object.ToString%2A> method returns the fully qualified name of the type of the <xref:System.Object>, as the following example shows.</span></span>  
  
 [!code-cpp[System.Object.ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring1.cpp#1)]
 [!code-csharp[System.Object.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Object.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring1.vb#1)]  
  
 <span data-ttu-id="63c59-473">Поскольку <xref:System.Object> является базовым классом для всех ссылочных типов в .NET Framework, это поведение наследуется ссылочных типов, которые не переопределяют <xref:System.Object.ToString%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="63c59-473">Because <xref:System.Object> is the base class of all reference types in the .NET Framework, this behavior is inherited by reference types that do not override the <xref:System.Object.ToString%2A> method.</span></span> <span data-ttu-id="63c59-474">Это показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="63c59-474">The following example illustrates this.</span></span> <span data-ttu-id="63c59-475">Он определяет класс с именем `Object1` , принимающий реализацию по умолчанию все <xref:System.Object> члены.</span><span class="sxs-lookup"><span data-stu-id="63c59-475">It defines a class named `Object1` that accepts the default implementation of all <xref:System.Object> members.</span></span> <span data-ttu-id="63c59-476">Его <xref:System.Object.ToString%2A> метод возвращает полное имя объекта.</span><span class="sxs-lookup"><span data-stu-id="63c59-476">Its <xref:System.Object.ToString%2A> method returns the object's fully qualified type name.</span></span>  
  
 [!code-cpp[System.Object.ToString#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring2.cpp#2)]
 [!code-csharp[System.Object.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Object.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring2.vb#2)]  
  
<a name="Overriding"></a>   
## <a name="overriding-the-objecttostring-method"></a><span data-ttu-id="63c59-477">Переопределение метода Object.ToString()</span><span class="sxs-lookup"><span data-stu-id="63c59-477">Overriding the Object.ToString() method</span></span>  
 <span data-ttu-id="63c59-478">Типы часто переопределить <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод для возврата строки, который представляет экземпляр объекта.</span><span class="sxs-lookup"><span data-stu-id="63c59-478">Types commonly override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return a string that represents the object instance.</span></span> <span data-ttu-id="63c59-479">Например, базовый типы, такие как <xref:System.Char>, <xref:System.Int32>, и <xref:System.String> предоставляют <xref:System.Object.ToString%2A> реализации, которые возвращают значение, которое представляет объект строковой форме.</span><span class="sxs-lookup"><span data-stu-id="63c59-479">For example, the base types such as <xref:System.Char>, <xref:System.Int32>, and <xref:System.String> provide <xref:System.Object.ToString%2A> implementations that return the string form of the value that the object represents.</span></span> <span data-ttu-id="63c59-480">В следующем примере определяется класс, `Object2`, который переопределяет <xref:System.Object.ToString%2A> метод для возврата имени типа и его значение.</span><span class="sxs-lookup"><span data-stu-id="63c59-480">The following example defines a class, `Object2`, that overrides the <xref:System.Object.ToString%2A> method to return the type name along with its value.</span></span>  
  
 [!code-cpp[System.Object.ToString#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.object.tostring/cpp/tostring3.cpp#3)]
 [!code-csharp[System.Object.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Object.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostring3.vb#3)]  
  
 <span data-ttu-id="63c59-481">В следующей таблице перечислены категории типов в .NET Framework и указывает ли они переопределяют <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод.</span><span class="sxs-lookup"><span data-stu-id="63c59-481">The following table lists the type categories in the .NET Framework and indicates whether or not they override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method.</span></span>  
  
|<span data-ttu-id="63c59-482">Категория типа</span><span class="sxs-lookup"><span data-stu-id="63c59-482">Type category</span></span>|<span data-ttu-id="63c59-483">Переопределения Object.ToString()</span><span class="sxs-lookup"><span data-stu-id="63c59-483">Overrides Object.ToString()</span></span>|<span data-ttu-id="63c59-484">Поведение</span><span class="sxs-lookup"><span data-stu-id="63c59-484">Behavior</span></span>|  
|-------------------|-----------------------------------|--------------|  
|<span data-ttu-id="63c59-485">Класс</span><span class="sxs-lookup"><span data-stu-id="63c59-485">Class</span></span>|<span data-ttu-id="63c59-486">Н/Д</span><span class="sxs-lookup"><span data-stu-id="63c59-486">n/a</span></span>|<span data-ttu-id="63c59-487">Н/Д</span><span class="sxs-lookup"><span data-stu-id="63c59-487">n/a</span></span>|  
|<span data-ttu-id="63c59-488">Структура</span><span class="sxs-lookup"><span data-stu-id="63c59-488">Structure</span></span>|<span data-ttu-id="63c59-489">Да (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="63c59-489">Yes (<xref:System.ValueType.ToString%2A?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="63c59-490">То же, что Object.ToString()</span><span class="sxs-lookup"><span data-stu-id="63c59-490">Same as Object.ToString()</span></span>|  
|<span data-ttu-id="63c59-491">Перечисление</span><span class="sxs-lookup"><span data-stu-id="63c59-491">Enumeration</span></span>|<span data-ttu-id="63c59-492">Да (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span><span class="sxs-lookup"><span data-stu-id="63c59-492">Yes (<xref:System.Enum.ToString?displayProperty=nameWithType>)</span></span>|<span data-ttu-id="63c59-493">Имя члена</span><span class="sxs-lookup"><span data-stu-id="63c59-493">The member name</span></span>|  
|<span data-ttu-id="63c59-494">Интерфейс</span><span class="sxs-lookup"><span data-stu-id="63c59-494">Interface</span></span>|<span data-ttu-id="63c59-495">Нет</span><span class="sxs-lookup"><span data-stu-id="63c59-495">No</span></span>|<span data-ttu-id="63c59-496">Н/Д</span><span class="sxs-lookup"><span data-stu-id="63c59-496">n/a</span></span>|  
|<span data-ttu-id="63c59-497">делегат</span><span class="sxs-lookup"><span data-stu-id="63c59-497">Delegate</span></span>|<span data-ttu-id="63c59-498">Нет</span><span class="sxs-lookup"><span data-stu-id="63c59-498">No</span></span>|<span data-ttu-id="63c59-499">Н/Д</span><span class="sxs-lookup"><span data-stu-id="63c59-499">n/a</span></span>|  
  
 <span data-ttu-id="63c59-500">См. примечания для наследующих объектов раздел для получения дополнительных сведений о переопределении <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="63c59-500">See the Notes to Inheritors section for additional information on overriding <xref:System.Object.ToString%2A>.</span></span>  
  
<a name="Overloading"></a>   
## <a name="overloading-the-tostring-method"></a><span data-ttu-id="63c59-501">Перегрузка метода ToString</span><span class="sxs-lookup"><span data-stu-id="63c59-501">Overloading the ToString method</span></span>  
 <span data-ttu-id="63c59-502">Помимо без параметров переопределения <xref:System.Object.ToString?displayProperty=nameWithType> перегрузку метода, многие типы `ToString` метод для предоставления версии метода, которые принимают параметры.</span><span class="sxs-lookup"><span data-stu-id="63c59-502">In addition to overriding the parameterless <xref:System.Object.ToString?displayProperty=nameWithType> method, many types overload the `ToString` method to provide versions of the method that accept parameters.</span></span> <span data-ttu-id="63c59-503">Чаще всего это делается для обеспечения поддержки форматирования переменных и форматирование с учетом языка и региональных параметров.</span><span class="sxs-lookup"><span data-stu-id="63c59-503">Most commonly, this is done to provide support for variable formatting and culture-sensitive formatting.</span></span>  
  
 <span data-ttu-id="63c59-504">Следующий пример перегрузки `ToString` метод для возврата результата строку, содержащую значения различных полей `Automobile` класса.</span><span class="sxs-lookup"><span data-stu-id="63c59-504">The following example overloads the `ToString` method to return a result string that includes the value of various fields of an `Automobile` class.</span></span> <span data-ttu-id="63c59-505">Он определяет четыре строки формата: G, который возвращает имя модели и год. D, который возвращает имя модели, году и количества дверей; C, который возвращает имя модели, год и число цилиндров; и объект, который возвращает строку со значениями всех четырех полей.</span><span class="sxs-lookup"><span data-stu-id="63c59-505">It defines four format strings: G, which returns the model name and year; D, which returns the model name, year, and number of doors; C, which returns the model name, year, and number of cylinders; and A, which returns a string with all four field values.</span></span>  
  
 [!code-csharp[System.Object.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload1.cs#4)]
 [!code-vb[System.Object.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload1.vb#4)]  
  
 <span data-ttu-id="63c59-506">В следующем примере вызывается перегруженный <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> метод для отображения, зависящие от культуры форматирование значения валюты.</span><span class="sxs-lookup"><span data-stu-id="63c59-506">The following example calls the overloaded <xref:System.Decimal.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> method to display culture-sensitive formatting of a currency value.</span></span>  
  
 [!code-csharp[System.Object.ToString#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/tostringoverload2.cs#5)]
 [!code-vb[System.Object.ToString#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/tostringoverload2.vb#5)]  
  
 <span data-ttu-id="63c59-507">Дополнительные сведения о формате строк и форматирования с учетом языка и региональных параметров см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="63c59-507">For more information on format strings and culture-sensitive formatting, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span> <span data-ttu-id="63c59-508">Строки формата, поддерживаемые числовые значения, в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="63c59-508">For the format strings supported by numeric values, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span> <span data-ttu-id="63c59-509">Строки формата, поддерживаемых значений даты и времени, в разделе [стандартной строки даты и времени формат](~/docs/standard/base-types/standard-date-and-time-format-strings.md) и [пользовательских строк даты и времени формат](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="63c59-509">For the format strings supported by date and time values, see [Standard Date and Time Format Strings](~/docs/standard/base-types/standard-date-and-time-format-strings.md) and [Custom Date and Time Format Strings](~/docs/standard/base-types/custom-date-and-time-format-strings.md).</span></span>  
  
<a name="Extending"></a>   
## <a name="extending-the-objecttostring-method"></a><span data-ttu-id="63c59-510">Расширение Object.ToString-метод</span><span class="sxs-lookup"><span data-stu-id="63c59-510">Extending the Object.ToString method</span></span>  
 <span data-ttu-id="63c59-511">Так как тип наследует значение по умолчанию <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод, может найти нежелательное поведение и изменить его.</span><span class="sxs-lookup"><span data-stu-id="63c59-511">Because a type inherits the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method, you may find its behavior undesirable and want to change it.</span></span> <span data-ttu-id="63c59-512">Это особенно верно, массивы и классы коллекций.</span><span class="sxs-lookup"><span data-stu-id="63c59-512">This is particularly true of arrays and collection classes.</span></span> <span data-ttu-id="63c59-513">Хотя можно ожидать `ToString` метод класса массива или коллекции для отображения значений его членов, он вместо отображает полное имя типа, как показано в следующем примере.</span><span class="sxs-lookup"><span data-stu-id="63c59-513">While you may expect the `ToString` method of an array or collection class to display the values of its members, it instead displays the type fully qualified type name, as the following example shows.</span></span>  
  
 [!code-csharp[System.Object.ToString#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/array1.cs#6)]
 [!code-vb[System.Object.ToString#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/array1.vb#6)]  
  
 <span data-ttu-id="63c59-514">У вас есть несколько вариантов и получить результат, который будет.</span><span class="sxs-lookup"><span data-stu-id="63c59-514">You have several options to produce the result string that you'd like.</span></span>  
  
-   <span data-ttu-id="63c59-515">Если тип является массивом, объект коллекции или объект, реализующий интерфейс <xref:System.Collections.IEnumerable> или <xref:System.Collections.Generic.IEnumerable%601> интерфейсы, можно перечислить его элементы с помощью `foreach` инструкции на языке C# или `For Each...Next` построения в Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="63c59-515">If the type is an array, a collection object, or an object that implements the <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601> interfaces, you can enumerate its elements by using the `foreach` statement in C# or the `For Each...Next` construct in Visual Basic.</span></span>  
  
-   <span data-ttu-id="63c59-516">Если класс не является `sealed` (в C#) или `NotInheritable` (в Visual Basic), может создавать класс-оболочку, который наследует от базового класса, <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод, которую нужно настроить.</span><span class="sxs-lookup"><span data-stu-id="63c59-516">If the class is not `sealed` (in C#) or `NotInheritable` (in Visual Basic), you can develop a wrapper class that inherits from the base class whose <xref:System.Object.ToString%2A?displayProperty=nameWithType> method you want to customize.</span></span> <span data-ttu-id="63c59-517">Как минимум для этого необходимо сделать следующее:</span><span class="sxs-lookup"><span data-stu-id="63c59-517">At a minimum, this requires that you do the following:</span></span>  
  
    1.  <span data-ttu-id="63c59-518">Реализуйте все необходимые конструкторы.</span><span class="sxs-lookup"><span data-stu-id="63c59-518">Implement any necessary constructors.</span></span> <span data-ttu-id="63c59-519">Производные классы не наследуют их конструкторы базового класса.</span><span class="sxs-lookup"><span data-stu-id="63c59-519">Derived classes do not inherit their base class constructors.</span></span>  
  
    2.  <span data-ttu-id="63c59-520">Переопределить <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод строку результата, который будет возвращать.</span><span class="sxs-lookup"><span data-stu-id="63c59-520">Override the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to return the result string that you'd like.</span></span>  
  
     <span data-ttu-id="63c59-521">В следующем примере определяется класс-оболочку для <xref:System.Collections.Generic.List%601> класса.</span><span class="sxs-lookup"><span data-stu-id="63c59-521">The following example defines a wrapper class for the <xref:System.Collections.Generic.List%601> class.</span></span> <span data-ttu-id="63c59-522">Он переопределяет <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод для отображения значения каждого метода интерфейса коллекции, а не полное имя типа.</span><span class="sxs-lookup"><span data-stu-id="63c59-522">It overrides the <xref:System.Object.ToString%2A?displayProperty=nameWithType> method to display the value of each method of the collection rather than the fully qualified type name.</span></span>  
  
     [!code-csharp[System.Object.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize1.cs#7)]
     [!code-vb[System.Object.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize1.vb#7)]  
  
-   <span data-ttu-id="63c59-523">Разработка [метод расширения](~/docs/standard/design-guidelines/extension-methods.md) , возвращает строку результата, который будет.</span><span class="sxs-lookup"><span data-stu-id="63c59-523">Develop an [extension method](~/docs/standard/design-guidelines/extension-methods.md) that returns the result string that you want.</span></span> <span data-ttu-id="63c59-524">Обратите внимание, что не может переопределить значение по умолчанию <xref:System.Object.ToString%2A?displayProperty=nameWithType> метод таким образом (то есть класса расширения (в C#) или модуля (в Visual Basic) не может иметь метод без параметров с именем `ToString` , вызываемый вместо оригинального типа `ToString` метод .</span><span class="sxs-lookup"><span data-stu-id="63c59-524">Note that you can't override the default <xref:System.Object.ToString%2A?displayProperty=nameWithType> method in this way (that is, your extension class (in C#) or module (in Visual Basic) cannot have a parameterless method named `ToString` that is called in place of the original type's `ToString` method.</span></span> <span data-ttu-id="63c59-525">Необходимо указать другое имя для вашей без параметров `ToString` замены.</span><span class="sxs-lookup"><span data-stu-id="63c59-525">You'll have to provide some other name for your parameterless `ToString` replacement.</span></span>  
  
     <span data-ttu-id="63c59-526">В следующем примере определяются два метода, которые расширяют <xref:System.Collections.Generic.List%601> класса: конструктор без параметров `ToString2` метода и `ToString` метод с <xref:System.String> параметр, который представляет строку формата.</span><span class="sxs-lookup"><span data-stu-id="63c59-526">The following example defines two methods that extend the <xref:System.Collections.Generic.List%601> class: a parameterless `ToString2` method, and a `ToString` method with a <xref:System.String> parameter that represents a format string.</span></span>  
  
     [!code-csharp[System.Object.ToString#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.object.tostring/cs/customize2.cs#8)]
     [!code-vb[System.Object.ToString#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.object.tostring/vb/customize2.vb#8)]  
  
<a name="WinRT"></a>   
## <a name="notes-for-the-includewrtincludeswrt-mdmd"></a><span data-ttu-id="63c59-527">Заметки о [!INCLUDE[wrt](~/includes/wrt-md.md)]</span><span class="sxs-lookup"><span data-stu-id="63c59-527">Notes for the [!INCLUDE[wrt](~/includes/wrt-md.md)]</span></span>  
 <span data-ttu-id="63c59-528">При вызове <xref:System.Object.ToString%2A> метод класса в [!INCLUDE[wrt](~/includes/wrt-md.md)], он предоставляет поведение по умолчанию для классов, которые не переопределяют <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="63c59-528">When you call the <xref:System.Object.ToString%2A> method on a class in the [!INCLUDE[wrt](~/includes/wrt-md.md)], it provides the default behavior for classes that don’t override <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="63c59-529">Это является частью возможностей .NET Framework для [!INCLUDE[wrt](~/includes/wrt-md.md)] (см. [.NET Framework поддерживает для приложений магазина Windows и среды выполнения Windows](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span><span class="sxs-lookup"><span data-stu-id="63c59-529">This is part of the support that the .NET Framework provides for the [!INCLUDE[wrt](~/includes/wrt-md.md)] (see [.NET Framework Support for Windows Store Apps and Windows Runtime](~/docs/standard/cross-platform/support-for-windows-store-apps-and-windows-runtime.md)).</span></span> <span data-ttu-id="63c59-530">Классы в [!INCLUDE[wrt](~/includes/wrt-md.md)] не наследуют <xref:System.Object>и не всегда использовать <xref:System.Object.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="63c59-530">Classes in the [!INCLUDE[wrt](~/includes/wrt-md.md)] don’t inherit <xref:System.Object>, and don’t always implement a <xref:System.Object.ToString%2A>.</span></span> <span data-ttu-id="63c59-531">При этом они всегда будут иметь <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, и <xref:System.Object.GetHashCode%2A> методов при их использовании в коде C# или Visual Basic и .NET Framework предоставляет поведение по умолчанию для этих методов.</span><span class="sxs-lookup"><span data-stu-id="63c59-531">However, they always appear to have <xref:System.Object.ToString%2A>, <xref:System.Object.Equals%28System.Object%29>, and <xref:System.Object.GetHashCode%2A> methods when you use them in your C# or Visual Basic code, and the .NET Framework provides a default behavior for these methods.</span></span>  
  
 <span data-ttu-id="63c59-532">Начиная с [!INCLUDE[net_v451](~/includes/net-v451-md.md)], общеязыковая среда выполнения будет использовать [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) на [!INCLUDE[wrt](~/includes/wrt-md.md)] объекта перед возвратом к реализации по умолчанию <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="63c59-532">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], the common language runtime will use [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) on a [!INCLUDE[wrt](~/includes/wrt-md.md)] object before falling back to the default implementation of <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  [!INCLUDE[wrt](~/includes/wrt-md.md)]<span data-ttu-id="63c59-533"> классы, написанные на C# или Visual Basic можно переопределить <xref:System.Object.ToString%2A> метод.</span><span class="sxs-lookup"><span data-stu-id="63c59-533"> classes that are written in C# or Visual Basic can override the <xref:System.Object.ToString%2A> method.</span></span>  
  
### <a name="the-includewrtincludeswrt-mdmd-and-the-istringable-interface"></a><span data-ttu-id="63c59-534">[!INCLUDE[wrt](~/includes/wrt-md.md)] И интерфейс IStringable</span><span class="sxs-lookup"><span data-stu-id="63c59-534">The [!INCLUDE[wrt](~/includes/wrt-md.md)] and the IStringable Interface</span></span>  
 <span data-ttu-id="63c59-535">Начиная с [!INCLUDE[win81](~/includes/win81-md.md)], [!INCLUDE[wrt](~/includes/wrt-md.md)] включает [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) единственный метод которого [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), обеспечивает базовую поддержку форматирования, сравнимую с предоставляемые <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="63c59-535">Starting with [!INCLUDE[win81](~/includes/win81-md.md)], the [!INCLUDE[wrt](~/includes/wrt-md.md)] includes an [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface whose single method, [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx), provides basic formatting support comparable to that provided by <xref:System.Object.ToString%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="63c59-536">Чтобы избежать неоднозначности, не следует реализовывать [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) на управляемых типов.</span><span class="sxs-lookup"><span data-stu-id="63c59-536">To prevent ambiguity, you should not implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on managed types.</span></span>  
  
 <span data-ttu-id="63c59-537">При вызове управляемых объектов машинного кода или кода, написанного на языках, таких как JavaScript или C + +/ CX, они отображаются для реализации [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span><span class="sxs-lookup"><span data-stu-id="63c59-537">When managed objects are called by native code or by code written in languages such as JavaScript or C++/CX, they appear to implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span> <span data-ttu-id="63c59-538">Общеязыковая среда выполнения автоматически перенаправляет вызовы от [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) для <xref:System.Object.ToString%2A?displayProperty=nameWithType> событий [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) не реализован для управляемого объекта.</span><span class="sxs-lookup"><span data-stu-id="63c59-538">The common language runtime will automatically route calls from [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) to <xref:System.Object.ToString%2A?displayProperty=nameWithType> in the event [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) is not implemented on the managed object.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="63c59-539">Поскольку общеязыковая среда выполнения автоматически реализует [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) для всех управляемых типов в [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] , рекомендуется, вы не предоставляют свои собственные [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) реализации.</span><span class="sxs-lookup"><span data-stu-id="63c59-539">Because the common language runtime auto-implements [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) for all managed types in [!INCLUDE[win8_appstore_long](~/includes/win8-appstore-long-md.md)] apps, we recommend that you do not provide your own [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation.</span></span> <span data-ttu-id="63c59-540">Реализация [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) может привести к непредвиденному поведению при вызове `ToString` из [!INCLUDE[wrt](~/includes/wrt-md.md)], C + +/ CX или JavaScript.</span><span class="sxs-lookup"><span data-stu-id="63c59-540">Implementing [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) may result in unintended behavior when calling `ToString` from the [!INCLUDE[wrt](~/includes/wrt-md.md)], C++/CX, or JavaScript.</span></span>  
  
 <span data-ttu-id="63c59-541">Если вы решили реализовать [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) в открытом управляемом типе, экспортируемом в [!INCLUDE[wrt](~/includes/wrt-md.md)] компонента, применяются следующие ограничения:</span><span class="sxs-lookup"><span data-stu-id="63c59-541">If you do choose to implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) in a public managed type that is exported in a [!INCLUDE[wrt](~/includes/wrt-md.md)] component, the following restrictions apply:</span></span>  
  
-   <span data-ttu-id="63c59-542">Можно определить [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) интерфейса только в отношениях «класс реализует», такие как</span><span class="sxs-lookup"><span data-stu-id="63c59-542">You can define the [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) interface only in a "class implements" relationship, such as</span></span>  
  
    ```csharp  
    public class NewClass : IStringable  
    ```  
  
     <span data-ttu-id="63c59-543">в C# или</span><span class="sxs-lookup"><span data-stu-id="63c59-543">in C#, or</span></span>  
  
    ```vb  
    Public Class NewClass : Implements IStringable  
    ```  
  
     <span data-ttu-id="63c59-544">в Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="63c59-544">in Visual Basic.</span></span>  
  
-   <span data-ttu-id="63c59-545">Нельзя реализовать [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) в интерфейсе.</span><span class="sxs-lookup"><span data-stu-id="63c59-545">You cannot implement [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) on an interface.</span></span>  
  
-   <span data-ttu-id="63c59-546">Нельзя объявить параметр типа [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span><span class="sxs-lookup"><span data-stu-id="63c59-546">You cannot declare a parameter to be of type [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx).</span></span>  
  
-   <span data-ttu-id="63c59-547">[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) не может быть типом возвращаемого значения метода, свойства или поля.</span><span class="sxs-lookup"><span data-stu-id="63c59-547">[IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) cannot be the return type of a method, property, or field.</span></span>  
  
-   <span data-ttu-id="63c59-548">Невозможно скрыть вашей [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) реализации из базовых классов с помощью определения метода примерно следующего вида:</span><span class="sxs-lookup"><span data-stu-id="63c59-548">You cannot hide your [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) implementation from base classes by using a method definition such as the following:</span></span>  
  
    ```csharp  
  
    public class NewClass : IStringable  
    {  
       public new string ToString()  
       {  
          return "New ToString in NewClass";  
       }  
    }  
  
    ```  
  
     <span data-ttu-id="63c59-549">Вместо этого [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) реализация должна всегда переопределять реализацию базового класса.</span><span class="sxs-lookup"><span data-stu-id="63c59-549">Instead, the [IStringable.ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation must always override the base class implementation.</span></span> <span data-ttu-id="63c59-550">Реализацию `ToString` можно скрыть только путем вызова этого метода в строго типизированном экземпляре класса.</span><span class="sxs-lookup"><span data-stu-id="63c59-550">You can hide a `ToString` implementation only by invoking it on a strongly typed class instance.</span></span>  
  
 <span data-ttu-id="63c59-551">Обратите внимание, что в различных условиях вызовы из машинного кода в управляемый тип, реализующий [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) или скрывает его [ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) реализация может привести к непредвиденному поведению.</span><span class="sxs-lookup"><span data-stu-id="63c59-551">Note that under a variety of conditions, calls from native code to a managed type that implements [IStringable](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.aspx) or hides its [ToString](http://msdn.microsoft.com/library/windows/apps/windows.foundation.istringable.tostring.aspx) implementation can produce unexpected behavior.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="63c59-552">
            <para>При реализации собственных типов должны переопределять <see cref="M:System.Object.ToString" /> метод для возврата значений, которые важны для этих типов. Производные классы, которые требуется больший контроль над форматированием чем <see cref="M:System.Object.ToString" /> предоставляет можно реализовать <see cref="T:System.IFormattable" /> интерфейса. Его <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> метод позволяет определить строки формата, управляющие форматированием и использовать <see cref="T:System.IFormatProvider" /> объект, способный предоставлять для форматирования с учетом языка и региональных параметров.  Переопределений <see cref="M:System.Object.ToString" /> метод придерживаться следующих правил:-возвращаемой строки должно быть понятным и удобным для чтения человеком.  — Возвращаемая строка должен однозначно определять значение экземпляра объекта.  -Возвращаемой строки должно быть как можно более коротким, чтобы он подходит для отображения с помощью отладчика.  - <see cref="M:System.Object.ToString" /> Переопределения не должен возвращать <see cref="F:System.String.Empty" /> или пустая строка.  - <see cref="M:System.Object.ToString" /> Переопределение не должно создавать исключения.  -Если строковое представление экземпляра является язык и региональные параметры или форматируется различными способами, реализовать <see cref="T:System.IFormattable" /> интерфейса.  -Если возвращаемая строка содержит важные сведения, следует сначала запросить соответствующее разрешение. Если запрос выполнен успешно, можно вернуть конфиденциальной информации; в противном случае следует вернуть строку, которая не содержит конфиденциальные сведения.  - <see cref="M:System.Object.ToString" /> Переопределение должно иметь не наблюдаемый побочных эффектов, чтобы избежать затруднений при отладке. Например, вызов <see cref="M:System.Object.ToString" /> метод не должен изменять значения полей экземпляра.  -Если тип реализует метод синтаксического анализа (или <see langword="Parse" /> или <see langword="TryParse" /> метода, конструктора или некоторые другие статический метод, который создает экземпляр типа из строки), следует убедиться, что строка, возвращаемая функцией <see cref="M:System.Object.ToString" /> метод может быть преобразовать в экземпляр объекта.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="63c59-552">
              <para>When you implement your own types, you should override the <see cref="M:System.Object.ToString" /> method to return values that are meaningful for those types. Derived classes that require more control over formatting than <see cref="M:System.Object.ToString" /> provides can implement the <see cref="T:System.IFormattable" /> interface. Its <see cref="M:System.IFormattable.ToString(System.String,System.IFormatProvider)" /> method enables you to define format strings that control formatting and to use an <see cref="T:System.IFormatProvider" /> object that can provide for culture-specific formatting.  Overrides of the <see cref="M:System.Object.ToString" /> method should follow these guidelines:  -   The returned string should be friendly and readable by humans.  -   The returned string should uniquely identify the value of the object instance.  -   The returned string should be as short as possible so that it is suitable for display by a debugger.  -   Your <see cref="M:System.Object.ToString" /> override should not return <see cref="F:System.String.Empty" /> or a null string.  -   Your <see cref="M:System.Object.ToString" /> override should not throw an exception.  -   If the string representation of an instance is culture-sensitive or can be formatted in multiple ways, implement the <see cref="T:System.IFormattable" /> interface.  -   If the returned string includes sensitive information, you should first demand an appropriate permission. If the demand succeeds, you can return the sensitive information; otherwise, you should return a string that excludes the sensitive information.  -   Your <see cref="M:System.Object.ToString" /> override should have no observable side effects to avoid complications in debugging. For example, a call to the <see cref="M:System.Object.ToString" /> method should not change the value of instance fields.  -   If your type implements a parsing method (or <see langword="Parse" /> or <see langword="TryParse" /> method, a constructor, or some other static method that instantiates an instance of the type from a string), you should ensure that the string returned by the <see cref="M:System.Object.ToString" /> method can be converted to an object instance.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>