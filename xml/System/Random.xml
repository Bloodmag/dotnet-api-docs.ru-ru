<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Random.xml" source-language="en-US" target-language="ru-RU">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-15c36f0" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">02cd5861-7ce2-4a82-b358-31f8435a0ac5601795a307b1570fa0290d626c624db4c949b72e.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">601795a307b1570fa0290d626c624db4c949b72e</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/03/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7,netstandard-1.0,netstandard-1.1,netstandard-1.2,netstandard-1.3,netstandard-1.4,netstandard-1.5,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Random">
          <source>Represents a pseudo-random number generator, which is a device that produces a sequence of numbers that meet certain statistical requirements for randomness.</source>
          <target state="translated">Представляет генератор псевдослучайных чисел, то есть устройство, которое выдает последовательность чисел, отвечающую определенным статистическим критериям случайности.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Pseudo-random numbers are chosen with equal probability from a finite set of numbers.</source>
          <target state="translated">Псевдослучайные числа выбираются с равной вероятностью из конечного набора чисел.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The chosen numbers are not completely random because a mathematical algorithm is used to select them, but they are sufficiently random for practical purposes.</source>
          <target state="translated">Выбранные числа не являются строго случайными, так как математического алгоритма используется для выбора их, но они достаточно случайны практической точки зрения.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The current implementation of the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class is based on a modified version of Donald E. Knuth's subtractive random number generator algorithm.</source>
          <target state="translated">Текущая реализация <ph id="ph1">&lt;xref:System.Random&gt;</ph> класс основан на измененную версию Дональд E. Кнута субтрактивные алгоритма генерации случайных чисел.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For more information, see D. E.</source>
          <target state="translated">Дополнительные сведения см. в разделе E. г.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Knuth.</source>
          <target state="translated">Кнута.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">*</bpt>The Art of Computer Programming, Volume 2: Seminumerical Algorithms<ept id="p1">*</ept>.</source>
          <target state="translated"><bpt id="p1">*</bpt>Искусство программирования, том 2: искусство<ept id="p1">*</ept>.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Addison-Wesley, Reading, MA, third edition, 1997.</source>
          <target state="translated">Третье издание Addison-Wesley, чтение, MA, 1997.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To generate a cryptographically secure random number, such as one that's suitable for creating a random password, use the <ph id="ph1">&lt;xref:System.Security.Cryptography.RNGCryptoServiceProvider&gt;</ph> class or derive a class from <ph id="ph2">&lt;xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Для создания криптографически надежного случайного числа такой, которая подходит для создания случайного пароля используйте <ph id="ph1">&lt;xref:System.Security.Cryptography.RNGCryptoServiceProvider&gt;</ph> класса или являются производными от класса <ph id="ph2">&lt;xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In this topic:</source>
          <target state="translated">В этом разделе.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Instantiating the random number generator<ept id="p1">](#Instantiate)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>При создании экземпляра генератора случайных чисел<ept id="p1">](#Instantiate)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Avoiding multiple instantiations<ept id="p1">](#Multiple)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Предотвращение несколько экземпляров<ept id="p1">](#Multiple)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>The System.Random class and thread safety<ept id="p1">](#ThreadSafety)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Безопасность потока и класс System.Random<ept id="p1">](#ThreadSafety)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Generating different types of random numbers<ept id="p1">](#Functionality)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Создание разных типов случайных чисел<ept id="p1">](#Functionality)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Substituting your own algorithm<ept id="p1">](#Overriding)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Подстановка собственный алгоритм<ept id="p1">](#Overriding)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>How do you use System.Random to…<ept id="p1">](#Operations)</ept><ph id="ph1"> </ph></source>
          <target state="translated"><bpt id="p1">[</bpt>Как использовать System.Random для...<ept id="p1">](#Operations)</ept><ph id="ph1"> </ph></target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve the same sequence of random values<ept id="p1">](#Same)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Получить одну и ту же последовательность случайных значений<ept id="p1">](#Same)</ept></target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve unique sequences of random values<ept id="p1">](#Unique)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Получить уникальных последовательностей случайных значений<ept id="p1">](#Unique)</ept></target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve integers in a specified range<ept id="p1">](#Range)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Получить целых чисел в указанном диапазоне<ept id="p1">](#Range)</ept></target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve integers with a specified number of digits<ept id="p1">](#Digits)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Получить целых чисел с указанным числом знаков<ept id="p1">](#Digits)</ept></target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve floating-point values in a specified range<ept id="p1">](#Floats)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Получение значения с плавающей запятой в указанном диапазоне<ept id="p1">](#Floats)</ept></target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Generate random Boolean values<ept id="p1">](#Boolean)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Создание случайного логическими значениями<ept id="p1">](#Boolean)</ept></target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Generate random 64-bit integers<ept id="p1">](#Long)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Создание случайных 64-разрядных целых чисел.<ept id="p1">](#Long)</ept></target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve bytes in a specified range<ept id="p1">](#Bytes)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Получение байт в указанном диапазоне<ept id="p1">](#Bytes)</ept></target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve an element from an array or collection at random<ept id="p1">](#Array)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Получить элемент из массива или коллекции случайным образом<ept id="p1">](#Array)</ept></target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source><bpt id="p1">[</bpt>Retrieve a unique element from an array or collection<ept id="p1">](#UniqueArray)</ept></source>
          <target state="translated"><bpt id="p1">[</bpt>Получить уникальный элемент из массива или коллекции<ept id="p1">](#UniqueArray)</ept></target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Instantiating the random number generator</source>
          <target state="translated">При создании экземпляра генератора случайных чисел</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You instantiate the random number generator by providing a seed value (a starting value for the pseudo-random number generation algorithm) to a <ph id="ph1">&lt;xref:System.Random.%23ctor%2A&gt;</ph> class constructor.</source>
          <target state="translated">Создать экземпляр генератора случайных чисел, предоставляя начальное значение (начальное значение для алгоритм генерации псевдослучайных чисел) для <ph id="ph1">&lt;xref:System.Random.%23ctor%2A&gt;</ph> конструктора класса.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can supply the seed value either explicitly or implicitly:</source>
          <target state="translated">Можно указать начальное значение, явно или неявно:</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor uses an explicit seed value that you supply.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> Конструктор использует явную начальное значение, указываемое.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph> constructor uses the system clock to provide a seed value.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph> Конструктор использует системные часы для обеспечения начального значения.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This is the most common way of instantiating the random number generator.</source>
          <target state="translated">Это наиболее распространенным способом создания экземпляра генератора случайных чисел.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If the same seed is used for separate <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects, they will generate the same series of random numbers.</source>
          <target state="translated">Если же начальное значение используется для разных <ph id="ph1">&lt;xref:System.Random&gt;</ph> объекты, они получат та же последовательность случайных чисел.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This can be useful for creating a test suite that processes random values, or for replaying games that derive their data from random numbers.</source>
          <target state="translated">Это может быть полезно для создания набора тестов, который обрабатывает случайные значения или воспроизведения игры, которые являются производными свои данные от случайных чисел.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, note that <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects in processes running under different versions of the .NET Framework may return different series of random numbers even if they're instantiated with identical seed values.</source>
          <target state="translated">Тем не менее, обратите внимание, что <ph id="ph1">&lt;xref:System.Random&gt;</ph> объекты в процессах, под управлением различных версий платформы .NET Framework могут возвращать разные наборы случайных чисел, даже если они могут быть экземпляр которого создается без одинаковые начальные значения.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To produce different sequences of random numbers, you can make the seed value time-dependent, thereby producing a different series with each new instance of <ph id="ph1">&lt;xref:System.Random&gt;</ph>.</source>
          <target state="translated">Для получения различных последовательностей случайных чисел, можно сделать начального значения зависят от времени, что позволяет создавать различные последовательности для каждого нового экземпляра <ph id="ph1">&lt;xref:System.Random&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The parameterized <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor can take an <ph id="ph2">&lt;xref:System.Int32&gt;</ph> value based on the number of ticks in the current time, whereas the parameterless <ph id="ph3">&lt;xref:System.Random.%23ctor&gt;</ph> constructor uses the system clock to generate its seed value.</source>
          <target state="translated">Параметризованные <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> конструктор может занять <ph id="ph2">&lt;xref:System.Int32&gt;</ph> значение на основе количества тактов в текущее время, в то время как без параметров <ph id="ph3">&lt;xref:System.Random.%23ctor&gt;</ph> конструктор использует системные часы для формирования начального значения.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, because the clock has finite resolution, using the parameterless constructor to create different <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects in close succession creates random number generators that produce identical sequences of random numbers.</source>
          <target state="translated">Тем не менее, поскольку часы конечное решение, с помощью конструктора без параметров для создания различных <ph id="ph1">&lt;xref:System.Random&gt;</ph> объекты в закрытой последовательности создаются генераторы случайных чисел, производящих идентичные последовательности случайных чисел.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example illustrates how two <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects that are instantiated in close succession generate an identical series of random numbers.</source>
          <target state="translated">В следующем примере показано как два <ph id="ph1">&lt;xref:System.Random&gt;</ph> объекты, экземпляры которых создаются в быстрой последовательности, создают идентичные наборы случайных чисел.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>On most Windows systems, <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects created within 15 milliseconds of one another are likely to have identical seed values.</source>
          <target state="translated">В большинстве операционных систем <ph id="ph1">&lt;xref:System.Random&gt;</ph> объекты, созданные в течение 15 миллисекунд друг от друга, скорее всего, имеют одинаковые начальные значения.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To avoid this problem, create a single <ph id="ph1">&lt;xref:System.Random&gt;</ph> object instead of multiple objects.</source>
          <target state="translated">Чтобы избежать этой проблемы, создайте один <ph id="ph1">&lt;xref:System.Random&gt;</ph> объекта вместо нескольких объектов.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Avoiding multiple instantiations</source>
          <target state="translated">Предотвращение несколько экземпляров</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Initializing two random number generators in a tight loop or in rapid succession creates two random number generators that can produce identical sequences of random numbers.</source>
          <target state="translated">Инициализация двух генераторов случайных чисел в непрерывном цикле или в течение короткого промежутка времени создает два генераторы случайных чисел, можно производить идентичные последовательности случайных чисел.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In most cases, this is not the developer's intent and can lead to performance issues, because instantiating and initializing a random number generator is a relatively expensive process.</source>
          <target state="translated">В большинстве случаев это не намерения разработчика и может привести к проблем с производительностью, поскольку создание и инициализация генератора случайных чисел является процессом относительно требовательными к ресурсам.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Both to improve performance and to avoid inadvertently creating separate random number generators that generate identical numeric sequences, we recommend that you create one <ph id="ph1">&lt;xref:System.Random&gt;</ph> object to generate many random numbers over time, instead of creating new <ph id="ph2">&lt;xref:System.Random&gt;</ph> objects to generate one random number.</source>
          <target state="translated">Для повышения производительности и избежать случайного создания отдельных генераторы случайных чисел, формирующих идентичные числовой последовательности, рекомендуется создать один <ph id="ph1">&lt;xref:System.Random&gt;</ph> объект для генерации множества случайных чисел с течением времени, вместо создания новый <ph id="ph2">&lt;xref:System.Random&gt;</ph> объекты для каждого случайного числа.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class isn't thread safe.</source>
          <target state="translated">Однако <ph id="ph1">&lt;xref:System.Random&gt;</ph> класса не потокобезопасным.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If you call <ph id="ph1">&lt;xref:System.Random&gt;</ph> methods from multiple threads, follow the guidelines discussed in the next section.</source>
          <target state="translated">При вызове метода <ph id="ph1">&lt;xref:System.Random&gt;</ph> методы из различных потоков, следуйте рекомендациям, изложенным в следующем разделе.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The System.Random class and thread safety</source>
          <target state="translated">Безопасность потока и класс System.Random</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Instead of instantiating individual <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects, we recommend that you create a single <ph id="ph2">&lt;xref:System.Random&gt;</ph> instance to generate all the random numbers needed by your app.</source>
          <target state="translated">Вместо создания экземпляров отдельных <ph id="ph1">&lt;xref:System.Random&gt;</ph> объектов, рекомендуется создавать отдельный <ph id="ph2">&lt;xref:System.Random&gt;</ph> экземпляра для генерации случайных чисел, необходимых вашему приложению.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects are not thread safe.</source>
          <target state="translated">Тем не менее <ph id="ph1">&lt;xref:System.Random&gt;</ph> объекты не являются потокобезопасными.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If your app calls <ph id="ph1">&lt;xref:System.Random&gt;</ph> methods from multiple threads, you must use a synchronization object to ensure that only one thread can access the random number generator at a time.</source>
          <target state="translated">Если приложение вызывает <ph id="ph1">&lt;xref:System.Random&gt;</ph> методы из нескольких потоков, необходимо использовать объект синхронизации, только один поток может получить доступ к генератора случайных чисел одновременно.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If you don't ensure that the <ph id="ph1">&lt;xref:System.Random&gt;</ph> object is accessed in a thread-safe way, calls to methods that return random numbers return 0.</source>
          <target state="translated">Если вы не убедитесь, что <ph id="ph1">&lt;xref:System.Random&gt;</ph> получить доступ к объекту в потокобезопасным способом, вызовы методов, которые возвращают случайных чисел возвращает значение 0.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example uses the C# <bpt id="p1">[</bpt>lock Statement<ept id="p1">](~/docs/csharp/language-reference/keywords/lock-statement.md)</ept> and the Visual Basic <bpt id="p2">[</bpt>SyncLock statement<ept id="p2">](~/docs/visual-basic/language-reference/statements/synclock-statement.md)</ept> to ensure that a single random number generator is accessed by 11 threads in a thread-safe manner.</source>
          <target state="translated">В следующем примере C# <bpt id="p1">[</bpt>оператор lock<ept id="p1">](~/docs/csharp/language-reference/keywords/lock-statement.md)</ept> и Visual Basic <bpt id="p2">[</bpt>оператор SyncLock<ept id="p2">](~/docs/visual-basic/language-reference/statements/synclock-statement.md)</ept> чтобы убедиться, что один генератора случайных чисел, осуществляется с 11 потоков в потокобезопасным способом.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Each thread generates 2 million random numbers, counts the number of random numbers generated and calculates their sum, and then updates the totals for all threads when it finishes executing.</source>
          <target state="translated">Каждый поток создает случайные числа 2 миллиона подсчитывает число случайных чисел и вычисляет их суммы и затем обновляет итоги для всех потоков после завершения выполнения.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The example ensures thread-safety in the following ways:</source>
          <target state="translated">В примере проверяется потокобезопасности одним из следующих способов:</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute is used to define thread-local variables that track the total number of random numbers generated and their sum for each thread.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> Атрибут используется для определения локальных для потока переменные, которые отслеживают общее число случайных чисел и их сумма для каждого потока.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A lock (the <ph id="ph1">`lock`</ph> statement in C# and the <ph id="ph2">`SyncLock`</ph> statement in Visual Basic) protects access to the variables for the total count and sum of all random numbers generated on all threads.</source>
          <target state="translated">Блокировка ( <ph id="ph1">`lock`</ph> инструкции на языке C# и <ph id="ph2">`SyncLock`</ph> инструкции на языке Visual Basic) защищает доступ к переменным, общее количество и сумма всех случайных чисел, созданные во всех потоках.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A semaphore (the <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> object) is used to ensure that the main thread blocks until all other threads complete execution.</source>
          <target state="translated">Семафор ( <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> объекта) позволяет убедиться, что основной поток блокируется до всех остальных потоков завершения выполнения.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The example checks whether the random number generator has become corrupted by determining whether two consecutive calls to random number generation methods return 0.</source>
          <target state="translated">В примере проверяется, является ли генератора случайных чисел поврежден, определяя ли два последовательных вызовов случайных чисел поколения методы возвращают значение 0.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If corruption is detected, the example uses the <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> object to signal that all threads should be canceled.</source>
          <target state="translated">Если обнаружено повреждение в примере используется <ph id="ph1">&lt;xref:System.Threading.CancellationTokenSource&gt;</ph> объект указывают, что все потоки должна быть отменена.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Before generating each random number, each thread checks the state of the <ph id="ph1">&lt;xref:System.Threading.CancellationToken&gt;</ph> object.</source>
          <target state="translated">Перед созданием каждой случайное число, каждый поток для проверки состояния <ph id="ph1">&lt;xref:System.Threading.CancellationToken&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If cancellation is requested, the example calls the <ph id="ph1">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> method to cancel the thread.</source>
          <target state="translated">Если запрос на отмену в примере вызывается <ph id="ph1">&lt;xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType&gt;</ph> метода для отмены потока.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example is identical to the first, except that it uses a <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> object and a lambda expression instead of <ph id="ph2">&lt;xref:System.Threading.Thread&gt;</ph> objects.</source>
          <target state="translated">Следующий пример идентичен первому, за исключением того, что он использует <ph id="ph1">&lt;xref:System.Threading.Tasks.Task&gt;</ph> объекта и лямбда-выражение, а не <ph id="ph2">&lt;xref:System.Threading.Thread&gt;</ph> объектов.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>It differs from the first example in the following ways:</source>
          <target state="translated">Она отличается от первого примера, одним из следующих способов:</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The variables to keep track of the number of random numbers generated and their sum in each task are local to the task, so there is no need to use the <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> attribute.</source>
          <target state="translated">Переменные для отслеживания количества случайных чисел и их сумму в каждой задаче локальны для задачи, поэтому нет необходимости использовать <ph id="ph1">&lt;xref:System.ThreadStaticAttribute&gt;</ph> атрибута.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The static <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> method is used to ensure that the main thread doesn't complete before all tasks have finished.</source>
          <target state="translated">Статический <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> метод используется, чтобы убедиться, что основной поток не завершилось до завершения всех задач.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>There is no need for the <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> object.</source>
          <target state="translated">Нет необходимости для <ph id="ph1">&lt;xref:System.Threading.CountdownEvent&gt;</ph> объекта.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The exception that results from task cancellation is surfaced in the <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Исключение, полученное в результате отмены задачи будет отображена в <ph id="ph1">&lt;xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In the previous example, it is handled by each thread.</source>
          <target state="translated">В предыдущем примере он обрабатывается каждым потоком.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Generating different types of random numbers</source>
          <target state="translated">Создание разных типов случайных чисел</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The random number generator provides methods that let you generate the following kinds of random numbers:</source>
          <target state="translated">Генератор случайных чисел предоставляет методы, которые позволяют создавать следующие виды случайных чисел:</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A series of <ph id="ph1">&lt;xref:System.Byte&gt;</ph> values.</source>
          <target state="translated">Ряд <ph id="ph1">&lt;xref:System.Byte&gt;</ph> значения.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You determine the number of byte values by passing an array initialized to the number of elements you want the method to return to the <ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph> method.</source>
          <target state="translated">Определить количество байт, передавая массив присваивается количество элементов, метод для возврата <ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example generates 20 bytes.</source>
          <target state="translated">Следующий пример приводит к возникновению ошибки 20 байт.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A single integer.</source>
          <target state="translated">Целое число.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can choose whether you want an integer from 0 to a maximum value (<ph id="ph1">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> – 1) by calling the <ph id="ph2">&lt;xref:System.Random.Next&gt;</ph> method, an integer between 0 and a specific value by calling the <ph id="ph3">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> method, or an integer within a range of values by calling the <ph id="ph4">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method.</source>
          <target state="translated">Можно выбрать, следует ли целое число от 0 до максимального значения (<ph id="ph1">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph> – 1) путем вызова <ph id="ph2">&lt;xref:System.Random.Next&gt;</ph> метод, целое число от 0 до конкретного значения путем вызова <ph id="ph3">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> метода или целое число в пределах диапазона значений путем вызова <ph id="ph4">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph>метод.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In the parameterized overloads, the specified maximum value is exclusive; that is, the actual maximum number generated is one less than the specified value.</source>
          <target state="translated">В параметризованных перегрузки указанным максимальным значением является исчерпывающим; Максимальное число созданных является один меньше, чем указанное значение.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method to generate 10 random numbers between -10 and 10.</source>
          <target state="translated">В следующем примере вызывается <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> метод, чтобы создать 10 случайных чисел от -10 до 10.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Note that the second argument to the method specifies the exclusive upper bound of the range of random values returned by the method.</source>
          <target state="translated">Обратите внимание, что второй аргумент метода задает эксклюзивную верхнюю границу диапазона случайных значений, возвращаемая этим методом.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In other words, the largest integer that the method can return is one less than this value.</source>
          <target state="translated">Другими словами наибольшее целое число, которое этот метод может возвращать одно — меньше, чем это значение.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A single floating-point value from 0.0 to less than 1.0 by calling the <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method.</source>
          <target state="translated">Одного значения с плавающей запятой от 0,0 в меньше 1,0 путем вызова <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The exclusive upper bound of the random number returned by the method is 1, so its actual upper bound is 0.99999999999999978.</source>
          <target state="translated">Эксклюзивную верхнюю границу случайное число, возвращенное методом-1, поэтому его фактическое верхняя граница — 0.99999999999999978.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example generates 10 random floating-point numbers.</source>
          <target state="translated">Следующий пример приводит к возникновению ошибки 10 случайных чисел с плавающей запятой.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method allows you to specify the range of the returned random number.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> Метод позволяет указать диапазон возвращаемого случайного числа.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, the <ph id="ph1">`maxValue`</ph> parameter, which specifies the upper range returned number, is an exclusive, not an inclusive, value.</source>
          <target state="translated">Однако <ph id="ph1">`maxValue`</ph> параметр, который задает верхний предел возвращаемое число является монопольной, не включительно, значение.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This means that the method call <ph id="ph1">`Next(0, 100)`</ph> returns a value between 0 and 99, and not between 0 and 100.</source>
          <target state="translated">Это означает, что вызов метода <ph id="ph1">`Next(0, 100)`</ph> возвращает значение от 0 до 99, а не в диапазоне от 0 до 100.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can also use the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class for such tasks as generating <bpt id="p1">[</bpt>random T:System.Boolean values<ept id="p1">](#Boolean)</ept>, generating <bpt id="p2">[</bpt>random floating point values with a range other than 0 to 1<ept id="p2">](#Floats)</ept>, generating <bpt id="p3">[</bpt>random 64-bit integers<ept id="p3">](#Long)</ept>, and <bpt id="p4">[</bpt>randomly retrieving a unique element from an array or collection<ept id="p4">](#UniqueArray)</ept>.</source>
          <target state="translated">Можно также использовать <ph id="ph1">&lt;xref:System.Random&gt;</ph> класс для таких задач, как создание <bpt id="p1">[</bpt>случайных значений T:System.Boolean<ept id="p1">](#Boolean)</ept>, создающий <bpt id="p2">[</bpt>значения случайных чисел с плавающей запятой в диапазоне, отличного от 0 до 1<ept id="p2">](#Floats)</ept>, создания <bpt id="p3">[</bpt>случайных 64-битовых целых чисел<ept id="p3">](#Long)</ept>, и <bpt id="p4">[</bpt>случайным образом получение уникального элемента из массива или коллекции<ept id="p4">](#UniqueArray)</ept>.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For these and other common tasks, see the <bpt id="p1">[</bpt>How do you use System.Random to…<ept id="p1">](#Operations)</ept></source>
          <target state="translated">Для этих и других общих задач в разделе <bpt id="p1">[</bpt>использование System.Random для...<ept id="p1">](#Operations)</ept></target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>section.</source>
          <target state="translated">раздел.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Substituting your own algorithm</source>
          <target state="translated">Подстановка собственный алгоритм</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can implement your own random number generator by inheriting from the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class and supplying your random number generation algorithm.</source>
          <target state="translated">Можно реализовать путем наследования от случайного числа <ph id="ph1">&lt;xref:System.Random&gt;</ph> класса и предоставление вашей алгоритм генерации случайных чисел.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To supply your own algorithm, you must override the <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> method, which implements the random number generation algorithm.</source>
          <target state="translated">Чтобы реализовать собственный алгоритм, необходимо переопределить <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> метод, который реализует алгоритм генерации случайных чисел.</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You should also override the <ph id="ph1">&lt;xref:System.Random.Next&gt;</ph>, <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph>, and <ph id="ph3">&lt;xref:System.Random.NextBytes%2A&gt;</ph> methods to ensure that they call your overridden <ph id="ph4">&lt;xref:System.Random.Sample%2A&gt;</ph> method.</source>
          <target state="translated">Следует также переопределить <ph id="ph1">&lt;xref:System.Random.Next&gt;</ph>, <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph>, и <ph id="ph3">&lt;xref:System.Random.NextBytes%2A&gt;</ph> методов, чтобы гарантировать, что они вызывают переопределенном <ph id="ph4">&lt;xref:System.Random.Sample%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You don't have to override the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> and <ph id="ph2">&lt;xref:System.Random.NextDouble%2A&gt;</ph> methods.</source>
          <target state="translated">Не требуется переопределять <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> и <ph id="ph2">&lt;xref:System.Random.NextDouble%2A&gt;</ph> методы.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For an example that derives from the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class and modifies its default pseudo-random number generator, see the <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> reference page.</source>
          <target state="translated">Например, который является производным от <ph id="ph1">&lt;xref:System.Random&gt;</ph> класса и изменяет его по умолчанию генератор псевдослучайных чисел, в разделе <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> справочной странице.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>How do you use System.Random to…</source>
          <target state="translated">Как использовать System.Random для...</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following sections discuss and provide sample code for some of the ways you might want to use random numbers in your app.</source>
          <target state="translated">В следующих разделах рассматриваются и обсуждаются образцы кода для некоторые способы использования случайных чисел в приложении может потребоваться.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve the same sequence of random values</source>
          <target state="translated">Получить одну и ту же последовательность случайных значений</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Sometimes you want to generate the same sequence of random numbers in software test scenarios and in game playing.</source>
          <target state="translated">Иногда требуется получать одинаковые последовательности случайных чисел, в сценариях тестирования программного обеспечения, а также в игры.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Testing with the same sequence of random numbers allows you to detect regressions and confirm bug fixes.</source>
          <target state="translated">Тестирование с помощью того же последовательность случайных чисел дает возможность обнаружения регрессий и подтвердите исправления ошибок.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Using the same sequence of random number in games allows you to replay previous games.</source>
          <target state="translated">С помощью той же последовательности случайное число в играх позволяет воспроизводить предыдущих игры.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can generate the same sequence of random numbers by providing the same seed value to the <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">Можно создать одну и ту же последовательность случайных чисел, указав то же начальное значение для <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The seed value provides a starting value for the pseudo-random number generation algorithm.</source>
          <target state="translated">Начальное значение обеспечивает начальное значение для алгоритм генерации псевдослучайных чисел.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example uses 100100 as an arbitrary seed value to instantiate the <ph id="ph1">&lt;xref:System.Random&gt;</ph> object, displays 20 random floating-point values, and persists the seed value.</source>
          <target state="translated">В следующем примере используется 100100 как произвольный начальное значение для создания экземпляра <ph id="ph1">&lt;xref:System.Random&gt;</ph> объекта, отображает 20 случайных значений с плавающей запятой и сохраняет начального значения.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>It then restores the seed value, instantiates a new random number generator, and displays the same 20 random floating-point values.</source>
          <target state="translated">Затем он восстанавливает начальное значение, создает новый генератор случайных чисел и отображает одинаковые значения 20 случайных чисел с плавающей запятой.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Note that the example may produce different sequences of random numbers if run on different versions of the .NET Framework.</source>
          <target state="translated">Обратите внимание, что пример может давать различные последовательности случайных чисел при запуске в разных версиях платформы .NET Framework.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve unique sequences of random numbers</source>
          <target state="translated">Получить уникальный последовательность случайных чисел</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Providing different seed values to instances of the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class causes each random number generator to produce a different sequence of values.</source>
          <target state="translated">Предоставление различных начальных значений для экземпляров <ph id="ph1">&lt;xref:System.Random&gt;</ph> классу вызывает каждый генератора случайных чисел для создания различных последовательности значений.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can provide a seed value either explicitly by calling the <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor, or implicitly by calling the <ph id="ph2">&lt;xref:System.Random.%23ctor&gt;</ph> constructor.</source>
          <target state="translated">Укажите начальное значение явно с помощью вызова методов <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> конструктор, или неявно путем вызова <ph id="ph2">&lt;xref:System.Random.%23ctor&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Most developers call the parameterless constructor, which uses the system clock.</source>
          <target state="translated">Большинство разработчиков вызвать конструктор без параметров, который использует системные часы.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example uses this approach to instantiate two <ph id="ph1">&lt;xref:System.Random&gt;</ph> instances.</source>
          <target state="translated">В следующем примере этот подход используется для создания двух <ph id="ph1">&lt;xref:System.Random&gt;</ph> экземпляров.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Each instance displays a series of 10 random integers.</source>
          <target state="translated">Каждый экземпляр выводит ряд 10 случайных целых чисел.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, because of its finite resolution, the system clock doesn't detect time differences that are less than approximately 15 milliseconds.</source>
          <target state="translated">Тем не менее из-за его конечное разрешения системных часов не может обнаружить разницу во времени, являющиеся приблизительно не превышает 15 миллисекунд.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Therefore, if your code calls the <ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph> overload to instantiate two <ph id="ph2">&lt;xref:System.Random&gt;</ph> objects in succession, you might inadvertently be providing the objects with identical seed values.</source>
          <target state="translated">Таким образом Если код вызывает <ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph> перегрузку, чтобы создать два <ph id="ph2">&lt;xref:System.Random&gt;</ph> объектов подряд, вы может случайно предоставлять объекты с одинаковые начальные значения.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To see this in the previous example, comment out the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method call, and compile and run the example again.</source>
          <target state="translated">Чтобы увидеть это в предыдущем примере, закомментируйте <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> вызова метода и компиляции и снова запустите пример.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To prevent this from happening, we recommend that you instantiate a single <ph id="ph1">&lt;xref:System.Random&gt;</ph> object rather than multiple ones.</source>
          <target state="translated">Чтобы предотвратить возникновение этой ситуации, рекомендуется создать один экземпляр <ph id="ph1">&lt;xref:System.Random&gt;</ph> объекта, а не несколько сеансов.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, since <ph id="ph1">&lt;xref:System.Random&gt;</ph> isn't thread safe, you must use some synchronization device if you access a <ph id="ph2">&lt;xref:System.Random&gt;</ph> instance from multiple threads; for more information, see <bpt id="p1">[</bpt>The Random class and thread safety<ept id="p1">](#ThreadSafety)</ept> earlier in this topic.</source>
          <target state="translated">Однако, поскольку <ph id="ph1">&lt;xref:System.Random&gt;</ph> не потокобезопасным, некоторые синхронизации устройства необходимо использовать при доступе к <ph id="ph2">&lt;xref:System.Random&gt;</ph> из нескольких потоков; Дополнительные сведения см. в разделе <bpt id="p1">[</bpt>случайных безопасности потока и класс<ept id="p1">](#ThreadSafety)</ept> ранее в этом раздел.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Alternately, you can use a delay mechanism, such as the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> method used in the previous example, to ensure that the instantiations occur more than 15 millisecond apart.</source>
          <target state="translated">Кроме того, можно использовать механизм задержки, такие как <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A&gt;</ph> метод, используемый в предыдущем примере, чтобы избежать возникновения экземпляров превышает 15 миллисекунд друг от друга.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve integers in a specified range</source>
          <target state="translated">Получить целых чисел в указанном диапазоне</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can retrieve integers in a specified range by calling the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method, which lets you specify both the lower and the upper bound of the numbers you'd like the random number generator to return.</source>
          <target state="translated">Целые числа в указанном диапазоне можно получить, вызвав <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> метод, который позволяет задавать нижнюю и верхнюю границу номера хотелось бы генератора случайных чисел для возврата.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The upper bound is an exclusive, not an inclusive, value.</source>
          <target state="translated">Верхняя граница — монопольный, не включительно, значение.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>That is, it isn't included in the range of values returned by the method.</source>
          <target state="translated">То есть он не включен в диапазон значений, возвращаемая этим методом.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example uses this method to generate random integers between -10 and 10.</source>
          <target state="translated">В следующем примере этот метод используется для формирования случайных целых чисел в диапазоне от -10 до 10.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Note that it specifies 11, which is one greater than the desired value, as the value of the <ph id="ph1">`maxValue`</ph> argument in the method call.</source>
          <target state="translated">Обратите внимание, что он указывает 11, равное одному больше нужное значение в качестве значения для <ph id="ph1">`maxValue`</ph> аргумента в вызове метода.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve integers with a specified number of digits</source>
          <target state="translated">Получить целых чисел с указанным числом знаков</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can call the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method to retrieve numbers with a specified number of digits.</source>
          <target state="translated">Можно вызвать <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> метод для извлечения значений и цифр с указанного количества десятичных разрядов.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For example, to retrieve numbers with four digits (that is, numbers that range from 1000 to 9999), you call the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method with a <ph id="ph2">`minValue`</ph> value of 1000 and a <ph id="ph3">`maxValue`</ph> value of 10000, as the following example shows.</source>
          <target state="translated">Например, для получения цифры с четырьмя знаками (номера, в диапазоне от 1000 до 9999), следует вызвать <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> метод с <ph id="ph2">`minValue`</ph> значение 1000 и <ph id="ph3">`maxValue`</ph> значение 10000, как показано в следующем примере.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve floating-point values in a specified range</source>
          <target state="translated">Получение значения с плавающей запятой в указанном диапазоне</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method returns random floating-point values that range from 0 to less than 1.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> Метод возвращает случайных значений с плавающей запятой, диапазон от 0 до меньше 1.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, you'll often want to generate random values in some other range.</source>
          <target state="translated">Тем не менее часто необходимо создавать случайные значения в другого диапазона ячеек.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If the interval between the minimum and maximum desired values is 1, you can add the difference between the desired starting interval and 0 to the number returned by the <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method.</source>
          <target state="translated">Если интервал между минимальным и максимальным нужные значения 1, можно добавить к значению, возвращенному методом разницу между начальной необходимый интервал и 0 <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example does this to generate 10 random numbers between -1 and 0.</source>
          <target state="translated">В следующем примере выполняется этот параметр, чтобы создать 10 случайных чисел от -1 до 0.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To generate random floating-point numbers whose lower bound is 0 but upper bound is greater than 1 (or, in the case of negative numbers, whose lower bound is less than -1 and upper bound is 0), multiply the random number by the non-zero bound.</source>
          <target state="translated">Для генерации случайных чисел с плавающей запятой, нижняя граница — 0, но верхняя граница — больше, чем 1 (или, в случае отрицательных чисел, нижняя граница диапазона — меньше -1 и верхняя граница — 0), умножьте случайное число ненулевой границей.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example does this to generate 20 million random floating-point numbers that range from 0 to <ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">В следующем примере выполняется это для генерации случайных чисел с плавающей запятой 20 миллионов этого диапазона от 0 до <ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In also displays the distribution of the random values generated by the method.</source>
          <target state="translated">В также отображает распределение, случайных значений, созданной методом.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To generate random floating-point numbers between two arbitrary values, like the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method does for integers, use the following formula:</source>
          <target state="translated">Для генерации случайных чисел с плавающей запятой двух произвольных значений, таких как <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> метод не для целых чисел, используйте следующую формулу:</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example generates 1 million random numbers that range from 10.0 to 11.0, and displays their distribution.</source>
          <target state="translated">Следующий пример приводит к возникновению ошибки 1 миллион случайных чисел, начиная с версии 10.0 для 11.0 и отображает их распространения.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Generate random Boolean values</source>
          <target state="translated">Создание случайного логическими значениями</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Random&gt;</ph> class doesn't provide methods that generate <ph id="ph2">&lt;xref:System.Boolean&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random&gt;</ph> Класс не предоставляет методы, которые создают <ph id="ph2">&lt;xref:System.Boolean&gt;</ph> значения.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, you can define your own class or method to do that.</source>
          <target state="translated">Тем не менее можно определить собственный класс или метод для этого.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example defines a class, <ph id="ph1">`BooleanGenerator`</ph>, with a single method, <ph id="ph2">`NextBoolean`</ph>.</source>
          <target state="translated">В следующем примере определяется класс, <ph id="ph1">`BooleanGenerator`</ph>, с одним методом <ph id="ph2">`NextBoolean`</ph>.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">`BooleanGenerator`</ph> class stores a <ph id="ph2">&lt;xref:System.Random&gt;</ph> object as a private variable.</source>
          <target state="translated"><ph id="ph1">`BooleanGenerator`</ph> Класса хранилищ <ph id="ph2">&lt;xref:System.Random&gt;</ph> объект в качестве частной переменной.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">`NextBoolean`</ph> method calls the <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method and passes the result to the <ph id="ph3">&lt;xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">`NextBoolean`</ph> Вызовы метода <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> метод и передает результат в <ph id="ph3">&lt;xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Note that 2 is used as the argument to specify the upper bound of the random number.</source>
          <target state="translated">Обратите внимание, что 2 используется в качестве аргумента для указания верхней границы случайного числа.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Since this is an exclusive value, the method call returns either 0 or 1.</source>
          <target state="translated">Так как это значение монопольный, этот метод возвращает значение 0 или 1.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Instead of creating a separate class to generate random <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> values, the example could simply have defined a single method.</source>
          <target state="translated">Вместо того чтобы создавать отдельный класс для создания случайных <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> просто определенные значения в примере один метод.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In that case, however, the <ph id="ph1">&lt;xref:System.Random&gt;</ph> object should have been defined as a class-level variable to avoid instantiating a new <ph id="ph2">&lt;xref:System.Random&gt;</ph> instance in each method call.</source>
          <target state="translated">В этом случае, однако <ph id="ph1">&lt;xref:System.Random&gt;</ph> объект должен был определен как переменной уровня класса, чтобы избежать создания нового <ph id="ph2">&lt;xref:System.Random&gt;</ph> экземпляра в каждом вызове метода.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In Visual Basic, the Random instance can be defined as a <bpt id="p1">[</bpt>Static<ept id="p1">](~/docs/visual-basic/language-reference/modifiers/static.md)</ept> variable in the <ph id="ph1">`NextBoolean`</ph> method.</source>
          <target state="translated">В Visual Basic экземпляра Random может определяться как <bpt id="p1">[</bpt>статических<ept id="p1">](~/docs/visual-basic/language-reference/modifiers/static.md)</ept> переменных в <ph id="ph1">`NextBoolean`</ph> метод.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example provides an implementation.</source>
          <target state="translated">Следующий пример предоставляет реализацию.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Generate random 64-bit integers</source>
          <target state="translated">Создание случайных 64-разрядных целых чисел.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method return 32-bit integers.</source>
          <target state="translated">Перегруженные версии <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> метод возвращает 32-разрядных целых чисел.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>However, in some cases, you might want to work with 64-bit integers.</source>
          <target state="translated">Однако в некоторых случаях может потребоваться для работы с 64-разрядных целых чисел.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>You can do this as follows:</source>
          <target state="translated">Это можно сделать следующим образом:</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Call the <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method to retrieve a double-precision floating point value.</source>
          <target state="translated">Вызовите <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> метод для извлечения двойной точности с плавающей запятой.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Multiply that value by <ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Умножьте это значение с <ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example uses this technique to generate 20 million random long integers and categorizes them in 10 equal groups.</source>
          <target state="translated">В следующем примере использует этот метод для создания 20 миллионов случайных длинных целых чисел и распределяет их в 10 равные группы.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>It then evaluates the distribution of the random numbers by counting the number in each group from 0 to <ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Затем вычисляет распределение, случайных чисел, сосчитав число в каждой группе от 0 до <ph id="ph1">&lt;xref:System.Int64.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>As the output from the example shows, the numbers are distributed more or less equally through the range of a long integer.</source>
          <target state="translated">Как показывают выходные данные примера, номера распространяются более или менее равномерно по диапазон типа данных long integer.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>An alternative technique that uses bit manipulation does not generate truly random numbers.</source>
          <target state="translated">Альтернативный метод, что использует поразрядные не создает действительно случайные числа.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This technique calls <ph id="ph1">&lt;xref:System.Random.Next&gt;</ph> to generate two integers, left-shifts one by 32 bits, and ORs them together.</source>
          <target state="translated">Этот метод вызывает <ph id="ph1">&lt;xref:System.Random.Next&gt;</ph> для создания двух целых чисел, один по 32 сдвигает влево биты и схему или их вместе.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This technique has two limitations:</source>
          <target state="translated">Такой подход имеет два ограничения.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Because bit 31 is the sign bit, the value in bit 31 of the resulting long integer is always 0.</source>
          <target state="translated">Поскольку бит 31 бита знака, значение в бит 31 полученное значение типа long integer всегда равно 0.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>This can be addressed by generating a random 0 or 1, left-shifting it 31 bits, and ORing it with the original random long integer.</source>
          <target state="translated">Это можно устранить путем формирования случайных 0 или 1, влево сдвигая 31 бита и настройке его с исходной случайных длинное целое число.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>More seriously, because the probability that the value returned by <ph id="ph1">&lt;xref:System.Random.Next&gt;</ph> will be 0, there will be few if any random numbers in the range 0x0-0x00000000FFFFFFFF.</source>
          <target state="translated">Если серьезно поскольку вероятность того, что значение, возвращаемое <ph id="ph1">&lt;xref:System.Random.Next&gt;</ph> будет иметь значение 0, будет небольшим количеством случайных чисел в диапазоне от 0x0 0x00000000FFFFFFFF.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve bytes in a specified range</source>
          <target state="translated">Получение байт в указанном диапазоне</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The overloads of the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method allow you to specify the range of random numbers, but the <ph id="ph2">&lt;xref:System.Random.NextBytes%2A&gt;</ph> method does not.</source>
          <target state="translated">Перегруженные версии <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> метода позволяют указать диапазон случайных чисел, но <ph id="ph2">&lt;xref:System.Random.NextBytes%2A&gt;</ph> метод — нет.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example implements a <ph id="ph1">`NextBytes`</ph> method that lets you specify the range of the returned bytes.</source>
          <target state="translated">В следующем примере реализуется <ph id="ph1">`NextBytes`</ph> метод, который позволяет указать диапазон байтов, возвращенных.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>It defines a <ph id="ph1">`Random2`</ph> class that derives from <ph id="ph2">&lt;xref:System.Random&gt;</ph> and overloads its <ph id="ph3">`NextBytes`</ph> method.</source>
          <target state="translated">Он определяет <ph id="ph1">`Random2`</ph> класс, производный от <ph id="ph2">&lt;xref:System.Random&gt;</ph> и перегружает его <ph id="ph3">`NextBytes`</ph> метод.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">`NextBytes(Byte[], Byte, Byte)`</ph> method wraps a call to the <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method and specifies the minimum value and one greater than the maximum value (in this case, 0 and 101) that we want returned in the byte array.</source>
          <target state="translated"><ph id="ph1">`NextBytes(Byte[], Byte, Byte)`</ph> Метод создает оболочку для вызова <ph id="ph2">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> метод и указывает минимальное значение и один больше, чем максимальное значение (в этом случае 0 и 101), мы должны возвращаться в массиве байтов.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Because we are sure that the integer values returned by the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method are within the range of the <ph id="ph2">&lt;xref:System.Byte&gt;</ph> data type, we can safely cast them (in C#) or convert them (in Visual Basic) from integers to bytes.</source>
          <target state="translated">Так как мы уверены, что целочисленные значения, возвращает <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> метод находятся в диапазоне от <ph id="ph2">&lt;xref:System.Byte&gt;</ph> тип данных можно безопасно привести их (в C#) или преобразовать их (в Visual Basic) из целых чисел в байты.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve an element from an array or collection at random</source>
          <target state="translated">Получить элемент из массива или коллекции случайным образом</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Random numbers often serve as indexes to retrieve values from arrays or collections.</source>
          <target state="translated">Случайные числа часто используются в качестве индексов для извлечения значений из массивы или коллекции.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>To retrieve a random index value, you can call the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> method, and use the lower bound of the array as the value of its <ph id="ph2">`minValue`</ph> argument and one greater than the upper bound of the array as the value of its <ph id="ph3">`maxValue`</ph> argument.</source>
          <target state="translated">Для получения значения случайный индекс, можно вызвать <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> метод и использование, нижняя граница массива в качестве значения его <ph id="ph2">`minValue`</ph> аргумент и на единицу больше, чем значение верхней границы массива в качестве значения его <ph id="ph3">`maxValue`</ph> аргумент.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For a zero-based array, this is equivalent to its <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> property, or one greater than the value returned by the <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Отсчитываемый от нуля массив, это эквивалентно его <ph id="ph1">&lt;xref:System.Array.Length%2A&gt;</ph> свойства или единицу больше, чем значение, возвращаемое <ph id="ph2">&lt;xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example randomly retrieves the name of a city in the United States from an array of cities.</source>
          <target state="translated">В следующем примере случайным образом извлекается название города, в Соединенных Штатах из массив городов.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Retrieve a unique element from an array or collection</source>
          <target state="translated">Получить уникальный элемент из массива или коллекции</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>A random number generator can always return duplicate values.</source>
          <target state="translated">Генератор случайных чисел, всегда можно вернуться повторяющиеся значения.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>As the range of numbers becomes smaller or the number of values generated becomes larger, the probability of duplicates grows.</source>
          <target state="translated">Диапазон номеров уменьшается или число значения, создаваемые становится больше, увеличивается вероятность дубликатов.</target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>If random values must be unique, more numbers are generated to compensate for duplicates, resulting in increasingly poor performance.</source>
          <target state="translated">Если случайные значения должны быть уникальными, дополнительные номера создаются для компенсации повторяющиеся значения, в результате чего все более низкую производительность.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>There are a number of techniques to handle this scenario.</source>
          <target state="translated">Существует несколько способов для обработки этого сценария.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>One common solution is to create an array or collection that contains the values to be retrieved, and a parallel array that contains random floating-point numbers.</source>
          <target state="translated">Одно из распространенных решений является создание массива или коллекции, содержащей значения, которые нужно вернуть, а параллельный массив, который содержит случайных чисел с плавающей запятой.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The second array is populated with random numbers at the time the first array is created, and the <ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType&gt;</ph> method is used to sort the first array by using the values in the parallel array.</source>
          <target state="translated">Второй массив заполняется случайных чисел во время создания первого массива, и <ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType&gt;</ph> метод используется для сортировки первый массив с помощью значения в массиве, parallel.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>For example, if you're developing a Solitaire game, you want to ensure that each card is used only once.</source>
          <target state="translated">Например при разработке игры, необходимо убедиться, что каждая карта используется только один раз.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Instead of generating random numbers to retrieve a card and tracking whether that card has already been dealt, you can create a parallel array of random numbers that can be used to sort the deck.</source>
          <target state="translated">Вместо создания случайных чисел для извлечения карту и отслеживания ли уже были обработаны этой карты, можно создать массив, параллельный массиву случайных чисел, который может использоваться для сортировки колоде в.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>Once the deck is sorted, your app can maintain a pointer to indicate the index of the next card on the deck.</source>
          <target state="translated">После колоде отсортирован, приложение можно использовать указатель для указания индекса Далее карт в колоде.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example illustrates this approach.</source>
          <target state="translated">Этот подход показан в приведенном ниже примере.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>It defines a <ph id="ph1">`Card`</ph> class that represents a playing card and a <ph id="ph2">`Dealer`</ph> class that deals a deck of shuffled cards.</source>
          <target state="translated">Он определяет <ph id="ph1">`Card`</ph> класс, представляющий игральной карты и их <ph id="ph2">`Dealer`</ph> класс, который обрабатывает перемешать карт.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">`Dealer`</ph> class constructor populates two arrays: a <ph id="ph2">`deck`</ph> array that has class scope and that represents all the cards in the deck; and a local <ph id="ph3">`order`</ph> array that has the same number of elements as the <ph id="ph4">`deck`</ph> array and is populated with randomly generated <ph id="ph5">&lt;xref:System.Double&gt;</ph> values.</source>
          <target state="translated"><ph id="ph1">`Dealer`</ph> Конструктор класса заполняет два массива: <ph id="ph2">`deck`</ph> массива, который имеет область видимости класса, которое представляет всех карт в колоде; и локальный <ph id="ph3">`order`</ph> массив, который имеет то же число элементов, как <ph id="ph4">`deck`</ph> массива и заполняется с помощью формируется случайным образом <ph id="ph5">&lt;xref:System.Double&gt;</ph> значения.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The <ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType&gt;</ph> method is then called to sort the <ph id="ph2">`deck`</ph> array based on the values in the <ph id="ph3">`order`</ph> array.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType&gt;</ph> Для сортировки затем вызывается метод <ph id="ph2">`deck`</ph> массива на основе значений в <ph id="ph3">`order`</ph> массива.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example creates a single random number generator and calls its <ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Random.Next%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Random.NextDouble%2A&gt;</ph> methods to generate sequences of random numbers within different ranges.</source>
          <target state="translated">В следующем примере создается один генератора случайных чисел и вызывает его <ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Random.Next%2A&gt;</ph>, и <ph id="ph3">&lt;xref:System.Random.NextDouble%2A&gt;</ph> методов для автоматического создания последовательности случайных чисел в разных диапазонах.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The following example generates a random integer that it uses as an index to retrieve a string value from an array.</source>
          <target state="translated">Следующий пример приводит к возникновению ошибки случайное целое число, которое используется как индекс для получения строковое значение из массива.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In the .NET Framework 1.0 and 1.1, a minimum implementation of a class derived from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> required overriding the <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method to define a new or modified algorithm for generating random numbers.</source>
          <target state="translated">В .NET Framework 1.0 и 1.1, минимальная реализация класса, производным от <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> требовалось переопределение <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> метод для определения новых или измененных алгоритм генерации случайных чисел.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The derived class could then rely on the base class implementation of the <ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32)" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph>, <ph id="ph4">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph>, and <ph id="ph5">&lt;see cref="M:System.Random.NextDouble" /&gt;</ph> methods to call the derived class implementation of the <ph id="ph6">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method.</source>
          <target state="translated">Производный класс может использовать реализацию базового класса <ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32)" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph>, <ph id="ph4">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph>, и <ph id="ph5">&lt;see cref="M:System.Random.NextDouble" /&gt;</ph> методы для вызова реализации в производном классе <ph id="ph6">&lt;see cref="M:System.Random.Sample" /&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>In the .NET Framework 2.0 and later, the behavior of the <ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph>, and <ph id="ph3">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> methods have changed so that these methods do not necessarily call the derived class implementation of the <ph id="ph4">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method.</source>
          <target state="translated">В платформе .NET Framework 2.0 и более поздней версии, поведение <ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph>, <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph>, и <ph id="ph3">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> методы были изменены, чтобы эти методы не обязательно вызывать реализации в производном классе <ph id="ph4">&lt;see cref="M:System.Random.Sample" /&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>As a result, classes derived from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> that target the .NET Framework 2.0 and later should also override these three methods.</source>
          <target state="translated">В результате классы, производные от <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> , платформы .NET Framework 2.0 и более поздней версии, следует также переопределить эти три метода.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>The implementation of the random number generator in the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class isn't guaranteed to remain the same across major versions of the .NET Framework.</source>
          <target state="translated">Реализации генератора случайных чисел в <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> класса не обязательно будет остаются неизменными в разных основных версий платформы .NET Framework.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Random">
          <source>As a result, you shouldn't assume that the same seed will result in the same pseudo-random sequence in different versions of the .NET Framework.</source>
          <target state="translated">В результате не предполагается, что одинаковые начальные значения приведет к той же последовательности псевдослучайных чисел в различных версиях платформы .NET Framework.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" uid="T:System.Random">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" uid="M:System.Random.#ctor">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class, using a time-dependent default seed value.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> с помощью зависимого от времени начального значения по умолчанию.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>The default seed value is derived from the system clock and has finite resolution.</source>
          <target state="translated">Начальное значение по умолчанию является производным от системных часов и конечное разрешением.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>As a result, different <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects that are created in close succession by a call to the default constructor will have identical default seed values and, therefore, will produce identical sets of random numbers.</source>
          <target state="translated">Таким образом, разные <ph id="ph1">&lt;xref:System.Random&gt;</ph> объекты, создаваемые в закрытой последовательности путем вызова конструктора по умолчанию будут иметь одинаковые начальное значение по умолчанию и, таким образом, будут производить идентичные наборы случайных чисел.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>This problem can be avoided by using a single <ph id="ph1">&lt;xref:System.Random&gt;</ph> object to generate all random numbers.</source>
          <target state="translated">Этой проблемы можно избежать, используя одну <ph id="ph1">&lt;xref:System.Random&gt;</ph> объект для создания всех случайных чисел.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>You can also work around it by modifying the seed value returned by the system clock and then explicitly providing this new seed value to the <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">Можно также обойти его, изменив начальное значение, возвращенное методом системных часов и явно предоставив это новое начальное значение для <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>For more information, see the <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor.</source>
          <target state="translated">Дополнительные сведения см. в разделе <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> конструктор.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>Call this constructor if you want your random number generator to generate a random sequence of numbers.</source>
          <target state="translated">Если требуется генератора случайных чисел для создания случайную последовательность чисел, вызов этого конструктора.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>To generate a fixed  sequence of random numbers that will be the same for different random number generators, call the <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> constructor with a fixed seed value .</source>
          <target state="translated">Для создания основных последовательность случайных чисел, который будет одинаковым для разных генераторов случайных чисел следует вызвать <ph id="ph1">&lt;xref:System.Random.%23ctor%28System.Int32%29&gt;</ph> конструктор с предопределенной начальным значением.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>This <ph id="ph1">&lt;xref:System.Random&gt;</ph> constructor overload is frequently used when testing apps that use random numbers.</source>
          <target state="translated">Это <ph id="ph1">&lt;xref:System.Random&gt;</ph> перегрузку конструктора часто используется при тестировании приложений, использующих случайных чисел.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>Once you've instantiated the random number generator, you call individual <ph id="ph1">&lt;xref:System.Random&gt;</ph> methods, such as <ph id="ph2">&lt;xref:System.Random.Next&gt;</ph> or <ph id="ph3">&lt;xref:System.Random.NextDouble&gt;</ph>, to generate random numbers.</source>
          <target state="translated">После создания экземпляра генератора случайных чисел вызове отдельных <ph id="ph1">&lt;xref:System.Random&gt;</ph> методы, такие как <ph id="ph2">&lt;xref:System.Random.Next&gt;</ph> или <ph id="ph3">&lt;xref:System.Random.NextDouble&gt;</ph>, для генерации случайных чисел.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>The following example uses the default constructor to instantiate three <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects and displays a sequence of five random integers for each.</source>
          <target state="translated">В следующем примере используется конструктор по умолчанию для создания экземпляра три <ph id="ph1">&lt;xref:System.Random&gt;</ph> объектов и отображает последовательность случайных целых чисел.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>Because the first two <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects are created in close succession, they are instantiated using identical seed values based on the system clock and, therefore, they produce an identical sequence of random numbers.</source>
          <target state="translated">Так как первые две <ph id="ph1">&lt;xref:System.Random&gt;</ph> объекты создаются в быстрой последовательности, их экземпляры создаются с помощью одинаковые начальные значения в зависимости от системных часов и, таким образом, они создают идентичную последовательность случайных чисел.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>On the other hand, the default constructor of the third <ph id="ph1">&lt;xref:System.Random&gt;</ph> object is called after a two-second delay caused by calling the <ph id="ph2">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">С другой стороны, конструктор по умолчанию третьего <ph id="ph1">&lt;xref:System.Random&gt;</ph> объект, называется задержкой 2 секунды, вызвать <ph id="ph2">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor">
          <source>Because this produces a different seed value for the third <ph id="ph1">&lt;xref:System.Random&gt;</ph> object, it produces a different sequence of random numbers.</source>
          <target state="translated">Так как это создает различные начальное значение для третьего <ph id="ph1">&lt;xref:System.Random&gt;</ph> объекта, он создает различные последовательность случайных чисел.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" uid="M:System.Random.#ctor(System.Int32)">
          <source>A number used to calculate a starting value for the pseudo-random number sequence.</source>
          <target state="translated">Число, используемое для вычисления начального значения последовательности псевдослучайных чисел.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" uid="M:System.Random.#ctor(System.Int32)">
          <source>If a negative number is specified, the absolute value of the number is used.</source>
          <target state="translated">Если задано отрицательное число, используется его абсолютное значение.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" uid="M:System.Random.#ctor(System.Int32)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class, using the specified seed value.</source>
          <target state="translated">Инициализирует новый экземпляр класса <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> с помощью указанного начального значения.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>Providing an identical seed value to different <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects causes each instance to produce identical sequences of random numbers.</source>
          <target state="translated">Предоставление задать одинаковые начальные значения для разных <ph id="ph1">&lt;xref:System.Random&gt;</ph> объектов вызывает все экземпляры будут производить идентичные последовательности случайных чисел.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>This is often done when testing apps that rely on random number generators.</source>
          <target state="translated">Часто это делается при тестировании приложений, которые используют генераторы случайных чисел.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>If your application requires different random number sequences, invoke this constructor repeatedly with different seed values.</source>
          <target state="translated">Если приложение требует различные последовательности случайных чисел, вызовите этот конструктор несколько раз с различными начальными значениями.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>One way to produce a unique seed value is to make it time-dependent.</source>
          <target state="translated">Один из способов получения уникального исходного значения — позволить его зависимых от времени.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>For example, derive the seed value from the system clock, as the <ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph> overload does.</source>
          <target state="translated">Например, извлекать его из системных часов, как <ph id="ph1">&lt;xref:System.Random.%23ctor&gt;</ph> перегрузки.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>However, the system clock might not have sufficient resolution to provide different invocations of this constructor with a different seed value.</source>
          <target state="translated">Однако системные часы не могут иметь достаточно разрешения для предоставления различных вызовов этот конструктор используется другое начальное значение.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>This results in random number generators that generate identical sequences of pseudo-random numbers, as illustrated by the first two <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects in the following example.</source>
          <target state="translated">Это приведет генераторы случайных чисел, формирующих идентичные последовательности псевдослучайных чисел, как показано в первых двух <ph id="ph1">&lt;xref:System.Random&gt;</ph> объектов в следующем примере.</target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>To prevent this, apply an algorithm to differentiate the seed value in each invocation, or call the <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> method to ensure that you provide each constructor with a different seed value.</source>
          <target state="translated">Чтобы избежать этого, применить алгоритм, изменяющий начальное значение в каждый вызов или вызов <ph id="ph1">&lt;xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType&gt;</ph> метод, чтобы предоставить другое начальное значение каждого конструктора.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>Another option is to instantiate a single <ph id="ph1">&lt;xref:System.Random&gt;</ph> object that you use to generate all the random numbers in your application.</source>
          <target state="translated">Другой вариант — создать один <ph id="ph1">&lt;xref:System.Random&gt;</ph> , используется для формирования случайных чисел в приложении.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>This yields slightly better performance, since instantiating a random number generator is fairly expensive.</source>
          <target state="translated">Это дает немного более высокую производительность, так как при создании экземпляра генератора случайных чисел является довольно дорогой.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>The following example creates <ph id="ph1">&lt;xref:System.Random&gt;</ph> objects with the class constructor that takes a seed parameter and generates a sequence of random integers and doubles.</source>
          <target state="translated">В следующем примере создается <ph id="ph1">&lt;xref:System.Random&gt;</ph> объектов с помощью конструктора класса, которая принимает параметр начального значения и создает последовательность случайных целых чисел и чисел типа Double.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.#ctor(System.Int32)">
          <source>The example illustrates that the same sequence is generated when the <ph id="ph1">&lt;xref:System.Random&gt;</ph> object is created again with the constructor and seed parameter.</source>
          <target state="translated">В примере показано, что и та же последовательность создается при <ph id="ph1">&lt;xref:System.Random&gt;</ph> попытку создать объект с помощью конструктора и начальное значение параметра.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="T:System.Random">
          <source>Returns a random integer.</source>
          <target state="translated">Возвращает случайное целое число.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Random.Next">
          <source>Returns a non-negative random integer.</source>
          <target state="translated">Возвращает неотрицательное случайное целое число.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Random.Next">
          <source>A 32-bit signed integer that is greater than or equal to 0 and less than <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">32-разрядное целое число со знаком, которое больше или равно нулю и меньше чем <ph id="ph1">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source><ph id="ph1">&lt;xref:System.Random.Next%2A?displayProperty=nameWithType&gt;</ph> generates a random number whose value ranges from 0 to less than <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random.Next%2A?displayProperty=nameWithType&gt;</ph> Создает случайное число в диапазоне от 0 до меньше, чем <ph id="ph2">&lt;xref:System.Int32.MaxValue?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>To generate a random number whose value ranges from 0 to some other positive number, use the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">Чтобы создать случайное число в диапазоне от 0 до других положительного числа, используйте <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType&gt;</ph> перегрузки метода.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>To generate a random number within a different range, use the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method overload.</source>
          <target state="translated">Чтобы создать случайное число в пределах другой диапазон, используйте <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> перегрузки метода.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>The following example makes repeated calls to the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method to generate a specific number of random numbers requested by the user.</source>
          <target state="translated">В следующем примере создается повторные вызовы <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> метод для создания определенного числа случайных чисел, заданного пользователем.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>The <ph id="ph1">&lt;xref:System.Console.ReadLine%2A?displayProperty=nameWithType&gt;</ph> method is used to get customer input.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Console.ReadLine%2A?displayProperty=nameWithType&gt;</ph> Метод используется для получения входных данных клиента.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>The following example derives a class from <ph id="ph1">&lt;xref:System.Random&gt;</ph> to generate a sequence of random numbers whose distribution differs from the uniform distribution generated by the <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> method of the base class.</source>
          <target state="translated">Следующий пример является производным от класса <ph id="ph1">&lt;xref:System.Random&gt;</ph> для создания последовательности случайных чисел, распределение которых отличается от равномерного распределения, созданные <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> метод базового класса.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>It overrides the <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> method to provide the distribution of random numbers, and overrides the <ph id="ph2">&lt;xref:System.Random.Next%2A?displayProperty=nameWithType&gt;</ph> method to use series of random numbers.</source>
          <target state="translated">Он переопределяет <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> способ предоставления распределения случайных чисел и переопределяет <ph id="ph2">&lt;xref:System.Random.Next%2A?displayProperty=nameWithType&gt;</ph> метод, используемый последовательность случайных чисел.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>Starting with the .NET Framework version 2.0, if you derive a class from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> and override the <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method, the distribution provided by the derived class implementation of the <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method is not used in calls to the base class implementation of the <ph id="ph4">&lt;see cref="M:System.Random.Next" /&gt;</ph> method.</source>
          <target state="translated">Начиная с .NET Framework версии 2.0, если производный класс <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> и Переопределите <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> метод, дистрибутив, предоставленный реализации в производном классе <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> метода не используется в вызовах базового класса Реализация <ph id="ph4">&lt;see cref="M:System.Random.Next" /&gt;</ph> метода.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>Instead, the uniform distribution returned by the base <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class is used.</source>
          <target state="translated">Вместо этого возвращается равномерного распределения базовыми <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> используется класс.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>This behavior improves the overall performance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class.</source>
          <target state="translated">Это повышает общую производительность <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next">
          <source>To modify this behavior to call the <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method in the derived class, you must also override the <ph id="ph2">&lt;see cref="M:System.Random.Next" /&gt;</ph> method.</source>
          <target state="translated">Чтобы изменить это поведение, чтобы вызвать <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> метод в производном классе, необходимо также переопределить <ph id="ph2">&lt;see cref="M:System.Random.Next" /&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source>The exclusive upper bound of the random number to be generated.</source>
          <target state="translated">Эксклюзивная верхняя граница создаваемого случайного числа.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>maxValue<ept id="p1">&lt;/c&gt;</ept> must be greater than or equal to 0.</source>
          <target state="translated">Значение <bpt id="p1">&lt;c&gt;</bpt>maxValue<ept id="p1">&lt;/c&gt;</ept> должно быть больше или равно 0.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source>Returns a non-negative random integer that is less than the specified maximum.</source>
          <target state="translated">Возвращает неотрицательное случайное целое число, которое меньше максимально допустимого значения.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source>A 32-bit signed integer that is greater than or equal to 0, and less than <ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph>; that is, the range of return values ordinarily includes 0 but not <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>.</source>
          <target state="translated">32-разрядное целое число со знаком, большее или равное 0 и меньшее, чем <ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph>. То есть диапазон возвращаемых значений включает в себя 0, но не включает <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source>However, if <ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph> equals 0, <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph> is returned.</source>
          <target state="translated">Однако если значение параметра <ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph> равно нулю, возвращается значение <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> overload returns random integers that range from 0 to <ph id="ph2">`maxValue`</ph> – 1.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%29&gt;</ph> Перегрузка возвращает случайных целых чисел диапазона от 0 до <ph id="ph2">`maxValue`</ph> – 1.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32)">
          <source>However, if <ph id="ph1">`maxValue`</ph> is 0, the method returns 0.</source>
          <target state="translated">Однако если <ph id="ph1">`maxValue`</ph> равно 0, метод возвращает значение 0.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32)">
          <source>The following example generates random integers with various overloads of the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method.</source>
          <target state="translated">Следующий пример приводит к возникновению случайных целых чисел с помощью перегрузок <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32)">
          <source>The following example generates a random integer that it uses as an index to retrieve a string value from an array.</source>
          <target state="translated">Следующий пример приводит к возникновению ошибки случайное целое число, которое используется как индекс для получения строковое значение из массива.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32)">
          <source>Because the highest index of the array is one less than its length, the value of the <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> property is supplied as a the <ph id="ph2">`maxValue`</ph> parameter.</source>
          <target state="translated">Поскольку наибольший индекс массива имеет один меньше его длину, то значение <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> свойство будет задано как <ph id="ph2">`maxValue`</ph> параметр.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph> is less than 0.</source>
          <target state="translated">Значение параметра <ph id="ph1">&lt;paramref name="maxValue" /&gt;</ph> меньше 0.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>The inclusive lower bound of the random number returned.</source>
          <target state="translated">Включенной нижний предел возвращаемого случайного числа.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>The exclusive upper bound of the random number returned.</source>
          <target state="translated">Исключенный верхний предел возвращаемого случайного числа.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source><bpt id="p1">&lt;c&gt;</bpt>maxValue<ept id="p1">&lt;/c&gt;</ept> must be greater than or equal to <bpt id="p2">&lt;c&gt;</bpt>minValue<ept id="p2">&lt;/c&gt;</ept>.</source>
          <target state="translated">Значение <bpt id="p1">&lt;c&gt;</bpt>maxValue<ept id="p1">&lt;/c&gt;</ept> должно быть больше или равно <bpt id="p2">&lt;c&gt;</bpt>minValue<ept id="p2">&lt;/c&gt;</ept>.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Returns a random integer that is within a specified range.</source>
          <target state="translated">Возвращает случайное целое число в указанном диапазоне.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>A 32-bit signed integer greater than or equal to <ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> and less than <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>; that is, the range of return values includes <ph id="ph3">&lt;paramref name="minValue" /&gt;</ph> but not <ph id="ph4">&lt;paramref name="maxValue" /&gt;</ph>.</source>
          <target state="translated">32-разрядное целое число со знаком большее или равное <ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> и меньше, чем <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>; то есть, диапазон возвращаемого значения включает <ph id="ph3">&lt;paramref name="minValue" /&gt;</ph>, не включает <ph id="ph4">&lt;paramref name="maxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>If <ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> equals <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>, <ph id="ph3">&lt;paramref name="minValue" /&gt;</ph> is returned.</source>
          <target state="translated">Если значение параметра <ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> равно значению параметра <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>, то возвращается значение <ph id="ph3">&lt;paramref name="minValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> overload returns random integers that range from <ph id="ph2">`minValue`</ph> to <ph id="ph3">`maxValue`</ph> – 1.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29&gt;</ph> Перегрузка возвращает случайных целых чисел из указанного диапазона <ph id="ph2">`minValue`</ph> для <ph id="ph3">`maxValue`</ph> – 1.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>However, if <ph id="ph1">`maxValue`</ph> equals <ph id="ph2">`minValue`</ph>, the method returns <ph id="ph3">`minValue`</ph>.</source>
          <target state="translated">Однако если <ph id="ph1">`maxValue`</ph> равняется <ph id="ph2">`minValue`</ph>, метод возвращает <ph id="ph3">`minValue`</ph>.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Unlike the other overloads of the <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> method, which return only non-negative values, this method can return a negative random integer.</source>
          <target state="translated">В отличие от других перегрузок <ph id="ph1">&lt;xref:System.Random.Next%2A&gt;</ph> метод, который возвращает только неотрицательные значения, этот метод возвращает отрицательное случайное целое число.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> method to generate random integers with three distinct ranges.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType&gt;</ph> метод для создания случайных целых чисел с тремя различными диапазонами.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Note that the exact output from the example depends on the system-supplied seed value passed to the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class constructor.</source>
          <target state="translated">Обратите внимание, что точное выходные данные примера зависит от системным начальное значение, передаваемое <ph id="ph1">&lt;xref:System.Random&gt;</ph> конструктора класса.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>The following example generates a random integer that it uses as an index to retrieve a string value from an array.</source>
          <target state="translated">Следующий пример приводит к возникновению ошибки случайное целое число, которое используется как индекс для получения строковое значение из массива.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Because the highest index of the array is one less than its length, the value of the <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> property is supplied as a the <ph id="ph2">`maxValue`</ph> parameter.</source>
          <target state="translated">Поскольку наибольший индекс массива имеет один меньше его длину, то значение <ph id="ph1">&lt;xref:System.Array.Length%2A?displayProperty=nameWithType&gt;</ph> свойство будет задано как <ph id="ph2">`maxValue`</ph> параметр.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> is greater than <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>.</source>
          <target state="translated">Значение <ph id="ph1">&lt;paramref name="minValue" /&gt;</ph> больше значения <ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Starting with the .NET Framework version 2.0, if you derive a class from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> and override the <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method, the distribution provided by the derived class implementation of the <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method is not used in calls to the base class implementation of the <ph id="ph4">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph> method overload if the difference between the <ph id="ph5">&lt;paramref name="minValue" /&gt;</ph> and <ph id="ph6">&lt;paramref name="maxValue" /&gt;</ph> parameters is greater than <ph id="ph7">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated">Начиная с .NET Framework версии 2.0, если производный класс <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> и Переопределите <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> метод, дистрибутив, предоставленный реализации в производном классе <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> метода не используется в вызовах базового класса Реализация <ph id="ph4">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph> перегрузку метода, если разность <ph id="ph5">&lt;paramref name="minValue" /&gt;</ph> и <ph id="ph6">&lt;paramref name="maxValue" /&gt;</ph> параметров больше, чем <ph id="ph7">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>Instead, the uniform distribution returned by the base <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class is used.</source>
          <target state="translated">Вместо этого возвращается равномерного распределения базовыми <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> используется класс.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>This behavior improves the overall performance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class.</source>
          <target state="translated">Это повышает общую производительность <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Next(System.Int32,System.Int32)">
          <source>To modify this behavior to call the <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method in the derived class, you must also override the <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph> method overload.</source>
          <target state="translated">Чтобы изменить это поведение, чтобы вызвать <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> метод в производном классе, необходимо также переопределить <ph id="ph2">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph> перегрузки метода.</target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>An array of bytes to contain random numbers.</source>
          <target state="translated">Массив байтов, содержащий случайные числа.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>Fills the elements of a specified array of bytes with random numbers.</source>
          <target state="translated">Заполняет элементы указанного массива байтов случайными числами.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>Each element of the array of bytes is set to a random number greater than or equal to 0, and less than or equal to <ph id="ph1">&lt;xref:System.Byte.MaxValue&gt;</ph>.</source>
          <target state="translated">Каждый элемент массива байтов равно случайное число, больше или равно 0 и меньше или равно <ph id="ph1">&lt;xref:System.Byte.MaxValue&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>For example, to generate a cryptographically secured random number suitable for creating a random password, use a method such as <ph id="ph1">&lt;xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Например, для генерации криптографически защищенного случайного числа, подходит для создания случайного пароля, используйте метод например <ph id="ph1">&lt;xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>The following example demonstrates how to use the <ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph> method to fill an array of bytes with random byte values.</source>
          <target state="translated">В следующем примере демонстрируется использование <ph id="ph1">&lt;xref:System.Random.NextBytes%2A&gt;</ph> метод для заполнения массива байтов случайных байтовых значений.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Random.NextBytes(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Свойство <ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> имеет значение <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>Starting with the .NET Framework version 2.0, if you derive a class from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> and override the <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method, the distribution provided by the derived class implementation of the <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method is not used in calls to the base class implementation of the <ph id="ph4">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> method.</source>
          <target state="translated">Начиная с .NET Framework версии 2.0, если производный класс <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> и Переопределите <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> метод, дистрибутив, предоставленный реализации в производном классе <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> метода не используется в вызовах базового класса Реализация <ph id="ph4">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> метода.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>Instead, the uniform distribution returned by the base <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class is used.</source>
          <target state="translated">Вместо этого возвращается равномерного распределения базовыми <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> используется класс.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>This behavior improves the overall performance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class.</source>
          <target state="translated">Это повышает общую производительность <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextBytes(System.Byte[])">
          <source>To modify this behavior to call the <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method in the derived class, you must also override the <ph id="ph2">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> method.</source>
          <target state="translated">Чтобы изменить это поведение, чтобы вызвать <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> метод в производном классе, необходимо также переопределить <ph id="ph2">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" uid="M:System.Random.NextDouble">
          <source>Returns a random floating-point number that is greater than or equal to 0.0, and less than 1.0.</source>
          <target state="translated">Возвращает случайное число с плавающей запятой, которое больше или равно 0,0 и меньше 1,0.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" uid="M:System.Random.NextDouble">
          <source>A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</source>
          <target state="translated">Число двойной точности с плавающей запятой, которое больше или равно 0,0, и меньше 1,0.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextDouble">
          <source>The actual upper bound of the random number returned by this method is 0.99999999999999978.</source>
          <target state="translated">Фактический верхней границы случайного числа, возвращаемого этим методом является 0.99999999999999978.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextDouble">
          <source>To retrieve random floating-point values within a range other than 0.0 and 1.0, see the "Retrieve floating-point values in a specified range" section of the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class topic.</source>
          <target state="translated">Для получения случайных значений с плавающей запятой в диапазоне, отличные от 0,0 до 1,0, обратитесь к разделу «Получать значения с плавающей запятой в указанном диапазоне» <ph id="ph1">&lt;xref:System.Random&gt;</ph> разделе, посвященном классу.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextDouble">
          <source>This method is the public version of the protected method, <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph>.</source>
          <target state="translated">Этот метод является открытой версией защищенного метода <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextDouble">
          <source>The following example uses the <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method to generate sequences of random doubles.</source>
          <target state="translated">В следующем примере используется <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> метод для создания последовательности случайных чисел типа Double.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.NextDouble">
          <source>The following example calls the <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method to generate 100 random numbers and displays their frequency distribution.</source>
          <target state="translated">В следующем примере вызывается <ph id="ph1">&lt;xref:System.Random.NextDouble%2A&gt;</ph> метод для создания 100 случайных чисел и отображает их частоту распределение.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" uid="M:System.Random.Sample">
          <source>Returns a random floating-point number between 0.0 and 1.0.</source>
          <target state="translated">Возвращает случайное число с плавающей запятой в диапазоне от 0,0 до 1,0.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" uid="M:System.Random.Sample">
          <source>A double-precision floating point number that is greater than or equal to 0.0, and less than 1.0.</source>
          <target state="translated">Число двойной точности с плавающей запятой, которое больше или равно 0,0, и меньше 1,0.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>To produce a different random distribution or a different random number generator principle, derive a class from the <ph id="ph1">&lt;xref:System.Random&gt;</ph> class and override the <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> method.</source>
          <target state="translated">Для создания другого распределения случайных или различных случайных числа принцип генератора, создайте класс, производный от <ph id="ph1">&lt;xref:System.Random&gt;</ph> класса и переопределить <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> method is <ph id="ph2">`protected`</ph>, which means that it is accessible only within the <ph id="ph3">&lt;xref:System.Random&gt;</ph> class and its derived classes.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> Метод <ph id="ph2">`protected`</ph>, что означает, что он доступен только в пределах <ph id="ph3">&lt;xref:System.Random&gt;</ph> класс и его производные классы.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>To generate a random number between 0 and 1 from a <ph id="ph1">&lt;xref:System.Random&gt;</ph> instance, call the <ph id="ph2">&lt;xref:System.Random.NextDouble%2A&gt;</ph> method.</source>
          <target state="translated">Чтобы получить случайное число между 0 и 1 из <ph id="ph1">&lt;xref:System.Random&gt;</ph> экземпляра, вызовите метод <ph id="ph2">&lt;xref:System.Random.NextDouble%2A&gt;</ph> метод.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The following example derives a class from <ph id="ph1">&lt;xref:System.Random&gt;</ph> and overrides the <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> method to generate a distribution of random numbers.</source>
          <target state="translated">Следующий пример является производным от класса <ph id="ph1">&lt;xref:System.Random&gt;</ph> и переопределяет <ph id="ph2">&lt;xref:System.Random.Sample%2A&gt;</ph> метод для создания распределения случайных чисел.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>This distribution is different than the uniform distribution generated by the <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> method of the base class.</source>
          <target state="translated">Это распределение отличается от равномерного распределения, созданные <ph id="ph1">&lt;xref:System.Random.Sample%2A&gt;</ph> метод базового класса.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>Starting with the .NET Framework version 2.0, if you derive a class from <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> and override the <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method, the distribution provided by the derived class implementation of the <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method is not used in calls to the base class implementation of the following methods:</source>
          <target state="translated">Начиная с .NET Framework версии 2.0, если производный класс <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> и Переопределите <ph id="ph2">&lt;see cref="M:System.Random.Sample" /&gt;</ph> метод, дистрибутив, предоставленный реализации в производном классе <ph id="ph3">&lt;see cref="M:System.Random.Sample" /&gt;</ph> метода не используется в вызовах базового класса Реализация следующих методов:</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The <ph id="ph1">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph> method.</source>
          <target state="translated">метод <ph id="ph1">&lt;see cref="M:System.Random.NextBytes(System.Byte[])" /&gt;</ph>;</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The <ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph> method.</source>
          <target state="translated">метод <ph id="ph1">&lt;see cref="M:System.Random.Next" /&gt;</ph>;</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The <ph id="ph1">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph> method, if (<ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph><ph id="ph3"> - </ph><ph id="ph4">&lt;paramref name="minValue" /&gt;</ph>) is greater than <ph id="ph5">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Random.Next(System.Int32,System.Int32)" /&gt;</ph> Метод, если (<ph id="ph2">&lt;paramref name="maxValue" /&gt;</ph><ph id="ph3"> - </ph><ph id="ph4">&lt;paramref name="minValue" /&gt;</ph>) больше, чем <ph id="ph5">&lt;see cref="F:System.Int32.MaxValue" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>Instead, the uniform distribution provided by the base <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class is used.</source>
          <target state="translated">Вместо этого равномерного распределения, предоставляемые базовый <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> используется класс.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>This behavior improves the overall performance of the <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> class.</source>
          <target state="translated">Это повышает общую производительность <ph id="ph1">&lt;see cref="T:System.Random" /&gt;</ph> класса.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>To modify this behavior to call the implementation of the <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> method in the derived class, you must also override the behavior of these three members.</source>
          <target state="translated">Чтобы изменить это поведение, чтобы вызвать реализацию <ph id="ph1">&lt;see cref="M:System.Random.Sample" /&gt;</ph> метод в производном классе, необходимо также переопределить поведение этих трех элементов.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Random.Sample">
          <source>The example provides an illustration.</source>
          <target state="translated">Иллюстрация приведена в примере.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>