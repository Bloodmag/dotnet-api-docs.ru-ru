<Type Name="Random" FullName="System.Random">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="4ad7a7caff000dc43adcd1a90679ce6c6f419bc0" />
    <Meta Name="ms.sourcegitcommit" Value="3907f9a5780957d9c85af2e54c0a5bc2a5bf19ab" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/14/2018" />
    <Meta Name="ms.locfileid" Value="34174130" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Random" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit Random extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Random" />
  <TypeSignature Language="VB.NET" Value="Public Class Random" />
  <TypeSignature Language="C++ CLI" Value="public ref class Random" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет генератор псевдослучайных чисел, то есть устройство, которое выдает последовательность чисел, отвечающую определенным статистическим критериям случайности.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Псевдослучайные числа выбираются с равной вероятностью из конечного набора чисел. Выбранные числа не являются строго случайными, так как математического алгоритма используется для выбора их, но они достаточно случайны практической точки зрения. Текущая реализация <xref:System.Random> класс основан на измененную версию Дональд E. Кнута субтрактивные алгоритма генерации случайных чисел. Дополнительные сведения см. в разделе E. г. Кнута. *Искусство программирования, том 2: искусство*. Третье издание Addison-Wesley, чтение, MA, 1997.  
  
 Для создания криптографически надежного случайного числа такой, которая подходит для создания случайного пароля используйте <xref:System.Security.Cryptography.RNGCryptoServiceProvider> класса или являются производными от класса <xref:System.Security.Cryptography.RandomNumberGenerator?displayProperty=nameWithType>.  
  
 В этом разделе.  
  
 [При создании экземпляра генератора случайных чисел](#Instantiate)   
 [Предотвращение несколько экземпляров](#Multiple)   
 [Безопасность потока и класс System.Random](#ThreadSafety)   
 [Создание разных типов случайных чисел](#Functionality)   
 [Подстановка собственный алгоритм](#Overriding)   
 [Как использовать System.Random для...](#Operations)   
 [Получить одну и ту же последовательность случайных значений](#Same)  
 [Получить уникальных последовательностей случайных значений](#Unique)  
 [Получить целых чисел в указанном диапазоне](#Range)  
 [Получить целых чисел с указанным числом знаков](#Digits)  
 [Получение значения с плавающей запятой в указанном диапазоне](#Floats)  
 [Создание случайного логическими значениями](#Boolean)  
 [Создание случайных 64-разрядных целых чисел.](#Long)  
 [Получение байт в указанном диапазоне](#Bytes)  
 [Получить элемент из массива или коллекции случайным образом](#Array)  
 [Получить уникальный элемент из массива или коллекции](#UniqueArray)  
  
<a name="Instantiate"></a>   
## <a name="instantiating-the-random-number-generator"></a>При создании экземпляра генератора случайных чисел  
 Создать экземпляр генератора случайных чисел, предоставляя начальное значение (начальное значение для алгоритм генерации псевдослучайных чисел) для <xref:System.Random.%23ctor%2A> конструктора класса.  Можно указать начальное значение, явно или неявно:  
  
-   <xref:System.Random.%23ctor%28System.Int32%29> Конструктор использует явную начальное значение, указываемое.  
  
-   <xref:System.Random.%23ctor> Конструктор использует системные часы для обеспечения начального значения. Это наиболее распространенным способом создания экземпляра генератора случайных чисел.  
  
 Если же начальное значение используется для разных <xref:System.Random> объекты, они получат та же последовательность случайных чисел. Это может быть полезно для создания набора тестов, который обрабатывает случайные значения или воспроизведения игры, которые являются производными свои данные от случайных чисел. Тем не менее, обратите внимание, что <xref:System.Random> объекты в процессах, под управлением различных версий платформы .NET Framework могут возвращать разные наборы случайных чисел, даже если они могут быть экземпляр которого создается без одинаковые начальные значения.  
  
 Для получения различных последовательностей случайных чисел, можно сделать начального значения зависят от времени, что позволяет создавать различные последовательности для каждого нового экземпляра <xref:System.Random>. Параметризованные <xref:System.Random.%23ctor%28System.Int32%29> конструктор может занять <xref:System.Int32> значение на основе количества тактов в текущее время, в то время как без параметров <xref:System.Random.%23ctor> конструктор использует системные часы для формирования начального значения. Тем не менее, поскольку часы конечное решение, с помощью конструктора без параметров для создания различных <xref:System.Random> объекты в закрытой последовательности создаются генераторы случайных чисел, производящих идентичные последовательности случайных чисел. В следующем примере показано как два <xref:System.Random> объекты, экземпляры которых создаются в быстрой последовательности, создают идентичные наборы случайных чисел. В большинстве операционных систем <xref:System.Random> объекты, созданные в течение 15 миллисекунд друг от друга, скорее всего, имеют одинаковые начальные значения.  
  
 [!code-cpp[System.Random#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random1.cpp#1)]
 [!code-csharp[System.Random#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random1.cs#1)]
 [!code-vb[System.Random#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random1.vb#1)]  
  
 Чтобы избежать этой проблемы, создайте один <xref:System.Random> объекта вместо нескольких объектов.  
  
<a name="Multiple"></a>   
## <a name="avoiding-multiple-instantiations"></a>Предотвращение несколько экземпляров  
 Инициализация двух генераторов случайных чисел в непрерывном цикле или в течение короткого промежутка времени создает два генераторы случайных чисел, можно производить идентичные последовательности случайных чисел. В большинстве случаев это не намерения разработчика и может привести к проблем с производительностью, поскольку создание и инициализация генератора случайных чисел является процессом относительно требовательными к ресурсам.  
  
 Для повышения производительности и избежать случайного создания отдельных генераторы случайных чисел, формирующих идентичные числовой последовательности, рекомендуется создать один <xref:System.Random> объект для генерации множества случайных чисел с течением времени, вместо создания новый <xref:System.Random> объекты для каждого случайного числа.  
  
 Однако <xref:System.Random> класса не потокобезопасным. При вызове метода <xref:System.Random> методы из различных потоков, следуйте рекомендациям, изложенным в следующем разделе.  
  
<a name="ThreadSafety"></a>   
## <a name="the-systemrandom-class-and-thread-safety"></a>Безопасность потока и класс System.Random  
 Вместо создания экземпляров отдельных <xref:System.Random> объектов, рекомендуется создавать отдельный <xref:System.Random> экземпляра для генерации случайных чисел, необходимых вашему приложению. Тем не менее <xref:System.Random> объекты не являются потокобезопасными. Если приложение вызывает <xref:System.Random> методы из нескольких потоков, необходимо использовать объект синхронизации, только один поток может получить доступ к генератора случайных чисел одновременно. Если вы не убедитесь, что <xref:System.Random> получить доступ к объекту в потокобезопасным способом, вызовы методов, которые возвращают случайных чисел возвращает значение 0.  
  
 В следующем примере C# [оператор lock](~/docs/csharp/language-reference/keywords/lock-statement.md) и Visual Basic [оператор SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) чтобы убедиться, что один генератора случайных чисел, осуществляется с 11 потоков в потокобезопасным способом. Каждый поток создает случайные числа 2 миллиона подсчитывает число случайных чисел и вычисляет их суммы и затем обновляет итоги для всех потоков после завершения выполнения.  
  
 [!code-cpp[System.Random#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/threadsafeex1.cpp#3)]
 [!code-csharp[System.Random#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex1.cs#3)]
 [!code-vb[System.Random#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex1.vb#3)]  
  
 В примере проверяется потокобезопасности одним из следующих способов:  
  
-   <xref:System.ThreadStaticAttribute> Атрибут используется для определения локальных для потока переменные, которые отслеживают общее число случайных чисел и их сумма для каждого потока.  
  
-   Блокировка ( `lock` инструкции на языке C# и `SyncLock` инструкции на языке Visual Basic) защищает доступ к переменным, общее количество и сумма всех случайных чисел, созданные во всех потоках.  
  
-   Семафор ( <xref:System.Threading.CountdownEvent> объекта) позволяет убедиться, что основной поток блокируется до всех остальных потоков завершения выполнения.  
  
-   В примере проверяется, является ли генератора случайных чисел поврежден, определяя ли два последовательных вызовов случайных чисел поколения методы возвращают значение 0. Если обнаружено повреждение в примере используется <xref:System.Threading.CancellationTokenSource> объект указывают, что все потоки должна быть отменена.  
  
-   Перед созданием каждой случайное число, каждый поток для проверки состояния <xref:System.Threading.CancellationToken> объекта. Если запрос на отмену в примере вызывается <xref:System.Threading.CancellationToken.ThrowIfCancellationRequested%2A?displayProperty=nameWithType> метода для отмены потока.  
  
 Следующий пример идентичен первому, за исключением того, что он использует <xref:System.Threading.Tasks.Task> объекта и лямбда-выражение, а не <xref:System.Threading.Thread> объектов.  
  
 [!code-csharp[System.Random#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/threadsafeex2.cs#4)]
 [!code-vb[System.Random#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/threadsafeex2.vb#4)]  
  
 Она отличается от первого примера, одним из следующих способов:  
  
-   Переменные для отслеживания количества случайных чисел и их сумму в каждой задаче локальны для задачи, поэтому нет необходимости использовать <xref:System.ThreadStaticAttribute> атрибута.  
  
-   Статический <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> метод используется, чтобы убедиться, что основной поток не завершилось до завершения всех задач. Нет необходимости для <xref:System.Threading.CountdownEvent> объекта.  
  
-   Исключение, полученное в результате отмены задачи будет отображена в <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> метод. В предыдущем примере он обрабатывается каждым потоком.  
  
<a name="Functionality"></a>   
## <a name="generating-different-types-of-random-numbers"></a>Создание разных типов случайных чисел  
 Генератор случайных чисел предоставляет методы, которые позволяют создавать следующие виды случайных чисел:  
  
-   Ряд <xref:System.Byte> значения. Определить количество байт, передавая массив присваивается количество элементов, метод для возврата <xref:System.Random.NextBytes%2A> метод. Следующий пример приводит к возникновению ошибки 20 байт.  
  
     [!code-cpp[System.Random#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextbytes1.cpp#5)]
     [!code-csharp[System.Random#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextbytes1.cs#5)]
     [!code-vb[System.Random#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextbytes1.vb#5)]  
  
-   Целое число. Можно выбрать, следует ли целое число от 0 до максимального значения (<xref:System.Int32.MaxValue?displayProperty=nameWithType> – 1) путем вызова <xref:System.Random.Next> метод, целое число от 0 до конкретного значения путем вызова <xref:System.Random.Next%28System.Int32%29> метода или целое число в пределах диапазона значений путем вызова <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>метод. В параметризованных перегрузки указанным максимальным значением является исчерпывающим; Максимальное число созданных является один меньше, чем указанное значение.  
  
     В следующем примере вызывается <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> метод, чтобы создать 10 случайных чисел от -10 до 10. Обратите внимание, что второй аргумент метода задает эксклюзивную верхнюю границу диапазона случайных значений, возвращаемая этим методом. Другими словами наибольшее целое число, которое этот метод может возвращать одно — меньше, чем это значение.  
  
     [!code-cpp[System.Random#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextex1.cpp#6)]
     [!code-csharp[System.Random#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextex1.cs#6)]
     [!code-vb[System.Random#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextex1.vb#6)]  
  
-   Одного значения с плавающей запятой от 0,0 в меньше 1,0 путем вызова <xref:System.Random.NextDouble%2A> метод. Эксклюзивную верхнюю границу случайное число, возвращенное методом-1, поэтому его фактическое верхняя граница — 0.99999999999999978. Следующий пример приводит к возникновению ошибки 10 случайных чисел с плавающей запятой.  
  
     [!code-cpp[System.Random#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/nextdoubleex1.cpp#7)]
     [!code-csharp[System.Random#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/nextdoubleex1.cs#7)]
     [!code-vb[System.Random#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/nextdoubleex1.vb#7)]  
  
> [!IMPORTANT]
>  <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> Метод позволяет указать диапазон возвращаемого случайного числа. Однако `maxValue` параметр, который задает верхний предел возвращаемое число является монопольной, не включительно, значение. Это означает, что вызов метода `Next(0, 100)` возвращает значение от 0 до 99, а не в диапазоне от 0 до 100.  
  
 Можно также использовать <xref:System.Random> класс для таких задач, как создание [случайных значений T:System.Boolean](#Boolean), создающий [значения случайных чисел с плавающей запятой в диапазоне, отличного от 0 до 1](#Floats), создания [случайных 64-битовых целых чисел](#Long), и [случайным образом получение уникального элемента из массива или коллекции](#UniqueArray). Для этих и других общих задач в разделе [использование System.Random для...](#Operations) раздел.  
  
<a name="Overriding"></a>   
## <a name="substituting-your-own-algorithm"></a>Подстановка собственный алгоритм  
 Можно реализовать путем наследования от случайного числа <xref:System.Random> класса и предоставление вашей алгоритм генерации случайных чисел. Чтобы реализовать собственный алгоритм, необходимо переопределить <xref:System.Random.Sample%2A> метод, который реализует алгоритм генерации случайных чисел. Следует также переопределить <xref:System.Random.Next>, <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29>, и <xref:System.Random.NextBytes%2A> методов, чтобы гарантировать, что они вызывают переопределенном <xref:System.Random.Sample%2A> метод. Не требуется переопределять <xref:System.Random.Next%28System.Int32%29> и <xref:System.Random.NextDouble%2A> методы.  
  
 Например, который является производным от <xref:System.Random> класса и изменяет его по умолчанию генератор псевдослучайных чисел, в разделе <xref:System.Random.Sample%2A> справочной странице.  
  
<a name="Operations"></a>   
## <a name="how-do-you-use-systemrandom-to"></a>Как использовать System.Random для...  
 В следующих разделах рассматриваются и обсуждаются образцы кода для некоторые способы использования случайных чисел в приложении может потребоваться.  
  
<a name="Same"></a>   
### <a name="retrieve-the-same-sequence-of-random-values"></a>Получить одну и ту же последовательность случайных значений  
 Иногда требуется получать одинаковые последовательности случайных чисел, в сценариях тестирования программного обеспечения, а также в игры. Тестирование с помощью того же последовательность случайных чисел дает возможность обнаружения регрессий и подтвердите исправления ошибок. С помощью той же последовательности случайное число в играх позволяет воспроизводить предыдущих игры.  
  
 Можно создать одну и ту же последовательность случайных чисел, указав то же начальное значение для <xref:System.Random.%23ctor%28System.Int32%29> конструктор. Начальное значение обеспечивает начальное значение для алгоритм генерации псевдослучайных чисел. В следующем примере используется 100100 как произвольный начальное значение для создания экземпляра <xref:System.Random> объекта, отображает 20 случайных значений с плавающей запятой и сохраняет начального значения. Затем он восстанавливает начальное значение, создает новый генератор случайных чисел и отображает одинаковые значения 20 случайных чисел с плавающей запятой.  Обратите внимание, что пример может давать различные последовательности случайных чисел при запуске в разных версиях платформы .NET Framework.  
  
 [!code-cpp[System.Random#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/same1.cpp#12)]
 [!code-csharp[System.Random#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/same1.cs#12)]
 [!code-vb[System.Random#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/same1.vb#12)]  
  
<a name="Unique"></a>   
### <a name="retrieve-unique-sequences-of-random-numbers"></a>Получить уникальный последовательность случайных чисел  
 Предоставление различных начальных значений для экземпляров <xref:System.Random> классу вызывает каждый генератора случайных чисел для создания различных последовательности значений. Укажите начальное значение явно с помощью вызова методов <xref:System.Random.%23ctor%28System.Int32%29> конструктор, или неявно путем вызова <xref:System.Random.%23ctor> конструктор. Большинство разработчиков вызвать конструктор без параметров, который использует системные часы. В следующем примере этот подход используется для создания двух <xref:System.Random> экземпляров. Каждый экземпляр выводит ряд 10 случайных целых чисел.  
  
 [!code-cpp[System.Random#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/unique.cpp#13)]
 [!code-csharp[System.Random#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/unique.cs#13)]
 [!code-vb[System.Random#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/unique.vb#13)]  
  
 Тем не менее из-за его конечное разрешения системных часов не может обнаружить разницу во времени, являющиеся приблизительно не превышает 15 миллисекунд. Таким образом Если код вызывает <xref:System.Random.%23ctor> перегрузку, чтобы создать два <xref:System.Random> объектов подряд, вы может случайно предоставлять объекты с одинаковые начальные значения. Чтобы увидеть это в предыдущем примере, закомментируйте <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> вызова метода и компиляции и снова запустите пример.  
  
 Чтобы предотвратить возникновение этой ситуации, рекомендуется создать один экземпляр <xref:System.Random> объекта, а не несколько сеансов. Однако, поскольку <xref:System.Random> не потокобезопасным, некоторые синхронизации устройства необходимо использовать при доступе к <xref:System.Random> из нескольких потоков; Дополнительные сведения см. в разделе [случайных безопасности потока и класс](#ThreadSafety) ранее в этом раздел. Кроме того, можно использовать механизм задержки, такие как <xref:System.Threading.Thread.Sleep%2A> метод, используемый в предыдущем примере, чтобы избежать возникновения экземпляров превышает 15 миллисекунд друг от друга.  
  
<a name="Range"></a>   
### <a name="retrieve-integers-in-a-specified-range"></a>Получить целых чисел в указанном диапазоне  
 Целые числа в указанном диапазоне можно получить, вызвав <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> метод, который позволяет задавать нижнюю и верхнюю границу номера хотелось бы генератора случайных чисел для возврата. Верхняя граница — монопольный, не включительно, значение. То есть он не включен в диапазон значений, возвращаемая этим методом. В следующем примере этот метод используется для формирования случайных целых чисел в диапазоне от -10 до 10. Обратите внимание, что он указывает 11, равное одному больше нужное значение в качестве значения для `maxValue` аргумента в вызове метода.  
  
 [!code-cpp[System.Random#15](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range1.cpp#15)]
 [!code-csharp[System.Random#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range1.cs#15)]
 [!code-vb[System.Random#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range1.vb#15)]  
  
<a name="Digits"></a>   
### <a name="retrieve-integers-with-a-specified-number-of-digits"></a>Получить целых чисел с указанным числом знаков  
 Можно вызвать <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> метод для извлечения значений и цифр с указанного количества десятичных разрядов. Например, для получения цифры с четырьмя знаками (номера, в диапазоне от 1000 до 9999), следует вызвать <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> метод с `minValue` значение 1000 и `maxValue` значение 10000, как показано в следующем примере.  
  
 [!code-cpp[System.Random#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/range2.cpp#16)]
 [!code-csharp[System.Random#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/range2.cs#16)]
 [!code-vb[System.Random#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/range2.vb#16)]  
  
<a name="Floats"></a>   
### <a name="retrieve-floating-point-values-in-a-specified-range"></a>Получение значения с плавающей запятой в указанном диапазоне  
 <xref:System.Random.NextDouble%2A> Метод возвращает случайных значений с плавающей запятой, диапазон от 0 до меньше 1. Тем не менее часто необходимо создавать случайные значения в другого диапазона ячеек.  
  
 Если интервал между минимальным и максимальным нужные значения 1, можно добавить к значению, возвращенному методом разницу между начальной необходимый интервал и 0 <xref:System.Random.NextDouble%2A> метод. В следующем примере выполняется этот параметр, чтобы создать 10 случайных чисел от -1 до 0.  
  
 [!code-cpp[System.Random#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange2.cpp#17)]
 [!code-csharp[System.Random#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange2.cs#17)]
 [!code-vb[System.Random#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange2.vb#17)]  
  
 Для генерации случайных чисел с плавающей запятой, нижняя граница — 0, но верхняя граница — больше, чем 1 (или, в случае отрицательных чисел, нижняя граница диапазона — меньше -1 и верхняя граница — 0), умножьте случайное число ненулевой границей. В следующем примере выполняется это для генерации случайных чисел с плавающей запятой 20 миллионов этого диапазона от 0 до <xref:System.Int64.MaxValue?displayProperty=nameWithType>. В также отображает распределение, случайных значений, созданной методом.  
  
 [!code-cpp[System.Random#18](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange1.cpp#18)]
 [!code-csharp[System.Random#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange1.cs#18)]
 [!code-vb[System.Random#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange1.vb#18)]  
  
 Для генерации случайных чисел с плавающей запятой двух произвольных значений, таких как <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> метод не для целых чисел, используйте следующую формулу:  
  
```csharp  
Random.NextDouble() * (maxValue – minValue) + minValue  
```  
  
 Следующий пример приводит к возникновению ошибки 1 миллион случайных чисел, начиная с версии 10.0 для 11.0 и отображает их распространения.  
  
 [!code-cpp[System.Random#19](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/doublerange3.cpp#19)]
 [!code-csharp[System.Random#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/doublerange3.cs#19)]
 [!code-vb[System.Random#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/doublerange3.vb#19)]  
  
<a name="Boolean"></a>   
### <a name="generate-random-boolean-values"></a>Создание случайного логическими значениями  
 <xref:System.Random> Класс не предоставляет методы, которые создают <xref:System.Boolean> значения. Тем не менее можно определить собственный класс или метод для этого. В следующем примере определяется класс, `BooleanGenerator`, с одним методом `NextBoolean`. `BooleanGenerator` Класса хранилищ <xref:System.Random> объект в качестве частной переменной. `NextBoolean` Вызовы метода <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> метод и передает результат в <xref:System.Convert.ToBoolean%28System.Int32%29?displayProperty=nameWithType> метод. Обратите внимание, что 2 используется в качестве аргумента для указания верхней границы случайного числа. Так как это значение монопольный, этот метод возвращает значение 0 или 1.  
  
 [!code-cpp[System.Random#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans1.cpp#8)]
 [!code-csharp[System.Random#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans1.cs#8)]
 [!code-vb[System.Random#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans1.vb#8)]  
  
 Вместо того чтобы создавать отдельный класс для создания случайных <xref:System.Boolean> просто определенные значения в примере один метод. В этом случае, однако <xref:System.Random> объект должен был определен как переменной уровня класса, чтобы избежать создания нового <xref:System.Random> экземпляра в каждом вызове метода. В Visual Basic экземпляра Random может определяться как [статических](~/docs/visual-basic/language-reference/modifiers/static.md) переменных в `NextBoolean` метод.  Следующий пример предоставляет реализацию.  
  
 [!code-cpp[System.Random#20](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/booleans2.cpp#20)]
 [!code-csharp[System.Random#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/booleans2.cs#20)]
 [!code-vb[System.Random#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/booleans2.vb#20)]  
  
<a name="Long"></a>   
### <a name="generate-random-64-bit-integers"></a>Создание случайных 64-разрядных целых чисел.  
 Перегруженные версии <xref:System.Random.Next%2A> метод возвращает 32-разрядных целых чисел. Однако в некоторых случаях может потребоваться для работы с 64-разрядных целых чисел. Это можно сделать следующим образом:  
  
1.  Вызовите <xref:System.Random.NextDouble%2A> метод для извлечения двойной точности с плавающей запятой.  
  
2.  Умножьте это значение с <xref:System.Int64.MaxValue?displayProperty=nameWithType>.  
  
 В следующем примере использует этот метод для создания 20 миллионов случайных длинных целых чисел и распределяет их в 10 равные группы. Затем вычисляет распределение, случайных чисел, сосчитав число в каждой группе от 0 до <xref:System.Int64.MaxValue?displayProperty=nameWithType>. Как показывают выходные данные примера, номера распространяются более или менее равномерно по диапазон типа данных long integer.  
  
 [!code-cpp[System.Random#14](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/long1.cpp#14)]
 [!code-csharp[System.Random#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/long1.cs#14)]
 [!code-vb[System.Random#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/long1.vb#14)]  
  
 Альтернативный метод, что использует поразрядные не создает действительно случайные числа. Этот метод вызывает <xref:System.Random.Next> для создания двух целых чисел, один по 32 сдвигает влево биты и схему или их вместе. Такой подход имеет два ограничения.  
  
1.  Поскольку бит 31 бита знака, значение в бит 31 полученное значение типа long integer всегда равно 0.  Это можно устранить путем формирования случайных 0 или 1, влево сдвигая 31 бита и настройке его с исходной случайных длинное целое число.  
  
2.  Если серьезно поскольку вероятность того, что значение, возвращаемое <xref:System.Random.Next> будет иметь значение 0, будет небольшим количеством случайных чисел в диапазоне от 0x0 0x00000000FFFFFFFF.  
  
<a name="Bytes"></a>   
### <a name="retrieve-bytes-in-a-specified-range"></a>Получение байт в указанном диапазоне  
 Перегруженные версии <xref:System.Random.Next%2A> метода позволяют указать диапазон случайных чисел, но <xref:System.Random.NextBytes%2A> метод — нет. В следующем примере реализуется `NextBytes` метод, который позволяет указать диапазон байтов, возвращенных. Он определяет `Random2` класс, производный от <xref:System.Random> и перегружает его `NextBytes` метод.  
  
 [!code-cpp[System.Random#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/bytes1.cpp#9)]
 [!code-csharp[System.Random#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/bytes1.cs#9)]
 [!code-vb[System.Random#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/bytes1.vb#9)]  
  
 `NextBytes(Byte[], Byte, Byte)` Метод создает оболочку для вызова <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> метод и указывает минимальное значение и один больше, чем максимальное значение (в этом случае 0 и 101), мы должны возвращаться в массиве байтов. Так как мы уверены, что целочисленные значения, возвращает <xref:System.Random.Next%2A> метод находятся в диапазоне от <xref:System.Byte> тип данных можно безопасно привести их (в C#) или преобразовать их (в Visual Basic) из целых чисел в байты.  
  
<a name="Array"></a>   
### <a name="retrieve-an-element-from-an-array-or-collection-at-random"></a>Получить элемент из массива или коллекции случайным образом  
 Случайные числа часто используются в качестве индексов для извлечения значений из массивы или коллекции. Для получения значения случайный индекс, можно вызвать <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> метод и использование, нижняя граница массива в качестве значения его `minValue` аргумент и на единицу больше, чем значение верхней границы массива в качестве значения его `maxValue` аргумент. Отсчитываемый от нуля массив, это эквивалентно его <xref:System.Array.Length%2A> свойства или единицу больше, чем значение, возвращаемое <xref:System.Array.GetUpperBound%2A?displayProperty=nameWithType> метод. В следующем примере случайным образом извлекается название города, в Соединенных Штатах из массив городов.  
  
 [!code-cpp[System.Random#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/array1.cpp#10)]
 [!code-csharp[System.Random#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/array1.cs#10)]
 [!code-vb[System.Random#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/array1.vb#10)]  
  
<a name="UniqueArray"></a>   
### <a name="retrieve-a-unique-element-from-an-array-or-collection"></a>Получить уникальный элемент из массива или коллекции  
 Генератор случайных чисел, всегда можно вернуться повторяющиеся значения. Диапазон номеров уменьшается или число значения, создаваемые становится больше, увеличивается вероятность дубликатов. Если случайные значения должны быть уникальными, дополнительные номера создаются для компенсации повторяющиеся значения, в результате чего все более низкую производительность.  
  
 Существует несколько способов для обработки этого сценария. Одно из распространенных решений является создание массива или коллекции, содержащей значения, которые нужно вернуть, а параллельный массив, который содержит случайных чисел с плавающей запятой. Второй массив заполняется случайных чисел во время создания первого массива, и <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> метод используется для сортировки первый массив с помощью значения в массиве, parallel.  
  
 Например при разработке игры, необходимо убедиться, что каждая карта используется только один раз. Вместо создания случайных чисел для извлечения карту и отслеживания ли уже были обработаны этой карты, можно создать массив, параллельный массиву случайных чисел, который может использоваться для сортировки колоде в. После колоде отсортирован, приложение можно использовать указатель для указания индекса Далее карт в колоде.  
  
 Этот подход показан в приведенном ниже примере. Он определяет `Card` класс, представляющий игральной карты и их `Dealer` класс, который обрабатывает перемешать карт. `Dealer` Конструктор класса заполняет два массива: `deck` массива, который имеет область видимости класса, которое представляет всех карт в колоде; и локальный `order` массив, который имеет то же число элементов, как `deck` массива и заполняется с помощью формируется случайным образом <xref:System.Double> значения.  <xref:System.Array.Sort%28System.Array%2CSystem.Array%29?displayProperty=nameWithType> Для сортировки затем вызывается метод `deck` массива на основе значений в `order` массива.  
  
 [!code-cpp[System.Random#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/uniquearray1.cpp#11)]
 [!code-csharp[System.Random#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/uniquearray1.cs#11)]
 [!code-vb[System.Random#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/uniquearray1.vb#11)]  
  
   
  
## Examples  
 В следующем примере создается один генератора случайных чисел и вызывает его <xref:System.Random.NextBytes%2A>, <xref:System.Random.Next%2A>, и <xref:System.Random.NextDouble%2A> методов для автоматического создания последовательности случайных чисел в разных диапазонах.  
  
 [!code-cpp[System.Random#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random/cpp/random2.cpp#2)]
 [!code-csharp[System.Random#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random/cs/Random2.cs#2)]
 [!code-vb[System.Random#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random/vb/Random2.vb#2)]  
  
 Следующий пример приводит к возникновению ошибки случайное целое число, которое используется как индекс для получения строковое значение из массива.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>В .NET Framework 1.0 и 1.1, минимальная реализация класса, производным от <see cref="T:System.Random" /> требовалось переопределение <see cref="M:System.Random.Sample" /> метод для определения новых или измененных алгоритм генерации случайных чисел. Производный класс может использовать реализацию базового класса <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32)" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, <see cref="M:System.Random.NextBytes(System.Byte[])" />, и <see cref="M:System.Random.NextDouble" /> методы для вызова реализации в производном классе <see cref="M:System.Random.Sample" /> метод.  В платформе .NET Framework 2.0 и более поздней версии, поведение <see cref="M:System.Random.Next" />, <see cref="M:System.Random.Next(System.Int32,System.Int32)" />, и <see cref="M:System.Random.NextBytes(System.Byte[])" /> методы были изменены, чтобы эти методы не обязательно вызывать реализации в производном классе <see cref="M:System.Random.Sample" /> метод. В результате классы, производные от <see cref="T:System.Random" /> , платформы .NET Framework 2.0 и более поздней версии, следует также переопределить эти три метода.</para>
    </block>
    <block subset="none" type="usage">
      <para>Реализации генератора случайных чисел в <see cref="T:System.Random" /> класса не обязательно будет остаются неизменными в разных основных версий платформы .NET Framework. В результате не предполагается, что одинаковые начальные значения приведет к той же последовательности псевдослучайных чисел в различных версиях платформы .NET Framework.</para>
    </block>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Random" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Random" /> с помощью зависимого от времени начального значения по умолчанию.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Начальное значение по умолчанию является производным от системных часов и конечное разрешением. Таким образом, разные <xref:System.Random> объекты, создаваемые в закрытой последовательности путем вызова конструктора по умолчанию будут иметь одинаковые начальное значение по умолчанию и, таким образом, будут производить идентичные наборы случайных чисел. Этой проблемы можно избежать, используя одну <xref:System.Random> объект для создания всех случайных чисел. Можно также обойти его, изменив начальное значение, возвращенное методом системных часов и явно предоставив это новое начальное значение для <xref:System.Random.%23ctor%28System.Int32%29> конструктор. Дополнительные сведения см. в разделе <xref:System.Random.%23ctor%28System.Int32%29> конструктор.  
  
 Если требуется генератора случайных чисел для создания случайную последовательность чисел, вызов этого конструктора. Для создания основных последовательность случайных чисел, который будет одинаковым для разных генераторов случайных чисел следует вызвать <xref:System.Random.%23ctor%28System.Int32%29> конструктор с предопределенной начальным значением. Это <xref:System.Random> перегрузку конструктора часто используется при тестировании приложений, использующих случайных чисел.  
  
 После создания экземпляра генератора случайных чисел вызове отдельных <xref:System.Random> методы, такие как <xref:System.Random.Next> или <xref:System.Random.NextDouble>, для генерации случайных чисел.  
  
   
  
## Examples  
 В следующем примере используется конструктор по умолчанию для создания экземпляра три <xref:System.Random> объектов и отображает последовательность случайных целых чисел. Так как первые две <xref:System.Random> объекты создаются в быстрой последовательности, их экземпляры создаются с помощью одинаковые начальные значения в зависимости от системных часов и, таким образом, они создают идентичную последовательность случайных чисел. С другой стороны, конструктор по умолчанию третьего <xref:System.Random> объект, называется задержкой 2 секунды, вызвать <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> метод. Так как это создает различные начальное значение для третьего <xref:System.Random> объекта, он создает различные последовательность случайных чисел.  
  
 [!code-csharp[System.Random.Ctor#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor1.cs#2)]
 [!code-vb[System.Random.Ctor#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Random (int Seed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 Seed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (Seed As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Random(int Seed);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="Seed" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="Seed">Число, используемое для вычисления начального значения последовательности псевдослучайных чисел. Если задано отрицательное число, используется его абсолютное значение.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.Random" /> с помощью указанного начального значения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Предоставление задать одинаковые начальные значения для разных <xref:System.Random> объектов вызывает все экземпляры будут производить идентичные последовательности случайных чисел. Часто это делается при тестировании приложений, которые используют генераторы случайных чисел.  
  
 Если приложение требует различные последовательности случайных чисел, вызовите этот конструктор несколько раз с различными начальными значениями. Один из способов получения уникального исходного значения — позволить его зависимых от времени. Например, извлекать его из системных часов, как <xref:System.Random.%23ctor> перегрузки. Однако системные часы не могут иметь достаточно разрешения для предоставления различных вызовов этот конструктор используется другое начальное значение. Это приведет генераторы случайных чисел, формирующих идентичные последовательности псевдослучайных чисел, как показано в первых двух <xref:System.Random> объектов в следующем примере. Чтобы избежать этого, применить алгоритм, изменяющий начальное значение в каждый вызов или вызов <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> метод, чтобы предоставить другое начальное значение каждого конструктора.  
  
 [!code-csharp[System.Random.Ctor#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor4.cs#4)]
 [!code-vb[System.Random.Ctor#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor4.vb#4)]  
  
 Другой вариант — создать один <xref:System.Random> , используется для формирования случайных чисел в приложении. Это дает немного более высокую производительность, так как при создании экземпляра генератора случайных чисел является довольно дорогой.  
  
   
  
## Examples  
 В следующем примере создается <xref:System.Random> объектов с помощью конструктора класса, которая принимает параметр начального значения и создает последовательность случайных целых чисел и чисел типа Double. В примере показано, что и та же последовательность создается при <xref:System.Random> попытку создать объект с помощью конструктора и начальное значение параметра.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Next">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает случайное целое число.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает неотрицательное случайное целое число.</summary>
        <returns>32-разрядное целое число со знаком, которое больше или равно нулю и меньше чем <see cref="F:System.Int32.MaxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%2A?displayProperty=nameWithType> Создает случайное число в диапазоне от 0 до меньше, чем <xref:System.Int32.MaxValue?displayProperty=nameWithType>. Чтобы создать случайное число в диапазоне от 0 до других положительного числа, используйте <xref:System.Random.Next%28System.Int32%29?displayProperty=nameWithType> перегрузки метода. Чтобы создать случайное число в пределах другой диапазон, используйте <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> перегрузки метода.  
  
   
  
## Examples  
 В следующем примере создается повторные вызовы <xref:System.Random.Next%2A> метод для создания определенного числа случайных чисел, заданного пользователем. <xref:System.Console.ReadLine%2A?displayProperty=nameWithType> Метод используется для получения входных данных клиента.  
  
 [!code-cpp[System.Random.Next#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next3.cpp#5)]
 [!code-csharp[System.Random.Next#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next3.cs#5)]
 [!code-vb[System.Random.Next#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next3.vb#5)]  
  
 Следующий пример является производным от класса <xref:System.Random> для создания последовательности случайных чисел, распределение которых отличается от равномерного распределения, созданные <xref:System.Random.Sample%2A> метод базового класса. Он переопределяет <xref:System.Random.Sample%2A> способ предоставления распределения случайных чисел и переопределяет <xref:System.Random.Next%2A?displayProperty=nameWithType> метод, используемый последовательность случайных чисел.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Начиная с .NET Framework версии 2.0, если производный класс <see cref="T:System.Random" /> и Переопределите <see cref="M:System.Random.Sample" /> метод, дистрибутив, предоставленный реализации в производном классе <see cref="M:System.Random.Sample" /> метода не используется в вызовах базового класса Реализация <see cref="M:System.Random.Next" /> метода. Вместо этого возвращается равномерного распределения базовыми <see cref="T:System.Random" /> используется класс. Это повышает общую производительность <see cref="T:System.Random" /> класса. Чтобы изменить это поведение, чтобы вызвать <see cref="M:System.Random.Sample" /> метод в производном классе, необходимо также переопределить <see cref="M:System.Random.Next" /> метод.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int maxValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxValue">Эксклюзивная верхняя граница создаваемого случайного числа. Значение <c>maxValue</c> должно быть больше или равно 0.</param>
        <summary>Возвращает неотрицательное случайное целое число, которое меньше максимально допустимого значения.</summary>
        <returns>32-разрядное целое число со знаком, большее или равное 0 и меньшее, чем <paramref name="maxValue" />. То есть диапазон возвращаемых значений включает в себя 0, но не включает <paramref name="maxValue" />. Однако если значение параметра <paramref name="maxValue" /> равно нулю, возвращается значение <paramref name="maxValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%28System.Int32%29> Перегрузка возвращает случайных целых чисел диапазона от 0 до `maxValue` – 1. Однако если `maxValue` равно 0, метод возвращает значение 0.  
  
   
  
## Examples  
 Следующий пример приводит к возникновению случайных целых чисел с помощью перегрузок <xref:System.Random.Next%2A> метод.  
  
 [!code-cpp[System.Random.Next#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next.cpp#1)]
 [!code-csharp[System.Random.Next#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next.cs#1)]
 [!code-vb[System.Random.Next#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next.vb#1)]  
  
 Следующий пример приводит к возникновению ошибки случайное целое число, которое используется как индекс для получения строковое значение из массива. Поскольку наибольший индекс массива имеет один меньше его длину, то значение <xref:System.Array.Length%2A?displayProperty=nameWithType> свойство будет задано как `maxValue` параметр.  
  
 [!code-cpp[System.Random.Next#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next1.cpp#3)]
 [!code-csharp[System.Random.Next#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next1.cs#3)]
 [!code-vb[System.Random.Next#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение параметра <paramref name="maxValue" /> меньше 0.</exception>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="Next">
      <MemberSignature Language="C#" Value="public virtual int Next (int minValue, int maxValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 Next(int32 minValue, int32 maxValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Next(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Next (minValue As Integer, maxValue As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int Next(int minValue, int maxValue);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="minValue" Type="System.Int32" />
        <Parameter Name="maxValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="minValue">Включенной нижний предел возвращаемого случайного числа.</param>
        <param name="maxValue">Исключенный верхний предел возвращаемого случайного числа. Значение <c>maxValue</c> должно быть больше или равно <c>minValue</c>.</param>
        <summary>Возвращает случайное целое число в указанном диапазоне.</summary>
        <returns>32-разрядное целое число со знаком большее или равное <paramref name="minValue" /> и меньше, чем <paramref name="maxValue" />; то есть, диапазон возвращаемого значения включает <paramref name="minValue" />, не включает <paramref name="maxValue" />. Если значение параметра <paramref name="minValue" /> равно значению параметра <paramref name="maxValue" />, то возвращается значение <paramref name="minValue" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29> Перегрузка возвращает случайных целых чисел из указанного диапазона `minValue` для `maxValue` – 1. Однако если `maxValue` равняется `minValue`, метод возвращает `minValue`.  
  
 В отличие от других перегрузок <xref:System.Random.Next%2A> метод, который возвращает только неотрицательные значения, этот метод возвращает отрицательное случайное целое число.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Random.Next%28System.Int32%2CSystem.Int32%29?displayProperty=nameWithType> метод для создания случайных целых чисел с тремя различными диапазонами. Обратите внимание, что точное выходные данные примера зависит от системным начальное значение, передаваемое <xref:System.Random> конструктора класса.  
  
 [!code-cpp[System.Random.Next#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next2.cpp#2)]
 [!code-csharp[System.Random.Next#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/Next2.cs#2)]
 [!code-vb[System.Random.Next#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next2.vb#2)]  
  
 Следующий пример приводит к возникновению ошибки случайное целое число, которое используется как индекс для получения строковое значение из массива. Поскольку наибольший индекс массива имеет один меньше его длину, то значение <xref:System.Array.Length%2A?displayProperty=nameWithType> свойство будет задано как `maxValue` параметр.  
  
 [!code-cpp[System.Random.Next#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Next/CPP/next4.cpp#4)]
 [!code-csharp[System.Random.Next#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Next/CS/next4.cs#4)]
 [!code-vb[System.Random.Next#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Next/VB/next4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Значение <paramref name="minValue" /> больше значения <paramref name="maxValue" />.</exception>
        <block subset="none" type="overrides">
          <para>Начиная с .NET Framework версии 2.0, если производный класс <see cref="T:System.Random" /> и Переопределите <see cref="M:System.Random.Sample" /> метод, дистрибутив, предоставленный реализации в производном классе <see cref="M:System.Random.Sample" /> метода не используется в вызовах базового класса Реализация <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> перегрузку метода, если разность <paramref name="minValue" /> и <paramref name="maxValue" /> параметров больше, чем <see cref="F:System.Int32.MaxValue" />. Вместо этого возвращается равномерного распределения базовыми <see cref="T:System.Random" /> используется класс. Это повышает общую производительность <see cref="T:System.Random" /> класса. Чтобы изменить это поведение, чтобы вызвать <see cref="M:System.Random.Sample" /> метод в производном классе, необходимо также переопределить <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> перегрузки метода.</para>
        </block>
        <altmember cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Массив байтов, содержащий случайные числа.</param>
        <summary>Заполняет элементы указанного массива байтов случайными числами.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Каждый элемент массива байтов равно случайное число, больше или равно 0 и меньше или равно <xref:System.Byte.MaxValue>.  
  
 Например, для генерации криптографически защищенного случайного числа, подходит для создания случайного пароля, используйте метод например <xref:System.Security.Cryptography.RNGCryptoServiceProvider.GetBytes%2A?displayProperty=nameWithType>.  
  
   
  
## Examples  
 В следующем примере демонстрируется использование <xref:System.Random.NextBytes%2A> метод для заполнения массива байтов случайных байтовых значений.  
  
 [!code-cpp[Classic Random.NextBytes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Random.NextBytes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/CS/source.cs#1)]
 [!code-vb[Classic Random.NextBytes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Random.NextBytes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="buffer" /> имеет значение <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>Начиная с .NET Framework версии 2.0, если производный класс <see cref="T:System.Random" /> и Переопределите <see cref="M:System.Random.Sample" /> метод, дистрибутив, предоставленный реализации в производном классе <see cref="M:System.Random.Sample" /> метода не используется в вызовах базового класса Реализация <see cref="M:System.Random.NextBytes(System.Byte[])" /> метода. Вместо этого возвращается равномерного распределения базовыми <see cref="T:System.Random" /> используется класс. Это повышает общую производительность <see cref="T:System.Random" /> класса. Чтобы изменить это поведение, чтобы вызвать <see cref="M:System.Random.Sample" /> метод в производном классе, необходимо также переопределить <see cref="M:System.Random.NextBytes(System.Byte[])" /> метод.</para>
        </block>
        <altmember cref="T:System.Byte" />
      </Docs>
    </Member>
    <Member MemberName="NextBytes">
      <MemberSignature Language="C#" Value="public virtual void NextBytes (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void NextBytes(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextBytes(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub NextBytes (buffer As Span(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void NextBytes(Span&lt;System::Byte&gt; buffer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="NextDouble">
      <MemberSignature Language="C#" Value="public virtual double NextDouble ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance float64 NextDouble() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.NextDouble" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function NextDouble () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual double NextDouble();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает случайное число с плавающей запятой, которое больше или равно 0,0 и меньше 1,0.</summary>
        <returns>Число двойной точности с плавающей запятой, которое больше или равно 0,0, и меньше 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Фактический верхней границы случайного числа, возвращаемого этим методом является 0.99999999999999978.  
  
 Для получения случайных значений с плавающей запятой в диапазоне, отличные от 0,0 до 1,0, обратитесь к разделу «Получать значения с плавающей запятой в указанном диапазоне» <xref:System.Random> разделе, посвященном классу.  
  
 Этот метод является открытой версией защищенного метода <xref:System.Random.Sample%2A>.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Random.NextDouble%2A> метод для создания последовательности случайных чисел типа Double.  
  
 [!code-cpp[System.Random.Ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Ctor/CPP/ctor.cpp#1)]
 [!code-csharp[System.Random.Ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Ctor/CS/ctor.cs#1)]
 [!code-vb[System.Random.Ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Ctor/VB/ctor.vb#1)]  
  
 В следующем примере вызывается <xref:System.Random.NextDouble%2A> метод для создания 100 случайных чисел и отображает их частоту распределение.  
  
 [!code-csharp[System.Random.NextDouble#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.random.nextdouble/cs/nextdouble1.cs#2)]
 [!code-vb[System.Random.NextDouble#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.random.nextdouble/vb/nextdouble1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sample">
      <MemberSignature Language="C#" Value="protected virtual double Sample ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance float64 Sample() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Random.Sample" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function Sample () As Double" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual double Sample();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает случайное число с плавающей запятой в диапазоне от 0,0 до 1,0.</summary>
        <returns>Число двойной точности с плавающей запятой, которое больше или равно 0,0, и меньше 1,0.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для создания другого распределения случайных или различных случайных числа принцип генератора, создайте класс, производный от <xref:System.Random> класса и переопределить <xref:System.Random.Sample%2A> метод.  
  
> [!IMPORTANT]
>  <xref:System.Random.Sample%2A> Метод `protected`, что означает, что он доступен только в пределах <xref:System.Random> класс и его производные классы. Чтобы получить случайное число между 0 и 1 из <xref:System.Random> экземпляра, вызовите метод <xref:System.Random.NextDouble%2A> метод.  
  
   
  
## Examples  
 Следующий пример является производным от класса <xref:System.Random> и переопределяет <xref:System.Random.Sample%2A> метод для создания распределения случайных чисел. Это распределение отличается от равномерного распределения, созданные <xref:System.Random.Sample%2A> метод базового класса.  
  
 [!code-cpp[System.Random.Sample#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Random.Sample/cpp/sampleex.cpp#1)]
 [!code-csharp[System.Random.Sample#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Random.Sample/CS/sample.cs#1)]
 [!code-vb[System.Random.Sample#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Random.Sample/VB/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Начиная с .NET Framework версии 2.0, если производный класс <see cref="T:System.Random" /> и Переопределите <see cref="M:System.Random.Sample" /> метод, дистрибутив, предоставленный реализации в производном классе <see cref="M:System.Random.Sample" /> метода не используется в вызовах базового класса Реализация следующих методов: - <see cref="M:System.Random.NextBytes(System.Byte[])" /> метод.  - <see cref="M:System.Random.Next" /> Метод.  - <see cref="M:System.Random.Next(System.Int32,System.Int32)" /> Метод, если (<paramref name="maxValue" /> - <paramref name="minValue" />) больше, чем <see cref="F:System.Int32.MaxValue" />.  Вместо этого равномерного распределения, предоставляемые базовый <see cref="T:System.Random" /> используется класс. Это повышает общую производительность <see cref="T:System.Random" /> класса. Чтобы изменить это поведение, чтобы вызвать реализацию <see cref="M:System.Random.Sample" /> метод в производном классе, необходимо также переопределить поведение этих трех элементов. Иллюстрация приведена в примере.</para>
        </block>
        <altmember cref="M:System.Random.NextDouble" />
      </Docs>
    </Member>
  </Members>
</Type>