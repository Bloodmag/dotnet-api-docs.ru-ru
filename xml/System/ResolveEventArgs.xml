<Type Name="ResolveEventArgs" FullName="System.ResolveEventArgs">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="e2985b3251ad8db5aed59f5b3d689e9e1101a65a" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36428619" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class ResolveEventArgs : EventArgs" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit ResolveEventArgs extends System.EventArgs" />
  <TypeSignature Language="DocId" Value="T:System.ResolveEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class ResolveEventArgs&#xA;Inherits EventArgs" />
  <TypeSignature Language="C++ CLI" Value="public ref class ResolveEventArgs : EventArgs" />
  <TypeSignature Language="F#" Value="type ResolveEventArgs = class&#xA;    inherit EventArgs" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет данные для событий разрешения загрузчика, например<see cref="E:System.AppDomain.TypeResolve" />, <see cref="E:System.AppDomain.ResourceResolve" />, <see cref="E:System.AppDomain.ReflectionOnlyAssemblyResolve" /> и <see cref="E:System.AppDomain.AssemblyResolve" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Если загрузчику не удается разрешить ссылку на сборку и обработчик предоставлен для соответствующего события разрешения загрузчика, вызывается событие и <xref:System.ResolveEventArgs> содержит сведения об элементе, для разрешения.  
  
-   <xref:System.ResolveEventArgs.Name%2A> Свойство содержит имя элемента для разрешения.  
  
-   Начиная с версии [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.ResolveEventArgs.RequestingAssembly%2A> свойство содержит сборку, который запросил сборку, которая может предоставить именованный элемент. Дополнительные сведения см. в описании свойства <xref:System.ResolveEventArgs.RequestingAssembly%2A>.  
  
 ]]></format>
    </remarks>
    <altmember cref="E:System.AppDomain.TypeResolve" />
    <altmember cref="E:System.AppDomain.ResourceResolve" />
    <altmember cref="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
    <altmember cref="E:System.AppDomain.AssemblyResolve" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ResolveEventArgs" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResolveEventArgs (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ResolveEventArgs.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResolveEventArgs(System::String ^ name);" />
      <MemberSignature Language="F#" Value="new ResolveEventArgs : string -&gt; ResolveEventArgs" Usage="new System.ResolveEventArgs name" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Имя разрешаемого элемента.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ResolveEventArgs" />, используя имя элемента для разрешения.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот конструктор обычно вызывается только средой CLR.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ResolveEventArgs (string name, System.Reflection.Assembly requestingAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Reflection.Assembly requestingAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ResolveEventArgs.#ctor(System.String,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, requestingAssembly As Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ResolveEventArgs(System::String ^ name, System::Reflection::Assembly ^ requestingAssembly);" />
      <MemberSignature Language="F#" Value="new ResolveEventArgs : string * System.Reflection.Assembly -&gt; ResolveEventArgs" Usage="new System.ResolveEventArgs (name, requestingAssembly)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="requestingAssembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="name">Имя разрешаемого элемента.</param>
        <param name="requestingAssembly">Сборка, зависимость которой необходимо разрешить.</param>
        <summary>Инициализирует новый экземпляр класса <see cref="T:System.ResolveEventArgs" />, используя имя элемента для разрешения и сборку, зависимость которой необходимо разрешить.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.ResolveEventArgs.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.ResolveEventArgs.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает имя разрешаемого элемента.</summary>
        <value>Имя разрешаемого элемента.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Для <xref:System.AppDomain.AssemblyResolve> событий, <xref:System.ResolveEventArgs.Name%2A> это имя сборки, до применения политики.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RequestingAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly RequestingAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly RequestingAssembly" />
      <MemberSignature Language="DocId" Value="P:System.ResolveEventArgs.RequestingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RequestingAssembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::Assembly ^ RequestingAssembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RequestingAssembly : System.Reflection.Assembly" Usage="System.ResolveEventArgs.RequestingAssembly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Получает сборку, зависимость которой необходимо разрешить.</summary>
        <value>Сборка, запросившая элемент, задается свойством <see cref="P:System.ResolveEventArgs.Name" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Сборки, который возвращается этим свойством — это сборка, не удалось разрешить элемент с указанным <xref:System.ResolveEventArgs.Name%2A> свойство, поскольку элемент не существует в этой сборке, в каком-либо из его зависимостей загрузки или любой зависимости смог найти загрузчик до проверки.  
  
 Предположим, например, текущей сборки использует <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> метод для загрузки сборки из каталог за пределами путь поиска сборок, чтобы использовать класс ЦС. Предположим, что дальнейшей класса ЦС использует класс CB, в сборке B и сборка A имеет время компиляции ссылку на сборку B, также расположенную вне путь поиска сборок. Если текущая сборка пытается создать экземпляр ЦС, загрузчик пытается разрешить ссылку на сборку B. Тем не менее поскольку сборка A был загружен с помощью <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> метод, загрузчик не удается разрешить зависимость. Если имеется обработчик для <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> события, события и <xref:System.ResolveEventArgs.RequestingAssembly%2A> результирующего <xref:System.ResolveEventArgs> объект содержит сборку A, так как сборка A является сборкой, отсутствует зависимость.  
  
 Семантика <xref:System.ResolveEventArgs.RequestingAssembly%2A> свойства различаются в зависимости от того, как запрашивающая сборка была загружена:  
  
-   Контекст загрузки: значение свойства может быть `null`. Контекст загрузки не зависит от порядка загрузки, а Идентификация запрашиваемой сборки не обязательно имеет смысл. Пример ненулевой происходит при <xref:System.Type.GetType%2A?displayProperty=nameWithType> вызывается метод и указанный тип неизвестен запрашивающей сборки или любого из его зависимостей.  
  
-   Контекст загрузки с: свойство может использоваться как подсказка поиска сборок, но обработчик событий не должны получить более одного запроса для имени заданной сборки.  
  
-   Контекст не (то есть, запрашивающей сборки был загружен с помощью <xref:System.Reflection.Assembly.LoadFile%2A?displayProperty=nameWithType> метода, как поток байтов или в смешанном режиме): можно использовать обработчик <xref:System.ResolveEventArgs.RequestingAssembly%2A> свойства для загрузки различных реализаций той же сборки на основе идентификатора объекта запрос сборки.  
  
 ]]></format>
        </remarks>
        <altmember cref="E:System.AppDomain.TypeResolve" />
        <altmember cref="E:System.AppDomain.ResourceResolve" />
        <altmember cref="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
        <altmember cref="E:System.AppDomain.AssemblyResolve" />
      </Docs>
    </Member>
  </Members>
</Type>