<Type Name="Single" FullName="System.Single">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="77e71ab8535b5bfefd6030c3226091df1a03daa3" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36429419" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit float32 extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;float32&gt;, class System.IConvertible, class System.IEquatable`1&lt;float32&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Single" />
  <TypeSignature Language="VB.NET" Value="Public Structure Single&#xA;Implements IComparable, IComparable(Of Single), IConvertible, IEquatable(Of Single), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Single : IComparable, IComparable&lt;float&gt;, IConvertible, IEquatable&lt;float&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type single = struct&#xA;    interface IFormattable&#xA;    interface IConvertible" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IConvertible</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Single&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Представляет число с плавающей запятой одиночной точности.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single> Тип значения представляет 32-разрядное число одинарной точности с диапазоном значений от минус 3, 402823E38 до плюс 3, 402823E38, а также положительный и отрицательный нуль, <xref:System.Single.PositiveInfinity>, <xref:System.Single.NegativeInfinity>и не является числом (<xref:System.Single.NaN>). Он предназначен для представления значений, которые слишком большой (например, расстояния между планеты или галактики) или очень малые (например молекулярные масса вещества в килограмм) и, часто являются неточными (например, расстояние от Земли до другой Солнечной системе ). <xref:System.Single> Тип соответствует стандарту IEC 60559:1989 (IEEE 754) стандартная двоичной арифметики с плавающей запятой.  
  
 В этом разделе:  
  
-   [Представление с плавающей запятой и точностью](#Precision)  
  
-   [Тестирование на равенство](#Equality)  
  
-   [Значения с плавающей запятой и исключений](#Exceptions)  
  
-   [Преобразование типов и одной структуры](#Conversion)  
  
-   [Функции с плавающей запятой](#Functionality)  
  
 <xref:System.Single?displayProperty=nameWithType> Предоставляет методы для сравнения экземпляров этого типа, для преобразования значения экземпляра в строковое представление, а также для преобразования строкового представления числа в экземпляр данного типа. Сведения о том, как коды спецификации формата управляют строковое представление типов значений см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md), [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md), и [настраиваемый числовой Строки форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
<a name="Precision"></a>   
## <a name="floating-point-representation-and-precision"></a>Представление с плавающей запятой и точностью  
 <xref:System.Single> Тип данных хранит значения с плавающей запятой одиночной точности в двоичном формате 32 бита, как показано в следующей таблице:  
  
|Отделение|Биты|  
|----------|----------|  
|Значащей части числа или мантиссы|0-22|  
|Показатель степени|23-30|  
|Знак (0 = положительное, 1 = отрицательное)|31|  
  
 Точно так же как десятичные дроби удается точно представить некоторые дробные значения (такие как 1/3 или <xref:System.Math.PI?displayProperty=nameWithType>), двоичные дроби удается представить некоторые дробных значений. Например 2-10, представленного точно.2 десятичной дробью, представленного.0011111001001100 виде бинарной доли, с помощью шаблона «1100» повторяющийся до бесконечности. В этом случае значение с плавающей запятой предоставляет представление неточный число, которое он представляет. Выполнения дополнительных математических операций на исходное значение с плавающей запятой часто увеличивает его недостаточной точности. Например если сравнение результатов умножения.3 по 10 и добавление.3 для.3 девяти раз, вы увидите этот выводятся менее точный результат, так как он содержит более восьми операций, чем умножения. Обратите внимание, что это несоответствие виден только в том случае, если отобразить два <xref:System.Single> значения с помощью символа «R» [строкой стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md), который, при необходимости отображает все 9 значащих цифр, поддерживаемые <xref:System.Single> тип.  
  
 [!code-csharp[System.Single.Structure#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation1.cs#3)]
 [!code-vb[System.Single.Structure#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation1.vb#3)]  
  
 Так как некоторые числа невозможно представить точно так, как доли двоичные значения, числа с плавающей запятой можно только приблизительные вещественных чисел.  
  
 Все числа с плавающей запятой имеют ограниченное число значащих цифр, который определяет точность значение с плавающей запятой аппроксимирует вещественным числом. Объект <xref:System.Single> значение имеет до 7 десятичных цифр, хотя для внутренних целей поддерживается до 9 цифр. Это означает, что некоторые операции с плавающей запятой не имеет точность, чтобы изменить значение с плавающей запятой. Следующий пример определяет большое значение с плавающей запятой одиночной точности, а затем добавляет произведение <xref:System.Single.Epsilon?displayProperty=nameWithType> и один септильонов к нему. Тем не менее продукт слишком мал для изменения исходного значения с плавающей запятой. Его наименее значащие цифры — тысячные доли, а наиболее значимую цифру в продукте — 1<sup>-312</sup>.  
  
 [!code-csharp[System.Single.Structure#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/representation2.cs#4)]
 [!code-vb[System.Single.Structure#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/representation2.vb#4)]  
  
 Ограниченную точность числа с плавающей запятой происходит следующее:  
  
-   Два числа с плавающей запятой, казаться равными при определенной точности могут не отличаются, поскольку их менее значащие цифры различаются. В следующем примере складываются ряд чисел и их сумма сравнивается с их ожидаемой суммы. Несмотря на то, что отображаются два значения должны совпадать, вызов `Equals` метод указывает, что они не являются.  
  
     [!code-csharp[System.Single.Structure#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist3.cs#6)]
     [!code-vb[System.Single.Structure#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist3.vb#6)]  
  
     Если изменить элементы формата в <xref:System.Console.WriteLine%28System.String%2CSystem.Object%2CSystem.Object%29?displayProperty=nameWithType> инструкции от `{0}` и `{1}` для `{0:R}` и `{1:R}` для отображения всех значащих цифр из двух <xref:System.Single> значения, очевидно, что эти два значения не равны из-за потери точности при выполнении операций сложения. В этом случае проблему можно разрешить путем вызова <xref:System.Math.Round%28System.Double%2CSystem.Int32%29?displayProperty=nameWithType> метод округления <xref:System.Single> значения до требуемой точности перед выполнением сравнения.  
  
-   Математическая операция или сравнение, использующий число с плавающей запятой может не дать разные результаты при использовании десятичного числа, так как двоичное число с плавающей запятой может не равняться десятичное число. Предыдущего примера показано это результат умножения.3 по 10 и добавление.3 для.3 девяти раз.  
  
     Если точность в математических операций с дробными важен, использовать <xref:System.Decimal> введите вместо <xref:System.Single> типа. Если точность числовых операций с целыми значениями за пределами диапазона <xref:System.Int64> или <xref:System.UInt64> типов важно использовать <xref:System.Numerics.BigInteger> типа.  
  
-   Значение может не кругового пути, если представлено числом с плавающей запятой. Если некоторой операции, преобразующей исходное число с плавающей запятой в другую форму, применения обратной операции полученный результат обратно в число с плавающей запятой и получившееся число равно исходное значение считается приема-передачи число с плавающей запятой. Обмен данными может завершиться ошибкой, так как один или несколько менее значащих цифр теряются или меняются в результате преобразования. В следующем примере три <xref:System.Single> значения преобразуются в строки и сохранены в файле. Как показывают выходные данные, несмотря на то, что значения выглядят идентичными, восстановленные значения не равны исходные значения.  
  
     [!code-csharp[System.Single.Structure#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist4a.cs#17)]
     [!code-vb[System.Single.Structure#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList4a.vb#17)]  
  
     В этом случае значения могут быть успешно обхода с помощью «G9» [строкой стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) для сохранения полная точность <xref:System.Single> значения, как показано в следующем примере.  
  
     [!code-csharp[System.Single.Structure#18](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/PrecisionList5a.cs#18)]
     [!code-vb[System.Single.Structure#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/PrecisionList5a.vb#18)]  
  
-   <xref:System.Single> значения имеют меньшую точность, чем <xref:System.Double> значения. Объект <xref:System.Single> значение, которое преобразуется в первый взгляд эквивалентные <xref:System.Double> часто не равно <xref:System.Double> значение из-за различия в точности. В следующем примере результат деления идентичные операций присваивается <xref:System.Double> значение и <xref:System.Single> значение. После <xref:System.Single> значение приводится к <xref:System.Double>, сравнение двух значений показывает, что они не равны.  
  
     [!code-csharp[System.Double.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.double.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Double.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.double.structure/vb/precisionlist1.vb#5)]  
  
     Чтобы избежать этой проблемы, либо используйте <xref:System.Double> вместо типа данных <xref:System.Single> тип данных, или используйте <xref:System.Math.Round%2A> метод, чтобы оба значения имеют такую же точность.  
  
<a name="Equality"></a>   
## <a name="testing-for-equality"></a>Тестирование на равенство  
 Одинаковыми, два <xref:System.Single> значения должны представлять одинаковые значения. Однако из-за различия в точности между значениями, или из-за потери точности, одно или оба значения, значения с плавающей запятой, которые должны быть идентичными часто оказываются считались из-за различий в их менее значащие цифры. В результате вызовы <xref:System.Single.Equals%2A> метод, чтобы определить, равны ли два значения или вызовы <xref:System.Single.CompareTo%2A> метод, чтобы определить связь между двумя <xref:System.Single> значения, часто привести к непредвиденным результатам. Это видно в следующем примере, где два внешне равно <xref:System.Single> значения оказываются считались, так как первое значение 7-знаковая точность, а второе значение имеет 9.  
  
 [!code-csharp[System.Single.Structure#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison1.cs#9)]
 [!code-vb[System.Single.Structure#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison1.vb#9)]  
  
 Вычисленные значения, выполните разных путей кода и который осуществляется различными способами, часто доказать, что были не эквивалентны. В следующем примере один <xref:System.Single> значение возводится в квадрат, а затем вычисляется квадратный корень восстановить исходное значение. Второй <xref:System.Single> умноженное 3.51 и перед квадратный корень из результат делится 3.51, чтобы восстановить исходное значение в квадрате. Несмотря на то, что отображаются два значения идентичными, вызов <xref:System.Single.Equals%28System.Single%29> метод указывает, что они не равны. С помощью строки стандартного формата «G9» для возврата результирующую строку, отображает все значимые цифры каждого <xref:System.Single> значение показывает, что второе значение —.0000000000001 меньше, чем первый.  
  
 [!code-csharp[System.Single.Structure#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison2.cs#10)]
 [!code-vb[System.Single.Structure#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison2.vb#10)]  
  
 В случаях, когда потеря точности может повлиять на результат сравнения, можно использовать следующие методы вместо вызова метода <xref:System.Single.Equals%2A> или <xref:System.Single.CompareTo%2A> метод:  
  
-   Вызовите <xref:System.Math.Round%2A?displayProperty=nameWithType> метод, чтобы гарантировать, что оба значения имеют такую же точность. В следующем примере изменяется в предыдущем примере, чтобы использовать этот подход, чтобы эквивалентны двух дробных значений.  
  
     [!code-csharp[System.Single.Structure#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison3.cs#11)]
     [!code-vb[System.Single.Structure#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison3.vb#11)]  
  
     Обратите внимание, что проблема точность по-прежнему применяется округление средние значения. Дополнительные сведения см. в описании метода <xref:System.Math.Round%28System.Double%2CSystem.Int32%2CSystem.MidpointRounding%29?displayProperty=nameWithType>.  
  
-   Проверка на равенство приблизительное вместо проверки на равенство. Этот способ требует определения либо абсолютной суммы, по которому два значения могут отличаться, но по-прежнему совпадать, или определить относительную величину, на который меньшее значение может отличаться от большего значения.  
  
    > [!WARNING]
    >  <xref:System.Single.Epsilon?displayProperty=nameWithType> Иногда используется в качестве меры абсолютное расстояние между двумя <xref:System.Single> значениями при проверки на равенство.  Тем не менее <xref:System.Single.Epsilon?displayProperty=nameWithType> измеряет наименьшее возможное значение, которое может быть добавляется или вычитается из, <xref:System.Single> , значение которого равно нулю. Большинство положительные и отрицательные <xref:System.Single> значений, значение <xref:System.Single.Epsilon?displayProperty=nameWithType> слишком мал, чтобы быть обнаруженным. Таким образом за исключением значений, равно нулю, не рекомендуется использовать его в тесты на равенство.  
  
     В следующем примере используется последний подход для определения `IsApproximatelyEqual` метод, который проверяет относительная разница между двумя значениями. Результат вызова также сопоставляются `IsApproximatelyEqual` метод и <xref:System.Single.Equals%28System.Single%29> метод.  
  
     [!code-csharp[System.Single.Structure#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/comparison4.cs#12)]
     [!code-vb[System.Single.Structure#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/comparison4.vb#12)]  
  
<a name="Exceptions"></a>   
## <a name="floating-point-values-and-exceptions"></a>Значения с плавающей запятой и исключений  
 Операции со значениями с плавающей запятой не вызывают исключений, в отличие от операций с целочисленными типами, которые создают исключения в случаях недопустимые операции, например при делении на ноль или переполнения.  Вместо этого в этих случаях результат операции с плавающей запятой является ноль, плюс бесконечности, отрицательной бесконечностью или не является числом (NaN):  
  
-   Если результат операции с плавающей запятой слишком мал для конечного формата, результат равен нулю. Это может произойти при умножении двух очень небольшого числа с плавающей запятой, как показано в следующем примере.  
  
     [!code-csharp[System.Single.Structure#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional1.cs#1)]
     [!code-vb[System.Single.Structure#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional1.vb#1)]  
  
-   При величина результата операции с плавающей точкой выходит за пределы типа конечного формата, результатом операции является <xref:System.Single.PositiveInfinity> или <xref:System.Single.NegativeInfinity>, в зависимости от знака результата. Результат операции, которая вызывает переполнение <xref:System.Single.MaxValue?displayProperty=nameWithType> — <xref:System.Single.PositiveInfinity>и результат операции, которая вызывает переполнение <xref:System.Single.MinValue?displayProperty=nameWithType> — <xref:System.Single.NegativeInfinity>, как показано в следующем примере.  
  
     [!code-csharp[System.Single.Structure#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/exceptional2.cs#2)]
     [!code-vb[System.Single.Structure#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/exceptional2.vb#2)]  
  
     <xref:System.Single.PositiveInfinity> также происходит с деление на ноль с положительным делимое, и <xref:System.Single.NegativeInfinity> полученный в результате деления на ноль с отрицательным делимое.  
  
-   Если операции с плавающей запятой недопустимо, результат операции становится <xref:System.Single.NaN>. Например <xref:System.Single.NaN> результатов из следующих операций:  
  
    -   Деление на ноль с делимое равно нулю. Обратите внимание, в других случаях деления по нулевой результат, либо <xref:System.Single.PositiveInfinity> или <xref:System.Single.NegativeInfinity>.  
  
    -   Все операции с плавающей запятой с недопустимые входные данные. Например, предпринимается попытка найти возвращает квадратный корень из отрицательное значение <xref:System.Single.NaN>.  
  
    -   Любая операция с аргументом, значение которого является <xref:System.Single.NaN?displayProperty=nameWithType>.  
  
<a name="Conversion"></a>   
## <a name="type-conversions-and-the-single-structure"></a>Преобразования типов и одной структуры  
 <xref:System.Single> Структура не определяет любые операторы явного или неявного преобразования; вместо этого преобразования реализуются с помощью компилятора.  
  
 В следующей таблице перечислены возможные преобразования значения из других числовых типов-примитивов для <xref:System.Single> значение, он также указывает ли расширяющее или сужающее преобразование и ли итоговое <xref:System.Single> , возможно, меньшей точностью, чем исходное значение.  
  
|Допустимо ли преобразование из|Расширяющие и сужающие|Возможна потеря точности|  
|---------------------|-------------------------|--------------------------------|  
|<xref:System.Byte>|Widening|Нет|  
|<xref:System.Decimal>|Widening<br /><br /> Обратите внимание, что C# требует оператора приведения.|Да. <xref:System.Decimal> поддерживает 29 десятичных цифр; <xref:System.Single> поддерживает 9.|  
|<xref:System.Double>|Сужение; значения вне диапазона, преобразуются в <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> или <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.|Да. <xref:System.Double> поддерживает десятичных цифр увеличивается до 17; <xref:System.Single> поддерживает 9.|  
|<xref:System.Int16>|Widening|Нет|  
|<xref:System.Int32>|Widening|Да. <xref:System.Int32> поддерживает 10 десятичных цифр; <xref:System.Single> поддерживает 9.|  
|<xref:System.Int64>|Widening|Да. <xref:System.Int64> поддерживает 19 цифр точности; <xref:System.Single> поддерживает 9.|  
|<xref:System.SByte>|Widening|Нет|  
|<xref:System.UInt16>|Widening|Нет|  
|<xref:System.UInt32>|Widening|Да. <xref:System.UInt32> поддерживает 10 десятичных цифр; <xref:System.Single> поддерживает 9.|  
|<xref:System.UInt64>|Widening|Да. <xref:System.Int64> поддерживает 20 десятичных цифр; <xref:System.Single> поддерживает 9.|  
  
 В следующем примере преобразуется минимальное или максимальное значение другие числовые типы-примитивы <xref:System.Single> значение.  
  
 [!code-csharp[System.Single.Structure#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert1.cs#20)]
 [!code-vb[System.Single.Structure#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert1.vb#20)]  
  
 Кроме того <xref:System.Double> значения <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, и <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> преобразовать для <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, и <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>соответственно.  
  
 Обратите внимание, что преобразование значения некоторых числовых типов к <xref:System.Single> значение может приводить к потере точности. Как показано в примере, возможна потеря точности при преобразовании <xref:System.Decimal>, <xref:System.Double>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.UInt32>, и <xref:System.UInt64> значения <xref:System.Single> значения.  
  
 Преобразование <xref:System.Single> значение <xref:System.Double> расширяющие преобразования. Преобразование может привести к потере точности, если <xref:System.Double> тип не имеет точное представление для <xref:System.Single> значение.  
  
 Преобразование <xref:System.Single> значение любой тип-примитив числовое значение, отличное от <xref:System.Double> сужающего преобразования и требует оператора приведения (в C#) или метод преобразования (в Visual Basic). Значения, которые находятся вне диапазона целевого типа данных, определенных для целевого типа `MinValue` и `MaxValue` поведение свойств, как показано в следующей таблице.  
  
|Тип результирующего значения|Результат|  
|-----------------|------------|  
|Любой целочисленный тип|<xref:System.OverflowException> Исключение, если преобразование выполняется в проверяемом контексте.<br /><br /> Если преобразование выполняется в непроверенном контексте (по умолчанию в C#), операции преобразования выполняется успешно, но произойдет переполнение значения.|  
|<xref:System.Decimal>|<xref:System.OverflowException> Исключения,|  
  
 Кроме того <xref:System.Single.NaN?displayProperty=nameWithType>, <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>, и <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> throw <xref:System.OverflowException> для преобразования в целые числа в проверяемом контексте, но эти значения переполнения при преобразовании к целым числам в непроверенном контексте. Для преобразования в <xref:System.Decimal>, всегда возникает исключение <xref:System.OverflowException>. Для преобразования в <xref:System.Double>, они преобразуются в <xref:System.Double.NaN?displayProperty=nameWithType>, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, и <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>соответственно.  
  
 Обратите внимание, что с может привести к потере точности <xref:System.Single> значения другого числового типа. В случае преобразование не интегрированные <xref:System.Single> значения, как показывают выходные данные примера, дробная будут потеряны при <xref:System.Single> значение округляется (как в Visual Basic) или усечен (как в C#). Для преобразования в <xref:System.Decimal> значения, <xref:System.Single> value не может иметь точное представление в целевой тип данных.  
  
 В следующем примере преобразуется ряд <xref:System.Single> значения в нескольких числовых типов. Преобразования выполняются в проверяемом контексте в Visual Basic (по умолчанию) и в C# (из-за [проверяется](~/docs/csharp/language-reference/keywords/checked.md) ключевое слово). Выходные данные примера показан результат преобразования в обоих checked непроверяемом контексте. Преобразование может быть выполнено в непроверенном контексте в Visual Basic при компиляции с `/removeintchecks+` переключатель компилятора и C#, преобразуйте `checked` инструкции.  
  
 [!code-csharp[System.Single.Structure#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/convert2.cs#21)]
 [!code-vb[System.Single.Structure#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/convert2.vb#21)]  
  
 Дополнительные сведения о преобразовании числовых типов см. в разделе [преобразование типов в .NET Framework](~/docs/standard/base-types/type-conversion.md) и [таблицы преобразования типов](~/docs/standard/base-types/conversion-tables.md).  
  
<a name="Functionality"></a>   
## <a name="floating-point-functionality"></a>Функции с плавающей запятой  
 <xref:System.Single> Структуры и связанных типов предоставляют методы для выполнения операций следующих категорий:  
  
-   **Сравнение значений**. Можно вызвать <xref:System.Single.Equals%2A> метод, чтобы определить, является ли два <xref:System.Single> значения равны или <xref:System.Single.CompareTo%2A> метод, чтобы определить связь между двумя значениями.  
  
     <xref:System.Single> Структура также поддерживает полный набор операторов сравнения. Например можно проверки на равенство или неравенство или определить, является ли одно значение больше или равно другому значению. Если один из операндов является <xref:System.Double>, <xref:System.Single> значение преобразуется в <xref:System.Double> перед выполнением сравнения. Если один из операндов — это целочисленный тип, он преобразуется в <xref:System.Single> перед выполнением сравнения. Несмотря на то, что они расширяющие преобразования, они могут приводить к потере точности.  
  
    > [!WARNING]
    >  Из-за различия в точности два <xref:System.Single> значения, которые должны быть равны может оказываются считались, что влияет на результат сравнения. В разделе [проверки на равенство](#Equality) Дополнительные сведения о сравнении двух <xref:System.Single> значения.  
  
     Можно также вызвать <xref:System.Single.IsNaN%2A>, <xref:System.Single.IsInfinity%2A>, <xref:System.Single.IsPositiveInfinity%2A>, и <xref:System.Single.IsNegativeInfinity%2A> методов для проверки на эти особые значения.  
  
-   **Математические операции**. Стандартные арифметические операции, такие как сложение, вычитание, умножение и деление реализуются языковые компиляторы и инструкции языка CIL (Common Intermediate), а не <xref:System.Single> методы. Если другой операнд Математическая операция <xref:System.Double>, <xref:System.Single> преобразуется в <xref:System.Double> до выполнения операции и результат операции также <xref:System.Double> значение. Если другой операнд имеет целый тип, он преобразуется в <xref:System.Single> до выполнения операции и результат операции также <xref:System.Single> значение.  
  
     Другие математические операции можно выполнять путем вызова `static` (`Shared` в Visual Basic) методов в <xref:System.Math?displayProperty=nameWithType> класса. К ним относятся дополнительные методы, обычно используется для выполнения арифметических действий (таких как <xref:System.Math.Abs%2A?displayProperty=nameWithType>, <xref:System.Math.Sign%2A?displayProperty=nameWithType>, и <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>), geometry (такие как <xref:System.Math.Cos%2A?displayProperty=nameWithType> и <xref:System.Math.Sin%2A?displayProperty=nameWithType>) и вычисления (такие как <xref:System.Math.Log%2A?displayProperty=nameWithType>).  Во всех случаях <xref:System.Single> значение преобразуется в <xref:System.Double>.  
  
     Можно управлять отдельными битами <xref:System.Single> значение. <xref:System.BitConverter.GetBytes%28System.Single%29?displayProperty=nameWithType> Метод возвращает его битов в массив байтов.  Передав этот массив байтов для <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType> метода, вы также можете сохранить <xref:System.Single> значение битового шаблона в 32-разрядное целое число.  
  
-   **Округление**. Округление для часто используется как способ уменьшить влияние различия между значениями, вызванные неполадками представление с плавающей запятой и точностью. Можно провести округление <xref:System.Single> , вызвав <xref:System.Math.Round%2A?displayProperty=nameWithType> метод. Тем не менее, обратите внимание, что <xref:System.Single> значение преобразуется в <xref:System.Double> перед вызывается метод, и преобразование может приводить к потере точности.  
  
-   **Форматирование**. Вы можете преобразовать <xref:System.Single> значение в строковое представление, вызвав <xref:System.Single.ToString%2A> метода или с помощью [составное форматирование](~/docs/standard/base-types/composite-formatting.md) компонентов. Сведения об управлении строковое представление значения с плавающей запятой в строках формата см. в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md) разделы.  
  
-   **Разбор строк**. Можно преобразовать строковое представление значения с плавающей запятой для <xref:System.Single> , вызвав <xref:System.Single.Parse%2A> или <xref:System.Single.TryParse%2A> метод. Если операция анализа завершается ошибкой, <xref:System.Single.Parse%2A> метод создает исключение, в то время как <xref:System.Single.TryParse%2A> возвращает `false`.  
  
-   **Преобразование типов**. <xref:System.Single> Структура предоставляет явной реализации интерфейса для <xref:System.IConvertible> интерфейс, который поддерживает преобразование между любые две стандартные типы данных .NET Framework. Языковые компиляторы также поддерживает неявное преобразование значений для всех других стандартных числовых типов, за исключением преобразование <xref:System.Double> для <xref:System.Single> значения. Преобразование значения из любой стандартный числовой тип, отличный от <xref:System.Double> для <xref:System.Single> расширяющие преобразования и не требует использования явное приведение оператор или преобразование методов.  
  
     Однако преобразования 32-разрядных и 64-разрядных целочисленных значений можно привести к потере точности. В следующей таблице перечислены различия в точности для 32-разрядных, 64-разрядная версия, и <xref:System.Double> типы:  
  
    |Тип|Максимальная точность (в десятичных цифр)|Внутренняя точность (в десятичных цифр)|  
    |----------|---------------------------------------------|----------------------------------------------|  
    |<xref:System.Double>|15|17|  
    |<xref:System.Int32> и <xref:System.UInt32>.|10|10|  
    |<xref:System.Int64> и <xref:System.UInt64>.|19|19|  
    |<xref:System.Single>|7|9|  
  
     Чаще всего проблема точности влияет на <xref:System.Single> значения, которые преобразуются в <xref:System.Double> значения. В следующем примере, полученных при операции деления одинаковые значения не равны, так как одно из значений является обычной точностью значение с плавающей запятой, преобразуется в <xref:System.Double>.  
  
     [!code-csharp[System.Single.Structure#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.structure/cs/precisionlist1.cs#5)]
     [!code-vb[System.Single.Structure#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.structure/vb/precisionlist1.vb#5)]  
  
 ]]></format>
    </remarks>
    <threadsafe>Все члены этого типа являются потокобезопасными. Элементы, используемые для изменения состояния экземпляра на самом деле возвращается новый экземпляр инициализирован с новым значением. Как с любым другим типом, чтения и записи к общей переменной, содержащий экземпляр этого типа должны быть защищены блокировкой, чтобы гарантировать потокобезопасность.</threadsafe>
    <altmember cref="T:System.Decimal" />
    <altmember cref="T:System.Double" />
  </Docs>
  <Members>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Сравнивает данный экземпляр с указанным объектом или другим экземпляром <see cref="T:System.Single" /> и возвращает целое число, которое показывает, как соотносится значение данного экземпляра со значением другого экземпляра <see cref="T:System.Single" />: меньше, равняется или больше него.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="single.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">Объект для сравнения или значение <see langword="null" />.</param>
        <summary>Сравнивает данный экземпляр с указанным объектом и возвращает целое число, которое показывает, является ли значение данного экземпляра меньше, больше или равно значению заданного объекта.</summary>
        <returns>Знаковое число, представляющее относительные значения этого экземпляра и параметра <paramref name="value" />.  
  
 <list type="table"><listheader><term> Возвращаемое значение  </term><description> Описание  </description></listheader><item><term> Меньше нуля  </term><description> Этот экземпляр меньше <paramref name="value" />. -или- Этот экземпляр не является числом (<see cref="F:System.Single.NaN" />), а <paramref name="value" /> является числом.  </description></item><item><term> Ноль  </term><description> Этот экземпляр равен <paramref name="value" />. -или- Этот экземпляр и значение не являются числом (<see cref="F:System.Single.NaN" />), <see cref="F:System.Single.PositiveInfinity" /> или <see cref="F:System.Single.NegativeInfinity" />.  </description></item><item><term> Больше нуля  </term><description> Этот экземпляр больше <paramref name="value" />. -или- Этот экземпляр является числом, а <paramref name="value" /> не является числом (<see cref="F:System.Single.NaN" />). -или- <paramref name="value" /> имеет значение <see langword="null" />.  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `value` Параметр должен быть `null` или экземпляром <xref:System.Single>; в противном случае создается исключение. Любой экземпляр <xref:System.Single>, независимо от его значения, считается больше, чем `null`.  
  
 Значения должны быть идентичными одинаковыми. Особенно в том случае, если значения с плавающей запятой, зависят от множества математических операций, чаще всего для к потере точности, а также для значений, чтобы быть практически идентичны, за исключением их менее значащие цифры. По этой причине возвращаемое значение <xref:System.Single.CompareTo%2A> метод может показаться странным, время от времени. Например умножение по определенному значению следуют деления тем же значением должен создать исходное значение, но в следующем примере вычисляемое значение оказывается больше, чем исходное значение. Отображение всех значащих цифр из двух значений с помощью символа «R» [строкой стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) указывает, что вычисляемое значение отличается от исходного значения в его менее значащих цифр. Сведения об обработке такие сравнения см. в разделе «Примечания» <xref:System.Single.Equals%28System.Single%29> метод.  
  
 [!code-csharp[System.Single.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto3.cs#2)]
 [!code-vb[System.Single.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto3.vb#2)]  
  
 Этот метод реализуется для поддержки <xref:System.IComparable> интерфейса. Обратите внимание, что, несмотря на то что <xref:System.Single.NaN> не считается равным другому <xref:System.Single.NaN> (даже самого) <xref:System.IComparable> требуется интерфейс `A.CompareTo(A)` возвращают нуль.  
  
## <a name="precision-in-comparisons"></a>Точность при сравнении  
 Точность чисел с плавающей запятой за пределы задокументированной точности зависит от реализации и версии платформы .NET Framework. Таким образом сравнения двух определенных чисел может меняться в различных версиях платформы .NET Framework точность внутреннего представления чисел может измениться.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.Single.CompareTo%2A> метод.  
  
 [!code-cpp[System.Single#16](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#16)]
 [!code-csharp[System.Single#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#16)]
 [!code-vb[System.Single#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#16)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="value" /> не является объектом <see cref="T:System.Single" />.</exception>
        <altmember cref="M:System.Single.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.CompareTo(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (value As Single) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(float value);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : single -&gt; int&#xA;override this.CompareTo : single -&gt; int" Usage="single.CompareTo value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Сравниваемое число с плавающей запятой одиночной точности.</param>
        <summary>Сравнивает данный экземпляр с заданным числом с плавающей запятой одиночной точности и возвращает целое число, которое показывает, является ли значение данного экземпляра меньше, больше или равным значению заданного числа с плавающей запятой одиночной точности.</summary>
        <returns>Знаковое число, представляющее относительные значения этого экземпляра и параметра <paramref name="value" />.  
  
 <list type="table"><listheader><term> Возвращаемое значение  </term><description> Описание  </description></listheader><item><term> Меньше нуля  </term><description> Этот экземпляр меньше <paramref name="value" />. -или- Этот экземпляр не является числом (<see cref="F:System.Single.NaN" />), а <paramref name="value" /> является числом.  </description></item><item><term> Ноль  </term><description> Этот экземпляр равен <paramref name="value" />. -или- Этот экземпляр и <paramref name="value" /> не являются числом (<see cref="F:System.Single.NaN" />), <see cref="F:System.Single.PositiveInfinity" /> или <see cref="F:System.Single.NegativeInfinity" />.  </description></item><item><term> Больше нуля  </term><description> Этот экземпляр больше <paramref name="value" />. -или- Этот экземпляр является числом, а <paramref name="value" /> не является числом (<see cref="F:System.Single.NaN" />).  </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значения должны быть идентичными одинаковыми. Чаще всего для значений с плавающей запятой к потере точности и стать почти те же, за исключением их менее значащие цифры, особенно в том случае, если значения зависят от множества математических операций. По этой причине возвращаемое значение <xref:System.Single.CompareTo%2A> метод в некоторых случаях может показаться странным. Например умножение на любое значение, следуют деления тем же значением следует производить исходное значение. Тем не менее в следующем примере вычисляемое значение оказывается больше, чем исходное значение. Отображение всех значащих цифр из двух значений с помощью символа «R» [строкой стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) указывает, что вычисляемое значение отличается от исходного значения в его менее значащих цифр. Сведения об обработке такие сравнения см. в разделе «Примечания» <xref:System.Single.Equals%28System.Single%29> метод.  
  
 [!code-csharp[System.Single.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.compareto/cs/compareto2.cs#1)]
 [!code-vb[System.Single.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.compareto/vb/compareto2.vb#1)]  
  
 Этот метод реализует <xref:System.IComparable%601?displayProperty=nameWithType> интерфейс, а также выполняет немного быстрее, чем <xref:System.Single.CompareTo%2A?displayProperty=nameWithType> метода, так как его не нужно выполнять преобразование `value` параметр объекта.  
  
 Обратите внимание, что, несмотря на то что объект, значение которого равно <xref:System.Single.NaN> не считаются равными, в другой объект, значение которого является <xref:System.Single.NaN> (даже самого) <xref:System.IComparable%601> требуется интерфейс `A.CompareTo(A)` возвращают нуль.  
  
## <a name="widening-conversions"></a>расширяющие преобразования  
 Языках программирования, могут быть доступны для кода <xref:System.Single.CompareTo%2A> метода, где параметр типа имеет меньшее число битов (является более коротким) от экземпляра типа. Это можно сделать, так как некоторые языки программирования выполняют неявное расширяющее преобразование, которое представляет количество бит типа параметра до количества бит типа экземпляра.  
  
 Предположим, что типом экземпляра является <xref:System.Single> и тип параметра является <xref:System.Int32>. Компилятор Microsoft C# создает инструкции для представления значения параметра, как <xref:System.Single> объекта, а затем создает <xref:System.Single.CompareTo%28System.Single%29?displayProperty=nameWithType> метод, который сравнивает значения экземпляра и расширенными представление параметра.  
  
 Обратитесь к документации язык программирования, чтобы определить, выполняет ли компилятор явное расширяющее преобразование числовых типов. Дополнительные сведения см. в разделе [таблицы преобразования типов](~/docs/standard/base-types/conversion-tables.md) раздела.  
  
## <a name="precision-in-comparisons"></a>Точность при сравнении  
 Точность чисел с плавающей запятой за пределы задокументированной точности зависит от реализации и версии платформы .NET Framework. Таким образом сравнения двух определенных чисел может меняться в различных версиях платформы .NET Framework точность внутреннего представления чисел может измениться.  
  
   
  
## Examples  
 В следующем примере кода демонстрируются универсальных и неуниверсальных версии <xref:System.Single.CompareTo%2A> метод для нескольких типов значений и ссылочных типов.  
  
 [!code-cpp[T.CompareTo#1](~/samples/snippets/cpp/VS_Snippets_CLR/T.CompareTo/CPP/cat.cpp#1)]
 [!code-csharp[T.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR/T.CompareTo/CS/cat.cs#1)]
 [!code-vb[T.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/T.CompareTo/VB/cat.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Equals(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Epsilon">
      <MemberSignature Language="C#" Value="public const float Epsilon = 1.401298E-45;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 Epsilon = float32(1.401298E-45)" />
      <MemberSignature Language="DocId" Value="F:System.Single.Epsilon" />
      <MemberSignature Language="VB.NET" Value="Public Const Epsilon As Single  = 1.401298E-45" />
      <MemberSignature Language="C++ CLI" Value="public: float Epsilon = 1.401298E-45;" />
      <MemberSignature Language="F#" Value="val mutable Epsilon : single" Usage="System.single.Epsilon" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>1.401298E-45</MemberValue>
      <Docs>
        <summary>Представляет наименьшее положительное значение <see cref="T:System.Single" /> больше нуля. Это поле является константой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение <xref:System.Single.Epsilon> свойство отражает наименьшее положительное <xref:System.Single> значение, которое является существенным для числовых операций или сравнения при значение <xref:System.Single> экземпляра равно нулю. Например, в следующем коде показано, нуля и <xref:System.Single.Epsilon> считаются неравных значений, тогда как нулевой и половина значение <xref:System.Single.Epsilon> считаются равными.  
  
 [!code-csharp[System.Single.Epsilon#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon.cs#5)]
 [!code-vb[System.Single.Epsilon#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon.vb#5)]  
  
 Точнее формате с плавающей запятой одиночной точности состоит из одного знака, 23-битной мантиссы или значащую часть и 8-разрядную экспоненту. Как показано в следующем примере, ноль имеет показатель степени-126 и мантиссы 0. <xref:System.Single.Epsilon> имеет показатель степени-126 и мантиссы 1. Это означает, что <xref:System.Single.Epsilon?displayProperty=nameWithType> представляет наименьшее положительное <xref:System.Single> значение, которое больше нуля и представляет минимально допустимое значение и наименьшее приращение возможных <xref:System.Single> , показатель степени является-126.  
  
 [!code-csharp[System.Single.Epsilon#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/epsilon1.cs#6)]
 [!code-vb[System.Single.Epsilon#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/epsilon1.vb#6)]  
  
 Тем не менее <xref:System.Single.Epsilon> свойство не общие измерения точности <xref:System.Single> введите; применяется только к <xref:System.Single> экземпляров, имеющих нулевое значение.  
  
> [!NOTE]
>  Значение <xref:System.Single.Epsilon> свойства не эквивалентен epsilon компьютера, который представляет собой верхнюю границу относительный ошибки из-за округления в арифметических операций с плавающей запятой.  
  
 Значение этой константы равно 1, 4e-45.  
  
 Два очевидно эквивалентные числа с плавающей запятой могут не совпасть из-за различий в их менее значащие цифры. Например, выражение C#, `(float)1/3 == (float)0.33333`, не отличаются, поскольку операция деления в левой части имеет максимальной точности, а константа с правой стороны является точным только для указанных цифр. При создании пользовательского алгоритма, который определяет два числа с плавающей запятой может быть считаются ли равными, необходимо использовать значение, которое больше, чем <xref:System.Single.Epsilon> константа для установления допустимую предельную разность двух чисел для рассматриваются как равные. (Как правило, что погрешность много раз больше, чем <xref:System.Single.Epsilon>.)  
  
## <a name="platform-notes"></a>Заметки о платформе  
 В системах ARM, значение <xref:System.Single.Epsilon> константы слишком мал для обнаружения, поэтому оно приравнивается к нулю. Можно определить альтернативный epsilon значение, равное 1, 175494351e-38 вместо него.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Возвращает значение, указывающее, представляют ли два экземпляра <see cref="T:System.Single" /> одно и то же значение.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="single.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Объект для сравнения с данным экземпляром.</param>
        <summary>Возвращает значение, показывающее, равен ли данный экземпляр заданному объекту.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="obj" /> является экземпляром типа <see cref="T:System.Single" /> и равен значению данного экземпляра; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.Equals%2A> Метод следует использовать с осторожностью, поскольку два очевидно эквивалентные значения могут быть из-за различий в точности эти два значения равны. В следующем примере сообщается, <xref:System.Single> значение.3333 и <xref:System.Single> возвращается путем деления не равны 1 по 3.  
  
 [!code-csharp[System.Single.Epsilon#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#3)]
 [!code-vb[System.Single.Epsilon#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#3)]  
  
 Вместо сравнения на равенство, один из рекомендуемых подход заключается в определении допустимого поля разницу между двумя значениями (такими как. 0,1% одного из значений). Если абсолютное значение разницы между двумя значениями меньше или равно значению поля, разница скорее всего, будут из-за различия в точности и, таким образом, значения равны. Следующий пример использует этот метод для сравнения.33333 и 1/3, два <xref:System.Single> значений, которые были не эквивалентны предыдущему примеру кода.  
  
 [!code-csharp[System.Single.Epsilon#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#4)]
 [!code-vb[System.Single.Epsilon#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#4)]  
  
 В этом случае значения равны.  
  
> [!NOTE]
>  Поскольку <xref:System.Single.Epsilon> определяет минимальное выражение положительного значения, диапазон которого приближается к нулю, граница различия должно быть больше <xref:System.Single.Epsilon>. Как правило, сколько раз больше, чем <xref:System.Single.Epsilon>.  
  
 Точность чисел с плавающей запятой за пределы задокументированной точности зависит от реализации и версии платформы .NET Framework. Таким образом сравнения двух определенных чисел может меняться в различных версиях платформы .NET Framework точность внутреннего представления чисел может измениться.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.Single.Equals%2A> метод.  
  
 [!code-cpp[System.Single#17](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#17)]
 [!code-csharp[System.Single#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#17)]
 [!code-vb[System.Single#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#17)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Разрешение перегрузки компилятор может учитывать видимого различия в поведении между этими двумя <see cref="M:System.Single.Equals(System.Object)" /> перегруженных версий метода. Если неявное преобразование между <paramref name="obj" /> аргумент и <see cref="T:System.Single" /> определен и не имеет тип аргумента <see cref="T:System.Object" />, компиляторы могут выполнять неявное преобразование и вызова <see cref="M:System.Single.Equals(System.Single)" /> метод. В противном случае они вызывают <see cref="M:System.Single.Equals(System.Object)" /> метод, который всегда возвращает <see langword="false" /> при его <paramref name="obj" /> аргумент не <see cref="T:System.Single" /> значение. В следующем примере показано различие в поведении между перегрузки двух методов. В случае всех числовых типов-примитивов за исключением <see cref="T:System.Double" /> в Visual Basic и за исключением <see cref="T:System.Decimal" /> и <see cref="T:System.Double" /> в C#, первое сравнение возвращает <see langword="true" /> , поскольку компилятор автоматически выполняет расширяющие преобразования и вызовы <see cref="M:System.Single.Equals(System.Single)" /> метода, в то время как второй сравнение возвращает <see langword="false" /> , так как компилятор вызывает <see cref="M:System.Single.Equals(System.Object)" /> метод.  [! code-csharp[System.Single.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)] [! code-vb[System.Single.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Single.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (float obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(float32 obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Equals(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (obj As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(float obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : single -&gt; bool" Usage="single.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="obj">Объект для сравнения с данным экземпляром.</param>
        <summary>Возвращает значение, позволяющее определить, представляют ли этот экземпляр и заданный объект <see cref="T:System.Single" /> одно и то же значение.</summary>
        <returns>Значение <see langword="true" />, если значение параметра <paramref name="obj" /> равно данному экземпляру; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот метод реализует <xref:System.IEquatable%601?displayProperty=nameWithType> интерфейсов и выполняет немного быстрее, чем <xref:System.Single.Equals%2A> , так как его не нужно выполнять преобразование `obj` параметр объекта.  
  
## <a name="widening-conversions"></a>расширяющие преобразования  
 Языках программирования, могут быть доступны для кода <xref:System.Single.Equals%2A> метода, где параметр типа имеет меньшее число битов (является более коротким) от экземпляра типа. Это можно сделать, так как некоторые языки программирования выполняют неявное расширяющее преобразование, которое представляет количество бит типа параметра до количества бит типа экземпляра.  
  
 Предположим, что типом экземпляра является <xref:System.Single> и тип параметра является <xref:System.Int32>. Компилятор Microsoft C# создает инструкции для представления значения параметра, как <xref:System.Single> объекта, а затем создает <xref:System.Single.Equals%28System.Single%29?displayProperty=nameWithType> метод, который сравнивает значения экземпляра и расширенными представление параметра.  
  
 Обратитесь к документации язык программирования, чтобы определить, выполняет ли компилятор явное расширяющее преобразование числовых типов. Дополнительные сведения см. в разделе [таблицы преобразования типов](~/docs/standard/base-types/conversion-tables.md) раздела.  
  
## <a name="precision-in-comparisons"></a>Точность при сравнении  
 <xref:System.Single.Equals%2A> Метод следует использовать с осторожностью, так как из-за различий в точности эти два значения могут быть равны два очевидно эквивалентные значения. В следующем примере сообщается, <xref:System.Single> значение.3333 и <xref:System.Single> возвращается путем деления не равны 1 по 3.  
  
 [!code-csharp[System.Single.Epsilon#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#1)]
 [!code-vb[System.Single.Epsilon#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#1)]  
  
 Сравнение один метод, который позволяет избежать проблем, связанных с сравнения для проверки на равенство заключается в определении допустимого поля разницу между двумя значениями (такими как. 0,1% одного из значений). Если абсолютное значение разницы между двумя значениями меньше или равно значению поля, разница будет занимать результату различия в точности и, таким образом, значения равны. В следующем примере этот метод используется для сравнения.33333 и 1/3, которые являются двумя <xref:System.Single> значений, которые были не эквивалентны предыдущему примеру кода.  
  
 [!code-csharp[System.Single.Epsilon#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Epsilon/cs/SingleEquals_25051.cs#2)]
 [!code-vb[System.Single.Epsilon#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Epsilon/vb/SingleEquals_25051.vb#2)]  
  
 В этом случае значения равны.  
  
> [!NOTE]
>  Поскольку <xref:System.Single.Epsilon> определяет минимальное выражение положительного значения, диапазон которого приближается к нулю, граница различия должно быть больше <xref:System.Single.Epsilon>. Как правило, сколько раз больше, чем <xref:System.Single.Epsilon>. По этой причине мы рекомендуем не использовать <xref:System.Double.Epsilon> при сравнении <xref:System.Double> значения на равенство.  
  
 Второй метод, который позволяет избежать проблем, связанных с сравнение на равенство подразумевает сравнение различий между двумя числами с плавающей запятой с некоторыми абсолютное значение. Если разница, меньше или равно, абсолютное значение числа равны. Если оно больше числа не равны. Один из способов сделать это является произвольным образом выбор в абсолютном значении. Однако это создает проблему, так как допустимого поля Разница зависит от масштабов <xref:System.Single> значения. Второй способ использует преимущества является особенностью формате с плавающей запятой: количество возможных значений с плавающей запятой, разделяющий указывает разницу между компонентами мантиссы представления целых чисел из двух значений с плавающей запятой два значения. Например, разница между 0,0 и <xref:System.Single.Epsilon> равно 1, поскольку <xref:System.Single.Epsilon> является наименьшим представимым значением при работе с <xref:System.Single> , значение которого равно нулю. В следующем примере этот метод используется для сравнения.33333 и 1/3, которые являются двумя <xref:System.Double> значения, которые в предыдущем примере кода с <xref:System.Single.Equals%28System.Single%29> найти метод были не эквивалентны. Обратите внимание, что в этом примере <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> и <xref:System.BitConverter.ToInt32%2A?displayProperty=nameWithType> методы преобразования в представление целое значение с плавающей запятой одиночной точности.  
  
 [!code-csharp[System.Single.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsabs1.cs#1)]
 [!code-vb[System.Single.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsabs1.vb#1)]  
  
 Точность чисел с плавающей запятой за пределы задокументированной точности зависит от реализации и версии платформы .NET Framework. Следовательно сравнения двух чисел может давать разные результаты в зависимости от версии платформы .NET Framework, может измениться точность внутреннего представления чисел.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage">
          <para>Разрешение перегрузки компилятор может учитывать видимого различия в поведении между этими двумя <see cref="M:System.Single.Equals(System.Object)" /> перегруженных версий метода. Если неявное преобразование между <paramref name="obj" /> аргумент и <see cref="T:System.Single" /> определен и не имеет тип аргумента <see cref="T:System.Object" />, компиляторы могут выполнять неявное преобразование и вызова <see cref="M:System.Single.Equals(System.Single)" /> метод. В противном случае они вызывают <see cref="M:System.Single.Equals(System.Object)" /> метод, который всегда возвращает <see langword="false" /> при его <paramref name="obj" /> аргумент не <see cref="T:System.Single" /> значение. В следующем примере показано различие в поведении между перегрузки двух методов. В случае всех числовых типов-примитивов за исключением <see cref="T:System.Double" /> в Visual Basic и за исключением <see cref="T:System.Decimal" /> и <see cref="T:System.Double" /> в C#, первое сравнение возвращает <see langword="true" /> , поскольку компилятор автоматически выполняет расширяющие преобразования и вызовы <see cref="M:System.Single.Equals(System.Single)" /> метода, в то время как второй сравнение возвращает <see langword="false" /> , так как компилятор вызывает <see cref="M:System.Single.Equals(System.Object)" /> метод.  [! code-csharp[System.Single.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.equals/cs/equalsoverl.cs#2)] [! code-vb[System.Single.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.equals/vb/equalsoverl.vb#2)]</para>
        </block>
        <altmember cref="M:System.Single.Equals(System.Object)" />
        <altmember cref="Overload:System.Single.CompareTo" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="single.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает хэш-код данного экземпляра.</summary>
        <returns>Хэш-код в виде 32-разрядного целого числа со знаком.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public TypeCode GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.TypeCode GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Public Function GetTypeCode () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual TypeCode GetTypeCode();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCode : unit -&gt; TypeCode&#xA;override this.GetTypeCode : unit -&gt; TypeCode" Usage="single.GetTypeCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Возвращает <see cref="T:System.TypeCode" /> для типа значения <see cref="T:System.Single" />.</summary>
        <returns>Константа перечислимого типа, <see cref="F:System.TypeCode.Single" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="T:System.TypeCode" />
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsFinite(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(float f);" />
      <MemberSignature Language="F#" Value="static member IsFinite : single -&gt; bool" Usage="System.single.IsFinite f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : single -&gt; bool" Usage="System.single.IsInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Число с плавающей запятой одиночной точности.</param>
        <summary>Возвращает значение, позволяющее определить, равно ли данное число плюс или минус бесконечности.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="f" /> равен значению <see cref="F:System.Single.PositiveInfinity" /> или <see cref="F:System.Single.NegativeInfinity" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операции с плавающей запятой возвращают <xref:System.Single.PositiveInfinity> или <xref:System.Single.NegativeInfinity> , чтобы указать на условие переполнения.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.Single.IsInfinity%2A> метод.  
  
 [!code-cpp[System.Single#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#11)]
 [!code-csharp[System.Single#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#11)]
 [!code-vb[System.Single#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#11)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNaN(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(float f);" />
      <MemberSignature Language="F#" Value="static member IsNaN : single -&gt; bool" Usage="System.single.IsNaN f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Число с плавающей запятой одиночной точности.</param>
        <summary>Возвращает значение, показывающее, что указанное значение не является числом (<see cref="F:System.Single.NaN" />).</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="f" /> относится к нечисловому типу (<see cref="F:System.Single.NaN" />); в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операции с плавающей запятой возвращают <xref:System.Single.NaN> сигнала, результат этой операции не определен. Например, деление 0,0 на 0,0 приводит к <xref:System.Single.NaN>.  
  
> [!NOTE]
>  <xref:System.Single.IsNaN%2A> Возвращает `false` Если <xref:System.Single> значение <xref:System.Single.PositiveInfinity> или <xref:System.Single.NegativeInfinity>. Чтобы проверить эти значения, используйте <xref:System.Single.IsInfinity%2A>, <xref:System.Single.IsPositiveInfinity%2A>, и <xref:System.Single.IsNegativeInfinity%2A> методы.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.Single.IsNaN%2A> метод.  
  
 [!code-cpp[System.Single#8](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#8)]
 [!code-csharp[System.Single#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#8)]
 [!code-vb[System.Single#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#8)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.NaN" />
      </Docs>
    </Member>
    <Member MemberName="IsNegative">
      <MemberSignature Language="C#" Value="public static bool IsNegative (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegative(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegative(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegative (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegative(float f);" />
      <MemberSignature Language="F#" Value="static member IsNegative : single -&gt; bool" Usage="System.single.IsNegative f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNegativeInfinity">
      <MemberSignature Language="C#" Value="public static bool IsNegativeInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNegativeInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNegativeInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNegativeInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNegativeInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsNegativeInfinity : single -&gt; bool" Usage="System.single.IsNegativeInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Число с плавающей запятой одиночной точности.</param>
        <summary>Возвращает значение, позволяющее определить, равно ли данное число минус бесконечности.</summary>
        <returns>Значение <see langword="true" />, если значение параметра <paramref name="f" /> равно значению <see cref="F:System.Single.NegativeInfinity" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операции с плавающей запятой возвращают <xref:System.Single.NegativeInfinity> , чтобы указать на условие переполнения.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.Single.IsNegativeInfinity%2A> метод.  
  
 [!code-cpp[System.Single#13](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#13)]
 [!code-csharp[System.Single#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#13)]
 [!code-vb[System.Single#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#13)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsNormal">
      <MemberSignature Language="C#" Value="public static bool IsNormal (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNormal(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsNormal(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNormal (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNormal(float f);" />
      <MemberSignature Language="F#" Value="static member IsNormal : single -&gt; bool" Usage="System.single.IsNormal f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsPositiveInfinity">
      <MemberSignature Language="C#" Value="public static bool IsPositiveInfinity (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsPositiveInfinity(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsPositiveInfinity(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsPositiveInfinity (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsPositiveInfinity(float f);" />
      <MemberSignature Language="F#" Value="static member IsPositiveInfinity : single -&gt; bool" Usage="System.single.IsPositiveInfinity f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">Число с плавающей запятой одиночной точности.</param>
        <summary>Возвращает значение, показывающее, равно ли данное число плюс бесконечности.</summary>
        <returns>Значение <see langword="true" />, если значение параметра <paramref name="f" /> равно значению <see cref="F:System.Single.PositiveInfinity" />; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Операции с плавающей запятой возвращают <xref:System.Single.PositiveInfinity> , чтобы указать на условие переполнения.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.Single.IsPositiveInfinity%2A> метод.  
  
 [!code-cpp[System.Single#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#12)]
 [!code-csharp[System.Single#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#12)]
 [!code-vb[System.Single#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="IsSubnormal">
      <MemberSignature Language="C#" Value="public static bool IsSubnormal (float f);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsSubnormal(float32 f) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.IsSubnormal(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsSubnormal (f As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsSubnormal(float f);" />
      <MemberSignature Language="F#" Value="static member IsSubnormal : single -&gt; bool" Usage="System.single.IsSubnormal f" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="f" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="f">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxValue">
      <MemberSignature Language="C#" Value="public const float MaxValue = 3.402823E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MaxValue = float32(3.402823E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MaxValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MaxValue As Single  = 3.402823E+38" />
      <MemberSignature Language="C++ CLI" Value="public: float MaxValue = 3.402823E+38;" />
      <MemberSignature Language="F#" Value="val mutable MaxValue : single" Usage="System.single.MaxValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>3.402823E+38</MemberValue>
      <Docs>
        <summary>Представляет наибольшее возможное значение типа <see cref="T:System.Single" />. Это поле является константой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этой константы — положительное 3.40282347E + 38.  
  
 Результат операции, которая превышает <xref:System.Single.MaxValue?displayProperty=nameWithType> — <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>. В следующем примере <xref:System.Single.PositiveInfinity?displayProperty=nameWithType> полученный в результате операции сложения, умножение и возведение в степень, когда результат превышает <xref:System.Single.MaxValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Single.MaxValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.maxvalue/cs/maxvalueex.cs#1)]
 [!code-vb[System.Single.MaxValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.maxvalue/vb/maxvalueex.vb#1)]  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.Single.MaxValue> константой.  
  
 [!code-cpp[System.Single#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#4)]
 [!code-csharp[System.Single#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#4)]
 [!code-vb[System.Single#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.MinValue" />
      </Docs>
    </Member>
    <Member MemberName="MinValue">
      <MemberSignature Language="C#" Value="public const float MinValue = -3.402823E+38;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 MinValue = float32(-3.402823E+38)" />
      <MemberSignature Language="DocId" Value="F:System.Single.MinValue" />
      <MemberSignature Language="VB.NET" Value="Public Const MinValue As Single  = -3.402823E+38" />
      <MemberSignature Language="C++ CLI" Value="public: float MinValue = -3.402823E+38;" />
      <MemberSignature Language="F#" Value="val mutable MinValue : single" Usage="System.single.MinValue" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-3.402823E+38</MemberValue>
      <Docs>
        <summary>Представляет минимально допустимое значение типа <see cref="T:System.Single" />. Это поле является константой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этой константы — минус 3, 402823E38.  
  
 Результат операции, которое меньше, чем <xref:System.Single.MinValue?displayProperty=nameWithType> — <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>. В следующем примере <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> результатом вычитание и умножение, если результат меньше, чем <xref:System.Single.MinValue?displayProperty=nameWithType>.  
  
 [!code-csharp[System.Single.MinValue#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.minvalue/cs/minvalueex.cs#1)]
 [!code-vb[System.Single.MinValue#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.minvalue/vb/minvalueex.vb#1)]  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.Single.MinValue> константой.  
  
 [!code-cpp[System.Single#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#5)]
 [!code-csharp[System.Single#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#5)]
 [!code-vb[System.Single#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#5)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Single.MaxValue" />
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public const float NaN = NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NaN = float32(NaN)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Const NaN As Single  = NaN" />
      <MemberSignature Language="C++ CLI" Value="public: float NaN = NaN;" />
      <MemberSignature Language="F#" Value="val mutable NaN : single" Usage="System.single.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>NaN</MemberValue>
      <Docs>
        <summary>Представляет нечисловое значение (<see langword="NaN" />). Это поле является константой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Метод или оператор возвращает <xref:System.Single.NaN> Если результат операции является неопределенным. Например, результат деления нуля на нуль является <xref:System.Single.NaN>, как показано в следующем примере. (Но Обратите внимание, что деления на ноль ненулевое число возвращает либо <xref:System.Single.PositiveInfinity> или <xref:System.Single.NegativeInfinity>, в зависимости от знак делителя.)  
  
 [!code-csharp[System.Single.NaN#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#1)]
 [!code-vb[System.Single.NaN#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#1)]  
  
 Кроме того, вызов метода с <xref:System.Single.NaN> значение или операцию над <xref:System.Single.NaN> значение возвращает <xref:System.Single.NaN>, как показано в следующем примере.  
  
 [!code-csharp[System.Single.NaN#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/nan1.cs#2)]
 [!code-vb[System.Single.NaN#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/nan1.vb#2)]  
  
 Используйте <xref:System.Single.IsNaN%2A> метод, чтобы определить, является ли значение не является числом. В общем случае <xref:System.Single> операторы не могут использоваться для сравнения <xref:System.Single.NaN?displayProperty=nameWithType> с другими <xref:System.Single> значения, хотя методы сравнения (например, <xref:System.Single.Equals%2A> и <xref:System.Single.CompareTo%2A>) может. Следующий пример иллюстрирует разницу в поведении между <xref:System.Single> операторы сравнения и методы.  
  
 [!code-csharp[System.Single.NaN#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.nan/cs/single.nan4.cs#4)]
 [!code-vb[System.Single.NaN#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.nan/vb/single.nan4.vb#4)]  
  
   
  
## Examples  
 В следующем примере демонстрируется <xref:System.Single.NaN> константой.  
  
 [!code-cpp[System.Single#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#7)]
 [!code-csharp[System.Single#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#7)]
 [!code-vb[System.Single#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsNaN(System.Single)" />
      </Docs>
    </Member>
    <Member MemberName="NegativeInfinity">
      <MemberSignature Language="C#" Value="public const float NegativeInfinity = -Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 NegativeInfinity = float32(-Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.NegativeInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const NegativeInfinity As Single  = -Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: float NegativeInfinity = -Infinity;" />
      <MemberSignature Language="F#" Value="val mutable NegativeInfinity : single" Usage="System.single.NegativeInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>-Infinity</MemberValue>
      <Docs>
        <summary>Представляет минус бесконечность. Это поле является константой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этой константы — результат деления отрицательного числа на ноль.  
  
 Эта константа возвращается в том случае, если результат операции меньше, чем <xref:System.Single.MinValue>.  
  
 Используйте <xref:System.Single.IsNegativeInfinity%2A> для определения, равно ли значение минус бесконечности.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.Single.NegativeInfinity> константой.  
  
 [!code-cpp[System.Single#9](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#9)]
 [!code-csharp[System.Single#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#9)]
 [!code-vb[System.Single#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#9)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsNegativeInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="F:System.Single.PositiveInfinity" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Equality(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : single * single -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, равны ли два заданных значения <see cref="T:System.Single" />.</summary>
        <returns>Значение <see langword="true" />, если <paramref name="left" /> и <paramref name="right" /> равны; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.op_Equality%2A> Метода определяется оператор равенства для <xref:System.Single> значения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThan(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : single * single -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, действительно ли заданное значение <see cref="T:System.Single" /> больше другого заданного значения <see cref="T:System.Single" />.</summary>
        <returns>
          <see langword="true" />, если <paramref name="left" /> больше <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.op_GreaterThan%2A> Метод определяет операцию больше — не для <xref:System.Single> значения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_GreaterThanOrEqual(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : single * single -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, действительно ли заданное значение <see cref="T:System.Single" /> больше или равно другому заданному значению <see cref="T:System.Single" />.</summary>
        <returns>
          <see langword="true" />, если значение <paramref name="left" /> больше или равно значению <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.op_GreaterThanOrEqual%2A> Метод определяет операцию от оператора больше или равно для <xref:System.Single> значения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_Inequality(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : single * single -&gt; bool" Usage="System.single.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, не равны ли два заданных значения <see cref="T:System.Single" />.</summary>
        <returns>Значение <see langword="true" />, если <paramref name="left" /> и <paramref name="right" /> не равны друг другу; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.op_Inequality%2A> Метода определяется оператор неравенства для <xref:System.Single> значения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThan(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : single * single -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, действительно ли заданное значение <see cref="T:System.Single" /> меньше другого заданного значения <see cref="T:System.Single" />.</summary>
        <returns>
          <see langword="true" />, если значение <paramref name="left" /> меньше значения <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.op_LessThan%2A> Метод определяет операцию меньше-оператора для <xref:System.Single> значения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (float left, float right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(float32 left, float32 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.op_LessThanOrEqual(System.Single,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Single, right As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(float left, float right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : single * single -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Single" />
        <Parameter Name="right" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="left">Первое сравниваемое значение.</param>
        <param name="right">Второе сравниваемое значение.</param>
        <summary>Возвращает значение, указывающее, действительно ли заданное значение <see cref="T:System.Single" /> меньше или равно другому заданному значению <see cref="T:System.Single" />.</summary>
        <returns>
          <see langword="true" />, если значение <paramref name="left" /> меньше или равно значению <paramref name="right" />; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.op_LessThanOrEqual%2A> Метод определяет операцию оператора меньше или равно для <xref:System.Single> значения.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразует строковое представление числа в эквивалентное ему число с плавающей запятой одиночной точности.</summary>
        <altmember cref="Overload:System.Single.TryParse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; single" Usage="System.single.Parse s" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая преобразуемое число.</param>
        <summary>Преобразует строковое представление числа в эквивалентное ему число с плавающей запятой одиночной точности.</summary>
        <returns>Число с плавающей запятой одиночной точности, эквивалентное числовому значению или символу, указанному в параметре <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `s` Параметр может содержать текущего языка и региональных параметров <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, или строку в формате:  
  
 [*ws*] [*входа*] [*целые числа*[*,*]]*целые числа*[*.* [*дробной части*]] [e [*входа*]*экспоненциальные цифры*] [*ws*]  
  
 Элементы в квадратных скобках ([и]) являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*ws*|Последовательность знаков пустого пространства.|  
|*sign*|Знак "минус" символа или символа положительного числа. Допустимые знаки определяются по <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> и <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> свойств текущего языка и региональных параметров. Можно использовать только знак в начале.|  
|*целые числа*|Последовательность цифр в диапазоне от 0 до 9, задающих целую часть числа. Работает *целые числа* могут быть разделены символом разделителя групп. Например в некоторых странах запятую (,) разделяет групп разрядов. *Целые числа* элемент может отсутствовать Если строка содержит *дробной части* элемента.|  
|*,*|Разделителя групп разрядов символ-разделитель.|  
|*.*|Символ десятичной запятой для конкретного языка и региональных параметров.|  
|*дробной части*|Последовательность цифр в диапазоне от 0 до 9, задающих дробную часть числа.|  
|E|«E» или «E» знаком, который указывает, что значение будет представлено в экспоненциальной нотации (научный).|  
|*экспоненциальные цифры*|Последовательность цифр в диапазоне от 0 до 9, задающих экспоненту.|  
  
 `s` Параметр интерпретируется с использованием сочетания <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> и <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> флаги. Это означает, что пробелы и тысяч разделители разрешены, но не являются символами валют. Для явного определения элементов (такие как символы денежной единицы, тысячи разделители и символы-разделители), могут быть представлены в `s`, используйте <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> перегрузки метода.  
  
 `s` Параметр анализируется с использованием сведений о форматировании в <xref:System.Globalization.NumberFormatInfo> , инициализируемый для текущего языка и региональных параметров системы. Дополнительные сведения см. в разделе <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A>. Для разбора строки, используя сведения о форматировании для определенного языка и региональных параметров, используйте <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> или <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> метод.  
  
 Как правило если передать <xref:System.Single.Parse%2A> метод строку, которая создается путем вызова <xref:System.Single.ToString%2A> метод, исходные <xref:System.Single> возвращаемое значение. Однако из-за потери точности значения могут не быть равны.  
  
 Если обнаружен разделитель в `s` параметр во время операции синтаксического анализа и применимые валюты или число десятичных и разделители групп совпадают, предполагается, что разделитель является десятичного разделителя, а не группой разделитель. Дополнительные сведения о разделители см. в разделе <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, и <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Single.Parse%28System.String%29> метод, чтобы преобразовать массив строк в эквивалент <xref:System.Single> значения.  
  
 [!code-csharp[System.Single.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse1.cs#2)]
 [!code-vb[System.Single.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="s" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Параметр <paramref name="s" /> не представляет число в допустимом формате.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> представляет число, которое меньше значения <see cref="F:System.Single.MinValue" /> или больше значения <see cref="F:System.Single.MaxValue" />.</exception>
        <altmember cref="M:System.Single.ToString" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; single" Usage="System.single.Parse (s, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая преобразуемое число.</param>
        <param name="style">Побитовое сочетание значений перечисления, определяющих элементы стиля, которые могут быть представлены в параметре <c>s</c>. Обычно указывается значение <see cref="F:System.Globalization.NumberStyles.Float" /> в сочетании со значением <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <summary>Преобразует строковое представление числа в указанном стиле в эквивалентное ему число с плавающей запятой одиночной точности.</summary>
        <returns>Число с плавающей запятой одиночной точности, эквивалентное числовому значению или символу, указанному в параметре <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `style` Параметр определяет элементы стиля (таких как пробелы, тысячи разделители и символы валют), которые допускаются в `s` параметр для успешного выполнения операции синтаксического анализа. Он должен быть сочетанием одноразрядных флагов из <xref:System.Globalization.NumberStyles> перечисления. Следующие <xref:System.Globalization.NumberStyles> элементы не поддерживаются:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 `s` Параметр может содержать текущего языка и региональных параметров <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>. В зависимости от значения `style`, он также может принимать форму:  
  
 [*ws*] [*$*] [*входа*] [*целые числа*[*,*]]* целые числа*[*.* [*дробной части*]] [E [*входа*]*экспоненциальные цифры*] [*ws*]  
  
 Элементы в квадратных скобках ([и]) являются необязательными. Каждый из элементов описан в таблице ниже.  
  
 *ws*  
 Серия символы-разделители. Пробелы могут отображаться в начале `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> флаг, который может находиться в конце `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> флаг.  
  
 $  
 Символ валюты. Его положение в строке определяется <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> и <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> свойств текущего языка и региональных параметров. Символ валюты для текущего языка и региональных параметров могут использоваться в `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> флаг.  
  
 *sign*  
 Знак минус (-) файлы символов или символов, знак плюс (+). Знак может располагаться в начале `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> флаг, который может находиться в конце `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> флаг. Можно использовать круглые скобки в `s` указывает отрицательное значение, если `style` включает <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> флаг.  
  
 *целые числа*  
 Последовательность цифр в диапазоне от 0 до 9, задающих целую часть числа. *Целые числа* элемент может отсутствовать Если строка содержит *дробной части* элемента.  
  
 ,  
 Разделитель групп, зависящий от языка и региональных параметров. Символ-разделитель групп текущего языка и региональных параметров могут использоваться в `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> флаг  
  
 .  
 Символ десятичной запятой для конкретного языка и региональных параметров. Символ десятичной точки текущего языка и региональных параметров могут использоваться в `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> флаг.  
  
 *дробной части*  
 Последовательность цифр в диапазоне от 0 до 9, задающих дробную часть числа. Дробных разрядов может встречаться в `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> флаг.  
  
 E  
 «E» или «E» знаком, который указывает, что значение будет представлено в экспоненциальной нотации (научный). `value` Параметр может представлять число в экспоненциальном представлении, если `style` включает <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> флаг.  
  
 *экспоненциальные цифры*  
 Последовательность цифр в диапазоне от 0 до 9, задающих экспоненту.  
  
 Строка с только цифры (что соответствует <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> стиль) всегда успешно выполняет синтаксический анализ. Оставшиеся <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> члены управляют элементами, которые могут присутствовать, но необязательно должны присутствовать во входной строке. Следующая таблица показывает, как отдельные <xref:System.Globalization.NumberStyles> флаги влияют на элементы, которые могут присутствовать в `s`.  
  
|Значение NumberStyles|Элементы, допустимые в `s` помимо цифр|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*Целые числа* только элемент.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Десятичной запятой (*.*) и *дробной части* элементов.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|«E» или «E» символ, который указывает на экспоненциальное представление. Этот флаг сам по себе поддерживает значения в форме *цифр*E*цифр*; дополнительные флаги необходимы для успешного анализа строки с такими элементами, как положительное или отрицательное подписывает и десятичный разделитель.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws* элемент в начале `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws* элемент в конце `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*Входа* элемент в начале `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*Входа* элемент в конце `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*Входа* элемент в скобки, ограничивающие числовое значение.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Тысяч элемент разделителя (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Элемент валюты ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Все элементы. Однако `s` не может представлять шестнадцатеричное число или число в экспоненциальном представлении.|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws* элемент в начале или конце `s`, *входа* в начале `s`и символ десятичной точки (.). `s` Параметр можно также использовать экспоненциальное представление.|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`, `sign`, Тысячи разделитель (,) и элементы десятичной точки (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Все элементы. Однако `s` не может представлять шестнадцатеричное число.|  
  
 Некоторые примеры `s` являются «100», «-123456789", «123, 45e + 6", «+ 500», «5e2», «3,1416», «600.», «-. 123" и «-бесконечность».  
  
 `s` Параметр анализируется с использованием сведений о форматировании в <xref:System.Globalization.NumberFormatInfo> , инициализируемый для текущего языка и региональных параметров системы. Чтобы указать язык и региональные параметры, чье форматирования используется для выполнения операции синтаксического анализа, вызовите <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> перегрузки.  
  
 Как правило если передать <xref:System.Single.Parse%2A> метод строку, которая создается путем вызова <xref:System.Single.ToString%2A> метод, исходные <xref:System.Single> возвращаемое значение. Однако из-за потери точности значения могут не быть равны.  
  
 Если обнаружен разделитель в `s` параметр во время операции синтаксического анализа и применимые валюты или число десятичных и разделители групп совпадают, предполагается, что разделитель является десятичного разделителя, а не группой разделитель. Дополнительные сведения о разделители см. в разделе <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, и <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> метода для синтаксического анализа строковые представления <xref:System.Single> значения. В примере используются сведения о форматировании для языка и региональных параметров en US.  
  
 [!code-csharp[System.Single.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse2.cs#3)]
 [!code-vb[System.Single.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse2.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="s" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> не является числом в допустимом формате.</exception>
        <exception cref="T:System.OverflowException">Параметр <paramref name="s" /> представляет число меньше <see cref="F:System.Single.MinValue" /> или больше <see cref="F:System.Single.MaxValue" />.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> не является значением <see cref="T:System.Globalization.NumberStyles" />.  -или- <paramref name="style" /> включает значение <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <altmember cref="M:System.Single.ToString" />
        <altmember cref="Overload:System.Single.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, provider As IFormatProvider) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; single" Usage="System.single.Parse (s, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая преобразуемое число.</param>
        <param name="provider">Объект, который предоставляет сведения о форматировании параметра <c>s</c> в зависимости от языка и региональных параметров.</param>
        <summary>Преобразует строковое представление числа, записанное в формате, соответствующем определенному языку и региональным параметрам, в эквивалентное ему число с плавающей запятой одиночной точности.</summary>
        <returns>Число с плавающей запятой одиночной точности, эквивалентное числовому значению или символу, указанному в параметре <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка обычно используется для преобразования текста можно форматировать в различных способов <xref:System.Single> значение. Например он может использоваться для преобразования текста, введенного пользователем в текстовое поле HTML в числовое значение.  
  
 `s` Параметр интерпретируется с использованием сочетания <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> и <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> флаги. `s` Параметр может содержать <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, или <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> для языка и региональных параметров, заданные `provider`, или он может содержать строку в формате:  
  
 [*ws*] [*входа*]*целые числа*[*.* [*дробной части*]] [E [*входа*]*экспоненциальные цифры*] [*ws*]  
  
 Необязательные элементы заключены в квадратные скобки ([и]). Элементов, содержащих термин «цифры» состоят из последовательности цифр от 0 до 9.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*ws*|Серия символы-разделители.|  
|*sign*|Знак минус (-) файлы символов или символов, знак плюс (+).|  
|*целые числа*|Последовательность цифр в диапазоне от 0 до 9, задающих целую часть числа. Работает *целые числа* могут быть разделены символом разделителя групп. Например в некоторых странах запятую (,) разделяет групп разрядов. *Целые числа* элемент может отсутствовать Если строка содержит *дробной части* элемента.|  
|.|Символ десятичной запятой для конкретного языка и региональных параметров.|  
|*дробной части*|Последовательность цифр в диапазоне от 0 до 9, задающих дробную часть числа.|  
|E|«E» или «E» знаком, который указывает, что значение будет представлено в экспоненциальной нотации (научный).|  
|*экспоненциальные цифры*|Последовательность цифр в диапазоне от 0 до 9, задающих экспоненту.|  
  
 Дополнительные сведения о числовых форматах см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md) раздела.  
  
 `provider` Параметр <xref:System.IFormatProvider> реализация которого <xref:System.IFormatProvider.GetFormat%2A> возвращает <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров. При <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> вызывается метод, он вызывает метод `provider` параметра <xref:System.IFormatProvider.GetFormat%2A> метод и передает его <xref:System.Type> , представляющий <xref:System.Globalization.NumberFormatInfo> типа. <xref:System.IFormatProvider.GetFormat%2A> Метод затем возвращает <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о формате параметра `s` параметр. Существует три способа использования `provider` для предоставления пользовательских сведений о форматировании операции синтаксического анализа:  
  
-   Можно передать <xref:System.Globalization.CultureInfo> , представляющий язык и региональные параметры, предоставляющий сведения о форматировании. Его <xref:System.Globalization.CultureInfo.GetFormat%2A> возвращает <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании числовых для этого языка и региональных параметров.  
  
-   Вы можете передать фактического <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании числовых значений. (Реализация <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> просто возвращает сам.)  
  
-   Можно передать пользовательский объект, который реализует <xref:System.IFormatProvider>. Его <xref:System.IFormatProvider.GetFormat%2A> метод создает и возвращает <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании.  
  
 Если `provider` — `null` или <xref:System.Globalization.NumberFormatInfo> не удается получить, сведения о форматировании для используемых текущую культуру системы.  
  
 Если обнаружен разделитель в `s` параметр во время операции синтаксического анализа и применимые валюты или число десятичных и разделители групп совпадают, предполагается, что разделитель является десятичного разделителя, а не группой разделитель. Дополнительные сведения о разделители см. в разделе <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, и <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
 Некоторые примеры `s` являются «100», «-123456789", «123, 45e + 6", «+ 500», «5e2», «3,1416», «600.», «-. 123" и «-бесконечность».  
  
   
  
## Examples  
 Следующий пример является веб-формы обработчик событий нажатия кнопки. Она использует массив, возвращаемый методом <xref:System.Web.HttpRequest.UserLanguages%2A?displayProperty=nameWithType> свойства, чтобы определить языковой стандарт пользователя. Затем он создает <xref:System.Globalization.CultureInfo> объект, соответствующий этим языковым стандартом. <xref:System.Globalization.NumberFormatInfo> Объекта, которому принадлежит, <xref:System.Globalization.CultureInfo> объект затем передается <xref:System.Single.Parse%28System.String%2CSystem.IFormatProvider%29> данные метода для преобразования пользователь <xref:System.Single> значение.  
  
 [!code-csharp[ParseMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR/ParseMethod/cs/Default.aspx.cs#1)]
 [!code-vb[ParseMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ParseMethod/vb/Default.aspx.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="s" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">Параметр <paramref name="s" /> не представляет число в допустимом формате.</exception>
        <exception cref="T:System.OverflowException">
          <paramref name="s" /> представляет число, которое меньше значения <see cref="F:System.Single.MinValue" /> или больше значения <see cref="F:System.Single.MaxValue" />.</exception>
        <altmember cref="M:System.Single.ToString" />
        <altmember cref="Overload:System.Single.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.AllowDecimalPoint | System.Globalization.NumberStyles.AllowExponent | System.Globalization.NumberStyles.AllowLeadingSign | System.Globalization.NumberStyles.AllowLeadingWhite | System.Globalization.NumberStyles.AllowThousands | System.Globalization.NumberStyles.AllowTrailingWhite | System.Globalization.NumberStyles.Float | System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As Single" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; single" Usage="System.single.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static float Parse (string s, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 Parse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (s As String, style As NumberStyles, provider As IFormatProvider) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float Parse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; single" Usage="System.single.Parse (s, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="s">Строка, содержащая преобразуемое число.</param>
        <param name="style">Побитовое сочетание значений перечисления, определяющих элементы стиля, которые могут быть представлены в параметре <c>s</c>. Обычно указывается значение <see cref="F:System.Globalization.NumberStyles.Float" /> в сочетании со значением <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Объект, который предоставляет сведения о форматировании параметра <c>s</c> в зависимости от языка и региональных параметров.</param>
        <summary>Преобразует строковое представление числа в указанном стиле и с использованием формата, соответствующего данному языку и региональным параметрам, в эквивалентное ему число с плавающей запятой одиночной точности.</summary>
        <returns>Число с плавающей запятой одиночной точности, эквивалентное числовому значению или символу, указанному в параметре <paramref name="s" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 `style` Параметр определяет элементы стиля (таких как пробелы, тысячи разделители и символы валют), которые допускаются в `s` параметр для успешного выполнения операции синтаксического анализа. Он должен быть сочетанием одноразрядных флагов из <xref:System.Globalization.NumberStyles> перечисления. Следующие <xref:System.Globalization.NumberStyles> элементы не поддерживаются:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber>  
  
 `s` Параметр может содержать <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A?displayProperty=nameWithType>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A?displayProperty=nameWithType>, или <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A?displayProperty=nameWithType> для языка и региональных параметров, заданные `provider`. В зависимости от значения `style`, он также может принимать форму:  
  
 [*ws*] [*$*] [*входа*] [*целые числа*,]*целые числа*[. [ *дробной части*]] [E [*входа*]*экспоненциальные цифры*] [*ws*]  
  
 Элементы, заключенных в квадратные скобки ([и]) являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*ws*|Серия символы-разделители. Пробелы могут отображаться в начале `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> флаг, который может находиться в конце `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> флаг.|  
|$|Символ валюты. Его положение в строке определяется <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> и <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> свойств текущего языка и региональных параметров. Символ валюты для текущего языка и региональных параметров могут использоваться в `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> флаг.|  
|*sign*|Знак минус (-) файлы символов или символов, знак плюс (+). Знак может располагаться в начале `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> флаг, который может находиться в конце `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> флаг. Можно использовать круглые скобки в `s` указывает отрицательное значение, если `style` включает <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> флаг.|  
|*целые числа*|Последовательность цифр в диапазоне от 0 до 9, задающих целую часть числа. *Целые числа* элемент может отсутствовать Если строка содержит *дробной части* элемента.|  
|,|Разделитель групп, зависящий от языка и региональных параметров. Символ-разделитель групп текущего языка и региональных параметров могут использоваться в `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> флаг|  
|.|Символ десятичной запятой для конкретного языка и региональных параметров. Символ десятичной точки текущего языка и региональных параметров могут использоваться в `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> флаг.|  
|*дробной части*|Последовательность цифр в диапазоне от 0 до 9, задающих дробную часть числа. Дробных разрядов может встречаться в `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> флаг.|  
|E|«E» или «E» знаком, который указывает, что значение будет представлено в экспоненциальной нотации (научный). `s` Параметр может представлять число в экспоненциальном представлении, если `style` включает <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> флаг.|  
|*экспоненциальные цифры*|Последовательность цифр в диапазоне от 0 до 9, задающих экспоненту.|  
  
 Строка с только цифры (что соответствует <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> стиль) всегда успешно выполняет синтаксический анализ. Оставшиеся <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> члены управляют элементами, которые могут присутствовать, но необязательно должны присутствовать во входной строке. Следующая таблица показывает, как отдельные <xref:System.Globalization.NumberStyles> флаги влияют на элементы, которые могут присутствовать в `s`.  
  
|Значение NumberStyles|Элементы, допустимые в `s` помимо цифр|  
|------------------------|-----------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*Целые числа* только элемент.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Десятичной запятой (*.*) и *дробной части* элементов.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|«E» или «E» символ, который указывает на экспоненциальное представление. Этот флаг сам по себе поддерживает значения в форме *цифр*E*цифр*; дополнительные флаги необходимы для успешного анализа строки с такими элементами, как положительное или отрицательное подписывает и десятичный разделитель.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws* элемент в начале `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws* элемент в конце `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*Входа* элемент в начале `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*Входа* элемент в конце `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*Входа* элемент в скобки, ограничивающие числовое значение.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Тысяч элемент разделителя (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Элемент валюты ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Все элементы. Однако `s` не может представлять шестнадцатеричное число или число в экспоненциальном представлении.|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws* элемент в начале или конце `s`, *входа* в начале `s`и символ десятичной точки (.). `s` Параметр можно также использовать экспоненциальное представление.|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`, `sign`, Тысячи разделитель (,) и элементы десятичной точки (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Все элементы. Однако `s` не может представлять шестнадцатеричное число.|  
  
 `provider` Параметр <xref:System.IFormatProvider> реализации. Его <xref:System.IFormatProvider.GetFormat%2A> возвращает <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о формат для определенного языка и региональных параметров `value`. Как правило `provider` может принимать любое из следующих действий:  
  
-   Объект <xref:System.Globalization.CultureInfo> , представляющий язык и региональные параметры, предоставляющий сведения о форматировании числовых значений. Его <xref:System.Globalization.CultureInfo.GetFormat%2A> возвращает <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании числовых значений.  
  
-   Объект <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании. (Реализация <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> просто возвращает сам.)  
  
-   Пользовательский объект, который реализует <xref:System.IFormatProvider> и использует <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> метод для создания экземпляра и возвращать <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании.  
  
 Если `provider` — `null`, <xref:System.Globalization.NumberFormatInfo> объекта используется текущий язык и региональные параметры.  
  
 Если обнаружен разделитель в `s` параметр во время операции синтаксического анализа и применимые валюты или число десятичных и разделители групп совпадают, предполагается, что разделитель является десятичного разделителя, а не группой разделитель. Дополнительные сведения о разделители см. в разделе <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, и <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 Следующий пример кода использует <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> метода для синтаксического анализа строковые представления <xref:System.Single> значения. Каждая строка в массиве анализируется с использованием соглашений о форматировании en US, nl-NL и пользовательского языка и региональных параметров. Пользовательский язык и региональные параметры определяет символ-разделитель групп как символ подчеркивания («_») и размер группы, как два.  
  
 [!code-csharp[System.Single.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.Parse/CS/parse3.cs#4)]
 [!code-vb[System.Single.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.Parse/VB/parse3.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Свойство <paramref name="s" /> имеет значение <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="s" /> не представляет числовое значение.</exception>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> не является значением <see cref="T:System.Globalization.NumberStyles" />.  -или- <paramref name="style" /> является значением <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <exception cref="T:System.OverflowException">Параметр <paramref name="s" /> представляет число меньше <see cref="F:System.Single.MinValue" /> или больше <see cref="F:System.Single.MaxValue" />.</exception>
        <altmember cref="M:System.Single.ToString" />
      </Docs>
    </Member>
    <Member MemberName="PositiveInfinity">
      <MemberSignature Language="C#" Value="public const float PositiveInfinity = Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static literal float32 PositiveInfinity = float32(Infinity)" />
      <MemberSignature Language="DocId" Value="F:System.Single.PositiveInfinity" />
      <MemberSignature Language="VB.NET" Value="Public Const PositiveInfinity As Single  = Infinity" />
      <MemberSignature Language="C++ CLI" Value="public: float PositiveInfinity = Infinity;" />
      <MemberSignature Language="F#" Value="val mutable PositiveInfinity : single" Usage="System.single.PositiveInfinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <MemberValue>Infinity</MemberValue>
      <Docs>
        <summary>Представляет плюс бесконечность. Это поле является константой.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Значение этой константы — результат деления положительного числа на ноль.  
  
 Эта константа возвращается в том случае, если результат операции больше, чем <xref:System.Single.MaxValue>.  
  
 Используйте <xref:System.Single.IsPositiveInfinity%2A> для определения, равно ли значение плюс бесконечность.  
  
   
  
## Examples  
 В следующем примере кода показано <xref:System.Single.PositiveInfinity> константой.  
  
 [!code-cpp[System.Single#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#10)]
 [!code-csharp[System.Single#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#10)]
 [!code-vb[System.Single#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#10)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.IsPositiveInfinity(System.Single)" />
        <altmember cref="M:System.Single.IsInfinity(System.Single)" />
        <altmember cref="F:System.Single.NegativeInfinity" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object value);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (value As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ value) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.GetTypeCode">
      <MemberSignature Language="C#" Value="TypeCode IConvertible.GetTypeCode ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.TypeCode System.IConvertible.GetTypeCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#GetTypeCode" />
      <MemberSignature Language="VB.NET" Value="Function GetTypeCode () As TypeCode Implements IConvertible.GetTypeCode" />
      <MemberSignature Language="C++ CLI" Value=" virtual TypeCode System.IConvertible.GetTypeCode() = IConvertible::GetTypeCode;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.GetTypeCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToBoolean">
      <MemberSignature Language="C#" Value="bool IConvertible.ToBoolean (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IConvertible.ToBoolean(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToBoolean(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToBoolean (provider As IFormatProvider) As Boolean Implements IConvertible.ToBoolean" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IConvertible.ToBoolean(IFormatProvider ^ provider) = IConvertible::ToBoolean;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToBoolean(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToBoolean(System.IFormatProvider)" />.</summary>
        <returns>
          <see langword="true" />, если значение текущего экземпляра не равно нулю; в противном случае — <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Взамен рекомендуется использовать заключается в вызове <xref:System.Convert.ToBoolean%28System.Single%29?displayProperty=nameWithType> метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToByte">
      <MemberSignature Language="C#" Value="byte IConvertible.ToByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int8 System.IConvertible.ToByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToByte (provider As IFormatProvider) As Byte Implements IConvertible.ToByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Byte System.IConvertible.ToByte(IFormatProvider ^ provider) = IConvertible::ToByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToByte(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.Byte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Взамен рекомендуется использовать заключается в вызове <xref:System.Convert.ToByte%28System.Single%29?displayProperty=nameWithType> метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToChar">
      <MemberSignature Language="C#" Value="char IConvertible.ToChar (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance char System.IConvertible.ToChar(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToChar(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToChar (provider As IFormatProvider) As Char Implements IConvertible.ToChar" />
      <MemberSignature Language="C++ CLI" Value=" virtual char System.IConvertible.ToChar(IFormatProvider ^ provider) = IConvertible::ToChar;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToChar(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Данное преобразование не поддерживается. При попытке использовать этот метод выбрасывается исключение <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Данное преобразование не поддерживается. Возвращаемое значение отсутствует.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Во всех случаях.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDateTime">
      <MemberSignature Language="C#" Value="DateTime IConvertible.ToDateTime (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.DateTime System.IConvertible.ToDateTime(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDateTime(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDateTime (provider As IFormatProvider) As DateTime Implements IConvertible.ToDateTime" />
      <MemberSignature Language="C++ CLI" Value=" virtual DateTime System.IConvertible.ToDateTime(IFormatProvider ^ provider) = IConvertible::ToDateTime;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDateTime(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Данное преобразование не поддерживается. При попытке использовать этот метод выбрасывается исключение <see cref="T:System.InvalidCastException" />.</summary>
        <returns>Данное преобразование не поддерживается. Возвращаемое значение отсутствует.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidCastException">Во всех случаях.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDecimal">
      <MemberSignature Language="C#" Value="decimal IConvertible.ToDecimal (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Decimal System.IConvertible.ToDecimal(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDecimal(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDecimal (provider As IFormatProvider) As Decimal Implements IConvertible.ToDecimal" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Decimal System.IConvertible.ToDecimal(IFormatProvider ^ provider) = IConvertible::ToDecimal;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDecimal(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToDecimal(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.Decimal" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Взамен рекомендуется использовать заключается в вызове <xref:System.Convert.ToDecimal%28System.Single%29?displayProperty=nameWithType> метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToDouble">
      <MemberSignature Language="C#" Value="double IConvertible.ToDouble (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float64 System.IConvertible.ToDouble(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToDouble(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToDouble (provider As IFormatProvider) As Double Implements IConvertible.ToDouble" />
      <MemberSignature Language="C++ CLI" Value=" virtual double System.IConvertible.ToDouble(IFormatProvider ^ provider) = IConvertible::ToDouble;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToDouble(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToDouble(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.Double" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Взамен рекомендуется использовать заключается в вызове <xref:System.Convert.ToDouble%28System.Single%29?displayProperty=nameWithType> метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt16">
      <MemberSignature Language="C#" Value="short IConvertible.ToInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int16 System.IConvertible.ToInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt16 (provider As IFormatProvider) As Short Implements IConvertible.ToInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual short System.IConvertible.ToInt16(IFormatProvider ^ provider) = IConvertible::ToInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToInt16(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.Int16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Взамен рекомендуется использовать заключается в вызове <xref:System.Convert.ToInt16%28System.Single%29?displayProperty=nameWithType> метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt32">
      <MemberSignature Language="C#" Value="int IConvertible.ToInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IConvertible.ToInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt32 (provider As IFormatProvider) As Integer Implements IConvertible.ToInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IConvertible.ToInt32(IFormatProvider ^ provider) = IConvertible::ToInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToInt32(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.Int32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Взамен рекомендуется использовать заключается в вызове <xref:System.Convert.ToInt32%28System.Single%29?displayProperty=nameWithType> метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToInt64">
      <MemberSignature Language="C#" Value="long IConvertible.ToInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int64 System.IConvertible.ToInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToInt64 (provider As IFormatProvider) As Long Implements IConvertible.ToInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual long System.IConvertible.ToInt64(IFormatProvider ^ provider) = IConvertible::ToInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToInt64(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.Int64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Взамен рекомендуется использовать заключается в вызове <xref:System.Convert.ToInt64%28System.Single%29?displayProperty=nameWithType> метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSByte">
      <MemberSignature Language="C#" Value="sbyte IConvertible.ToSByte (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int8 System.IConvertible.ToSByte(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSByte(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSByte (provider As IFormatProvider) As SByte Implements IConvertible.ToSByte" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::SByte System.IConvertible.ToSByte(IFormatProvider ^ provider) = IConvertible::ToSByte;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSByte(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToSByte(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.SByte" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Взамен рекомендуется использовать заключается в вызове <xref:System.Convert.ToSByte%28System.Single%29?displayProperty=nameWithType> метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToSingle">
      <MemberSignature Language="C#" Value="float IConvertible.ToSingle (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance float32 System.IConvertible.ToSingle(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToSingle(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToSingle (provider As IFormatProvider) As Single Implements IConvertible.ToSingle" />
      <MemberSignature Language="C++ CLI" Value=" virtual float System.IConvertible.ToSingle(IFormatProvider ^ provider) = IConvertible::ToSingle;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToSingle(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToSingle(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, не измененное.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToType">
      <MemberSignature Language="C#" Value="object IConvertible.ToType (Type type, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.IConvertible.ToType(class System.Type type, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToType(System.Type,System.IFormatProvider)" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.IConvertible.ToType(Type ^ type, IFormatProvider ^ provider) = IConvertible::ToType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToType(System.Type,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="type">Тип, к которому необходимо привести это значение <see cref="T:System.Single" />.</param>
        <param name="provider">Объект, предоставляющий сведения о формате возвращаемого значения.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToType(System.Type,System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <paramref name="type" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Взамен рекомендуется использовать заключается в вызове `static` (`Shared` в Visual Basic) <xref:System.Convert.ChangeType%2A?displayProperty=nameWithType> метод.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt16">
      <MemberSignature Language="C#" Value="ushort IConvertible.ToUInt16 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int16 System.IConvertible.ToUInt16(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt16(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt16 (provider As IFormatProvider) As UShort Implements IConvertible.ToUInt16" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt16 System.IConvertible.ToUInt16(IFormatProvider ^ provider) = IConvertible::ToUInt16;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt16(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.UInt16" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Взамен рекомендуется использовать заключается в вызове <xref:System.Convert.ToUInt16%28System.Single%29?displayProperty=nameWithType> метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt32">
      <MemberSignature Language="C#" Value="uint IConvertible.ToUInt32 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int32 System.IConvertible.ToUInt32(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt32(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt32 (provider As IFormatProvider) As UInteger Implements IConvertible.ToUInt32" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt32 System.IConvertible.ToUInt32(IFormatProvider ^ provider) = IConvertible::ToUInt32;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt32(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToUInt32(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.UInt32" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Взамен рекомендуется использовать заключается в вызове <xref:System.Convert.ToUInt32%28System.Single%29?displayProperty=nameWithType> метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.IConvertible.ToUInt64">
      <MemberSignature Language="C#" Value="ulong IConvertible.ToUInt64 (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance unsigned int64 System.IConvertible.ToUInt64(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.System#IConvertible#ToUInt64(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Function ToUInt64 (provider As IFormatProvider) As ULong Implements IConvertible.ToUInt64" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::UInt64 System.IConvertible.ToUInt64(IFormatProvider ^ provider) = IConvertible::ToUInt64;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToUInt64(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Этот параметр не учитывается.</param>
        <summary>Описание этого члена см. в разделе <see cref="M:System.IConvertible.ToUInt64(System.IFormatProvider)" />.</summary>
        <returns>Значение текущего экземпляра, приведенное к типу <see cref="T:System.UInt64" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Этот член представляет собой явную реализацию члена интерфейса. Он может использоваться, только если экземпляр <xref:System.Single> приведен к типу интерфейса <xref:System.IConvertible>. Взамен рекомендуется использовать заключается в вызове <xref:System.Convert.ToUInt64%28System.Single%29?displayProperty=nameWithType> метода.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразовывает числовое значение данного экземпляра в эквивалентное ему строковое представление.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="single.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Преобразовывает числовое значение данного экземпляра в эквивалентное ему строковое представление.</summary>
        <returns>Строковое представление значения этого экземпляра.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString> Форматы метода <xref:System.Single> значение в значение по умолчанию («G» или Общие) формат текущего языка и региональных параметров. Если вы хотите указать другой формат или язык и региональные параметры, использовать другие перегрузки <xref:System.Single.ToString%2A> метод следующим образом:  
  
|Для использования формата|Для языка и региональных параметров|Используйте перегрузку|  
|-------------------|-----------------|----------------------|  
|Формат по умолчанию («G»)|Определенного языка и региональных параметров|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Определенный формат|По умолчанию (текущего) язык и региональные параметры|<xref:System.Single.ToString%28System.String%29>|  
|Определенный формат|Определенного языка и региональных параметров|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Возвращаемое значение может быть <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, или строку в формате:  
  
 целые числа [вход] [. [ дробной части]] [e [вход] экспоненты числа]  
  
 Необязательные элементы заключены в квадратные скобки ([и]). Элементов, содержащих термин «цифры» состоят из последовательности цифр от 0 до 9. В следующей таблице перечислены все элементы:  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*sign*|Отрицательный знак плюс или.|  
|*целые числа*|Последовательность цифр, обозначающих целую часть числа. Целые числа могут отсутствовать при наличии дробной части.|  
|'.'|Символ десятичной запятой для конкретного языка и региональных параметров.|  
|*дробной части*|Последовательность цифр, обозначающих дробную часть числа.|  
|«e»|Строчная буква «e», используемая в экспоненциальном представлении (научный).|  
|*экспоненциальные цифры*|Последовательность цифр, обозначающих показатель степени.|  
  
 Примеры возвращаемого значения: «100», «-123456789", «123, 45e + 6", «500», «3,1416», «600», «-0,123» и «-бесконечность».  
  
 .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах форматирования:  
  
-   Дополнительные сведения об описателях числового формата см. в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
   
  
## Examples  
 В следующем примере используется значение по умолчанию <xref:System.Single.ToString%2A?displayProperty=nameWithType> метод для отображения строковые представления числа <xref:System.Single> значения.  
  
 [!code-csharp[System.Single.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#1)]
 [!code-vb[System.Single.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#1)]  
  
 В следующем примере кода показано использование <xref:System.Single.Parse%28System.String%29> метод вместе с <xref:System.Single.ToString> метод.  
  
 [!code-cpp[System.Single#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Single/CPP/singlesample.cpp#3)]
 [!code-csharp[System.Single#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single/CS/singlesample.cs#3)]
 [!code-vb[System.Single#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single/VB/singlesample.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="single.ToString provider" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IConvertible.ToString(System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <summary>Преобразует числовое значение данного экземпляра в эквивалентное ему строковое представление с использованием указанных сведений об особенностях форматирования для данного языка и региональных параметров.</summary>
        <returns>Строковое представление значения данного экземпляра, определяемое параметром <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%28System.IFormatProvider%29> Форматы метода <xref:System.Single> значение в значение по умолчанию («G» или Общие) формат указанного языка и региональных параметров. Если вы хотите указать другой формат или текущего языка и региональных параметров, использовать другие перегрузки <xref:System.Single.ToString%2A> метод следующим образом:  
  
|Для использования формата|Для языка и региональных параметров|Используйте перегрузку|  
|-------------------|-----------------|----------------------|  
|Формат по умолчанию («G»)|По умолчанию (текущего) язык и региональные параметры|<xref:System.Single.ToString>|  
|Определенный формат|По умолчанию (текущего) язык и региональные параметры|<xref:System.Single.ToString%28System.String%29>|  
|Определенный формат|Определенного языка и региональных параметров|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Возвращаемое значение может быть <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, или строку в формате:  
  
 целые числа [вход] [. [ дробной части]] [e [вход] экспоненты числа]  
  
 Необязательные элементы заключены в квадратные скобки ([и]). Элементы со словом «цифры» состоят из последовательности цифр от 0 до 9. В следующей таблице перечислены каждого элемента.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|sign|Отрицательный знак плюс или.|  
|целые числа|Последовательность цифр, обозначающих целую часть числа. Целые числа могут отсутствовать при наличии дробной части.|  
|'.'|Символ десятичной запятой для конкретного языка и региональных параметров.|  
|дробной части|Последовательность цифр, обозначающих дробную часть числа.|  
|«e»|Строчная буква «e», используемая в экспоненциальном представлении (научный).|  
|экспоненциальные цифры|Последовательность цифр, обозначающих показатель степени.|  
  
 Примеры возвращаемого значения: «100», «-123456789", «123, 45e + 6", «500», «3,1416», «600», «-0,123» и «-бесконечность».  
  
 .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах форматирования:  
  
-   Дополнительные сведения об описателях числового формата см. в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 `provider` Параметр <xref:System.IFormatProvider> реализация которого <xref:System.IFormatProvider.GetFormat%2A> возвращает метод <xref:System.Globalization.NumberFormatInfo> объекта. Как правило `provider` — <xref:System.Globalization.CultureInfo> объекта или <xref:System.Globalization.NumberFormatInfo> объекта. `provider` Параметр предоставляет сведения о культуре, используемый для форматирования. Если `provider` — `null`, возвращаемое значение форматируется с использованием <xref:System.Globalization.NumberFormatInfo> данные для текущего языка и региональных параметров.  
  
 Чтобы преобразовать <xref:System.Single> значение в строковое представление с использованием указанного языка и региональных параметров и конкретную строку формата, вызов <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType> метод.  
  
   
  
## Examples  
 Следующий пример отображает строковое представление двух <xref:System.Single> значения с помощью <xref:System.Globalization.CultureInfo> объектов, представляющих несколько разных языков и региональных параметров.  
  
 [!code-csharp[System.Single.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#2)]
 [!code-vb[System.Single.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="single.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Строка числового формата.</param>
        <summary>Преобразует числовое значение данного экземпляра в эквивалентное строковое представление с использованием указанного формата.</summary>
        <returns>Строковое представление значения данного экземпляра, определяемое параметром <paramref name="format" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%28System.String%29> Форматы метода <xref:System.Single> значение в указанном формате, с использованием правил текущего языка и региональных параметров. Если вы хотите использовать значение по умолчанию («G» или Общие) формат или указать другой язык и региональные параметры, использовать другие перегрузки <xref:System.Single.ToString%2A> метод следующим образом:  
  
|Для использования формата|Для языка и региональных параметров|Используйте перегрузку|  
|-------------------|-----------------|----------------------|  
|Формат по умолчанию («G»)|По умолчанию (текущего) язык и региональные параметры|<xref:System.Single.ToString>|  
|Формат по умолчанию («G»)|Определенного языка и региональных параметров|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Определенный формат|Определенного языка и региональных параметров|<xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Возвращаемое значение может быть <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, или строковое представление значения текущего экземпляра, определяемое параметром `format`.  
  
 `format` Параметр может быть любой допустимый стандартный описатель числового формата, за исключением D и X, а также любым сочетанием описателях настраиваемого числового формата. Если формат `null` или пустая строка, возвращаемое значение форматируется с помощью спецификатора общего числового формата («G»).  
  
 .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах форматирования:  
  
-   Дополнительные сведения об описателях числового формата см. в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 По умолчанию возвращаемое значение содержит только 7-знаковая точность хотя для внутренних целей поддерживается до 9 цифр. Если значение этого экземпляра имеет более 7 цифр <xref:System.Single.ToString%28System.String%29> возвращает <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> или <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> вместо ожидаемого числа. Если требуется более высокая точность указать `format` с спецификации формата «G9» всегда возвращается точность или «R», возвращается 7 цифр, если число может быть представлено с этой точностью или 9 цифр, если число может быть представлено только с наибольшей точностью.  
  
   
  
## Examples  
 В следующем примере определяет числовое значение и форматирует их в виде значения валюты с использованием строки стандартного числового формата «C», так и в виде числового значения до трех десятичных знаков с использованием строки стандартного числового формата «N». Результирующие строки форматируются с использованием соглашений о региональных параметров en US. Дополнительные сведения о строки числовых форматов см. в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
 [!code-csharp[System.Single.ToString#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString7.cs#7)]
 [!code-vb[System.Single.ToString#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString7.vb#7)]  
  
 В следующем примере показаны некоторые <xref:System.Single> значений с использованием всех поддерживаемых стандартных числовых форматов описателей вместе с двумя строки настраиваемых числовых форматов. Одно из этих строк настраиваемого формата показывает, как выполнить заполнение <xref:System.Single> значения начальными нулями. В преобразовании числовых значений в строки, в примере соглашений о форматировании языка и региональных параметров en US.  
  
 [!code-csharp[System.Single.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#3)]
 [!code-vb[System.Single.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> недопустим.</exception>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="single.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Строка числового формата.</param>
        <param name="provider">Объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров.</param>
        <summary>Преобразует числовое значение данного экземпляра в эквивалентное ему строковое представление с использованием указанного формата и сведений об особенностях форматирования для данного языка и региональных параметров.</summary>
        <returns>Строковое представление значения данного экземпляра, определяемое параметрами <paramref name="format" /> и <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Single.ToString%28System.String%2CSystem.IFormatProvider%29> Форматы метода <xref:System.Single> значение в указанном формате указанного языка и региональных параметров. Если вы хотите использовать параметры форматирования или язык и региональные параметры по умолчанию, использовать другие перегрузки <xref:System.Single.ToString%2A> метод следующим образом:  
  
|Для использования формата|Для языка и региональных параметров|Используйте перегрузку|  
|-------------------|-----------------|----------------------|  
|Формат по умолчанию («G»)|По умолчанию (текущего) язык и региональные параметры|<xref:System.Single.ToString>|  
|Формат по умолчанию («G»)|Определенного языка и региональных параметров|<xref:System.Single.ToString%28System.IFormatProvider%29>|  
|Определенный формат|По умолчанию (текущего) язык и региональные параметры|<xref:System.Single.ToString%28System.String%29>|  
  
 Возвращаемое значение может быть <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A>, или строковое представление значения текущего экземпляра, определяемое параметром `format`.  
  
 `format` Параметр может быть любой допустимый стандартный описатель числового формата, за исключением D и X, а также любым сочетанием описателях настраиваемого числового формата. Если `format` — `null` или пустая строка, возвращаемое значение для данного экземпляра форматируется с помощью спецификатора общего числового формата («G»).  
  
 .NET Framework предоставляет широкую поддержку форматирования, который описан более подробно в следующих разделах форматирования:  
  
-   Дополнительные сведения об описателях числового формата см. в разделе [строки стандартного числового формата](~/docs/standard/base-types/standard-numeric-format-strings.md) и [строки настраиваемых числовых форматов](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Дополнительные сведения о форматировании см. в разделе [типы форматирования](~/docs/standard/base-types/formatting-types.md).  
  
 `provider` Параметр <xref:System.IFormatProvider> реализация которого <xref:System.IFormatProvider.GetFormat%2A> возвращает метод <xref:System.Globalization.NumberFormatInfo> объекта. Как правило `provider` — <xref:System.Globalization.CultureInfo> объекта или <xref:System.Globalization.NumberFormatInfo> объекта. `provider` Параметр предоставляет сведения о культуре, используемый для форматирования. Если `provider` — `null`, возвращаемое значение форматируется с <xref:System.Globalization.NumberFormatInfo> объект для текущего языка и региональных параметров.  
  
 По умолчанию возвращаемое значение содержит только 7-знаковая точность хотя для внутренних целей поддерживается до 9 цифр. Если значение этого экземпляра имеет более 7 цифр <xref:System.Single.ToString%2A> возвращает <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A> или <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A> вместо ожидаемого числа. Если требуется более высокая точность указать `format` с спецификации формата «G9» всегда возвращается точность или «R», возвращается 7 цифр, если число может быть представлено с этой точностью или 9 цифр, если число может быть представлено только с наибольшей точностью.  
  
   
  
## Examples  
 В следующем примере отображается <xref:System.Single> с использованием всех описателей стандартных числовых форматов поддерживаемые для нескольких языков и региональных параметров.  
  
 [!code-csharp[System.Single.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Single.ToString/CS/ToString1.cs#4)]
 [!code-vb[System.Single.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Single.ToString/VB/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="single.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32&amp;" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Преобразует строковое представление числа в эквивалентное ему число с плавающей запятой одиночной точности. Возвращает значение, указывающее, успешно ли выполнено преобразование.</summary>
        <altmember cref="Overload:System.Single.Parse" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.single.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Single&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.single.TryParse (s, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="result" Type="System.Single&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Строка, представляющая преобразуемое число.</param>
        <param name="result">Когда этот метод возвращает значение, оно содержит эквивалент числового значения или символа, содержащегося в параметре <c>s</c>, представленный в виде числа с плавающей запятой одиночной точности, если преобразование прошло успешно, или нуль, если произошел сбой преобразования. Преобразование завершается неудачно, если значение параметра <c>s</c> равно <see langword="null" /> или <see cref="F:System.String.Empty" />, не является числом допустимого формата или представляет число меньше <see cref="F:System.Single.MinValue" /> или больше <see cref="F:System.Single.MaxValue" />. Этот параметр передается неинициализированным; любое значение, первоначально предоставленное в параметре <c>result</c>, будет перезаписано.</param>
        <summary>Преобразует строковое представление числа в эквивалентное ему число с плавающей запятой одиночной точности. Возвращает значение, указывающее, успешно ли выполнено преобразование.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="s" /> успешно преобразован; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка отличается от <xref:System.Single.Parse%28System.String%29?displayProperty=nameWithType> метода, возвращая логическое значение, указывающее, успешно ли выполнена операция анализа вместо проанализированного числового значения. Отпадает необходимость использования обработки исключений для проверки на наличие <xref:System.FormatException> в случае, если `s` является недопустимым и не может быть успешно обработан.  
  
 `s` Параметр может содержать <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> (сравнение строк с учетом регистра), или строку в формате:  
  
 [ws] [вход] [целые числа,] целые числа [. [ дробной части]] [e [вход] экспоненты числа] [ws]  
  
 Элементы в квадратных скобках являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*ws*|Серия символы-разделители.|  
|*sign*|Отрицательный знак плюс или.|  
|*целые числа*|Последовательность цифр в диапазоне от 0 до 9, задающих целую часть числа. Целые числа могут отсутствовать при наличии дробной части.|  
|*,*|Символ разделителя групп, зависящий от языка и региональных параметров.|  
|*.*|Символ десятичной запятой для конкретного языка и региональных параметров.|  
|*дробной части*|Последовательность цифр в диапазоне от 0 до 9, задающих дробную часть числа.|  
|*E*|Верхнего или нижнего регистра символ «e», который указывает на экспоненциальное представление (научный).|  
|*экспоненциальные цифры*|Последовательность цифр в диапазоне от 0 до 9, задающих экспоненту.|  
  
 `s` Параметр интерпретируется с использованием сочетания <xref:System.Globalization.NumberStyles.Float?displayProperty=nameWithType> и <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> флаги. Это означает, что пробелы и тысяч разделители разрешены, но не являются символами валют. Для явного определения элементов (такие как символы денежной единицы, тысячи разделители и символы-разделители), могут быть представлены в `s`, используйте <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> перегрузки метода.  
  
 `s` Параметр анализируется с использованием сведений о форматировании в <xref:System.Globalization.NumberFormatInfo> , инициализируемый для текущего языка и региональных параметров системы. Дополнительные сведения см. в разделе <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Для анализа строки с использованием сведений о форматировании для другого языка и региональных параметров, используйте <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> перегрузки метода.  
  
 Как правило если передать <xref:System.Single.TryParse%2A?displayProperty=nameWithType> метод строку, которая создается путем вызова <xref:System.Single.ToString%2A?displayProperty=nameWithType> метод, исходные <xref:System.Single> возвращаемое значение. Однако из-за потери точности значения могут не быть равны.  
  
 Если обнаружен разделитель в `s` параметр во время операции синтаксического анализа и применимые валюты или число десятичных и разделители групп совпадают, предполагается, что разделитель является десятичного разделителя, а не группой разделитель. Дополнительные сведения о разделители см. в разделе <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, и <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 В следующем примере используется <xref:System.Single.TryParse%28System.String%2CSystem.Single%40%29> метод преобразования строковые представления числовых значений для <xref:System.Single> значения. Предполагается, что текущий язык и региональные параметры en US.  
  
 [!code-csharp[System.Single.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#1)]
 [!code-vb[System.Single.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="M:System.Single.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.single.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Single&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string s, System.Globalization.NumberStyles style, IFormatProvider provider, out float result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string s, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] float32&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Single.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (s As String, style As NumberStyles, provider As IFormatProvider, ByRef result As Single) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ s, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] float % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.single.TryParse (s, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="s" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Single&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="s">Строка, представляющая преобразуемое число.</param>
        <param name="style">Побитовая комбинация значений перечисления, которая определяет разрешенный формат параметра <c>s</c>. Обычно указывается значение <see cref="F:System.Globalization.NumberStyles.Float" /> в сочетании со значением <see cref="F:System.Globalization.NumberStyles.AllowThousands" />.</param>
        <param name="provider">Объект, который предоставляет сведения о форматировании параметра <c>s</c> в зависимости от языка и региональных параметров.</param>
        <param name="result">Когда этот метод возвращает значение, оно содержит эквивалент числового значения или символа, содержащегося в параметре <c>s</c>, представленный в виде числа с плавающей запятой одиночной точности, если преобразование прошло успешно, или нуль, если произошел сбой преобразования. Преобразование завершается неудачно, если параметр <c>s</c> имеет значение <see langword="null" /> или <see cref="F:System.String.Empty" />, не является значением в формате, совместимом с параметром <c>style</c>, представляет число меньше <see cref="F:System.Single.MinValue" /> или больше <see cref="F:System.Single.MaxValue" /> либо если <c>style</c> не является допустимой комбинацией перечисленных констант <see cref="T:System.Globalization.NumberStyles" />. Этот параметр передается неинициализированным; любое значение, первоначально предоставленное в параметре <c>result</c>, будет перезаписано.</param>
        <summary>Преобразует строковое представление числа в указанном стиле и с использованием формата, соответствующего данному языку и региональным параметрам, в эквивалентное ему число с плавающей запятой одиночной точности. Возвращает значение, указывающее, успешно ли выполнено преобразование.</summary>
        <returns>Значение <see langword="true" />, если параметр <paramref name="s" /> успешно преобразован; в противном случае — значение <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Эта перегрузка отличается от <xref:System.Single.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> метода, возвращая логическое значение, указывающее, успешно ли выполнена операция анализа вместо проанализированного числового значения. Отпадает необходимость использования обработки исключений для проверки на наличие <xref:System.FormatException> в случае, если `s` является недопустимым и не может быть успешно обработан.  
  
 `style` Параметр определяет допустимый формат `s` параметр для успешного выполнения операции синтаксического анализа. Он должен быть сочетанием одноразрядных флагов из <xref:System.Globalization.NumberStyles> перечисления. Следующие <xref:System.Globalization.NumberStyles> элементы не поддерживаются:  
  
-   <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>  
  
-   <xref:System.Globalization.NumberStyles.HexNumber?displayProperty=nameWithType>  
  
 `s` Параметр может содержать <xref:System.Globalization.NumberFormatInfo.PositiveInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NegativeInfinitySymbol%2A>, <xref:System.Globalization.NumberFormatInfo.NaNSymbol%2A> языком и региональными параметрами, обозначенном `provider`. Кроме того, в зависимости от значения `style`, `s` параметр может содержать следующие элементы:  
  
 [ws] [$] [вход] [целые числа,] [.доли числа] [e [вход] экспоненты числа] целые числа [ws]  
  
 Элементы в квадратных скобках ([и]) являются необязательными. Каждый из элементов описан в таблице ниже.  
  
|Элемент|Описание:|  
|-------------|-----------------|  
|*ws*|Необязательный пробел. Пробелы могут отображаться в начале `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> флаг. Он может располагаться в конце `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> флаг.|  
|*$*|Символ валюты. Его положение в строке определяется <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> или <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> свойства <xref:System.Globalization.NumberFormatInfo> объект, возвращаемый <xref:System.IFormatProvider.GetFormat%2A?displayProperty=nameWithType> метод `provider` параметра. Символ валюты может встречаться в `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> флаг.|  
|*sign*|Необязательный знак. Знак может располагаться в начале `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> флаг, который может находиться в конце `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> флаг. Можно использовать круглые скобки в `s` указывает отрицательное значение, если `style` включает <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> флаг.|  
|*целые числа*|Последовательность цифр в диапазоне от 0 до 9, задающих целую часть числа. Целые числа могут отсутствовать при наличии дробной части.|  
|*,*|Разделителя групп разрядов символ-разделитель. Тысячи текущего языка и региональных параметров может присутствовать разделитель в `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> флаг.|  
|*.*|Символ десятичной запятой для конкретного языка и региональных параметров. Символ десятичной точки текущего языка и региональных параметров могут использоваться в `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> флаг.|  
|*дробной части*|Последовательность цифр в диапазоне от 0 до 9, задающих дробную часть числа. Дробных разрядов может встречаться в `s` Если `style` включает <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> флаг.|  
|*e*|E или E символ, который указывает, что `s` может представлять число в экспоненциальном представлении. `s` Параметр может представлять число в экспоненциальном представлении, если стиль включает <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> флаг.|  
|*экспоненциальные цифры*|Последовательность цифр в диапазоне от 0 до 9, задающих экспоненту.|  
  
 Строка с только цифры (что соответствует <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> стиль) всегда успешно выполняет синтаксический анализ. Оставшиеся <xref:System.Globalization.NumberStyles?displayProperty=nameWithType> члены управляют элементами, которые могут быть, но необязательно должны присутствовать во входной строке. Следующая таблица показывает, как отдельные <xref:System.Globalization.NumberStyles> флаги влияют на элементы, которые могут присутствовать в `s`.  
  
|Значение NumberStyles|Допустимые элементы s помимо цифр|  
|------------------------|---------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|*Целые числа* только элемент.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Языковой элемент *.* и *дробной части* элементов.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|`s` Параметр можно также использовать экспоненциальное представление. Этот флаг сам по себе поддерживает значения в форме *целые числа*E*экспоненциальные цифры*; дополнительные флаги необходимы для успешного анализа строк в экспоненциальной форме с такими элементами, как положительное или отрицательное подписывает и десятичный разделитель.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|*Ws* элемент в начале `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|*Ws* элемент в конце `s`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|*Входа* элемент в начале `s`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|*Входа* элемент в конце `s`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|*Входа* элемент в скобки, ограничивающие числовое значение.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|*,* Элемент.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|* $ * Элемента.|  
|<xref:System.Globalization.NumberStyles.Currency>|Все. `s` Параметра не может представлять шестнадцатеричное число или число в экспоненциальном представлении.|  
|<xref:System.Globalization.NumberStyles.Float>|*Ws* элемент в начале или конце `s`, *входа* в начале `s`и *.* символ. `s` Параметр можно также использовать экспоненциальное представление.|  
|<xref:System.Globalization.NumberStyles.Number>|`ws`, `sign`, Тысячи разделителя (*,),* и десятичной запятой (*.*) элементов.|  
|<xref:System.Globalization.NumberStyles.Any>|Все стили, кроме `s` не может представлять шестнадцатеричное число.|  
  
 `provider` Параметр <xref:System.IFormatProvider> реализация которого <xref:System.IFormatProvider.GetFormat%2A> возвращает <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании для определенного языка и региональных параметров. При <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29> вызывается метод, он вызывает метод `provider` параметра <xref:System.IFormatProvider.GetFormat%2A> метод и передает его <xref:System.Type> , представляющий <xref:System.Globalization.NumberFormatInfo> типа. <xref:System.IFormatProvider.GetFormat%2A> Метод затем возвращает <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о формате параметра `s` параметр. Существует три способа использования `provider` для предоставления пользовательских сведений о форматировании операции синтаксического анализа:  
  
-   Можно передать <xref:System.Globalization.CultureInfo> , представляющий язык и региональные параметры, предоставляющий сведения о форматировании. Его <xref:System.Globalization.CultureInfo.GetFormat%2A> возвращает <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании числовых для этого языка и региональных параметров.  
  
-   Вы можете передать фактического <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании числовых значений. (Реализация <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> просто возвращает сам.)  
  
-   Можно передать пользовательский объект, который реализует <xref:System.IFormatProvider>. Его <xref:System.IFormatProvider.GetFormat%2A> метод создает и возвращает <xref:System.Globalization.NumberFormatInfo> объект, предоставляющий сведения о форматировании.  
  
 Если `provider` — `null`, форматирование `s` обрабатывается на основе <xref:System.Globalization.NumberFormatInfo> объект текущего языка и региональных параметров.  
  
 Если обнаружен разделитель в `s` параметр во время операции синтаксического анализа и применимые валюты или число десятичных и разделители групп совпадают, предполагается, что разделитель является десятичного разделителя, а не группой разделитель. Дополнительные сведения о разделители см. в разделе <xref:System.Globalization.NumberFormatInfo.CurrencyDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.NumberDecimalSeparator%2A>, <xref:System.Globalization.NumberFormatInfo.CurrencyGroupSeparator%2A>, и <xref:System.Globalization.NumberFormatInfo.NumberGroupSeparator%2A>.  
  
   
  
## Examples  
 В следующем примере показано использование <xref:System.Single.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Single%40%29?displayProperty=nameWithType> метода для синтаксического анализа строковое представление числа, определенного стиля и форматируются в соответствии с соглашениями определенного языка и региональных параметров.  
  
 [!code-csharp[System.Single.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.single.tryparse/cs/tryparse1.cs#2)]
 [!code-vb[System.Single.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.single.tryparse/vb/tryparse1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> не является значением <see cref="T:System.Globalization.NumberStyles" />.  -или- <paramref name="style" /> является значением <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />.</exception>
        <altmember cref="M:System.Single.Parse(System.String)" />
        <altmember cref="M:System.Single.ToString" />
      </Docs>
    </Member>
  </Members>
</Type>