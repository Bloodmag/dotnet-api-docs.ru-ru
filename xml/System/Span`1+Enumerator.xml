<Type Name="Span&lt;T&gt;+Enumerator" FullName="System.Span&lt;T&gt;+Enumerator">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="37231be40b4f33690f93e784db62f3e6103caa70" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="ru-RU" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36428450" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Span&lt;T&gt;.Enumerator" />
  <TypeSignature Language="ILAsm" Value=".class nested public sequential ansi sealed beforefieldinit Span`1/Enumerator&lt;T&gt; extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Span`1.Enumerator" />
  <TypeSignature Language="VB.NET" Value="Public Structure Span(Of T).Enumerator" />
  <TypeSignature Language="C++ CLI" Value="public: value class Span&lt;T&gt;::Enumerator" />
  <TypeSignature Language="F#" Value="type Span&lt;'T&gt;.Enumerator = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.CompilerServices.IsByRefLike</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Предоставляет перечислитель для элементов <see cref="T:System.Span`1" />.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  

C# [foreach](~/docs/csharp/language-reference/keywords/foreach-in.md) языка C# и [For Each... Далее](~/docs/visual-basic/language-reference/statements/for-each-next-statement.md) конструкции в Visual Basic скрывает сложность перечислителей. Вместо непосредственного использования перечислителя, с помощью `foreach` или `For Each...Next` рекомендуется. 

Изначально перечислитель располагается перед первым элементом в <xref:System.Span%601>. В этой позиции значение свойства <xref:System.Span%601.Enumerator.Current> не определено. Необходимо вызвать <xref:System.Span%601.Enumerator.MoveNext%2A> Чтобы переместить перечислитель к первому элементу в <xref:System.Span%601> до считывания значения свойства <xref:System.Span%601.Enumerator.Current>.

<xref:System.Span%601.Enumerator.Current> Возвращает то же значение до <xref:System.Span%601.Enumerator.MoveNext%2A> вызывается. <xref:System.Span%601.Enumerator.MoveNext%2A> Задает <xref:System.Span%601.Enumerator.Current> к следующему элементу в <xref:System.Span%601>.

Если <xref:System.Span%601.Enumerator.MoveNext%2A> выходит за границы <xref:System.Span%601>, <xref:System.Span%601.Enumerator.MoveNext%2A> возвращает `false`. Когда перечислитель находится в это состояние последующие вызовы <xref:System.Span%601.Enumerator.MoveNext%2A> также возвращают `false` и <xref:System.Span%601.Enumerator.Current> не определено. Не удается задать <xref:System.Span%601.Enumerator.Current> к первому элементу в <xref:System.Span%601> попытку; вместо этого следует создать новый экземпляр перечислителя. 

Перечислитель не имеет монопольного доступа к <xref:System.Span%601>. Кроме того могут быть изменены базовые данные, лежащие в основе диапазон. Таким образом, перечисление фрагмент само по себе не является потокобезопасной процедурой. Для обеспечения потокобезопасности при перечислении, необходимо реализовать собственную синхронизацию. Например следующий код имеет состояние гонки. Не гарантирует, что диапазон будут перечислены перед `ClearContents` выполнения метода. В результате базовый массив очищается при перечислении диапазона:

[!code-csharp[System.Span<T>.Enumerator-no-synchronization](~/samples/snippets/csharp/api/system/span.enumerator/nosync/program.cs)]

Если синхронизация доступ к массиву при перечислении диапазона, как измененная версия `EnumerateSpan` метод выполняет в следующем примере `ClearContents` метод не изменяет исходные данные области при перечислении. Обратите внимание, что пример блокирует базовый массив, на котором основан диапазон.  

[!code-csharp[System.Span<T>.Enumerator-no-synchronization](~/samples/snippets/csharp/api/system/span.enumerator/sync/program.cs#1)]

В отличие от некоторых других структур перечислитель в .NET <xref:System.Span%601.Enumerator>:

- Не реализует <xref:System.Collections.IEnumerator> или <xref:System.Collections.Generic.IEnumerator%601> интерфейса. Это вызвано <xref:System.Span%601.Enumerator> — [структура ссылки](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type).

- Не включает `Reset` метод, который можно задать перечислитель в его начальное положение, перед первым элементом в диапазоне. ( <xref:System.Collections.IEnumerator.Reset?displayProperty=nameWithType> Метод должен быть реализован как часть интерфейса, но большинство средства реализации порождает исключение или не выполняют реализацию.) 
 
      ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public T Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Current" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Enumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T % Current { T % get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : " Usage="System.Span&lt;'T&gt;.Enumerator.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T@</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Возвращает ссылку на элемент в текущей позиции перечислителя.</summary>
        <value>Элемент коллекции <see cref="T:System.Span`1" />, находящийся в текущей позиции перечислителя.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

`Current` не определено в рамках одного из следующих условий: 

- Сразу после создания перечислителя перечислитель располагается перед первым элементом в диапазоне. <xref:System.Span%601.Enumerator.MoveNext%2A> необходимо вызвать, чтобы переместить перечислитель к первому элементу диапазона до считывания значения свойства `Current`.

- Последнего вызова <xref:System.Span%601.Enumerator.MoveNext%2A> возвращается `false`, который указывает конец диапазона. 

`Current` Возвращает то же значение до <xref:System.Span%601.Enumerator.MoveNext%2A> вызывается. <xref:System.Span%601.Enumerator.MoveNext%2A> Задает `Current` к следующему элементу в диапазоне. 

      ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Enumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool MoveNext();" />
      <MemberSignature Language="F#" Value="member this.MoveNext : unit -&gt; bool" Usage="enumerator.MoveNext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Перемещает перечислитель к следующему элементу <see cref="System.Span`1" />.</summary>
        <returns>"true", если перечислитель успешно перемещен к следующему элементу; "false", если пройден конец диапазона.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

После создания перечислитель располагается перед первым элементом в диапазон и первый вызов `MoveNext` перемещает перечислитель к первому элементу в диапазоне. 

Если `MoveNext` выходит за границы диапазона, `MoveNext` возвращает `false`. Когда перечислитель находится в это состояние последующие вызовы `MoveNext` также возвращают `false`.

         ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>